    def createGame(self, max_rounds=-1, num_deal=1, **layout):
        l, s = Layout(self), self.s
        kwdefault(layout, rows=8, waste=1, playcards=20)
        self.Layout_Method(l, **layout)
        self.setSize(l.size[0], l.size[1])

        # Create talon
        s.talon = self.Talon_Class(l.s.talon.x, l.s.talon.y, self,
                                   max_rounds=max_rounds, num_deal=num_deal)
        s.waste = WasteStack(l.s.waste.x, l.s.waste.y, self)

        # Create foundations
        for r in l.s.foundations[:4]:
            s.foundations.append(
                self.Foundation_Class(
                    r.x, r.y, self,
                    r.suit, mod=16, max_cards=16, max_move=1))
        r = l.s.foundations[4]
        s.foundations.append(
            HexATrump_Foundation(
                r.x, r.y, self, 4, mod=4,
                max_move=0, max_cards=4, base_rank=ANY_RANK))

        # Create rows
        for r in l.s.rows:
            s.rows.append(self.RowStack_Class(r.x, r.y, self,
                                              suit=ANY_SUIT, base_rank=15))

        # Define stack groups
        l.defaultAll()

    #
    # Game over rides
    #

    def startGame(self):
        assert len(self.s.talon.cards) == 68
        for i in range(len(self.s.rows)):
            self.s.talon.dealRow(rows=self.s.rows[i+1:], flip=0, frames=0)
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealCards()

    def _shuffleHook(self, cards):
        basecard = [None]
        for c in cards[:]:
            if c.suit == 4:
                if basecard[0] is None:
                    basecard[0] = c
                    cards.remove(c)
        cards = basecard + cards
        cards.reverse()
        return cards

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return (card1.color != card2.color and
                (card1.rank + 1 == card2.rank or card2.rank + 1 == card1.rank))


# ************************************************************************
# * Klondike Plus 16
# ************************************************************************

class KlondikePlus16(Game):
    Hint_Class = CautiousDefaultHint
    Layout_Method = staticmethod(Layout.klondikeLayout)
    Talon_Class = WasteTalonStack
    Foundation_Class = SS_FoundationStack
    RowStack_Class = HexAKlon_RowStack

    #
    # Game layout
    #

    def createGame(self, max_rounds=2, num_deal=1, **layout):
        l, s = Layout(self), self.s
        kwdefault(layout, rows=8, waste=1, playcards=20)
        self.Layout_Method(l, **layout)
        self.setSize(l.size[0], l.size[1])

        # Create talon
        s.talon = self.Talon_Class(l.s.talon.x, l.s.talon.y, self,
                                   max_rounds=max_rounds, num_deal=num_deal)
        s.waste = WasteStack(l.s.waste.x, l.s.waste.y, self)

        # Create foundations
        for r in l.s.foundations:
            s.foundations.append(
                self.Foundation_Class(
                    r.x, r.y, self,
                    r.suit, mod=16, max_cards=16, max_move=1))

        # Create rows
        for r in l.s.rows:
            s.rows.append(self.RowStack_Class(r.x, r.y, self,
                                              suit=ANY_SUIT, base_rank=15))

        # Define stack groups
        l.defaultAll()

    #
    # Game over rides
    #

    def startGame(self):
        assert len(self.s.talon.cards) == 68
        for i in range(len(self.s.rows)):
            self.s.talon.dealRow(rows=self.s.rows[i+1:], flip=0, frames=0)
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealCards()

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return (card1.color != card2.color and
                (card1.rank + 1 == card2.rank or card2.rank + 1 == card1.rank))


# ************************************************************************
# * The Familiar
# ************************************************************************

class TheFamiliar(Game):
    Hint_Class = CautiousDefaultHint
    Layout_Method = staticmethod(Layout.klondikeLayout)
    Talon_Class = WasteTalonStack
    Foundation_Class = SS_FoundationStack
    RowStack_Class = AC_RowStack

    #
    # Game layout
    #

    def createGame(self, max_rounds=2, num_deal=1, **layout):
        l, s = Layout(self), self.s
        kwdefault(layout, rows=8, waste=1, playcards=20)
        self.Layout_Method(l, **layout)
        self.setSize(l.size[0], l.size[1])

        # Create talon
        s.talon = self.Talon_Class(l.s.talon.x, l.s.talon.y, self,
                                   max_rounds=max_rounds, num_deal=num_deal)
        s.waste = WasteStack(l.s.waste.x, l.s.waste.y, self)

        # Create foundations
        for r in l.s.foundations:
            s.foundations.append(
                self.Foundation_Class(
                    r.x, r.y, self,
                    r.suit, mod=16, max_cards=16, max_move=1))

        # Create rows
        for r in l.s.rows:
            s.rows.append(self.RowStack_Class(r.x, r.y, self,
                                              suit=ANY_SUIT, base_rank=15))

        # Create reserve
        x, y = l.XM, self.height - l.YS
        s.reserves.append(Familiar_ReserveStack(x, y, self, max_cards=3))
        self.setRegion(
            s.reserves, (-999, y - l.YM, x + l.XS, 999999), priority=1)
        l.createText(s.reserves[0], "se")

        # Define stack groups
        l.defaultAll()

    #
    # Game over rides
    #

    def startGame(self):
        assert len(self.s.talon.cards) == 68
        for i in range(len(self.s.rows)):
            self.s.talon.dealRow(rows=self.s.rows[i+1:], flip=0, frames=0)
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealCards()

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return (card1.color != card2.color and
                (card1.rank + 1 == card2.rank or card2.rank + 1 == card1.rank))


# ************************************************************************
# * Two Familiars
# ************************************************************************

class TwoFamiliars(Game):
    Hint_Class = CautiousDefaultHint
    Layout_Method = staticmethod(Layout.klondikeLayout)
    Talon_Class = WasteTalonStack
    Foundation_Class = SS_FoundationStack
    RowStack_Class = AC_RowStack

    #
    # Game layout
    #

    def createGame(self, max_rounds=2, num_deal=1, **layout):
        l, s = Layout(self), self.s
        kwdefault(layout, rows=12, waste=1, playcards=20)
        self.Layout_Method(l, **layout)
        self.setSize(l.size[0], l.size[1])

        # Create talon
        s.talon = self.Talon_Class(l.s.talon.x, l.s.talon.y, self,
                                   max_rounds=max_rounds, num_deal=num_deal)
        s.waste = WasteStack(l.s.waste.x, l.s.waste.y, self)

        # Create foundations
        for r in l.s.foundations:
            s.foundations.append(
                self.Foundation_Class(
                    r.x, r.y, self,
                    r.suit, mod=16, max_cards=16, max_move=1))

        # Create rows
        for r in l.s.rows:
            s.rows.append(self.RowStack_Class(r.x, r.y, self,
                                              suit=ANY_SUIT, base_rank=15))

        # Create reserve
        x, y = l.XM, self.height - l.YS
        s.reserves.append(Familiar_ReserveStack(x, y, self, max_cards=3))
        self.setRegion(
            s.reserves, (-999, y - l.YM, x + l.XS, 999999), priority=1)
        l.createText(s.reserves[0], "se")

        # Define stack groups
        l.defaultAll()

    #
    # Game over rides
    #

    def startGame(self):
        assert len(self.s.talon.cards) == 68 * 2
        for i in range(len(self.s.rows)):
            self.s.talon.dealRow(rows=self.s.rows[i+1:], flip=0, frames=0)
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealCards()

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return (card1.color != card2.color and
                (card1.rank + 1 == card2.rank or card2.rank + 1 == card1.rank))


# ************************************************************************
# * Ten by Eight
# ************************************************************************

class TenByEight(Game):
    Hint_Class = CautiousDefaultHint
    Layout_Method = staticmethod(Layout.gypsyLayout)
    Talon_Class = WasteTalonStack
    Foundation_Class = SS_FoundationStack
    RowStack_Class = AC_RowStack

    #
    # Game layout
    #

    def createGame(self, max_rounds=-1, num_deal=1, **layout):
        l, s = Layout(self), self.s
        kwdefault(layout, rows=10, waste=1, playcards=30)
        self.Layout_Method(l, **layout)
        self.setSize(l.size[0], l.size[1])

        # Create talon
        s.talon = self.Talon_Class(l.s.talon.x, l.s.talon.y, self,
                                   max_rounds=max_rounds, num_deal=num_deal)
        s.waste = WasteStack(l.s.waste.x, l.s.waste.y, self)

        # Create foundations
        for r in l.s.foundations:
            s.foundations.append(
                self.Foundation_Class(
                    r.x, r.y, self,
                    r.suit, mod=16, max_cards=16, max_move=1))

        # Create rows
        for r in l.s.rows:
            s.rows.append(self.RowStack_Class(r.x, r.y, self,
                                              suit=ANY_SUIT,
                                              base_rank=ANY_RANK))

        # Define stack groups
        l.defaultAll()

    #
    # Game over rides
    #

    def startGame(self):
        assert len(self.s.talon.cards) == 68 * 2
        frames = 0
        for i in range(8):
            if i == 5:
                frames = -1
                self.startDealSample()
            self.s.talon.dealRow(frames=frames)
        self.s.talon.dealCards()

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return (card1.color != card2.color and
                (card1.rank + 1 == card2.rank or card2.rank + 1 == card1.rank))


# ************************************************************************
# * Drawbridge
# ************************************************************************

class Drawbridge(Game):
    Hint_Class = CautiousDefaultHint
    Layout_Method = staticmethod(Layout.harpLayout)
    Talon_Class = WasteTalonStack
    Foundation_Class = SS_FoundationStack
    RowStack_Class = AC_RowStack

    #
    # Game layout
    #

    def createGame(self, max_rounds=2, num_deal=1, **layout):
        l, s = Layout(self), self.s
        kwdefault(layout, rows=7, waste=1, playcards=20)
        self.Layout_Method(l, **layout)
        self.setSize(l.size[0], l.size[1])

        # Create talon
        s.talon = self.Talon_Class(l.s.talon.x, l.s.talon.y, self,
                                   max_rounds=max_rounds, num_deal=num_deal)
        s.waste = WasteStack(l.s.waste.x, l.s.waste.y, self)

        # Create foundations
        for r in l.s.foundations:
            s.foundations.append(
                self.Foundation_Class(
                    r.x, r.y, self,
                    r.suit, mod=16, max_cards=16, max_move=1))

        # Create rows
        for r in l.s.rows:
            s.rows.append(self.RowStack_Class(r.x, r.y, self,
                                              suit=ANY_SUIT,
                                              base_rank=ANY_RANK))

        # Define stack groups
        l.defaultAll()

    #
    # Game over rides
    #

    def startGame(self):
        assert len(self.s.talon.cards) == 68
        for i in range(len(self.s.rows) - 1):
            self.s.talon.dealRow(rows=self.s.rows[i+1:], flip=0, frames=0)
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealCards()

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return (card1.color != card2.color and
                (card1.rank + 1 == card2.rank or card2.rank + 1 == card1.rank))


# ************************************************************************
# * Double Drawbridge
# ************************************************************************

class DoubleDrawbridge(Game):
    Hint_Class = CautiousDefaultHint
    Layout_Method = staticmethod(Layout.harpLayout)
    Talon_Class = WasteTalonStack
    Foundation_Class = SS_FoundationStack
    RowStack_Class = AC_RowStack

    #
    # Game layout
    #

    def createGame(self, max_rounds=2, num_deal=1, **layout):
        l, s = Layout(self), self.s
        kwdefault(layout, rows=10, waste=1, playcards=20)
        self.Layout_Method(l, **layout)
        self.setSize(l.size[0], l.size[1])

        # Create talon
        s.talon = self.Talon_Class(l.s.talon.x, l.s.talon.y, self,
                                   max_rounds=max_rounds, num_deal=num_deal)
        s.waste = WasteStack(l.s.waste.x, l.s.waste.y, self)

        # Create foundations
        for r in l.s.foundations:
            s.foundations.append(
                self.Foundation_Class(
                    r.x, r.y, self,
                    r.suit, mod=16, max_cards=16, max_move=1))

        # Create rows
        for r in l.s.rows:
            s.rows.append(
                self.RowStack_Class(
                    r.x, r.y, self,
                    suit=ANY_SUIT, base_rank=ANY_RANK))

        # Define stack groups
        l.defaultAll()

    #
    # Game over rides
    #

    def startGame(self):
        assert len(self.s.talon.cards) == 68 * 2
        for i in range(len(self.s.rows) - 1):
            self.s.talon.dealRow(rows=self.s.rows[i+1:], flip=0, frames=0)
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealCards()

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return (card1.color != card2.color and
                (card1.rank + 1 == card2.rank or card2.rank + 1 == card1.rank))


# ************************************************************************
# * Hidden Passages
# ************************************************************************

class HiddenPassages(Game):
    Hint_Class = CautiousDefaultHint
    Layout_Method = staticmethod(Layout.klondikeLayout)
    Talon_Class = WasteTalonStack
    Foundation_Class = SS_FoundationStack
    RowStack_Class = AC_RowStack

    #
    # Game layout
    #

    def createGame(self, max_rounds=2, num_deal=1, **layout):
        l, s = Layout(self), self.s
        kwdefault(layout, rows=7, waste=1, playcards=20)
        self.Layout_Method(l, **layout)
        self.setSize(l.size[0], l.size[1])

        # Create talon
        s.talon = self.Talon_Class(l.s.talon.x, l.s.talon.y, self,
                                   max_rounds=max_rounds, num_deal=num_deal)
        s.waste = WasteStack(l.s.waste.x, l.s.waste.y, self)

        # Create foundations
        for r in l.s.foundations[:4]:
            s.foundations.append(
                self.Foundation_Class(
                    r.x, r.y, self,
                    r.suit, mod=16, max_cards=16, max_move=1))
        r = l.s.foundations[4]
        s.foundations.append(
            HexATrump_Foundation(
                r.x, r.y, self, 4, mod=4,
                max_move=0, max_cards=4, base_rank=ANY_RANK))

        # Create rows
        for r in l.s.rows:
            s.rows.append(self.RowStack_Class(r.x, r.y, self,
                                              suit=ANY_SUIT,
                                              base_rank=ANY_RANK))

        # Define stack groups
        l.defaultAll()

    #
    # Game over rides
    #
    def _shuffleHook(self, cards):
        topcards = [None] * 4
        for c in cards[:]:
            if c.rank == 0 and not c.suit == 4:
                topcards[c.suit] = c
                cards.remove(c)
        cards = topcards + cards
        cards.reverse()
        return cards

    def startGame(self):
        assert len(self.s.talon.cards) == 68
        self.s.talon.dealRow(rows=self.s.foundations[:4], frames=0)
        for i in range(2):
            self.s.talon.dealRow(flip=0, frames=0)
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealCards()

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return (card1.color != card2.color and
                (card1.rank + 1 == card2.rank or card2.rank + 1 == card1.rank))


# ************************************************************************
# * Cluitjar's Lair
# ************************************************************************

class CluitjarsLair(Game):
    Hint_Class = CautiousDefaultHint
    Layout_Method = staticmethod(Layout.klondikeLayout)
    Talon_Class = WasteTalonStack
    Foundation_Class = SS_FoundationStack
    RowStack_Class = HexADeck_ACRowStack

    #
    # Game layout
    #

    def createGame(self, max_rounds=1, num_deal=1, **layout):
        l, s = Layout(self), self.s
        kwdefault(layout, rows=7, waste=1, playcards=20)
        self.Layout_Method(l, **layout)
        self.setSize(l.size[0], l.size[1])

        # Create talon
        s.talon = self.Talon_Class(l.s.talon.x, l.s.talon.y, self,
                                   max_rounds=max_rounds, num_deal=num_deal)
        s.waste = WasteStack(l.s.waste.x, l.s.waste.y, self)

        # Create foundations
        for r in l.s.foundations[:4]:
            s.foundations.append(
                self.Foundation_Class(
                    r.x, r.y, self,
                    r.suit, mod=16, max_cards=16, max_move=1))
        r = l.s.foundations[4]
        s.foundations.append(
            HexATrump_Foundation(
                r.x, r.y, self, 4, mod=4,
                max_move=0, max_cards=4, base_rank=ANY_RANK))

        # Create rows
        for r in l.s.rows:
            s.rows.append(self.RowStack_Class(r.x, r.y, self,
                                              suit=ANY_SUIT,
                                              base_rank=ANY_RANK))

        # Define stack groups
        l.defaultAll()

    #
    # Game over rides
    #
    def startGame(self):
        assert len(self.s.talon.cards) == 68
        for i in range(2):
            self.s.talon.dealRow(flip=0, frames=0)
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealCards()

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return (card1.color != card2.color and
                (card1.rank + 1 == card2.rank or card2.rank + 1 == card1.rank))


# ************************************************************************
# * Merlin's Meander
# ************************************************************************

class MerlinsMeander(AbstractHexADeckGame):
    Hint_Class = Merlins_Hint
    MERLINS_CARDS = 20

    #
    # game layout
    #

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        # (piles up to 20 cards are playable - needed for Braid_BraidStack)
        h = max(4*l.YS + 30, l.YS+(self.MERLINS_CARDS-1)*l.YOFFSET)
        self.setSize(10*l.XS+l.XM, l.YM + h)

        # extra settings
        self.base_card = None

        # Create rows, reserves
        s.addattr(braid=None)      # register extra stack variable
        x, y = l.XM, l.YM
        for i in range(2):
            s.rows.append(Merlins_RowStack(x + l.XS * 0.5, y, self))
            s.rows.append(Merlins_RowStack(x + l.XS * 4.5, y, self))
            s.reserves.append(
                Familiar_ReserveStack(x + l.XS * 6.5, y, self, max_cards=3))
            y = y + l.YS * 3
        y = l.YM + l.YS
        for i in range(2):
            s.rows.append(Merlins_ReserveStack(x, y, self))
            s.rows.append(Merlins_ReserveStack(x + l.XS, y, self))
            s.rows.append(Merlins_ReserveStack(x, y + l.YS, self))
            s.rows.append(Merlins_ReserveStack(x + l.XS, y + l.YS, self))
            x = x + l.XS * 4

        # Create braid
        x, y = l.XM + l.XS * 2.2, l.YM
        s.braid = Merlins_BraidStack(x, y, self)

        # Create talon, waste
        x, y = l.XM + l.XS * 7, l.YM + l.YS * 1.5
        s.talon = WasteTalonStack(x, y, self, max_rounds=3)
        l.createText(s.talon, "s")
        s.talon.texts.rounds = MfxCanvasText(
            self.canvas,
            x + l.CW // 2, y - l.YM,
            anchor="s",
            font=self.app.getFont("canvas_default"))
        x -= l.XS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, "s")

        # Create foundations
        x, y = l.XM + l.XS * 8, l.YM
        for i in range(4):
            s.foundations.append(
                Merlins_Foundation(
                    x, y, self, i, mod=16,
                    max_cards=16, base_rank=ANY_RANK))
            s.foundations.append(
                Merlins_Foundation(
                    x + l.XS, y, self, i, mod=16,
                    max_cards=16, base_rank=ANY_RANK))
            y = y + l.YS
        self.texts.info = MfxCanvasText(
            self.canvas,
            x + l.CW + l.XM // 2, y,
            anchor="n",
            font=self.app.getFont("canvas_default"))

        # define stack-groups
        self.sg.talonstacks = [s.talon] + [s.waste]
        self.sg.openstacks = s.foundations + s.rows + s.reserves
        self.sg.dropstacks = [s.braid] + s.rows + [s.waste] + s.reserves

    #
    # game overrides
    #

    def startGame(self):
        assert len(self.s.talon.cards) == 68 * 2
        self.startDealSample()
        self.base_card = None
        self.updateText()
        for i in range(self.MERLINS_CARDS):
            self.s.talon.dealRow(rows=[self.s.braid])
        self.s.talon.dealRow()
        # deal base_card to foundations, update cap.base_rank
        self.base_card = self.s.talon.getCard()
        while self.base_card.suit == 4:
            self.s.talon.cards.remove(self.base_card)
            self.s.talon.cards.insert(0, self.base_card)
            self.base_card = self.s.talon.getCard()
        to_stack = self.s.foundations[2 * self.base_card.suit]
        self.flipMove(self.s.talon)
        self.moveMove(1, self.s.talon, to_stack)
        self.updateText()
        for s in self.s.foundations:
            s.cap.base_rank = self.base_card.rank
        # deal first card to WasteStack
        self.s.talon.dealCards()

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return (card1.suit == card2.suit and
                ((card1.rank + 1) % 16 == card2.rank or
                 (card2.rank + 1) % 16 == card1.rank))

    def getHighlightPilesStacks(self):
        return ()

    def _restoreGameHook(self, game):
        self.base_card = self.cards[game.loadinfo.base_card_id]
        for s in self.s.foundations:
            s.cap.base_rank = self.base_card.rank

    def _loadGameHook(self, p):
        self.loadinfo.addattr(base_card_id=None)    # register extra load var.
        self.loadinfo.base_card_id = p.load()

    def _saveGameHook(self, p):
        p.dump(self.base_card.id)

    #
    # game extras
    #

    def updateText(self):
        if self.preview > 1 or not self.texts.info:
            return
        if not self.base_card:
            t = ""
        else:
            t = self.RANKS[self.base_card.rank]
            dir = self.getFoundationDir() % 16
            if dir == 1:
                t = t + _(" Ascending")
            elif dir == 15:
                t = t + _(" Descending")
        self.texts.info.config(text=t)

    def isGameWon(self):
        for s in self.s.rows:
            if s.cards and s.cards[0].suit != 4:
                return 0
        if not len(self.s.talon.cards) and len(self.s.waste.cards) == 1:
            return self.s.waste.cards[0].suit == 4
        return len(self.s.talon.cards) + len(self.s.waste.cards) == 0


# ************************************************************************
# * Mage's Game
# ************************************************************************

class MagesGame(Game):
    Hint_Class = CautiousDefaultHint
    Layout_Method = staticmethod(Layout.gypsyLayout)
    Talon_Class = InitialDealTalonStack
    Foundation_Class = SS_FoundationStack
    RowStack_Class = AC_RowStack

    #
    # Game layout
    #

    def createGame(self, max_rounds=1, num_deal=1, **layout):
        l, s = Layout(self), self.s
        kwdefault(layout, rows=12, texts=0, playcards=20)
        self.Layout_Method(l, **layout)
        self.setSize(l.size[0], l.size[1])

        # Create talon
        s.talon = self.Talon_Class(l.s.talon.x, l.s.talon.y, self,
                                   max_rounds=max_rounds, num_deal=num_deal)

        # Create foundations
        for r in l.s.foundations:
            s.foundations.append(
                self.Foundation_Class(
                    r.x, r.y, self,
                    r.suit, mod=16, max_cards=16, max_move=1))

        # Create rows
        for r in l.s.rows:
            s.rows.append(self.RowStack_Class(r.x, r.y, self,
                                              suit=ANY_SUIT,
                                              base_rank=ANY_RANK))

        # Define stack groups
        l.defaultAll()

    #
    # Game over rides
    #

    def startGame(self):
        assert len(self.s.talon.cards) == 68
        self._startDealNumRows(4)
        self.s.talon.dealRow()
        self.s.talon.dealRow(rows=self.s.rows[2:10])
        self.s.talon.dealCards()

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return (card1.color != card2.color and
                (card1.rank + 1 == card2.rank or card2.rank + 1 == card1.rank))


# ************************************************************************
# *
# ************************************************************************

class Convolution(AbstractHexADeckGame):
    RowStack_Class = StackWrapper(HexADeck_RK_RowStack, base_rank=NO_RANK)

    #
    # game layout
    #

    def createGame(self, rows=9, reserves=8):
        # create layout
        l, s = Layout(self), self.s

        # set size
        maxrows = max(rows, reserves)
        self.setSize(l.XM + (maxrows + 2) * l.XS, l.YM + 6 * l.YS)

        #
        playcards = 4 * l.YS // l.YOFFSET
        xoffset, yoffset = [], []
        for i in range(playcards):
            xoffset.append(0)
            yoffset.append(l.YOFFSET)
        for i in range(68 * self.gameinfo.decks - playcards):
            xoffset.append(l.XOFFSET)
            yoffset.append(0)

        # create stacks
        x, y = l.XM + (maxrows - reserves) * l.XS // 2, l.YM
        for i in range(reserves):
            s.reserves.append(ReserveStack(x, y, self))
            x = x + l.XS
        x, y = l.XM + (maxrows - rows) * l.XS // 2, l.YM + l.YS
        self.setRegion(s.reserves, (-999, -999, 999999, y - l.YM // 2))
        for i in range(rows):
            stack = self.RowStack_Class(x, y, self, yoffset=yoffset)
            stack.CARD_XOFFSET = xoffset
            stack.CARD_YOFFSET = yoffset
            s.rows.append(stack)
            x = x + l.XS
        x, y = l.XM + maxrows * l.XS, l.YM
        for i in range(2):
            for suit in range(5):
                s.foundations.append(
                    SS_FoundationStack(x, y, self, suit=suit, max_cards=16))
                y = y + l.YS
            x, y = x + l.XS, l.YM
        self.setRegion(self.s.foundations, (x - l.XS * 2, -999, 999999,
                       self.height - (l.YS + l.YM)), priority=1)
        s.talon = InitialDealTalonStack(
            self.width - 3 * l.XS // 2, self.height - l.YS, self)

        # define stack-groups
        l.defaultStackGroups()

    #
    # game overrides
    #

    def startGame(self):
        self.startDealSample()
        i = 0
        while self.s.talon.cards:
            if self.s.talon.cards[-1].rank == 15:
                if self.s.rows[i].cards:
                    i = i + 1
            self.s.talon.dealRow(rows=[self.s.rows[i]], frames=4)

    # must look at cards
    def _getClosestStack(self, cx, cy, stacks, dragstack):
        closest, cdist = None, 999999999
        for stack in stacks:
            if stack.cards and stack is not dragstack:
                dist = (stack.cards[-1].x - cx)**2 + \
                    (stack.cards[-1].y - cy)**2
            else:
                dist = (stack.x - cx)**2 + (stack.y - cy)**2
            if dist < cdist:
                closest, cdist = stack, dist
        return closest

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        row = self.s.rows[0]
        sequence = row.isRankSequence
        return (sequence([card1, card2]) or sequence([card2, card1]))


# ************************************************************************
# *
# ************************************************************************

class Labyrinth(Convolution):
    RowStack_Class = StackWrapper(HexADeck_AC_RowStack, base_rank=NO_RANK)

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        row = self.s.rows[0]
        sequence = row.isAlternateColorSequence
        return (sequence([card1, card2]) or sequence([card2, card1]))


# ************************************************************************
# *
# ************************************************************************

class Snakestone(Convolution):
    RowStack_Class = StackWrapper(HexADeck_SS_RowStack, base_rank=NO_RANK)

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        row = self.s.rows[0]
        sequence = row.isSuitSequence
        return (sequence([card1, card2]) or sequence([card2, card1]))


# ************************************************************************
# *
# ************************************************************************

def r(id, gameclass, name, game_type, decks, redeals, skill_level):
    game_type = game_type | GI.GT_HEXADECK
    gi = GameInfo(id, gameclass, name, game_type, decks, redeals, skill_level,
                  suits=list(range(4)), ranks=list(range(16)),
                  trumps=list(range(4)))
    registerGame(gi)
    return gi


r(165, BitsNBytes, 'Bits n Bytes', GI.GT_HEXADECK, 1, 1, GI.SL_BALANCED)
r(166, HexAKlon, 'Hex A Klon', GI.GT_HEXADECK, 1, -1, GI.SL_BALANCED)
r(16666, KlondikePlus16, 'Klondike Plus 16', GI.GT_HEXADECK, 1, 1,
  GI.SL_BALANCED)
r(16667, HexAKlonByThrees, 'Hex A Klon by Threes', GI.GT_HEXADECK, 1, -1,
  GI.SL_BALANCED)
r(16668, KingOnlyHexAKlon, 'King Only Hex A Klon', GI.GT_HEXADECK, 1, -1,
  GI.SL_BALANCED)
r(16669, TheFamiliar, 'The Familiar', GI.GT_HEXADECK, 1, 1, GI.SL_BALANCED)
r(16670, TwoFamiliars, 'Two Familiars', GI.GT_HEXADECK, 2, 1, GI.SL_BALANCED)
r(16671, TenByEight, '10 x 8', GI.GT_HEXADECK, 2, -1, GI.SL_BALANCED)
r(16672, Drawbridge, 'Drawbridge', GI.GT_HEXADECK, 1, 1, GI.SL_BALANCED)
r(16673, DoubleDrawbridge, 'Double Drawbridge', GI.GT_HEXADECK, 2, 1,
  GI.SL_BALANCED)
r(16674, HiddenPassages, 'Hidden Passages', GI.GT_HEXADECK, 1, 1,
  GI.SL_MOSTLY_LUCK)
r(16675, CluitjarsLair, 'Cluitjar\'s Lair', GI.GT_HEXADECK, 1, 0,
  GI.SL_BALANCED)
r(16676, MerlinsMeander, 'Merlin\'s Meander', GI.GT_HEXADECK, 2, 2,
  GI.SL_BALANCED)
r(16677, MagesGame, 'Mage\'s Game', GI.GT_HEXADECK, 1, 0, GI.SL_BALANCED)
r(16678, Convolution, 'Convolution', GI.GT_HEXADECK, 2, 0, GI.SL_MOSTLY_SKILL)
r(16679, Labyrinth, 'Hex Labyrinth', GI.GT_HEXADECK, 2, 0, GI.SL_MOSTLY_SKILL)
r(16680, Snakestone, 'Snakestone', GI.GT_HEXADECK, 2, 0, GI.SL_MOSTLY_SKILL)

del r
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.games.ultra.hanafuda_common import \
        AbstractFlowerGame, \
        FlowerClock_RowStack, \
        Flower_OpenStack, \
        HanafudaRK_RowStack, \
        Hanafuda_SS_FoundationStack, \
        Hanafuda_SequenceStack, \
        JapaneseGarden_RowStack, \
        Queue_BraidStack, \
        Queue_Foundation, \
        Queue_Hint, \
        Queue_ReserveStack, \
        Queue_RowStack, \
        Samuri_RowStack
from pysollib.hint import AbstractHint, CautiousDefaultHint
from pysollib.layout import Layout
from pysollib.mfxutil import kwdefault
from pysollib.mygettext import _
from pysollib.pysoltk import MfxCanvasText
from pysollib.stack import \
        BasicRowStack, \
        DealRowTalonStack, \
        InitialDealTalonStack, \
        OpenStack, \
        ReserveStack, \
        StackWrapper, \
        WasteStack, \
        WasteTalonStack
from pysollib.util import ANY_RANK, ANY_SUIT, NO_RANK


# ************************************************************************
# * Paulownia
# ************************************************************************


class Paulownia(AbstractFlowerGame):
    Layout_Method = staticmethod(Layout.klondikeLayout)
    Talon_Class = WasteTalonStack
    Foundation_Class = Hanafuda_SS_FoundationStack
    RowStack_Class = Hanafuda_SequenceStack
    MaxRounds = -1
    BaseRank = 0
    NumDeal = 1

    #
    # Game layout
    #

    def createGame(self, **layout):
        l, s = Layout(self), self.s
        kwdefault(layout, rows=8, waste=1)
        self.Layout_Method(l, **layout)
        self.setSize(l.size[0], l.size[1])

        # Create talon
        s.talon = self.Talon_Class(l.s.talon.x, l.s.talon.y, self,
                                   max_rounds=self.MaxRounds,
                                   num_deal=self.NumDeal)
        s.waste = WasteStack(l.s.waste.x, l.s.waste.y, self)

        # Create foundations
        for r in l.s.foundations:
            s.foundations.append(self.Foundation_Class(r.x, r.y, self,
                                 suit=r.suit, base_rank=3))

        # Create row stacks
        for r in l.s.rows:
            s.rows.append(self.RowStack_Class(r.x, r.y, self,
                          base_rank=self.BaseRank, yoffset=l.YOFFSET))

        # Define stack groups
        l.defaultAll()

    #
    # Game over rides
    #

    def startGame(self):
        assert len(self.s.talon.cards) == 48 * self.gameinfo.decks
        for i in range(8):
            self.s.talon.dealRow(rows=self.s.rows[i + 1:], flip=0, frames=0)
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealCards()


class Pine(Paulownia):
    MaxRounds = 1
    NumDeal = 3


class Eularia(Paulownia):
    BaseRank = ANY_RANK


class Peony(Eularia):
    NumDeal = 3


class Iris(Peony):
    MaxRounds = 1


# ************************************************************************
# * Queue
# ************************************************************************

class LesserQueue(AbstractFlowerGame):
    Hint_Class = Queue_Hint
    BRAID_CARDS = 20
    BRAID_OFFSET = 1

    #
    # game layout
    #

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        decks = self.gameinfo.decks
        yoffset = l.YOFFSET*self.BRAID_OFFSET
        h = l.YM+max(l.YS*5.5, l.YS+self.BRAID_CARDS*yoffset+2*l.TEXT_MARGIN)
        self.setSize(l.XM + l.XS * 10.5, h)

        # extra settings
        self.base_card = None

        # Create rows, reserves
        s.addattr(braid=None)
        x, x0 = l.XM + l.XS * 2, (decks - 1.5) % 2.5
        for j in range(decks // 2):
            y = l.YM
            for i in range(2):
                s.rows.append(Queue_RowStack(x + l.XS * (x0 + j), y, self))
                s.rows.append(Queue_RowStack(x + l.XS * (4 + x0 + j + .5), y,
                                             self))
                y = y + l.YS * (3 + (decks > 2))
        y = l.YM + l.YS
        for i in range(2):
            s.rows.append(Queue_ReserveStack(x, y, self))
            s.rows.append(Queue_ReserveStack(x + l.XS, y, self))
            s.rows.append(Queue_ReserveStack(x, y + l.YS, self))
            s.rows.append(Queue_ReserveStack(x + l.XS, y + l.YS, self))
            if decks - 2:
                s.rows.append(Queue_ReserveStack(x, y + l.YS * 2, self))
                s.rows.append(Queue_ReserveStack(x + l.XS, y + l.YS * 2, self))
            x = x + l.XS * 4.5

        # Create braid
        x, y = l.XM + l.XS * 4.25, l.YM
        s.braid = Queue_BraidStack(x, y, self, yoffset=self.BRAID_OFFSET)

        # Create talon, waste
        x, y = l.XM, h-l.YS
        s.talon = WasteTalonStack(x, y, self, max_rounds=3)
        l.createText(s.talon, "n")
        s.talon.texts.rounds = MfxCanvasText(
            self.canvas,
            self.width//2, h-2*l.TEXT_MARGIN,
            anchor="center",
            font=self.app.getFont("canvas_default"))
        x = x + l.XS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, "n")

        # Create foundations
        x = l.XM
        for j in range(decks // 2):
            y = l.YM
            for i in range(4):
                s.foundations.append(Queue_Foundation(
                    x, y, self, -1, mod=12,
                    max_cards=12, base_suit=ANY_SUIT, base_rank=i, rank=i))
                s.foundations.append(
                    Queue_Foundation(
                        x + l.XS * (9.5 - j * 2),
                        y, self, -1, mod=12,
                        max_cards=12, base_suit=ANY_SUIT, base_rank=i, rank=i))
                y = y + l.YS
            x = x + l.XS
        self.texts.info = MfxCanvasText(
            self.canvas,
            self.width//2, h-l.TEXT_MARGIN,
            anchor="center",
            font=self.app.getFont("canvas_default"))

        # define stack-groups
        self.sg.talonstacks = [s.talon] + [s.waste]
        self.sg.openstacks = s.foundations + s.rows + s.reserves
        self.sg.dropstacks = [s.braid] + s.rows + [s.waste] + s.reserves

    #
    # game overrides
    #

    def startGame(self):
        assert len(self.s.talon.cards) == 48 * self.gameinfo.decks
        self.startDealSample()
        self.base_card = None
        self.updateText()
        for i in range(self.BRAID_CARDS):
            self.s.talon.dealRow(rows=[self.s.braid])
        self.s.talon.dealRow()
        # deal base_card to foundations, update cap.base_rank
        self.base_card = self.s.talon.getCard()
        to_stack = self.s.foundations[2 * self.base_card.rank]
        self.flipMove(self.s.talon)
        self.moveMove(1, self.s.talon, to_stack)
        self.updateText()
        for s in self.s.foundations:
            s.cap.base_suit = self.base_card.suit
        # deal first card to WasteStack
        self.s.talon.dealCards()

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return (card1.rank == card2.rank and
                ((card1.suit + 1) % 12 == card2.suit or
                 (card2.suit + 1) % 12 == card1.suit))

    def getHighlightPilesStacks(self):
        return ()

    def _restoreGameHook(self, game):
        self.base_card = self.cards[game.loadinfo.base_card_id]
        for s in self.s.foundations:
            s.cap.base_suit = self.base_card.suit

    def _loadGameHook(self, p):
        self.loadinfo.addattr(base_card_id=None)    # register extra load var.
        self.loadinfo.base_card_id = p.load()

    def _saveGameHook(self, p):
        p.dump(self.base_card.id)

    #
    # game extras
    #

    def updateText(self):
        if self.preview > 1 or not self.texts.info:
            return
        if not self.base_card:
            t = ""
        else:
            t = self.SUITS[self.base_card.suit]
            dir = self.getFoundationDir()
            if dir == 1:
                t = t + _(" Ascending")
            elif dir == 11:
                t = t + _(" Descending")
        self.texts.info.config(text=t)

    def getFoundationDir(self):
        for s in self.s.foundations:
            if len(s.cards) >= 2:
                return (s.cards[-1].suit - s.cards[-2].suit) % 12
        return 0


class GreaterQueue(LesserQueue):
    Hint_Class = Queue_Hint
    BRAID_CARDS = 40
    BRAID_OFFSET = .5


# ************************************************************************
# * Japanese Garden
# ************************************************************************

class JapaneseGarden(AbstractFlowerGame):
    Hint_Class = CautiousDefaultHint
    RowStack_Class = FlowerClock_RowStack
    WIDTH = 10
    HEIGHT = 6
    XROWS = 3
    YROWS = 2
    MAX_CARDS = 6
    MAX_MOVE = 1
    XRESERVES = 6
    YRESERVES = 2
    MAX_RESERVE = 0
    INITIAL_DEAL = 6
    DEAL_RESERVES = 1

    #
    # Game layout
    #

    def createGame(self):
        l, s = Layout(self), self.s

        # Set window size
        self.setSize(l.XM + l.XS * self.WIDTH, l.YM * 3 + l.YS * self.HEIGHT)

        # Create foundations
        x = self.width // 2 + l.XM // 2 - l.XS * 3
        y = l.YM
        for j in range(2):
            for i in range(6):
                s.foundations.append(
                    Hanafuda_SS_FoundationStack(
                        x, y, self, i + (j * 6),
                        max_cards=4, max_accept=1, base_rank=3))
                x = x + l.XS
            x = self.width // 2 + l.XM // 2 - l.XS * 3
            y = y + l.YS

        # Create flower beds
        x = l.XM
        y = l.YM * 2 + l.YS * 2
        for j in range(self.YROWS):
            for i in range(self.XROWS):
                row = self.RowStack_Class(
                    x, y, self, yoffset=0, max_accept=self.MAX_MOVE,
                    max_move=self.MAX_MOVE, max_cards=self.MAX_CARDS,
                    base_rank=0)
                row.CARD_XOFFSET = l.CW // 2
                s.rows.append(row)
                x = x + self.width // self.XROWS
            x = l.XM
            y = y + l.YS
        self.setRegion(s.rows, (l.XM, l.YS * 2, 999999, y))

        # Create pool
        x = self.width // 2 + l.XM // 2 - (l.XS * self.XRESERVES) // 2
        for j in range(self.YRESERVES):
            for i in range(self.XRESERVES):
                s.reserves.append(
                    ReserveStack(x, y, self, max_accept=self.MAX_RESERVE))
                x = x + l.XS
            x = self.width // 2 + l.XM // 2 - l.XS * (self.XRESERVES // 2)
            y = y + l.YS
        if s.reserves:
            self.setRegion(
                s.reserves, (l.XM, l.YS * (2 + self.YROWS), 999999, 999999))

        # Create talon
        s.talon = InitialDealTalonStack(l.XM, l.YM, self)

        # Define stack-groups
        l.defaultStackGroups()

    #
    # Game over rides
    #

    def startGame(self):
        assert len(self.s.talon.cards) == 48
        self.startDealSample()
        for i in range(self.INITIAL_DEAL):
            self.s.talon.dealRow()
        if self.DEAL_RESERVES:
            self.s.talon.dealRow(rows=self.s.reserves)
        self.s.talon.dealCards()


class JapaneseGardenII(JapaneseGarden):
    RowStack_Class = JapaneseGarden_RowStack


class JapaneseGardenIII(JapaneseGardenII):
    XROWS = 2
    YROWS = 4
    MAX_CARDS = 7
    XRESERVES = 0
    YRESERVES = 0
    DEAL_RESERVES = 0


class SixSages(JapaneseGarden):
    Hint_Class = CautiousDefaultHint
    XROWS = 2
    YROWS = 3
    MAX_CARDS = 9
    XRESERVES = 1
    YRESERVES = 1
    MAX_RESERVE = 1
    INITIAL_DEAL = 8
    DEAL_RESERVES = 0


class SixTengus(SixSages):
    RowStack_Class = HanafudaRK_RowStack
    HEIGHT = 5
    MAX_MOVE = 2
    XRESERVES = 0
    YRESERVES = 0


# ************************************************************************
# * Hanafuda Four Seasons
# ************************************************************************

class HanafudaFourSeasons(AbstractFlowerGame):

    #
    # Game layout
    #

    def createGame(self):
        l, s = Layout(self), self.s

        # Set window size
        self.setSize(l.XM + l.XS * 7, l.YM + l.YS * 5)

        # Create rows
        x, y, offset = l.XM, l.YM, self.app.images.CARD_YOFFSET
        for i in range(6):
            s.rows.append(Samuri_RowStack(x, y, self, offset, max_cards=8,
                                          max_accept=8, base_rank=0))
            x = x + l.XS + l.XM + (l.XM * (i == 2))
        x, y = l.XM, y + l.YS * 2.5
        for i in range(6):
            s.rows.append(Samuri_RowStack(x, y, self, offset, max_cards=8,
                                          max_accept=8, base_rank=0))
            x = x + l.XS + l.XM + (l.XM * (i == 2))
        self.setRegion(s.rows, (0, 0, 999999, 999999))

        # Create talon
        s.talon = InitialDealTalonStack(-l.XS, -l.YS, self)

        # Define stack-groups
        l.defaultAll()

    #
    # Game over rides
    #

    def startGame(self):
        assert len(self.s.talon.cards) == 48 * self.gameinfo.decks
        self.startDealSample()
        for i in range(4):
            self.s.talon.dealRow(flip=1)

    #
    # Game extras
    #

    def isGameWon(self):
        for r in self.s.rows:
            cards = r.cards
            if not len(cards) == 4:
                return 0
            if not (cards[0].suit == r.id and r.isHanafudaSequence(cards)):
                return 0
        return 1


# ************************************************************************
# * Wisteria
# ************************************************************************

class Wisteria(AbstractFlowerGame):
    RowStack_Class = StackWrapper(Hanafuda_SequenceStack, base_rank=NO_RANK)

    #
    # game layout
    #

    def createGame(self, rows=13):
        # create layout
        l, s = Layout(self), self.s

        # set size
        self.setSize(l.XM + rows * l.XS, l.YM + 6 * l.YS)

        # create stacks
        x, y = self.width // 2 - l.XS * 3, l.YM
        for i in range(2):
            for suit in range(6):
                s.foundations.append(
                    Hanafuda_SS_FoundationStack(
                        x, y, self, suit=suit + (6 * i)))
                x = x + l.XS
            x, y = self.width // 2 - l.XS * 3, y + l.YS
        self.setRegion(
            self.s.foundations, (-999, -999, 999999, l.YM + l.YS * 2),
            priority=1)
        x, y = l.XM, l.YM + l.YS * 2
        for i in range(rows):
            stack = self.RowStack_Class(x, y, self, yoffset=l.YOFFSET)
            s.rows.append(stack)
            x = x + l.XS
        s.talon = InitialDealTalonStack(l.XS, l.YS // 2, self)

        # define stack-groups
        l.defaultStackGroups()

    #
    # game overrides
    #

    def startGame(self):
        self.startDealSample()
        i = 0
        while self.s.talon.cards:
            if self.s.talon.cards[-1].rank == 0:
                if self.s.rows[i].cards:
                    i = i + 1
            self.s.talon.dealRow(rows=[self.s.rows[i]], frames=4)


# ************************************************************************
# * Flower Arrangement Hint
# ************************************************************************

class FlowerArrangement_Hint(AbstractHint):
    def computeHints(self):
        game = self.game

        # 2)See if we can move a card to the tableaux
        if not self.hints:
            for r in game.sg.dropstacks:
                pile = r.getPile()
                if not pile or len(pile) != 1:
                    continue
                if r in game.s.tableaux:
                    rr = self.ClonedStack(r, stackcards=r.cards[:-1])
                    if rr.acceptsCards(None, pile):
                        # do not move a card that is already in correct place
                        continue
                    base_score = 80000 + (4 - r.cap.base_suit)
                else:
                    base_score = 80000
                # find a stack that would accept this card
                for t in game.s.tableaux:
                    if t is not r and t.acceptsCards(r, pile):
                        score = base_score + 100 * (self.K - pile[0].rank)
                        self.addHint(score, 1, r, t)
                        break

        # 3)See if we can move a card from the tableaux
        #    to a row stack. This can only happen if there are
        #    no more cards to deal.
        if not self.hints:
            for r in game.s.tableaux:
                pile = r.getPile()
                if not pile or len(pile) != 1:
                    continue
                rr = self.ClonedStack(r, stackcards=r.cards[:-1])
                if rr.acceptsCards(None, pile):
                    # do not move a card that is already in correct place
                    continue
                # find a stack that would accept this card
                for t in game.s.rows:
                    if t is not r and t.acceptsCards(r, pile):
                        score = 70000 + 100 * (self.K - pile[0].rank)
                        self.addHint(score, 1, r, t)
                        break

        # 4)See if we can move a card within the row stacks
        if not self.hints:
            for r in game.s.rows:
                pile = r.getPile()
                if not pile or len(pile) != 1 or len(pile) == len(r.cards):
                    continue
                base_score = 60000
                # find a stack that would accept this card
                for t in game.s.rows:
                    if t is not r and t.acceptsCards(r, pile):
                        score = base_score + 100 * (self.K - pile[0].rank)
                        self.addHint(score, 1, r, t)
                        break

        # 5)See if we can deal cards
        if self.level >= 2:
            if game.canDealCards():
                self.addHint(self.SCORE_DEAL, 0, game.s.talon, None)


# ************************************************************************
# * Flower Arrangement Stacks
# ************************************************************************

class FlowerArrangement_TableauStack(Flower_OpenStack):
    def __init__(self, x, y, game, yoffset, **cap):
        kwdefault(cap, dir=-1, max_move=1, max_cards=4, max_accept=1,
                  base_rank=3)
        OpenStack.__init__(self, x, y, game, **cap)
        self.CARD_YOFFSET = yoffset

    def acceptsCards(self, from_stack, cards):
        if not self.basicAcceptsCards(from_stack, cards):
            return 0
        # check that the base card is correct
        suits = list(range(self.cap.mod, (self.cap.mod + 4)))
        if self.cards and (self.cards[0].rank == 3 and
                           self.cards[-1].suit in suits):
            return self.isHanafudaSequence([self.cards[-1], cards[0]])
        return not self.cards and cards[0].rank == 3 and cards[0].suit in suits

    def getBottomImage(self):
        return self.game.app.images.getSuitBottom()


class FlowerArrangement_RowStack(BasicRowStack):

    def acceptsCards(self, from_stack, cards):
        if not BasicRowStack.acceptsCards(self, from_stack, cards):
            return 0
        # check
        return not (self.cards or self.game.s.talon.cards)

    def getBottomImage(self):
        return self.game.app.images.getTalonBottom()


# ************************************************************************
# * Flower Arrangement
# ************************************************************************

class FlowerArrangement(Game):
    Hint_Class = FlowerArrangement_Hint

    #
    # game layout
    #

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s
        TABLEAU_YOFFSET = min(9, max(3, l.YOFFSET // 3))

        # set window
        th = l.YS + 3 * TABLEAU_YOFFSET
        # (set piles so that at least 2/3 of a card is visible with 10 cards)
        h = (10-1)*l.YOFFSET + l.CH*2//3
        self.setSize(10*l.XS+l.XM, l.YM + 3*th + l.YM + h)

        # create stacks
        s.addattr(tableaux=[])     # register extra stack variable
        x = l.XM + 8 * l.XS + l.XS // 2
        y = l.YM
        for i in range(3):
            x = l.XM
            for j in range(8):
                s.tableaux.append(
                    FlowerArrangement_TableauStack(
                        x, y, self, TABLEAU_YOFFSET, mod=i * 4))
                x = x + l.XS
            y = y + th
        x, y = l.XM, y + l.YM
        for i in range(8):
            s.rows.append(FlowerArrangement_RowStack(x, y, self, max_accept=1))
            x = x + l.XS
        x = l.XM + 8 * l.XS + l.XS // 2
        y = self.height - l.YS
        s.talon = DealRowTalonStack(x, y, self)
        l.createText(s.talon, "se")

        # define stack-groups
        self.sg.openstacks = s.tableaux + s.rows
        self.sg.talonstacks = [s.talon]
        self.sg.dropstacks = s.tableaux + s.rows

    #
    # game overrides
    #

    def startGame(self):
        self.s.talon.dealRow(rows=self.s.tableaux, frames=0)
        self._startAndDealRow()

    def isGameWon(self):
        for stack in self.s.tableaux:
            if len(stack.cards) != 4:
                return 0
        return 1

    def fillStack(self, stack):
        if self.s.talon.cards:
            if stack in self.s.rows and len(stack.cards) == 0:
                self.s.talon.dealRow(rows=[stack])

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return (card1.suit == card2.suit and
                (card1.rank + 3 == card2.rank or card2.rank + 3 == card1.rank))

    def getHighlightPilesStacks(self):
        return ()


# ************************************************************************
# * Register the games
# ************************************************************************

def r(id, gameclass, name, game_type, decks, redeals, skill_level):
    game_type = game_type | GI.GT_HANAFUDA
    gi = GameInfo(id, gameclass, name, game_type, decks, redeals, skill_level,
                  suits=list(range(12)), ranks=list(range(4)))
    registerGame(gi)
    return gi


r(12369, Paulownia, 'Paulownia', GI.GT_HANAFUDA, 1, -1, GI.SL_BALANCED)
r(12370, LesserQueue, 'Lesser Queue', GI.GT_HANAFUDA, 2, 2, GI.SL_BALANCED)
r(12371, GreaterQueue, 'Greater Queue', GI.GT_HANAFUDA, 4, 2, GI.SL_BALANCED)
r(12373, JapaneseGarden, 'Japanese Garden', GI.GT_HANAFUDA | GI.GT_OPEN, 1, 0,
  GI.SL_MOSTLY_SKILL)
r(12374, JapaneseGardenII, 'Japanese Garden II', GI.GT_HANAFUDA | GI.GT_OPEN,
  1, 0, GI.SL_MOSTLY_SKILL)
r(12375, SixSages, 'Six Sages', GI.GT_HANAFUDA | GI.GT_OPEN, 1, 0,
  GI.SL_MOSTLY_SKILL)
r(12376, SixTengus, 'Six Tengus', GI.GT_HANAFUDA | GI.GT_OPEN, 1, 0,
  GI.SL_MOSTLY_SKILL)
r(12377, JapaneseGardenIII, 'Japanese Garden III', GI.GT_HANAFUDA | GI.GT_OPEN,
  1, 0, GI.SL_MOSTLY_SKILL)
r(12378, HanafudaFourSeasons, 'Hanafuda Four Seasons',
  GI.GT_HANAFUDA | GI.GT_OPEN, 1, 0, GI.SL_MOSTLY_SKILL)
r(12380, Eularia, 'Eularia', GI.GT_HANAFUDA, 1, -1, GI.SL_BALANCED)
r(12381, Peony, 'Peony', GI.GT_HANAFUDA, 1, -1, GI.SL_BALANCED)
r(12382, Iris, 'Iris', GI.GT_HANAFUDA, 1, 0, GI.SL_BALANCED)
r(12383, Pine, 'Pine', GI.GT_HANAFUDA, 1, 0, GI.SL_BALANCED)
r(12384, Wisteria, 'Wisteria', GI.GT_HANAFUDA, 1, 0, GI.SL_MOSTLY_SKILL)
r(12385, FlowerArrangement, 'Flower Arrangement', GI.GT_HANAFUDA, 2, 0,
  GI.SL_BALANCED)

del r
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

import re
import time

from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.hint import AbstractHint
from pysollib.layout import Layout
from pysollib.mfxutil import Image, Struct, kwdefault
from pysollib.mygettext import _
from pysollib.mygettext import ungettext
from pysollib.pysoltk import ANCHOR_NW, EVENT_HANDLED, bind
from pysollib.pysoltk import MfxCanvasImage, MfxCanvasText
from pysollib.pysoltk import MfxMessageDialog
from pysollib.settings import DEBUG, TOOLKIT
from pysollib.stack import \
        InitialDealTalonStack, \
        OpenStack
from pysollib.util import ANY_SUIT, NO_RANK

from six.moves import range


def factorial(x):
    if x <= 1:
        return 1
    a = 1
    for i in range(x):
        a *= (i+1)
    return a


# ************************************************************************
# *
# ************************************************************************

class Mahjongg_Hint(AbstractHint):
    # FIXME: no intelligence whatsoever is implemented here
    def computeHints(self):
        game = self.game
        # get free stacks
        stacks = []
        for r in game.s.rows:
            if r.cards and not r.basicIsBlocked():
                stacks.append(r)
        # find matching tiles
        i = 0
        for r in stacks:
            for t in stacks[i+1:]:
                if game.cardsMatch(r.cards[0], t.cards[0]):
                    # simple scoring...
                    # score = 10000 + r.id + t.id
                    rb = r.blockmap
                    tb = t.blockmap
                    score = \
                        10000 + \
                        1000 * (len(rb.below) + len(tb.below)) + \
                        len(rb.all_left) + len(rb.all_right) + \
                        len(tb.all_left) + len(tb.all_right)
                    self.addHint(score, 1, r, t)
            i += 1


# ************************************************************************
# *
# ************************************************************************

# class Mahjongg_Foundation(AbstractFoundationStack):
class Mahjongg_Foundation(OpenStack):

    def __init__(self, x, y, game, suit=ANY_SUIT, **cap):
        kwdefault(cap, max_move=0, max_accept=0, max_cards=game.NCARDS)
        OpenStack.__init__(self, x, y, game, **cap)

    def acceptsCards(self, from_stack, cards):
        # We do not accept any cards - pairs will get
        # delivered by _dropPairMove() below.
        return 0

    def basicIsBlocked(self):
        return 1

    # def initBindings(self):
    #    pass

    def _position(self, card):
        # AbstractFoundationStack._position(self, card)
        OpenStack._position(self, card)

        fnds = self.game.s.foundations

        cols = (3, 2, 1, 0)
        for i in cols:
            for j in range(9):
                n = i*9+j
                if fnds[n].cards:
                    fnds[n].group.tkraise()
        return

    def getHelp(self):
        return ''


# ************************************************************************
# *
# ************************************************************************

class Mahjongg_RowStack(OpenStack):
    def __init__(self, x, y, game, **cap):
        kwdefault(cap, max_move=1, max_accept=1, max_cards=2,
                  base_rank=NO_RANK)
        OpenStack.__init__(self, x, y, game, **cap)

    def basicIsBlocked(self):
        # any of above blocks
        for stack in self.blockmap.above:
            if stack.cards:
                return 1
        # any of left blocks - but we can try right as well
        for stack in self.blockmap.left:
            if stack.cards:
                break
        else:
            return 0
        # any of right blocks
        for stack in self.blockmap.right:
            if stack.cards:
                return 1
        return 0

    def acceptsCards(self, from_stack, cards):
        if not OpenStack.acceptsCards(self, from_stack, cards):
            return 0
        return self.game.cardsMatch(self.cards[0], cards[-1])

    def canFlipCard(self):
        return 0

    def canDropCards(self, stacks):
        return (None, 0)

    def moveMove(self, ncards, to_stack, frames=-1, shadow=-1):
        self._dropPairMove(ncards, to_stack, frames=-1, shadow=shadow)

    def _dropPairMove(self, n, other_stack, frames=-1, shadow=-1):
        # print 'drop:', self.id, other_stack.id
        assert n == 1 and self.acceptsCards(
            other_stack, [other_stack.cards[-1]])
        if not self.game.demo:
            self.game.playSample("droppair", priority=200)
        old_state = self.game.enterState(self.game.S_FILL)
        c = self.cards[0]
        if c.suit == 3:
            if c.rank >= 8:
                i = 35
            elif c.rank >= 4:
                i = 34
            else:
                i = 30+c.rank
        elif c.rank == 9:
            i = 27+c.suit
        else:
            i = c.suit*9+c.rank
        f = self.game.s.foundations[i]
        self.game.moveMove(n, self, f, frames=frames, shadow=shadow)
        self.game.moveMove(n, other_stack, f, frames=frames, shadow=shadow)
        self.game.leaveState(old_state)
        self.fillStack()
        other_stack.fillStack()

    #
    # Mahjongg special overrides
    #

    # Mahjongg special: we must preserve the relative stacking order
    # to keep our pseudo 3D look.
    def _position(self, card):
        OpenStack._position(self, card)
        #
        if TOOLKIT == 'tk':
            rows = [s for s in self.game.s.rows[:self.id] if s.cards]
            if rows:
                self.group.tkraise(rows[-1].group)
                return
            rows = [s for s in self.game.s.rows[self.id+1:] if s.cards]
            if rows:
                self.group.lower(rows[0].group)
                return
        elif TOOLKIT == 'kivy':
            rows = [s for s in self.game.s.rows[:self.id] if s.cards]
            if rows:
                # self.group.tkraise(rows[-1].group)
                return
            rows = [s for s in self.game.s.rows[self.id+1:] if s.cards]
            if rows:
                # self.group.lower(rows[0].group)
                return
        elif TOOLKIT == 'gtk':
            # FIXME (this is very slow)
            for s in self.game.s.rows[self.id+1:]:
                s.group.tkraise()

    # In Mahjongg games type there are a lot of stacks, so we optimize
    # and don't create bindings that are not used anyway.
    def initBindings(self):
        group = self.group
        # FIXME: dirty hack to access the Stack's private methods
        # bind(group, "<1>", self._Stack__clickEventHandler)
        # bind(group, "<3>", self._Stack__controlclickEventHandler)
        # bind(group, "<Control-1>", self._Stack__controlclickEventHandler)
        #
        bind(group, "<1>", self.__clickEventHandler)
        bind(group, "<3>", self.__controlclickEventHandler)
        bind(group, "<Control-1>", self.__controlclickEventHandler)
        # bind(group, "<Enter>", self._Stack__enterEventHandler)
        # bind(group, "<Leave>", self._Stack__leaveEventHandler)

    def __defaultClickEventHandler(self, event, handler):
        self.game.event_handled = True  # for Game.undoHandler
        if self.game.demo:
            self.game.stopDemo(event)
        if self.game.busy:
            return EVENT_HANDLED
        handler(event)
        return EVENT_HANDLED

    def __clickEventHandler(self, event):
        # print 'click:', self.id
        return self.__defaultClickEventHandler(event, self.clickHandler)

    def __controlclickEventHandler(self, event):
        return self.__defaultClickEventHandler(event, self.controlclickHandler)

    def clickHandler(self, event):
        game = self.game
        drag = game.drag
        # checks
        if not self.cards:
            return 1
        card = self.cards[-1]
        from_stack = drag.stack
        if from_stack is self:
            # remove selection
            self.game.playSample("nomove")
            self._stopDrag()
            return 1
        if self.basicIsBlocked():
            # remove selection
            # self.game.playSample("nomove")
            return 1
        # possible move
        if from_stack:
            if self.acceptsCards(from_stack, from_stack.cards):
                self._stopDrag()
                # this code actually moves the tiles
                from_stack.playMoveMove(1, self, frames=0, sound=True)
                if TOOLKIT == 'kivy':
                    if drag.shade_img:
                        # drag.shade_img.dtag(drag.shade_stack.group)
                        drag.shade_img.delete()
                        # game.canvas.delete(drag.shade_img)
                        drag.shade_img = None
                return 1
        drag.stack = self
        self.game.playSample("startdrag")
        # create the shade image (see stack.py, _updateShade)
        if drag.shade_img:
            # drag.shade_img.dtag(drag.shade_stack.group)
            drag.shade_img.delete()
            # game.canvas.delete(drag.shade_img)
            drag.shade_img = None
        img = game.app.images.getHighlightedCard(
            card.deck, card.suit, card.rank)
        if img is None:
            return 1
        img = MfxCanvasImage(game.canvas, self.x, self.y, image=img,
                             anchor=ANCHOR_NW, group=self.group)
        drag.shade_img = img
        # raise/lower the shade image to the correct stacking order
        img.tkraise(card.item)
        drag.shade_stack = self
        return 1

    def cancelDrag(self, event=None):
        if event is None:
            self._stopDrag()

    def _findCard(self, event):
        # we need to override this because the shade may be hiding
        # the tile (from Tk's stacking view)
        return len(self.cards) - 1

    def getBottomImage(self):
        return None


# ************************************************************************
# *
# ************************************************************************

class AbstractMahjonggGame(Game):
    Hint_Class = Mahjongg_Hint
    RowStack_Class = Mahjongg_RowStack

    GAME_VERSION = 3

    NCARDS = 144

    def getTiles(self):
        # decode tile positions
        L = self.L

        assert L[0] == "0"
        assert (len(L) - 1) % 3 == 0

        tiles = []
        max_tl, max_tx, max_ty = -1, -1, -1
        t = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
        for i in range(1, len(L), 3):
            n = t.find(L[i])
            level, height = n // 7, n % 7 + 1
            tx = t.find(L[i+1])
            ty = t.find(L[i+2])
            assert n >= 0 and tx >= 0 and ty >= 0
            max_tl = max(level + height - 1, max_tl)
            max_tx = max(tx, max_tx)
            max_ty = max(ty, max_ty)
            for tl in range(level, level + height):
                tiles.append((tl, tx, ty))
        assert len(tiles) == self.NCARDS
        # tiles.sort()
        # tiles = tuple(tiles)
        return tiles, max_tl, max_tx, max_ty

    #
    # game layout
    #

    def createGame(self):
        tiles, max_tl, max_tx, max_ty = self.getTiles()

        # start layout
        l, s = Layout(self), self.s
        show_removed = self.app.opt.mahjongg_show_removed

        # dx, dy = 2, -2
        # dx, dy = 3, -3
        cs = self.app.cardset
        if cs.version >= 6:
            dx = l.XOFFSET
            dy = -l.YOFFSET
            d_x = cs.SHADOW_XOFFSET
            d_y = cs.SHADOW_YOFFSET
            if self.preview:
                # Fixme
                dx, dy, d_x, d_y = dx//2, dy//2, d_x//2, d_y//2
            self._delta_x, self._delta_y = dx, -dy
        else:
            dx = 3
            dy = -3
            d_x = 0
            d_y = 0
            self._delta_x, self._delta_y = 0, 0
        # print dx, dy, d_x, d_y, cs.version

        font = self.app.getFont("canvas_default")

        # width of self.texts.info
        # ti_width = Font(self.canvas, font).measure(_('Remaining'))
        ti_width = 80

        # set window size
        dxx, dyy = abs(dx) * (max_tl+1), abs(dy) * (max_tl+1)
        # foundations dxx dyy
        if self.NCARDS > 144:
            fdxx = abs(dx)*8
            fdyy = abs(dy)*8
        else:
            fdxx = abs(dx)*4
            fdyy = abs(dy)*4
        cardw, cardh = l.CW - d_x, l.CH - d_y
        if show_removed:
            left_margin = l.XM + 4*cardw+fdxx+d_x + l.XM
        else:
            left_margin = l.XM
        tableau_width = (max_tx+2)*cardw//2+dxx+d_x
        right_margin = l.XM+ti_width+l.XM
        w = left_margin + tableau_width + right_margin
        h = l.YM + dyy + (max_ty + 2) * cardh // 2 + d_y + l.YM
        if show_removed:
            h = max(h, l.YM+fdyy+cardh*9+d_y+l.YM)
        self.setSize(w, h)

        # set game extras
        self.check_dist = l.CW*l.CW + l.CH*l.CH     # see _getClosestStack()

        # sort tiles (for 3D)
        tiles.sort(key=lambda x: (x[0], x[2]-x[1]))

        # create a row stack for each tile and compute the tilemap
        tilemap = {}
        x0 = left_margin
        y0 = l.YM + dyy
        for level, tx, ty in tiles:
            # print level, tx, ty
            x = x0 + (tx * cardw) // 2 + level * dx
            y = y0 + (ty * cardh) // 2 + level * dy
            stack = self.RowStack_Class(x, y, self)
            # stack.G = (level, tx, ty)
            stack.CARD_XOFFSET = dx
            stack.CARD_YOFFSET = dy
            s.rows.append(stack)
            # tilemap - each tile covers 4 positions
            tilemap[(level, tx, ty)] = stack
            tilemap[(level, tx+1, ty)] = stack
            tilemap[(level, tx, ty+1)] = stack
            tilemap[(level, tx+1, ty+1)] = stack

        # compute blockmap
        for stack in s.rows:
            level, tx, ty = tiles[stack.id]
            above, below, left, right = {}, {}, {}, {}
            # above blockers
            for tl in range(level+1, level+2):
                above[tilemap.get((tl, tx, ty))] = 1
                above[tilemap.get((tl, tx+1, ty))] = 1
                above[tilemap.get((tl, tx, ty+1))] = 1
                above[tilemap.get((tl, tx+1, ty+1))] = 1
            #
            for tl in range(level):
                below[tilemap.get((tl, tx, ty))] = 1
                below[tilemap.get((tl, tx+1, ty))] = 1
                below[tilemap.get((tl, tx, ty+1))] = 1
                below[tilemap.get((tl, tx+1, ty+1))] = 1
            # left blockers
            left[tilemap.get((level, tx-1, ty))] = 1
            left[tilemap.get((level, tx-1, ty+1))] = 1
            # right blockers
            right[tilemap.get((level, tx+2, ty))] = 1
            right[tilemap.get((level, tx+2, ty+1))] = 1
            # up blockers
            # up[tilemap.get((level, tx, ty-1))] = 1
            # up[tilemap.get((level, tx+1, ty-1))] = 1
            # bottom blockers
            # bottom[tilemap.get((level, tx, ty+2))] = 1
            # bottom[tilemap.get((level, tx+1, ty+2))] = 1
            # sanity check - assert that there are no overlapping tiles
            assert tilemap.get((level, tx, ty)) is stack
            assert tilemap.get((level, tx+1, ty)) is stack
            assert tilemap.get((level, tx, ty+1)) is stack
            assert tilemap.get((level, tx+1, ty+1)) is stack
            #
            above = tuple([_f for _f in above.keys() if _f])
            below = tuple([_f for _f in below.keys() if _f])
            left = tuple([_f for _f in left.keys() if _f])
            right = tuple([_f for _f in right.keys() if _f])
            # up = tuple(filter(None, up.keys()))
            # bottom = tuple(filter(None, bottom.keys()))

            # assemble
            stack.blockmap = Struct(
                above=above,
                below=below,
                left=left,
                right=right,
                # up=up,
                # bottom=bottom,
                all_left=None,
                all_right=None,
            )

        def get_all_left(s):
            if s.blockmap.all_left is None:
                s.blockmap.all_left = {}
            for t in s.blockmap.left:
                if t.blockmap.all_left is None:
                    get_all_left(t)
                s.blockmap.all_left.update(t.blockmap.all_left)
                s.blockmap.all_left[t] = 1

        def get_all_right(s):
            if s.blockmap.all_right is None:
                s.blockmap.all_right = {}
            for t in s.blockmap.right:
                if t.blockmap.all_right is None:
                    get_all_right(t)
                s.blockmap.all_right.update(t.blockmap.all_right)
                s.blockmap.all_right[t] = 1

        for r in s.rows:
            get_all_left(r)
            get_all_right(r)
        for r in s.rows:
            r.blockmap.all_left = tuple(r.blockmap.all_left.keys())
            r.blockmap.all_right = tuple(r.blockmap.all_right.keys())

        # create other stacks
        for i in range(4):
            for j in range(9):
                if show_removed:
                    x = l.XM+i*cardw
                    y = l.YM+fdyy+j*cardh
                else:
                    if TOOLKIT == 'tk':
                        x = -l.XS-self.canvas.xmargin
                        y = l.YM+dyy
                    elif TOOLKIT == 'kivy':
                        x = -1000
                        y = l.YM+dyy
                    elif TOOLKIT == 'gtk':
                        # FIXME
                        x = self.width - l.XS
                        y = self.height - l.YS
                stack = Mahjongg_Foundation(x, y, self)
                if show_removed:
                    stack.CARD_XOFFSET = dx
                    stack.CARD_YOFFSET = dy
                s.foundations.append(stack)

        self.texts.info = MfxCanvasText(self.canvas,
                                        self.width - l.XM - ti_width,
                                        l.YM + dyy,
                                        anchor="nw", font=font)
        # the Talon is invisble
        s.talon = InitialDealTalonStack(-l.XS-self.canvas.xmargin,
                                        self.height-dyy, self)

        # Define stack groups
        l.defaultStackGroups()

    #
    # game overrides
    #

    def _shuffleHook(self, cards):
        if self.app.opt.mahjongg_create_solvable == 0:
            return cards
        # try to create a solvable game
        if self.app.opt.mahjongg_create_solvable == 1:
            # easy
            return self._shuffleHook1(cards[:])
        # hard
        new_cards = self._shuffleHook2(self.s.rows, cards)
        if new_cards is None:
            return cards
        return new_cards

    def _shuffleHook1(self, cards):
        # old version; it generate a very easy layouts
        old_cards = cards[:]
        rows = self.s.rows

        def is_blocked(s, new_cards):
            # any of above blocks
            for stack in s.blockmap.above:
                if new_cards[stack.id] is None:
                    return True
            # any of left blocks - but we can try right as well
            for stack in s.blockmap.left:
                if new_cards[stack.id] is None:
                    break
            else:
                return False
            # any of right blocks
            for stack in s.blockmap.right:
                if new_cards[stack.id] is None:
                    return True
            return False

        def create_solvable(cards, new_cards):
            if not cards:
                return new_cards
            # select two matching cards
            c1 = cards[0]
            del cards[0]
            c2 = None
            for i in range(len(cards)):
                if self.cardsMatch(c1, cards[i]):
                    c2 = cards[i]
                    del cards[i]
                    break
            #
            free_stacks = []            # none-blocked stacks
            for r in rows:
                if new_cards[r.id] is None and not is_blocked(r, new_cards):
                    free_stacks.append(r)
            if len(free_stacks) < 2:
                return None             # try another way
            #
            i = factorial(len(free_stacks))//2//factorial(len(free_stacks)-2)
            old_pairs = []
            for j in range(i):
                nc = new_cards[:]
                while True:
                    # create uniq pair
                    r1 = self.random.randrange(0, len(free_stacks))
                    r2 = self.random.randrange(0, len(free_stacks)-1)
                    if r2 >= r1:
                        r2 += 1
                    if (r1, r2) not in old_pairs and (r2, r1) not in old_pairs:
                        old_pairs.append((r1, r2))
                        break
                # add two selected cards to new_cards
                s1 = free_stacks[r1]
                s2 = free_stacks[r2]
                nc[s1.id] = c1
                nc[s2.id] = c2
                # check if this layout is solvable (backtracking)
                nc = create_solvable(cards[:], nc)
                if nc:
                    return nc
            return None                 # try another way

        new_cards = create_solvable(cards, [None]*len(cards))
        if new_cards:
            new_cards.reverse()
            return new_cards
        print('oops! can\'t create a solvable game')
        return old_cards

    def _shuffleHook2(self, rows, cards):

        start_time = time.time()
        iters = [0]
        # limitations
        max_time = 5.0                  # seconds
        max_iters = 2*len(cards)

        def is_suitable(stack, cards):
            for s in stack.blockmap.below:
                if cards[s.id] == 1:
                    continue
                # check if below stacks are non-empty
                if cards[s.id] is None:
                    return False

            for s in stack.blockmap.left:
                if cards[s.id] == 1:
                    continue
                if cards[s.id] is None:
                    for t in s.blockmap.all_left:
                        if cards[t.id] == 1:
                            continue
                        if cards[t.id] is not None:
                            # we have empty stack between two non-empty
                            return False

            for s in stack.blockmap.right:
                if cards[s.id] == 1:
                    continue
                if cards[s.id] is None:
                    for t in s.blockmap.all_right:
                        if cards[t.id] == 1:
                            continue
                        if cards[t.id] is not None:
                            # we have empty stack between two non-empty
                            return False
            return True

        def create_solvable(cards, new_cards):
            iters[0] += 1
            if iters[0] > max_iters:
                return None
            if time.time() - start_time > max_time:
                return None
            if not cards:
                return new_cards

            nc = new_cards[:]

            # select two matching cards
            c1 = cards[0]
            del cards[0]
            c2 = None
            for i in range(len(cards)):
                if self.cardsMatch(c1, cards[i]):
                    c2 = cards[i]
                    del cards[i]
                    break

            # find suitable stacks
            #  suitable_stacks = []
            #  for r in rows:
            #      if nc[r.id] is None and is_suitable(r, nc):
            #          suitable_stacks.append(r)
            suitable_stacks = [r for r in rows
                               if nc[r.id] is None and is_suitable(r, nc)]

            old_pairs = []
            i = factorial(len(suitable_stacks))//2 \
                // factorial(len(suitable_stacks)-2)
            for j in range(i):
                if iters[0] > max_iters:
                    return None
                if time.time() - start_time > max_time:
                    return None

                # select two suitable stacks
                while True:
                    # create a uniq pair
                    r1 = self.random.randrange(0, len(suitable_stacks))
                    r2 = self.random.randrange(0, len(suitable_stacks))
                    if r1 == r2:
                        continue
                    if (r1, r2) not in old_pairs and (r2, r1) not in old_pairs:
                        old_pairs.append((r1, r2))
                        break
                s1 = suitable_stacks[r1]
                s2 = suitable_stacks[r2]
                # check if s1 don't block s2
                nc[s1.id] = c1
                if not is_suitable(s2, nc):
                    nc[s1.id] = None
                    continue
                nc[s2.id] = c2
                # check if this layout is solvable (backtracking)
                ret = create_solvable(cards[:], nc)
                if ret:
                    ret = [x for x in ret if x != 1]
                    return ret
                nc[s1.id] = nc[s2.id] = None  # try another way

            return None

        new_cards = [None]*len(self.s.rows)  # None - empty stack, 1 - non-used
        drows = dict.fromkeys(rows)     # optimization
        for r in self.s.rows:
            if r not in drows:
                new_cards[r.id] = 1
        del drows

        while True:
            ret = create_solvable(cards[:], new_cards)
            if DEBUG:
                print('create_solvable time:', time.time() - start_time)
            if ret:
                ret.reverse()
                return ret
            if time.time() - start_time > max_time or \
                    iters[0] <= max_iters:
                print('oops! can\'t create a solvable game')
                return None
            iters = [0]
        print('oops! can\'t create a solvable game')
        return None

    def _mahjonggShuffle(self):
        talon = self.s.talon
        rows = []
        cards = []

        for r in self.s.rows:
            if r.cards:
                rows.append(r)
                cards.append(r.cards[0])
        if not rows:
            return

        if self.app.opt.mahjongg_create_solvable == 0:
            self.playSample('turnwaste')
            old_state = self.enterState(self.S_FILL)
            self.saveSeedMove()
            for r in rows:
                self.moveMove(1, r, talon, frames=0)
            self.shuffleStackMove(talon)
            for r in rows:
                self.moveMove(1, talon, r, frames=0)
            self.leaveState(old_state)
            self.finishMove()
            return

        self.playSample('turnwaste')
        old_state = self.enterState(self.S_FILL)
        self.saveSeedMove()

        new_cards = self._shuffleHook2(rows, cards)
        if new_cards is None:
            if TOOLKIT != 'kivy':
                MfxMessageDialog(self.top, title=_('Warning'),
                                 text=_('''\
Sorry, I can\'t find
a solvable configuration.'''),
                                 bitmap='warning')

            self.leaveState(old_state)
            # self.finishMove()
            # hack
            am = self.moves.current[0]
            am.undo(self)               # restore random
            self.moves.current = []
            return

        self.stats.shuffle_moves += 1
        # move new_cards to talon
        for c in new_cards:
            for r in rows:
                if r.cards and r.cards[0] is c:
                    self.moveMove(1, r, talon, frames=0)
                    break
        # deal
        for r in rows:
            self.moveMove(1, talon, r, frames=0)

        self.leaveState(old_state)
        self.finishMove()

    def canShuffle(self):
        return True

    def startGame(self):
        assert len(self.s.talon.cards) == self.NCARDS
        # self.s.talon.dealRow(rows = self.s.rows, frames = 0)
        n = 12
        self.s.talon.dealRow(rows=self.s.rows[:self.NCARDS-n], frames=0)
        self.startDealSample()
        self.s.talon.dealRow(rows=self.s.rows[self.NCARDS-n:])
        assert len(self.s.talon.cards) == 0

    def isGameWon(self):
        return sum([len(f.cards) for f in self.s.foundations]) == self.NCARDS

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        if stack1.basicIsBlocked() or stack2.basicIsBlocked():
            return 0
        return self.cardsMatch(card1, card2)

    def getAutoStacks(self, event=None):
        return ((), (), ())

    def updateText(self):
        if self.preview > 1 or self.texts.info is None:
            return

        # find matching tiles
        stacks = []
        for r in self.s.rows:
            if r.cards and not r.basicIsBlocked():
                stacks.append(r)
        f, i = 0, 0
        for r in stacks:
            n = 0
            for t in stacks[i+1:]:
                if self.cardsMatch(r.cards[0], t.cards[0]):
                    n += 1
            # if n == 3: n = 1
            # elif n == 2: n = 0
            n = n % 2
            f += n
            i += 1

        if f == 0:
            f = _('No Free\nMatching\nPairs')
        else:
            f = ungettext('%d Free\nMatching\nPair',
                          '%d Free\nMatching\nPairs',
                          f) % f
        t = sum([len(ii.cards) for ii in self.s.foundations])
        r1 = ungettext('%d\nTile\nRemoved\n\n',
                       '%d\nTiles\nRemoved\n\n',
                       t) % t
        r2 = ungettext('%d\nTile\nRemaining\n\n',
                       '%d\nTiles\nRemaining\n\n',
                       self.NCARDS - t) % (self.NCARDS - t)

        t = r1 + r2 + f
        self.texts.info.config(text=t)

    #
    # Mahjongg special overrides
    #

    def getHighlightPilesStacks(self):
        # Mahjongg special: highlight all moveable tiles
        return ((self.s.rows, 1),)

    def _highlightCards(self, info, sleep=1.5, delta=(1, 1, 1, 1)):
        if not Image:
            delta = (-self._delta_x, 0, 0, -self._delta_y)
            return Game._highlightCards(self, info, sleep=sleep, delta=delta)

        if not info:
            return 0
        if self.pause:
            return 0
        self.stopWinAnimation()
        items = []
        for s, c1, c2, color in info:
            assert c1 is c2
            assert c1 in s.cards
            x, y = s.x, s.y
            img = self.app.images.getHighlightedCard(
                c1.deck, c1.suit, c1.rank, 'black')
            if img is None:
                continue
            img = MfxCanvasImage(self.canvas, x, y, image=img,
                                 anchor=ANCHOR_NW, group=s.group)
            if self.drag.stack and s is self.drag.stack:
                img.tkraise(self.drag.shade_img)
            else:
                img.tkraise(c1.item)
            items.append(img)
        if not items:
            return 0
        self.canvas.update_idletasks()
        if sleep:
            self.sleep(sleep)
            items.reverse()
            for r in items:
                r.delete()
            self.canvas.update_idletasks()
            return EVENT_HANDLED
        else:
            # remove items later (find_card_dialog)
            return items

    def getCardFaceImage(self, deck, suit, rank):
        if suit == 3:
            cs = self.app.cardset
            if len(cs.ranks) >= 12 and len(cs.suits) >= 4:
                # make Mahjongg type games playable with other cardsets
                if rank >= 8:       # flower
                    suit = 1
                    rank = len(cs.ranks) - 2
                elif rank >= 4:     # season
                    rank = max(10, len(cs.ranks) - 3)
                else:               # wind
                    suit = rank
                    rank = len(cs.ranks) - 1
        return self.app.images.getFace(deck, suit, rank)

    def getCardBackImage(self, deck, suit, rank):
        # We avoid screen updates caused by flipping cards - all
        # cards are face up anyway. The Talon should be invisible
        # or else the top tile of the Talon will be visible during
        # game start.
        return self.getCardFaceImage(deck, suit, rank)

    def _createCard(self, id, deck, suit, rank, x, y):
        # if deck >= 1 and suit == 3 and rank >= 4:
        if deck % 4 and suit == 3 and rank >= 4:
            return None
        return Game._createCard(self, id, deck, suit, rank, x, y)

    def _getClosestStack(self, cx, cy, stacks, dragstack):
        closest, cdist = None, 999999999
        # Since we only compare distances,
        # we don't bother to take the square root.
        for stack in stacks:
            dist = (stack.x - cx)**2 + (stack.y - cy)**2
            if dist < cdist:
                # Mahjongg special: if the stack is very close, do
                # not consider blocked stacks
                if dist > self.check_dist or not stack.basicIsBlocked():
                    closest, cdist = stack, dist
        return closest

    #
    # Mahjongg extras
    #

    def cardsMatch(self, card1, card2):
        if card1.suit != card2.suit:
            return 0
        if card1.suit == 3:
            if card1.rank >= 8:
                return card2.rank >= 8
            if card1.rank >= 4:
                return 7 >= card2.rank >= 4
        return card1.rank == card2.rank


#  mahjongg util
def comp_cardset(ncards):
    # calc decks, ranks & trumps
    assert ncards % 4 == 0
    assert 0 < ncards <= 288  # ???
    decks = 1
    cards = ncards//4
    if ncards > 144:
        assert ncards % 8 == 0
        decks = 2
        cards = cards//2
    ranks, trumps = divmod(cards, 3)
    if ranks > 10:
        trumps += (ranks-10)*3
        ranks = 10
    if trumps > 4:
        trumps = 4+(trumps-4)*4
    assert 0 <= ranks <= 10 and 0 <= trumps <= 12
    return decks, ranks, trumps

# ************************************************************************
# * register a Mahjongg type game
# ************************************************************************


def r(id, short_name, name=None, ncards=144, layout=None):
    assert layout
    if not name:
        name = "Mahjongg " + short_name
    classname = re.sub('\\W', '', name)
    # create class
    gameclass = type(classname, (AbstractMahjonggGame,), {})
    gameclass.L = layout
    gameclass.NCARDS = ncards
    decks, ranks, trumps = comp_cardset(ncards)
    gi = GameInfo(id, gameclass, name,
                  GI.GT_MAHJONGG, 4*decks, 0,  # GI.SL_MOSTLY_SKILL,
                  category=GI.GC_MAHJONGG, short_name=short_name,
                  suits=list(range(3)), ranks=list(range(ranks)),
                  trumps=list(range(trumps)),
                  si={"decks": decks, "ncards": ncards})
    gi.ncards = ncards
    gi.rules_filename = "mahjongg.html"
    registerGame(gi)
    return gi
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.games.mahjongg.mahjongg import r

# ************************************************************************
# * game definitions
# ************************************************************************

r(5001, "Altar", layout="0aaaacaaiaakaama" +
    "aoaaqaasaauaawaa" +
    "CaaEaaacaccaicck" +
    "ccmccoccqccsccuc" +
    "awcaCcaEcaieckec" +
    "mecoecqecsecueaw" +
    "eaigckgcmgcogcqg" +
    "csgcugawgaiiakia" +
    "miaoiaqiasiauiaw" +
    "iaokaqkaamacmaom" +
    "aqmaCmaEmaaoacoa" +
    "ooaqoaCoaEohabhc" +
    "bhCbhEbkpijpkipm" +
    "hanhcnhCnhEnhpoo" +
    "bboDbobnoDnvlcvn" +
    "cvpcvrcvtcvlevne" +
    "vpevrevtevlgwngw" +
    "pgwrgvtgCocCqcCm" +
    "eCoeCqeCse")
r(5002, "Arena", layout="0eaadcaceabgaaia" +
    "aqabsacuadwaeyad" +
    "accccbecagcakcbm" +
    "caocascbuccwcdyc" +
    "caebceaeeameaueb" +
    "wecyebagacgakgbm" +
    "gaogawgbygcaibci" +
    "aeiamiauibwicyid" +
    "akcckbekagkakkbm" +
    "kaokaskbukcwkdyk" +
    "eamdcmcembgmaima" +
    "qmbsmcumdwmeym")
r(5003, "Arena 2", layout="0daadcabeabgaaia" +
    "akaamaaoaaqaasab" +
    "uabwadyadAadaccc" +
    "cbecagcaucbwccyc" +
    "dAcdaecceaeeawec" +
    "yedAedagccgaegaw" +
    "gcygdAgdaicciaei" +
    "awicyidAidakcckb" +
    "ekagkaukbwkcykdA" +
    "kdamdcmbembgmaim" +
    "asmbumbwmdymdAm")
#
r(5004, "Arrow", layout="0aaaaqbaacaccasc" +
    "aqdaudaaeaceaeea" +
    "geaieakeameaoeas" +
    "eaweaqfaufayfaag" +
    "acgaegaggaigakga" +
    "mgaogasgawgaAgaC" +
    "gaqhauhayhaaiaci" +
    "aeiagiaiiakiamia" +
    "oiasiawiaqjaujaa" +
    "kackaskaqlaamhbc" +
    "hrdhbehdehfehheh" +
    "jehlehnehpehtehr" +
    "fhvfhbghdghfghhg" +
    "hjghlghnghpghtgh" +
    "xghrhhvhhbihdihf" +
    "ihhihjihlihnihpi" +
    "htihrjhbkoceoeeo" +
    "geoieokeomeooeoq" +
    "eosfocgoegoggoig" +
    "okgomgoogoqgougo" +
    "shocioeiogioiiok" +
    "iomiooioqivfevhe" +
    "vjevlevnevpevfgv" +
    "hgvjgvlgvngvpgvr" +
    "gvfivhivjivlivni" +
    "vpiCkeCmeCoeCkgC" +
    "mgCogCqgCkiCmiCo" +
    "i")
r(5005, "Art Moderne", layout="0acaaeaagaaiaaka" +
    "amaaoaauaawaaaba" +
    "lcapcatcavcaxcaa" +
    "daddaleapeaseaue" +
    "bxeaafacfalganga" +
    "pgargatgavgaxgaa" +
    "hachaliapiasiaui" +
    "bxiaajadjalkapka" +
    "tkavkaxkaalacmae" +
    "magmaimakmammaom" +
    "aumawmhdahfahhah" +
    "jahlahnahvahxahu" +
    "chwchychedhldhpd" +
    "haehtehvehdfhlfh" +
    "pfhaghsghughwghd" +
    "hhlhhphhaihtihvi" +
    "hejhljhpjhukhwkh" +
    "ykhdmhfmhhmhjmhl" +
    "mhnmhvmhxmowaoya" +
    "ovcoxcozcofdokdo" +
    "ueoweoyeoefokfom" +
    "gotgovgoehokhoui" +
    "owioyiofjokjovko" +
    "xkozkowmoymvgdvj" +
    "dvffvjfvlgvfhvjh" +
    "vgjvjjChdCgfCifC" +
    "kgCghCihChj")
r(5006, "Balance", layout="0eoaeebbgbbibbkb" +
    "bmbbqbbsbbubbwbe" +
    "ybeoccedcydcoecc" +
    "faefcgfcwfayfcAf" +
    "cogachaghawhaAhc" +
    "oiaajacjaejagjai" +
    "jaujawjayjaAjaCj" +
    "cokadlaflaxlazlc" +
    "omagoaioakoamoao" +
    "oaqoasoauoawohbj" +
    "hdjhfjhhjhvjhxjh" +
    "zjhBjjeljylhhoij" +
    "ojloknokpojroito" +
    "hvoocjoejogjowjo" +
    "yjoAjvdjvfjvxjvz" +
    "jCejCyj")
r(5007, "Bat", layout="0ecaeAaaabalbanb" +
    "apbarbaCbcccaeca" +
    "yccAcaadandapdaC" +
    "dcceaeebgeaieaue" +
    "bweayecAeaafanfa" +
    "pfaCfbcgbegaggbi" +
    "gakgasgbugawgbyg" +
    "bAgaahamhbohaqha" +
    "Chbcibeiagibiiak" +
    "iasibuiawibyibAi" +
    "aajamjbojaqjaCjc" +
    "ckaekbgkaikakkas" +
    "kaukbwkaykcAkaal" +
    "aolaClccmaemaima" +
    "kmasmaumaymcAmaa" +
    "naCnecobkobsoeAo" +
    "hobhodhofhaghCgh" +
    "aihCi")
#
r(5008, "Beatle", layout="0aeaagaauaawaaic" +
    "akcamcaocaqcasca" +
    "eeageaieakeameao" +
    "eaqeaseaueadgafg" +
    "ahgajgalgangapga" +
    "rgatgavgaeiagiai" +
    "iakiamiaoiaqiasi" +
    "auiaikakkamkaoka" +
    "qkaskaemagmaumaw" +
    "mhhbhtbhjchlchnc" +
    "hpchrchdehfehheh" +
    "jehlehnehpehreht" +
    "eiegiggiigikgimg" +
    "iogiqgisghughdih" +
    "fihhihjihlihnihp" +
    "ihrihtihjkhlkhnk" +
    "hpkhrkhhlhtloceo" +
    "geoieokeomeooeoq" +
    "eoseociogioiioki" +
    "omiooioqiosivbdv" +
    "hevjevlevnevpevr" +
    "evfgvhgvjgvlgvng" +
    "vpgvrgvhivjivliv" +
    "nivpivrivbjCaaCa" +
    "cCggCigCkgCmgCog" +
    "CqgCakCam")
r(5009, "Big Hole", layout="0daadcadeadgadia" +
    "dkadmadoaaaccccd" +
    "ecdgcdicdkccmcao" +
    "caaeccedeedkecme" +
    "aoeaagccgdegdkgc" +
    "mgaogaaiccideidg" +
    "idiidkicmiaoidak" +
    "dckdekdgkdikdkkd" +
    "mkdok")
r(5010, "Bizarre", layout="0aaaaGadkbdmbdob" +
    "dqbdsbdubdwbdkdc" +
    "mdcodcqdcsdcuddw" +
    "ddkfcmfbofbqfbsf" +
    "cufdwfdkhcmhboha" +
    "qhbshcuhdwhakjbm" +
    "jcojdqjcsjbujawj" +
    "aklbmlcolcqlcslb" +
    "ulawlaknbmnbonbq" +
    "nbsnbunawnakpamp" +
    "aopaqpaspaupawpa" +
    "aqaGq")
r(5011, "Boat", layout="0alaapaataajcblc" +
    "apcbtcavcahebjec" +
    "leapectebveaxeaf" +
    "gbhgcjgdlgapgdtg" +
    "cvgbxgazgadibfic" +
    "hidjieliapietidv" +
    "icxibziaBiapkaam" +
    "bcmbembgmbimbkmb" +
    "mmbombqmbsmbumbw" +
    "mbymbAmbCmaEmado" +
    "bfobhobjoblobnob" +
    "pobrobtobvobxobz" +
    "oaBoaiqbkqbmqboq" +
    "bqqbsqbuqawq")
r(5012, "Bug", layout="0bhabnabtaajbapb" +
    "avbcadaidakdamda" +
    "odaqdasdaudawdac" +
    "eayeagfbifbkfbmf" +
    "bofbqfbsfbufbwfa" +
    "Afdegaygbchbghci" +
    "hckhcmhcohcqhcsh" +
    "cuhbwhaAhdeiayia" +
    "gjbijbkjbmjbojbq" +
    "jbsjbujbwjaAjack" +
    "aykcalailaklamla" +
    "olaqlaslaulawlaj" +
    "napnavnbhobnobto" +
    "hyhojfolfonfopfo" +
    "rfotfovfojjoljon" +
    "jopjorjotjovjvjh" +
    "vlhvnhvphvrhvthC" +
    "khCmhCohCqhCsh")
r(5013, "Butterfly", layout="0dmadqaaabaebayb" +
    "aCbagccocawcaada" +
    "edaidaudaydaCdac" +
    "eageakedoeaseawe" +
    "aAeaafaefbifamfa" +
    "qfbufayfaCfacgag" +
    "gbkgeogbsgawgaAg" +
    "aahaehbihbmhbqhb" +
    "uhayhaChaciagibk" +
    "ieoibsiawiaAiaaj" +
    "aejbijamjaqjbuja" +
    "yjaCjackagkakkeo" +
    "kaskawkaAkaalael" +
    "ailaulaylaClacma" +
    "gmeomawmaAmaanae" +
    "naynaCncoohgdhwd" +
    "heehyehcfhgfhwfh" +
    "AfhaghCghaihCihc" +
    "jhgjhwjhAjhekhyk" +
    "hglhwl")
#
r(5014, "Castle", layout="0eaaccaceacgacia" +
    "ckaemacacaccaeca" +
    "gcaicakccmcdaeac" +
    "eaeeageaieakedme" +
    "aoecagacgaegagga" +
    "igakgcmgbogaqgda" +
    "iaciaeiagiaiiaki" +
    "dmiaoicakackaeka" +
    "gkaikakkcmkeamcc" +
    "mcemcgmcimckmemm" +
    "hddhfdhhdhjdhdfh" +
    "ffhhfhjfhdhhfhhh" +
    "hhjhhdjhfjhhjhjj" +
    "oeeogeoieoegoggo" +
    "igoeiogioiivffvh" +
    "fvfhvhhCgg")
r(5015, "Cat and Mouse", layout="0cfabhacjablacna" +
    "bpacrabtacBacFab" +
    "dbbvbbbcbxcbBccD" +
    "cbFcahdajdaldbzd" +
    "baecBebDecFeahfa" +
    "jfalfbagahhajhal" +
    "hbuhbBhbbibsibwi" +
    "bFibqjbBjbckbokb" +
    "xkbFkcelbglcilbk" +
    "lcmlbsmbwmbunbAo" +
    "cCocEocGohiehkeh" +
    "ighkgohdojdoldoh" +
    "fojfolfohhojholh" +
    "oBkoFloAnvievkev" +
    "igvkgvBlvFmCjdCh" +
    "fClfCjh")
r(5016, "Ceremonial", layout="0bcabeaajaalaana" +
    "apaaraataavabAab" +
    "CabdcbfcbzcbBcaa" +
    "dapdaEdbeebgeane" +
    "arebyebAeaafbifb" +
    "kfapfbufbwfaEfbm" +
    "gbsgaahaphaEhbmi" +
    "bsiaajbijbkjapjb" +
    "ujbwjaEjbekbgkan" +
    "karkbykbAkaalapl" +
    "aElbdmbfmbzmbBmb" +
    "cobeoajoaloanoap" +
    "oaroatoavobAobCo" +
    "hkahmahoahqahsah" +
    "uahaehoehqehEeha" +
    "gipghEghaiipihEi" +
    "hakhokhqkhEkhkoh" +
    "mohoohqohsohuoon" +
    "aopaoraopeoahoEh" +
    "opkonoopoorovph")
r(5017, "Checkered", layout="0baabCaacbbebagb" +
    "bibakbbmbaobbqba" +
    "sbbubawbbybaAbbc" +
    "daedbgdaidbkdamd" +
    "bodaqdbsdaudbwda" +
    "ydbAdacfbefagfbi" +
    "fakfbmfaofbqfasf" +
    "bufawfbyfaAfbcha" +
    "ehbghaihbkhamhbo" +
    "haqhbshauhbwhayh" +
    "bAhacjbejagjbija" +
    "kjbmjaojbqjasjbu" +
    "jawjbyjaAjbclael" +
    "bglailbklamlbola" +
    "qlbslaulbwlaylbA" +
    "lacnbenagnbinakn" +
    "bmnaonbqnasnbuna" +
    "wnbynaAnbaobCo")
#
r(5018, "Chip", layout="0aeaaiaamaaqaata" +
    "becbgcbicbkcbmcb" +
    "ocbqcbscbucbwcaa" +
    "dbcdbydaAdbeecge" +
    "cieckecmecoecqec" +
    "secuebweaagbcgbe" +
    "gdggbigakgamgaog" +
    "aqgbsgdugbwgbyga" +
    "Agbeicgiciickicm" +
    "icoicqicsicuibwi" +
    "aajbcjbyjaAjbekb" +
    "gkbikbkkbmkbokbq" +
    "kbskbukbwkaemaim" +
    "ammaqmaum")
r(5019, "Columns", layout="0egaaiaakaamaaoa" +
    "aqaasaauaewaaeba" +
    "ybagcaicaocaucaw" +
    "ceadbcdaedaydbAd" +
    "eCdageekeameaoea" +
    "qeeseawebafbCfag" +
    "gakgasgawgaahamh" +
    "eohaqhaChagiakia" +
    "siawibajbCjagkdk" +
    "kamkaokaqkeskawk" +
    "ealbclaelaylbAle" +
    "Clagmaimaomaumaw" +
    "maenaynegoaioako" +
    "amoaooaqoasoauoe" +
    "wohgfhwfjghjwhhg" +
    "jhwj")
r(5020, "Crown", layout="0baabcabeabgabka" +
    "bmaboabqabsabwab" +
    "yabAabCabacaccae" +
    "cbgcbkcamcbocaqc" +
    "bscbwcaycaAcbCcb" +
    "aeaeebgebkeameaq" +
    "ebsebweayebCebag" +
    "aegbggbigbkgamga" +
    "qgbsgbugbwgaygbC" +
    "gbaiaeiagiaiiaki" +
    "amiaqiasiauiawia" +
    "yibCibakbCkbamac" +
    "maemagmaimakmbom" +
    "asmaumawmaymaAmb" +
    "Cmbaobcobeobgobi" +
    "obkoamobooaqobso" +
    "buobwobyobAobCo")
#
r(5021, "Cupola", layout="0aiaakaamaaoaaqa" +
    "asaagbaubaecawca" +
    "cdaydabfeofazfaa" +
    "hajhalhanhapharh" +
    "athaAhaajeojaAja" +
    "blazlacnaynaeoaw" +
    "oagpaupaiqakqamq" +
    "aoqaqqasqhjbhlbh" +
    "nbhpbhrbhhchtchf" +
    "dhvdhdehxehcghyg" +
    "hkhhmhhohhqhhshh" +
    "bihzihckhykhdmhx" +
    "mhfnhvnhhohtohjp" +
    "hlphnphpphrpokco" +
    "mcoocoqcoidosdog" +
    "eoueoefowfodholh" +
    "onhophorhoxhodjo" +
    "xjoelowlogmoumoi" +
    "nosnokoomoooooqo" +
    "vldvndvpdvjevrev" +
    "hfvtfvfgvvgvmhvo" +
    "hvqhveivwivfkvvk" +
    "vhlvtlvjmvrmvlnv" +
    "nnvpnCifCsfCggCu" +
    "gCnhCphCfiCviCgk" +
    "CukCilCsl")
r(5022, "Deep Well", layout="0acaaeaagaaiaaka" +
    "amaaaccccceccgcc" +
    "icckccmcaocaaecc" +
    "eeeeegeeieekecme" +
    "aoeaagccgeegekgc" +
    "mgaogaaiccieeiek" +
    "icmiaoiaakcckeek" +
    "egkeikekkcmkaoka" +
    "amccmcemcgmcimck" +
    "mcmmaomacoaeoago" +
    "aioakoamo")
r(5023, "Dragon", layout="0bgaaiaegceicdkc" +
    "cmcbocbqcbscbuca" +
    "wcaycaceaeeageai" +
    "eakebmeboeaqease" +
    "aueaweayeadgbfga" +
    "hgajgalgangapgaE" +
    "gayhaChaaiaciaei" +
    "agiaiiakiamiaoia" +
    "qiasiauiaAiaEiaC" +
    "jabkadkafkahkajk" +
    "alkaEkaamacmaema" +
    "gmbimakmaaoacobe" +
    "oagoaiockoamoixc" +
    "hdejhejigkkgjmgh" +
    "Ehhbihdikhikjijl" +
    "iiniipihrihtihCi" +
    "hEjhckhgkhkkhbmh" +
    "fmhboihopneocioE" +
    "iobn")
r(5024, "Dude", layout="0bfabtabhbbjbblb" +
    "brbaBbatcavcaxca" +
    "zcaedagdbldbndbp" +
    "dbrdacebjebueaye" +
    "aAeaCeaafbhfcmfc" +
    "ofcqfcsfbwfaEfbf" +
    "gckgcugbygcphbAh" +
    "beickicuicpjbBjc" +
    "jkclkcnkcrkctkcv" +
    "kcjmclmcnmcrmctm" +
    "cvmcpncjocvockqc" +
    "mqcoqcqqcsqcuq")
# r(5025, "Eagle", layout="0cmadoacqaasbbmc" +
#    "bocaedagdaudawdb" +
#    "cebieakebmeboeaq" +
#    "ebsebyeaefagfauf" +
#    "awfbcgbigakgbmgb" +
#    "ogaqgbsgbygaehag" +
#    "hauhawhaaiacibmi" +
#    "boiayiaAibejbwja" +
#    "akackbmkbokaykaA" +
#    "kaambkmanmbqmaAm" +
#    "cioclocpocsoheeh" +
#    "gehuehweheghgghu" +
#    "ghwghbihzihbkhzk" +
#    "omdoododeofeoheo" +
#    "teoveoxeomfoofod" +
#    "gofgohgotgovgoxg" +
#    "omhoohobjomjoojo" +
#    "zjvndveevgevuevw" +
#    "evnfvegvggvugvwg" +
#    "vnhvnjCfeCveCfgC" +
#    "vg")
r(5026, "Enterprise", layout="0agaaiaakaamaaoa" +
    "aqaasaauaawaayaa" +
    "acbccbecbgcbicbk" +
    "cbmcbocbqcbscbuc" +
    "bwcbycbAcbCcaEcd" +
    "qedogdmhaAiaajbc" +
    "jcejdgjeijekjemj" +
    "eojcqjayjaCjaAkh" +
    "haijailainaipair" +
    "aitaivahxaiAjodc" +
    "ofcohcojcolconco" +
    "pcorcotcovcoxcoz" +
    "coBcvkavmavoavqa" +
    "vsavecvgcvicvkcv" +
    "mcvocvqcvscvucvw" +
    "cvycChcCjcClcCnc" +
    "CpcCrcCtcCvc")
#
r(5027, "Eye", layout="0amaaoaakbaqbaic" +
    "amcaocascagdakda" +
    "qdaudaeeaieameao" +
    "easeaweacfagfakf" +
    "aqfaufayfaagaega" +
    "igamgaogasgawgaA" +
    "gachaghakhaqhauh" +
    "ayhaeiaiiamiaoia" +
    "siawiagjakjaqjau" +
    "jaikamkaokaskakl" +
    "aqlammaomhlbhobh" +
    "jchqchhdhldhodhs" +
    "dhfehjehqehuehdf" +
    "hhfhlfhofhsfhwfh" +
    "fghjghqghughdhhh" +
    "hhlhhohhshhwhhfi" +
    "hjihqihuihhjhljh" +
    "ojhsjhjkhqkhllho" +
    "lolcoocojdoqdohe" +
    "oleooeoseoffojfo" +
    "qfoufohgolgoogos" +
    "gowgofhojhoqhouh" +
    "ohioliooiosiojjo" +
    "qjolkookvldvodvj" +
    "evqevhfvlfvofvsf" +
    "vfgvjgvqgvhhvlhv" +
    "ohvshvjivqivljvo" +
    "j")
r(5028, "F-15 Eagle", layout="0aobaqbasbaubbEc" +
    "bGcandapdardatda" +
    "lebDebFeajfanfap" +
    "farfalgatgavgaxg" +
    "azgaBgaDgabhadha" +
    "fhahhajhanhaphar" +
    "haliatiaviaxiazi" +
    "aBiaDiajjanjapja" +
    "rjalkbDkbFkanlap" +
    "larlatlbEmbGmaon" +
    "aqnasnaunhpahrah" +
    "tahvahochqchschu" +
    "chmehoehqehsehif" +
    "hkfhmghoghqghsgh" +
    "ughwghyghAghCgia" +
    "hichjehjghjihjkh" +
    "hmihoihqihsihuih" +
    "wihyihAihCihijhk" +
    "jhmkhokhqkhskhom" +
    "hqmhsmhumhpohroh" +
    "tohvoozfoBfoDfom" +
    "hozjoBjoDjvAfvCf" +
    "vAjvCjCBfCDfCfhC" +
    "hhCjhCBjCDj")
r(5029, "Farandole", layout="0beabgabmaboabqa" +
    "bwabyabcbbibbkbb" +
    "sbbubbAbafcaxcbb" +
    "dbBdckecmecqecse" +
    "bbfbgfcifcufbwfb" +
    "Bfbegbygbahbchaj" +
    "hblhcnhcphbrhath" +
    "bAhbChbeibyibbjb" +
    "gjcijcujbwjbBjck" +
    "kcmkcqkcskbblbBl" +
    "afmaxmbcnbinbknb" +
    "snbunbAnbeobgobm" +
    "oboobqobwobyo")
r(5030, "Fish", layout="0afaajaasaauaawa" +
    "bhbaobaqbaybacca" +
    "mcbscbucbwcaAcak" +
    "dbodbqdaydaCdace" +
    "aeeaiebmebsebueb" +
    "weaEeagfbkfbofbq" +
    "fayfaCfacgaegaig" +
    "bmgbsgbugbwgaAga" +
    "EgakhbohbqhbyhaC" +
    "haciamibsibuibwi" +
    "aAiaojaqjayjahka" +
    "skaukawkbjlcemal" +
    "mbcndgnbCnaaoeio" +
    "aqoasodAoaEodkpb" +
    "opbupdypcmqcwqhc" +
    "dhcfhefhifhchore" +
    "oteolfonfopfovfo" +
    "rgotgovhoxh")
#
r(5031, "Five Pyramids", layout="0aaaacaaeaagaaya" +
    "aAaaCaaEaaacacca" +
    "ecagcapcaycaAcaC" +
    "caEcaaeaceaeeage" +
    "apeayeaAeaCeaEea" +
    "agacgaegaggangap" +
    "gargaygaAgaCgaEg" +
    "alhathaniapiaria" +
    "akackaekagkapkay" +
    "kaAkaCkaEkaamacm" +
    "aemagmapmaymaAma" +
    "CmaEmaaoacoaeoag" +
    "oayoaAoaCoaEoaaq" +
    "acqaeqagqayqaAqa" +
    "CqaEqhbbhdbhfbhz" +
    "bhBbhDbhbdhddhfd" +
    "hpdhzdhBdhDdhbfh" +
    "dfhffipfhzfhBfhD" +
    "fhnhhphhrhipjhbl" +
    "hdlhflhplhzlhBlh" +
    "DlhbnhdnhfnhznhB" +
    "nhDnhbphdphfphzp" +
    "hBphDpoccoecoAco" +
    "CcoceoeeoAeoCeoo" +
    "hoqhocmoemoAmoCm" +
    "ocooeooAooCovddv" +
    "BdvphvdnvBn")
# r(5032, "Five Pyramids 2", layout="0aoaaabacbaebagb" +
#    "awbaybaAbaCbboca" +
#    "adacdaedagdaidak" +
#    "damdaqdasdaudawd" +
#    "aydaAdaCdcoeaafa" +
#    "cfaefagfawfayfaA" +
#    "faCfamgdogaqgadh" +
#    "azhagibiickidmid" +
#    "oidqicsibuiawiad" +
#    "jazjamkdokaqkaal" +
#    "aclaelaglawlayla" +
#    "AlaClcomaanacnae" +
#    "nagnainaknamnaqn" +
#    "asnaunawnaynaAna" +
#    "Cnbooaapacpaepag" +
#    "pawpaypaApaCpaoq" +
#    "hbchdchfchxchzch" +
#    "Bchbehdehfehxehz" +
#    "ehBehbmhdmhfmhxm" +
#    "hzmhBmhbohdohfoh" +
#    "xohzohBoocdoedoy" +
#    "doAdocnoenoynoAn")
r(5033, "Flowers", layout="0baaccaceabgaaka" +
    "bmaboaaqaauabwab" +
    "yaaAadacdgcckccq" +
    "ccuccAcbaeccecee" +
    "bgeakebmeboeaqea" +
    "uebwebyeaAeadgan" +
    "gaxgafhahhajhalh" +
    "apharhathavhadia" +
    "niaxiaakbckbekag" +
    "kakkbmkbokaqkauk" +
    "bwkbykaAkcamcgmc" +
    "kmcqmcumcAmaaobc" +
    "obeoagoakobmoboo" +
    "aqoauobwobyoaAoo" +
    "naoxaoneoxeodkon" +
    "koxkodoonooxovda" +
    "vde")
r(5034, "Flying Dragon", layout="0acaaeaagaaiaaka" +
    "amaaoaaqaasaauaa" +
    "waayaagcbicbkcbm" +
    "cbocbqcbscaucaee" +
    "agebieckecmecoec" +
    "qebseaueaweacgae" +
    "gaggbigckgdmgdog" +
    "cqgbsgaugawgayga" +
    "ahaAhaChaciaeiag" +
    "ibiickidmidoicqi" +
    "bsiauiawiayiaeka" +
    "gkbikckkcmkcokcq" +
    "kbskaukawkagmbim" +
    "bkmbmmbombqmbsma" +
    "umacoaeoagoaioak" +
    "oamoaooaqoasoauo" +
    "awoayoCnh")
r(5035, "Fortress Towers", layout="0faaecadeacgabia" +
    "bkacmadoaeqafsae" +
    "acaccagcaicakcam" +
    "caqcescdaeaceage" +
    "aieakeameaqedsed" +
    "agacgaggaigakgam" +
    "gaqgdsgeaiaciagi" +
    "aiiakiamiaqiesif" +
    "akeckdekcgkbikbk" +
    "kcmkdokeqkfskhjc" +
    "hjehjghji")
#
r(5036, "Full Vision", layout="0aaaaiaamaaoaaqa" +
    "asaawaaEaacbaeba" +
    "gbaybaAbaCbaacai" +
    "camcaocaqcascawc" +
    "aEcacdaedagdayda" +
    "AdaCdaaeaieaweaE" +
    "eaefamfasfaAfagg" +
    "aigakgaugawgayga" +
    "ehamhashaAhagiai" +
    "iakiauiawiayiaej" +
    "amjasjaAjaakaika" +
    "wkaEkaclaelaglay" +
    "laAlaClaamaimaom" +
    "aqmawmaEmacnaena" +
    "gnamnasnaynaAnaC" +
    "naaoaioaooaqoawo" +
    "aEohpahbbhhbhnbh" +
    "rbhxbhDbhdchfchp" +
    "chzchBchbdhhdhxd" +
    "hDdhfghlghtghzgh" +
    "hhhjhhvhhxhhfihl" +
    "ihtihzihblhhlhxl" +
    "hDlhdmhfmhzmhBmh" +
    "bnhhnhnnhpnhrnhx" +
    "nhDnooboqboccogc" +
    "oycoCcoghokhouho" +
    "yhocmogmoymoCmvp" +
    "b")
#
r(5037, "Full Vision 2", layout="0aaaacaafaahaaka" +
    "amaapaaraauaawaa" +
    "zaaBaaacaccafcah" +
    "cakcamcapcarcauc" +
    "awcazcaBcaaeacea" +
    "feaheakeameapear" +
    "eaueaweazeaBeaag" +
    "acgafgahgakgamga" +
    "pgargaugawgazgaB" +
    "gaajacjaejagjakj" +
    "amjapjarjavjaxja" +
    "zjaBjaalaclaelag" +
    "laklamlaplarlavl" +
    "axlazlaBlaeoagoa" +
    "ioakoamoapoaroat" +
    "oavoaxohbbhgbhlb" +
    "hqbhvbhAbhadhcdh" +
    "fdhhdhkdhmdhpdhr" +
    "dhudhwdhzdhBdhbf" +
    "hgfhlfhqfhvfhAfh" +
    "djhyjhbkhfkhkkhm" +
    "khpkhrkhwkhAkhdl" +
    "hylobcogcolcoqco" +
    "vcoAcobeogeoleoq" +
    "eoveoAeockoekolk" +
    "oqkoxkozkvbdvgdv" +
    "ldvqdvvdvAdvdkvy" +
    "k")
r(5038, "Future", layout="0cgaaiaakaamaboa" +
    "aqaasaauacwaagcc" +
    "icakcamcbocaqcas" +
    "ccucawcaeeageaie" +
    "bkebmeboebqebsea" +
    "ueaweayeacfaAfaa" +
    "gcegcggdigdkgdmg" +
    "dogdqgdsgdugcwgc" +
    "ygaCgachaAhaeiag" +
    "iaiibkibmiboibqi" +
    "bsiauiawiayiagkc" +
    "ikakkamkbokaqkas" +
    "kcukawkcgmaimakm" +
    "ammbomaqmasmaumc" +
    "wmhcghAgoneopeon" +
    "iopiClgCngCpgCrg")
r(5039, "Garden", layout="0adaafaaoaaqaaza" +
    "aBaaabaibalbatba" +
    "wbaEbaccaecagcan" +
    "capcarcaycaAcaCc" +
    "aadaidaldatdawda" +
    "Edaceaeeageaneap" +
    "eareayeaAeaCeaaf" +
    "aifalfatfawfaEfa" +
    "chaehaghanhaphar" +
    "hayhaAhaChaajaij" +
    "aljatjawjaEjacka" +
    "ekagkankapkarkay" +
    "kaAkaCkaalailall" +
    "atlawlaElacmaema" +
    "gmanmapmarmaymaA" +
    "maCmaanainalnatn" +
    "awnaEnadoafoaooa" +
    "qoazoaBoheahpahA" +
    "ahcdhedhgdhndhpd" +
    "hrdhydhAdhCdhdhh" +
    "fhhohhqhhzhhBhhc" +
    "lhelhglhnlhplhrl" +
    "hylhAlhClheohpoh" +
    "Aooddofdoodoqdoz" +
    "doBdoehophoAhodl" +
    "oflooloqlozloBlv" +
    "edvpdvAdvelvplvA" +
    "l")
r(5040, "Gayle's", layout="0dcaceabgaaiaaka" +
    "amaaoaaqaasabuac" +
    "wadyaagcbicckccm" +
    "ccoccqcbscaucake" +
    "bmeboeaqeacgaega" +
    "ggbigbkgbmgbogbq" +
    "gbsgaugawgaygaah" +
    "aAhaciaeiagibiib" +
    "kibmiboibqibsiau" +
    "iawiayiakkbmkbok" +
    "aqkagmbimckmcmmc" +
    "omcqmbsmaumdcoce" +
    "obgoaioakoamoaoo" +
    "aqoasobuocwodyoo" +
    "jholhonhophorhvn" +
    "cvmhvohvnmCnh")
r(5041, "Glade", layout="0aaaacaaCaaEaaac" +
    "accaCcaEcahdejdc" +
    "ldcndbpdcrdctdev" +
    "daxddhfcjfblfbnf" +
    "bpfbrfbtfcvfdxfc" +
    "hhbjhblhanharhbt" +
    "hbvhcxhdhjcjjblj" +
    "bnjbpjbrjbtjcvjd" +
    "xjahlejlcllcnlbp" +
    "lcrlctlevlaxlaam" +
    "acmaCmaEmaaoacoa" +
    "CoaEohbahDahbchD" +
    "chbmhDmhbohDoobb" +
    "oDbobnoDn")
r(5042, "H for Haga", layout="0aaaacaaeaagaaka" +
    "amaaoaaqaaacacca" +
    "ecagcakcamcaocaq" +
    "caaeaceaeeageake" +
    "ameaoeaqeaifaaga" +
    "cgaegaggakgamgao" +
    "gaqgaihaaiaciaei" +
    "agiakiamiaoiaqia" +
    "ijaakackaekagkak" +
    "kamkaokaqkaamacm" +
    "aemagmakmammaoma" +
    "qmaaoacoaeoagoak" +
    "oamoaooaqohbbhdb" +
    "hfbhlbhnbhpbhbdh" +
    "ddhfdhldhndhpdhb" +
    "fhdfhffhlfhnfhpf" +
    "hhghjghbhhdhhfhh" +
    "lhhnhhphhhihjihb" +
    "jhdjhfjhljhnjhpj" +
    "hblhdlhflhllhnlh" +
    "plhbnhdnhfnhlnhn" +
    "nhpnoccoecomcooc" +
    "oceoeeomeooeocgo" +
    "egomgoogoghoihok" +
    "hocioeiomiooiock" +
    "oekomkookocmoemo" +
    "mmoomvddvndvdlvn" +
    "l")
# r(5043, "H for Haga Traditional", layout="0acaaeaagaaiaaka" +
#    "amaaoaaqaasaauaa" +
#    "waayabgcbicakcam" +
#    "caocaqcbscbucaee" +
#    "bgebieakeameaoea" +
#    "qebsebueaweacgae" +
#    "gbggbigbkgbmgbog" +
#    "bqgbsgbugawgayga" +
#    "ahaAhaciaeibgibi" +
#    "ibkibmiboibqibsi" +
#    "buiawiayiaekbgkb" +
#    "ikakkamkaokaqkbs" +
#    "kbukawkbgmbimakm" +
#    "ammaomaqmbsmbuma" +
#    "coaeoagoaioakoam" +
#    "oaooaqoasoauoawo" +
#    "ayoklcknckpchdhh" +
#    "xhklmknmkpm")
r(5044, "Helios", layout="0eaadcaduaewadac" +
    "bccbucdwcbaeacea" +
    "eeaiedkedmeaoeas" +
    "eauebwebagacgaeg" +
    "aggdigdogaqgasga" +
    "ugbwgblhbaiaciae" +
    "iagidiidoiaqiasi" +
    "auibwibakackaeka" +
    "ikdkkdmkaokaskau" +
    "kbwkdambcmbumdwm" +
    "eaodcoduoewohchh" +
    "ehhghhqhhshhuhCl" +
    "eCihCohClk")
r(5045, "High and Low", layout="0eaadcaceabgaaia" +
    "bkacmadoaeqadacc" +
    "ccdecagcbicckcbm" +
    "ceocdqccaebceeee" +
    "bgeciedkeamedoec" +
    "qebagacgdegcggdi" +
    "gekgbmgcogbqgaai" +
    "bciceidgieiidkic" +
    "miboiaqiaekagkbi" +
    "kakkamkahmajmhim")
#
# r(5046, "Hourglass", layout="0aaaacaaeaagaaia" +
#    "akaamaaoaaqaasaa" +
#    "uaawaayaaacamcay" +
#    "cacdawdaaeaeeame" +
#    "aueayeacfagfasfa" +
#    "wfaagaegaigamgaq" +
#    "gaugaygachaghbkh" +
#    "bohashawhaaiaeia" +
#    "iiamiaqiauiayiac" +
#    "jagjasjawjaakaek" +
#    "amkaukaykaclawla" +
#    "amammaymaaoacoae" +
#    "oagoaioakoamoaoo" +
#    "aqoasoauoawoayoh" +
#    "abhmbhybhadhmdhy" +
#    "dhcehwehafhefhuf" +
#    "hyfhcghgghsghwgh" +
#    "ahhehhihhqhhuhhy" +
#    "hhcihgihsihwihaj" +
#    "hejhujhyjhckhwkh" +
#    "alhmlhylhanhmnhy" +
#    "noacoycoaeoyeoag" +
#    "oygoaioyioakoyko" +
#    "amoymvadvydvafvy" +
#    "fvahvyhvajvyjval" +
#    "vylCaeCyeCagCygC" +
#    "aiCyiCakCyk")
r(5047, "Inca", layout="0aoaaqaaibakbamb" +
    "asbaubawbbocbqca" +
    "idbkdbmdbsdbudaw" +
    "dcoecqeaifbkfcmf" +
    "csfbufawfaagacgd" +
    "ogdqgaCgaEgahhbj" +
    "hclhcthbvhaxhaai" +
    "acidoidqiaCiaEia" +
    "hjbjjcljctjbvjax" +
    "jaakackdokdqkaCk" +
    "aEkailbklcmlcslb" +
    "ulawlcomcqmainbk" +
    "nbmnbsnbunawnboo" +
    "bqoaipakpampaspa" +
    "upawpaoqaqqhbihD" +
    "iCphCpj")
r(5048, "Inner Circle", layout="0aaaacaayaaAaaac" +
    "eccceccgcbicbkca" +
    "mcaocbqcbsccuccw" +
    "ceycaAcccecyedgf" +
    "cifbkfbqfcsfdufb" +
    "cgbygaghbuhbciby" +
    "iegjdijckjbmjboj" +
    "cqjdsjeujcckcyka" +
    "amecmcemcgmbimbk" +
    "mbqmbsmcumcwmdym" +
    "aAmaaoacoakoaqoa" +
    "yoaAo")
r(5049, "Joker", layout="0aaaaAaadbafbahb" +
    "ajbalbanbapbarba" +
    "tbavbaxbabdbddbf" +
    "dbhdbjdbldbndbpd" +
    "brdbtdbvdbxdazdc" +
    "bfbdfaffahfajfal" +
    "fanfapfarfatfavf" +
    "bxfczfcbhbdhafha" +
    "vhbxhczhajiamiap" +
    "iasicbjbdjafjavj" +
    "bxjczjcblbdlafla" +
    "hlajlallanlaplar" +
    "latlavlbxlczlabn" +
    "bdnbfnbhnbjnblnb" +
    "nnbpnbrnbtnbvnbx" +
    "naznadpafpahpajp" +
    "alpanpapparpatpa" +
    "vpaxpaaqaAqhgghu" +
    "ghgkhuk")
r(5050, "K for Kyodai", layout="0caaccaceacmacoa" +
    "cqacacbcccecckcb" +
    "mccoccaebceceeci" +
    "ebkecmecagbcgceg" +
    "cggbigckgcaibcib" +
    "eibgiciicakbckce" +
    "kcgkbikckkcambcm" +
    "cemcimbkmcmmcaob" +
    "coceockobmocooca" +
    "qccqceqcmqcoqcqq")
# r(5051, "K for Kyodai Traditional", layout="0acaaeaagaaiaaka" +
#    "amaaoaaqaasaauaa" +
#    "waayaagcaicakcam" +
#    "caocaqcascaucaee" +
#    "ageaieakeameaoea" +
#    "qeaseaueaweacgae" +
#    "gaggaigakgamgaog" +
#    "aqgasgaugawgayga" +
#    "ahaAhaciaeiagiai" +
#    "iakiamiaoiaqiasi" +
#    "auiawiayiaekagka" +
#    "ikakkamkaokaqkas" +
#    "kaukawkagmaimakm" +
#    "ammaomaqmasmauma" +
#    "coaeoagoaioakoam" +
#    "oaooaqoasoauoawo" +
#    "ayokjckrckpdkjeh" +
#    "gfknfhufkjghghkl" +
#    "hhuhkjihgjknjhuj" +
#    "kjkkplkjmkrm")
r(5052, "Km", layout="0baabcabiaakaboa" +
    "cqacyabAabacaccb" +
    "gcaicbocaqcdscdw" +
    "caycbAcdudbaeace" +
    "beeageboeaqeasea" +
    "weayebAeeufbagac" +
    "gbegaggbogaqgayg" +
    "bAgduhbaiacibgia" +
    "iiboiaqiayibAiba" +
    "kbckbikakkbokbqk" +
    "bykbAkjcfhgfoabo" +
    "oboAboadoodoAdoa" +
    "foefoofoAfoahooh" +
    "oAhoajoojoAjvacv" +
    "ocvAcvaevoevAeva" +
    "gvogvAgvaivoivAi" +
    "CadCodCAdCafCofC" +
    "AfCahCohCAh")
r(5053, "Kujaku", layout="0bnabpabrabtabva" +
    "bxablbczbaBbbhcb" +
    "jcancapcarcatcav" +
    "caxcaddbfdaldazd" +
    "dBdaDdaheajeabfc" +
    "dfaffaAfdCfaEfba" +
    "hcchaehakhamhaoh" +
    "ashaAhdChaEhabjc" +
    "djafjaAjdCjaEjah" +
    "kajkadlbflallazl" +
    "dBlaDlbhmbjmanma" +
    "pmarmatmavmaxmbl" +
    "ncznaBnbnobpobro" +
    "btobvobxohnghpgh" +
    "tghjhhnihpihtioo" +
    "foqfoufoihoojoqj" +
    "oujvpevrevvfvhhv" +
    "vjvpkvrkCwgCCgCg" +
    "hCwiCCi")
r(5054, "Labyrinth", layout="0caaacaaeaagaaia" +
    "akaamaaoaaqaasaa" +
    "uaawaayaaAaaCacE" +
    "aaacbkcbocbucaEc" +
    "aaebcebeebgebkeb" +
    "oebsebuebyebAeaE" +
    "eaagbkgbygaEgaai" +
    "beibiibkiboibqib" +
    "sibuibwibyibAiaE" +
    "iaakbekbokbwkaEk" +
    "aambembgmbimbkmb" +
    "ombqmbsmbwmbAmbC" +
    "maEmaaobkobwoaEo" +
    "caqacqbeqdgqdkqb" +
    "mqaoqaqqasqauqbw" +
    "qdyqdCqbEq")
r(5055, "Lion", layout="0bdbbfbcjbclbawb" +
    "aybbbcbhcaucaAcc" +
    "jdcldasdaCdbaeaq" +
    "ecvfczfaDfbbgapg" +
    "aEhcbiceichickia" +
    "oicxiaFjcckcfkci" +
    "kclkbokcwkcykbul" +
    "bAlaElcbmcemchmc" +
    "kmcnmbqmaDnccocf" +
    "ocioclocooaroato" +
    "avoaxoazoaBohvah" +
    "xahzahtbhBbhrchD" +
    "dhpehEfhoghFhhni" +
    "hGjhFlhEnhsohCoh" +
    "uphwphyphApwkc")
r(5056, "Lost ", layout="0afaaxaabbadbahb" +
    "ajbblbbnbbpbbrba" +
    "tbavbazbaBbafcax" +
    "cabdaddbkdcodbsd" +
    "azdaBdbiebmebqeb" +
    "ueaafacfaefbgfdo" +
    "fbwfayfaAfaCfaah" +
    "aehbghcihckhdmhd" +
    "ohdqhcshcuhbwhay" +
    "haChaajacjaejbgj" +
    "dojbwjayjaAjaCjb" +
    "ikbmkbqkbukablad" +
    "lbklcolbslazlaBl" +
    "afmaxmabnadnahna" +
    "jnblnbnnbpnbrnat" +
    "navnaznaBnafoaxo" +
    "ombooboqbomnoono" +
    "qn")
r(5057, "Maya", layout="0aaaacaaeaagaaia" +
    "aqaasaauaawaayaa" +
    "acaccaecagcaicaq" +
    "cascaucawcaycaae" +
    "aceaeeageaieakea" +
    "meaoeaqeaseaueaw" +
    "eayeaigakgamgaog" +
    "aqgaiiakiamiaoia" +
    "qiaakackaekagkai" +
    "kakkamkaokaqkask" +
    "aukawkaykaamacma" +
    "emagmaimaqmasmau" +
    "mawmaymaaoacoaeo" +
    "agoaioaqoasoauoa" +
    "woayohcbhebhgbhs" +
    "bhubhwbhcdhedhgd" +
    "hsdhudhwdhkfhmfh" +
    "ofhkhhmhhohhkjhm" +
    "jhojhclhelhglhsl" +
    "hulhwlhcnhenhgnh" +
    "snhunhwnoccoecog" +
    "coscoucowcolfonf" +
    "olhonholjonjocmo" +
    "emogmosmoumowmvd" +
    "cvfcvtcvvcvmfvmh" +
    "vmjvdmvfmvtmvvmC" +
    "ecCucCmgCmiCemCu" +
    "m")
r(5058, "Mesh", layout="0baabcabeabiabka" +
    "bmabqabsabuabyab" +
    "AabCabacbecbicbm" +
    "cbqcbucbycbCcbae" +
    "bcebeeagebiebkeb" +
    "meaoebqebsebueaw" +
    "ebyebAebCeaegbig" +
    "bmgbqgbugaygbaib" +
    "cibeiagibiibkibm" +
    "iaoibqibsibuiawi" +
    "byibAibCibakbekb" +
    "ikbmkbqkbukbykbC" +
    "kbambcmbembimbkm" +
    "bmmbqmbsmbumbymb" +
    "AmbCm")
r(5059, "Moth", layout="0baaccaceabgaana" +
    "apaarabyacAacCab" +
    "Eaaibawbbccagcak" +
    "ccpcaucaycbCcaid" +
    "amdasdawdadeakeb" +
    "oebqeaueaBeamfas" +
    "facgaegahgajgbog" +
    "bqgavgaxgaAgaCga" +
    "mhashadiakiboibq" +
    "iauiaBiaijamjasj" +
    "awjbckagkakkcpka" +
    "ukaykbCkailawlcc" +
    "mcembgmbpmbymcAm" +
    "cCmbanbEnhoahqah" +
    "ichwchmehsehdghi" +
    "ghwghBghmihsihik" +
    "hwkopaoneopeorep" +
    "pgoniopiorivdavB" +
    "avoevqevoivqivdm" +
    "vBmCpeCpi")
r(5060, "N for Namida", layout="0caaccaceacgacqa" +
    "csacuacacbccbecb" +
    "gcbiccqcbsccucca" +
    "ebcebeebgebiebke" +
    "cqebsecuecagbcgc" +
    "egbigbkgbmgcqgbs" +
    "gcugcaibciceibki" +
    "bmiboibqibsicuic" +
    "akbckcekbmkbokbq" +
    "kbskcukcamccmcem" +
    "comcqmcsmcum")
# r(5061, "N for Namida Traditional", layout="0acaaeaagaaiaaka" +
#    "amaaoaaqaasaauaa" +
#    "waayacgcaicakcbm" +
#    "ccoccqcasccucaee" +
#    "cgecieakeameaoea" +
#    "qeasecueaweacgae" +
#    "gcggcigakgcmgaog" +
#    "aqgasgcugawgayga" +
#    "ahaAhaciaeicgiai" +
#    "iakicmiaoicqiasi" +
#    "cuiawiayiaekcgka" +
#    "ikakkamkaokcqkas" +
#    "kcukawkcgmaimckm" +
#    "cmmbomaqmasmcuma" +
#    "coaeoagoaioakoam" +
#    "oaooaqoasoauoawo" +
#    "ayoikfikhiohioji" +
#    "sjisl")
# r(5062, "Naoki Haga Traditional", layout="0acaaeaagaaiaaka" +
#    "amaaoaaqaasaauaa" +
#    "waayadgcaicakcdm" +
#    "caocaqcascaucaee" +
#    "dgeaiedkedmeaoec" +
#    "qecseaueaweacgae" +
#    "gdggaigakgdmgaog" +
#    "aqgasgaugawgayga" +
#    "ahaAhaciaeiagiai" +
#    "iakiamidoiaqiasi" +
#    "duiawiayiaekagkc" +
#    "ikckkamkdokdqkds" +
#    "kdukawkagmaimakm" +
#    "ammdomaqmasmduma" +
#    "coaeoagoaioakoam" +
#    "oaooaqoasoauoawo" +
#    "ayojidvrevjk")
#
r(5063, "New Layout", layout="0aeaagaaiaakabpa" +
    "auaawaayaaAaacca" +
    "Ccahdajdavdaxdaa" +
    "eacealeateaCeaEe" +
    "anfarfaagacgahga" +
    "pgaCgaEganharhaa" +
    "iacialiatiaCiaEi" +
    "ahjajjavjaxjacka" +
    "Ckaemagmaimakmbp" +
    "maumawmaymaAmhfa" +
    "hhahjahvahxahzah" +
    "cdhidhwdhCdhkehu" +
    "ehafhcfhmfhofhqf" +
    "hsfhCfhEfhahhchh" +
    "mhhohhqhhshhChhE" +
    "hhkihuihcjhijhwj" +
    "hCjhfmhhmhjmhvmh" +
    "xmhzmogaoiaowaoy" +
    "aoceojeoveoCeolf" +
    "otfoagocgongopgo" +
    "rgoCgoEgolhothoc" +
    "iojiovioCiogmoim" +
    "owmoymvhavxavcfv" +
    "kfvufvCfvmgvogvq" +
    "gvsgvchvkhvuhvCh" +
    "vhmvxmCcgClgCngC" +
    "pgCrgCtgCCg")
r(5064, "Order", layout="0afaahaajaalaana" +
    "apaaraataaabayba" +
    "icakcamcaocaqcba" +
    "dacdaedaudawdbyd" +
    "akebmeaoecafbcfa" +
    "efaufbwfcyfaggai" +
    "gakgbmgaogaqgasg" +
    "cahcchbehbuhcwhc" +
    "yhagiaiiakibmiao" +
    "iaqiasicajbcjaej" +
    "aujbwjcyjakkbmka" +
    "okbalaclaelaulaw" +
    "lbylaimakmammaom" +
    "aqmaanaynafoahoa" +
    "joaloanoapoaroat" +
    "ohgahiaikaimaioa" +
    "hqahsahlchnchghh" +
    "ihhkhhohhqhhshhl" +
    "mhnmhgohioikoimo" +
    "ioohqohsoomcpmho" +
    "mm")
r(5065, "Pattern", layout="0aaaacaafaahaaka" +
    "amaapaaraauabwab" +
    "zaaBaaacaccafcah" +
    "cakcamcapcarcbuc" +
    "cwcczcbBccafacfa" +
    "ffchfckfcmfapfar" +
    "fcufawfazfcBfaah" +
    "cchcfhahhakhamhc" +
    "phcrhcuhawhazhcB" +
    "haakackafkahkakk" +
    "cmkcpkarkcukcwkc" +
    "zkcBkaamacmafmah" +
    "mckmammapmcrmaum" +
    "cwmczmaBmibailai" +
    "fbihbibciqciqfil" +
    "hialihl")
# r(5066, "Phoenix", layout="0aaaacaapaaraaEa" +
#    "aGaaebatbaCbaaca" +
#    "gcapcarcaAcaGcai" +
#    "daydakeboebqebse" +
#    "aweaafacfaefamfa" +
#    "ufaCfaEfaGfaggbp" +
#    "gbrgaAgaahaihamh" +
#    "auhayhaGhaeiakic" +
#    "picriawiaCiaajam" +
#    "jaujaGjbpkbrkacl" +
#    "aelaglailamlaula" +
#    "ylaAlaClaElakmbp" +
#    "mbrmawmacnafnamn" +
#    "aunaBnaEnaioaooa" +
#    "soayoacpafpaBpaE" +
#    "pakqawqhbbhFbhdc" +
#    "hDchfdhBdhhehzeh" +
#    "jfhxfhdghlghvghD" +
#    "ghfhhBhhhihnihti" +
#    "hzihjjhxjhdkhlkh" +
#    "vkhDkhflhnlhtlhB" +
#    "lhhmhzmhjnhxnhlo" +
#    "hvohnphtponfppfp" +
#    "rfotfoplorlvqivq" +
#    "lCqf")
r(5067, "Portal", layout="0accagcawcaAcaed" +
    "aydaceageaweaAea" +
    "mgaqgamiaqiackag" +
    "kawkaAkaelaylacm" +
    "agmawmaAmhbbhdbh" +
    "fbhhbhvbhxbhzbhB" +
    "bhbdhhdhvdhBdhbf" +
    "hdfhffhhfhlfhnfh" +
    "pfhrfhvfhxfhzfhB" +
    "fhlhhrhhbjhdjhfj" +
    "hhjhljhnjhpjhrjh" +
    "vjhxjhzjhBjhblhh" +
    "lhvlhBlhbnhdnhfn" +
    "hhnhvnhxnhznhBno" +
    "aaocaoeaogaoiaou" +
    "aowaoyaoAaoCaoac" +
    "oicoucoCcoaeoieo" +
    "keomeooeoqeoseou" +
    "eoCeoagocgoegogg" +
    "oigokgosgougowgo" +
    "ygoAgoCgoaiocioe" +
    "iogioiiokiosioui" +
    "owioyioAioCioako" +
    "ikokkomkookoqkos" +
    "koukoCkoamoimoum" +
    "oCmoaoocooeoogoo" +
    "ioouoowooyooAooC" +
    "o")
r(5068, "Rocket", layout="0amaaoaaqaazaaBa" +
    "aDaakbaicamcaoca" +
    "qcascaxcazcaBcaD" +
    "cagdakdaudaeeaie" +
    "ameaqeaseaweayea" +
    "cfagfakfaofaufaB" +
    "faegasgawgaygaah" +
    "bchbghbihbkhbmhb" +
    "ohcqhauhaAhaChae" +
    "iasiawiayiacjagj" +
    "akjaojaujaBjaeka" +
    "ikamkaqkaskawkay" +
    "kaglaklaulaimamm" +
    "aomaqmasmaxmazma" +
    "BmaDmaknamoaooaq" +
    "oazoaBoaDohnahpa" +
    "hlbhBbhjchnchpch" +
    "hdhsdhfehxehdfhs" +
    "fhughehhshiwhhyh" +
    "huihdjhsjhfkhxkh" +
    "hlhslhjmhnmhpmhl" +
    "nhBnhnohpoonbopb" +
    "osgodhofhohhojho" +
    "lhonhouhosionnop" +
    "nvobvehvghvihvsh" +
    "vonCfh")
r(5069, "Scorpion", layout="0avaacbaebagbaib" +
    "aacaxcazcagdaida" +
    "kdaoeaseayeaAeaa" +
    "facfaefagfaifakf" +
    "cmgaogcqgasgcuga" +
    "wgbygbAgckhciidm" +
    "iaoicqiasiduiawi" +
    "byibAickjcmkaokc" +
    "qkaskcukawkbykaa" +
    "laclaelaglailakl" +
    "aomasmawmagnaina" +
    "knaaoacpaepagpai" +
    "phdbhfbhhbhwbhbc" +
    "hychhdhzehbfhdfh" +
    "ffhhfhjfhofhsfho" +
    "hhshhwhhojhsjhwj" +
    "hblhdlhflhhlhjlh" +
    "olhslhwlhhnhbohd" +
    "phfphhpoogosgoyh" +
    "ooiosiowioyjooko" +
    "skvohvqhvshvojvq" +
    "jvsj")
r(5070, "Screw Up", layout="0ciackacmabgbbob" +
    "cecbicbkcbmccqcb" +
    "gdbodcceceeakeam" +
    "ecqecsebgfbofccg" +
    "cegakgamgcqgcsgb" +
    "ghbohcciceiaiiak" +
    "icqicsibgjbojcck" +
    "cekaikakkcqkcskb" +
    "glbolcembimbkmbm" +
    "mcqmbgnbonciocko" +
    "cmoilfikhijjvbfv" +
    "tfvbhvthvbjvtjCa" +
    "fCufCahCuhCajCuj")
#
r(5071, "Seven", layout="0aaaacaafaahaaka" +
    "amaapaaraauaawaa" +
    "zaaBaaEaaGaaacac" +
    "cafcahcakcamcapc" +
    "arcaucawcazcaBca" +
    "EcaGcaaeaceafeah" +
    "eakeameapeareaue" +
    "aweazeaBeaEeaGea" +
    "agacgafgahgakgam" +
    "gapgargaugawgazg" +
    "aBgaEgaGgaaiacia" +
    "fiahiakiamiapiar" +
    "iauiawiaziaBiaEi" +
    "aGiaakackafkahka" +
    "kkamkapkarkaukaw" +
    "kazkaBkaEkaGkaam" +
    "acmafmahmakmamma" +
    "pmarmaumawmazmaB" +
    "maEmaGmaaoacoafo" +
    "ahoakoamoapoaroa" +
    "uoawoazoaBoaEoaG" +
    "oaaqacqafqahqakq" +
    "amqapqarqauqawqa" +
    "zqaBqaEqaGqhqchl" +
    "ehvehggiqghAghbi" +
    "hlihvihFihgkiqkh" +
    "Akhlmhvmhqo")
#
r(5072, "Seven Pyramids", layout="0aaaacaaeaagaaoa" +
    "aqaayaaAaaCaaEaa" +
    "acaccaecagcaocaq" +
    "caycaAcaCcaEcaae" +
    "aceaeeageayeaAea" +
    "CeaEeaagacgaegag" +
    "gangapgargaygaAg" +
    "aCgaEganiapiaria" +
    "akackaekagkankap" +
    "karkaykaAkaCkaEk" +
    "aamacmaemagmayma" +
    "AmaCmaEmaaoacoae" +
    "oagoaooaqoayoaAo" +
    "aCoaEoaaqacqaeqa" +
    "gqaoqaqqayqaAqaC" +
    "qaEqhbbhdbhfbhpb" +
    "hzbhBbhDbhbdhddh" +
    "fdhzdhBdhDdhbfhd" +
    "fhffhzfhBfhDfhoh" +
    "hqhhojhqjhblhdlh" +
    "flhzlhBlhDlhbnhd" +
    "nhfnhznhBnhDnhbp" +
    "hdphfphpphzphBph" +
    "DpoccoecoAcoCcoc" +
    "eoeeoAeoCeopiocm" +
    "oemoAmoCmocooeoo" +
    "AooCovddvBdvdnvB" +
    "n")
r(5073, "Shield", layout="0aaaacaaeaagaaia" +
    "akaamaaoaaxaaaca" +
    "ccaecagcaicakcam" +
    "caocbxcaaeaceaee" +
    "ageaieakeameaoec" +
    "xeabgadgafgahgaj" +
    "galgangdxgaciaei" +
    "agiaiiakiamidxie" +
    "tjeBjaekagkaikak" +
    "kbvkexkbzkagmaim" +
    "cxmahodxohcbhebh" +
    "gbhibhkbhmbhcdhe" +
    "dhgdhidhkdhmdhcf" +
    "iefigfiifikfhmfh" +
    "dhifhihhijhhlhhe" +
    "jigjiijhkjhglhil" +
    "odbofbohbojbolbo" +
    "ddofdohdojdoldoh" +
    "lvfcvhcvjcvfevhe" +
    "vjevggvigvhiChdC" +
    "hf")
r(5074, "Siam", layout="0afaazaadbahbaxb" +
    "aBbacdaedagdaida" +
    "ndardawdaydaAdaC" +
    "daleateabfadfaff" +
    "ahfajfavfaxfazfa" +
    "BfaDfaahachaehag" +
    "haihakhamhaohaqh" +
    "ashauhawhayhaAha" +
    "ChaEhabjadjafjah" +
    "jajjavjaxjazjaBj" +
    "aDjalkatkaclaela" +
    "glailanlarlawlay" +
    "laAlaCladnahnaxn" +
    "aBnafoazohddhfdh" +
    "hdhxdhzdhBdhcfhe" +
    "fhgfhifhwfhyfhAf" +
    "hCfhbhhdhhfhhhhh" +
    "jhhlhhnhiphhrhht" +
    "hhvhhxhhzhhBhhDh" +
    "hcjhejhgjhijhwjh" +
    "yjhAjhCjhdlhflhh" +
    "lhxlhzlhBloedogd" +
    "oydoAdodfoffohfo" +
    "xfozfoBfochoehog" +
    "hoihowhoyhoAhoCh" +
    "odjofjohjoxjozjo" +
    "BjoelogloyloAl")
#
# r(5075, "Space Ship", layout="0afaahaajaalaana" +
#    "apaaraataavaadba" +
#    "xbabcancazcaaeaf" +
#    "eaheajealeaneape" +
#    "areateaveaAeadfa" +
#    "xfangadhaxhaniad" +
#    "jaxjankadlaxlanm" +
#    "adnaxnanohgahiah" +
#    "kahmahoahqahsahu" +
#    "ahebhwbhcchychad" +
#    "hmdhodhAdhgehieh" +
#    "kehqehsehuehmfho" +
#    "fhdghxghnhhdihxi" +
#    "hnjhdkhxkhnlhdmh" +
#    "xmhnnohaojaolaon" +
#    "aopaoraotaofbovb" +
#    "odcoxcobdozdoheo" +
#    "jeoleoneopeoreot" +
#    "eqngodhoxhqniodj" +
#    "oxjqnkodloxlqnmv" +
#    "iavkavmavoavqavs" +
#    "avgbvubvecvwcvcd" +
#    "vydvievkevmevoev" +
#    "qevsevdivxivdkvx" +
#    "kCnaCjeCleCneCpe" +
#    "CreCdjCxj")
#
r(5076, "Square", layout="0daadcadeadgadia" +
    "dkadacdccdecdgcd" +
    "icdkcdaedcedeedg" +
    "ediedkedagdcgdeg" +
    "dggdigdkgdaidcid" +
    "eidgidiidkidakdc" +
    "kdekdgkdikdkk")
r(5077, "Squares", layout="0caabcaceabgacia" +
    "bkacmaboacqabsac" +
    "uaaacauccddafdah" +
    "dajdaldandapdcrd" +
    "aaeauebdfbrfaagb" +
    "ggcigckgcmgbogau" +
    "gcdhcrhaaibgicii" +
    "ckicmiboiauibdjb" +
    "rjaakaukcdlaflah" +
    "lajlallanlaplcrl" +
    "aamaumcaobcoceob" +
    "gociobkocmoboocq" +
    "obsocuohidikdhmd" +
    "hiliklhmlvjgvlgv" +
    "jivli")
r(5078, "Squaring", layout="0caaacaceaciaaka" +
    "cmacqaasacuacyaa" +
    "AacCaaacaecaicdk" +
    "camcaqcaucaycdAc" +
    "aCccaeaceceeciea" +
    "kecmecqeasecuecy" +
    "eaAecCecahachceh" +
    "cihakhcmhcqhashc" +
    "uhcyhaAhcChaajdc" +
    "jaejaijamjaqjdsj" +
    "aujayjaCjcalaclc" +
    "elcilaklcmlcqlas" +
    "lculcylaAlcCl")
r(5079, "Stairs", layout="0aoaaebaybeacdcc" +
    "agcaicakcbmccocb" +
    "qcascaucawcdAceC" +
    "caedayddaeaieaoe" +
    "auedCebefbyfaaga" +
    "igaogaugaCgbchce" +
    "hbghakhbmhbqhash" +
    "bwhcyhbAhaaiaiia" +
    "oiauiaCibejbyjda" +
    "kaikaokaukdCkael" +
    "ayleamdcmagmaima" +
    "kmbmmcombqmasmau" +
    "mawmdAmeCmaenayn" +
    "aoohechychofhahk" +
    "ohhChhojhemhym")
r(5080, "Star Ship", layout="0eoaaabdmbdqbaCb" +
    "accckccscaAcaadb" +
    "idbudaCdbceageco" +
    "eawebAeaafaefamf" +
    "aqfayfaCfecgagga" +
    "igbkgdogbsgaugaw" +
    "geAgaahaehamhaqh" +
    "ayhaChbciagicoia" +
    "wibAiaajbijbujaC" +
    "jackckkcskaAkaal" +
    "dmldqlaCleomhach" +
    "CchaehCehaghegim" +
    "giqghyghCghaihCi" +
    "hakhCkoadoCdoafo" +
    "CfoahoChoajoCjva" +
    "evCevagvCgvaivCi" +
    "CafCCfCahCCh")
#
r(5081, "Steps Pyramid", layout="0aaaacaaeaagaaia" +
    "akaamaaoaaqaaaca" +
    "ccaecagcaicakcam" +
    "caocaqcaaeaceaoe" +
    "aqeaagacgaogaqga" +
    "aiaciaoiaqiaakac" +
    "kaekagkaikakkamk" +
    "aokaqkaamacmaema" +
    "gmaimakmammaomaq" +
    "mhbbhdbhfbhhbhjb" +
    "hlbhnbhpbhbdhddh" +
    "fdhhdhjdhldhndhp" +
    "dhbfhdfhnfhpfhbh" +
    "hdhhnhhphhbjhdjh" +
    "fjhhjhjjhljhnjhp" +
    "jhblhdlhflhhlhjl" +
    "hllhnlhplpccoeco" +
    "gcoicokcomcpococ" +
    "epeepgepiepkepme" +
    "ooeocgpegpmgoogo" +
    "cipeipgipiipkipm" +
    "iooipckoekogkoik" +
    "okkomkpokCffChfC" +
    "jfClfCfhChhCjhCl" +
    "h")
r(5082, "Stonehenge", layout="0cdachackacoacra" +
    "cvacyacCacaccFca" +
    "jeaneareavecagcF" +
    "gddhdhhdlhdphdth" +
    "dxhdBhcajcFjajka" +
    "nkarkavkcancFncd" +
    "pchpckpcopcrpcvp" +
    "cypcCpveavgavlav" +
    "navsavuavzavBava" +
    "dvFdvafvFfvakvFk" +
    "vamvFmvepvgpvlpv" +
    "npvspvupvzpvBpCe" +
    "hCghCihCkhCmhCoh" +
    "CqhCshCuhCwhCyhC" +
    "Ah")
r(5083, "SunMoon", layout="0dgaciabkaamabya" +
    "debbrbbBbdccbvcc" +
    "addcecheckecnebD" +
    "ecafbtfbAfdcgdjg" +
    "dlgbxgcahchhcnhd" +
    "cidjidlibribDica" +
    "jbvjdckchkckkcnk" +
    "bAkcalbsldcmbxmd" +
    "enbBndgociobkoam" +
    "obuovaevagvaivak" +
    "Ckh")
r(5084, "Temple", layout="0baaacaaeaalaana" +
    "apaaraataaAaaCab" +
    "Eaaacaccalcbncbp" +
    "cbrcatcaCcaEcajd" +
    "avdaaeblebnebpeb" +
    "rebteaEeaffahfaj" +
    "favfaxfazfblgbng" +
    "bpgbrgbtgadhafha" +
    "hhajhavhaxhazhaB" +
    "hblibnibpibribti" +
    "afjahjajjavjaxja" +
    "zjaakblkbnkbpkbr" +
    "kbtkaEkajlavlaam" +
    "acmalmbnmbpmbrma" +
    "tmaCmaEmbaoacoae" +
    "oaloanoapoaroato" +
    "aAoaCobEohhghjgh" +
    "vghxghhihjihvihx" +
    "iooeoqeokgomgoog" +
    "oqgosgougokiomio" +
    "oioqiosiouiookoq" +
    "kvpgvpi")
#
# r(5085, "Teotihucan", layout="0aaaacaaeaagaaia" +
#    "akaamaaoaaqaasaa" +
#    "acascaaeaseaagcg" +
#    "gckgcogasgaaicgi" +
#    "ckicoiasiaakaska" +
#    "amasmaaoacoaeoag" +
#    "oaioakoamoaooaqo" +
#    "asoajqhbbhdbhfbh" +
#    "hbhjbhlbhnbhpbhr" +
#    "bhbdhrdhbfhrfhbh" +
#    "hrhhbjhrjhblhrlh" +
#    "bnhdnhfnhhnhjnhl" +
#    "nhnnhpnhrnhjpocc" +
#    "oecogcoicokcomco" +
#    "ocoqcoceoqeocgoq" +
#    "gocioqiockoqkocm" +
#    "oemogmoimokmommo" +
#    "omoqmojovddvfdvh" +
#    "dvjdvldvndvpdvdf" +
#    "vffvhfvjfvlfvnfv" +
#    "pfvdhwfhvhhwjhvl" +
#    "hwnhvphvdjvfjvhj" +
#    "vjjvljvnjvpjvdlv" +
#    "flvhlvjlvllvnlvp" +
#    "lvjn")
r(5086, "The Door", layout="0amaaoaaqaeicekc" +
    "emceoceqcesceuca" +
    "gediedueaweaegag" +
    "gdigdugawgaygaei" +
    "bgidiiduibwiayia" +
    "ckaekcgkdikakkas" +
    "kdukcwkaykaAkaam" +
    "acmbemcgmdimakma" +
    "smdumcwmbymaAmaC" +
    "maaobcobeocgodio" +
    "akoasoduocwobyob" +
    "AoaCo")
#
r(5087, "The Great Wall", layout="0aaaacaaeaagaaia" +
    "akaamaaoaaqaasaa" +
    "uaawaayaaAaaCaaE" +
    "aaacaccaecagcaic" +
    "akcamcaocaqcasca" +
    "ucawcaycaAcaCcaE" +
    "caaeaceaeeageaie" +
    "akeameaoeaqeasea" +
    "ueaweayeaAeaCeaE" +
    "eaagacgaegaggaig" +
    "akgamgaogaqgasga" +
    "ugawgaygaAgaCgaE" +
    "gaaiaciaeiagiaii" +
    "akiamiaoiaqiasia" +
    "uiawiayiaAiaCiaE" +
    "iaakackaekagkaik" +
    "akkamkaokaqkaska" +
    "ukawkaykaAkaCkaE" +
    "kaamacmaemagmaim" +
    "akmammaomaqmasma" +
    "umawmaymaAmaCmaE" +
    "maaoacoaeoagoaio" +
    "akoamoaooaqoasoa" +
    "uoawoayoaAoaCoaE" +
    "oaaqacqaeqagqaiq" +
    "akqamqaoqaqqasqa" +
    "uqawqayqaAqaCqaE" +
    "q")
r(5088, "Theater", layout="0baaccaceabgaaia" +
    "amaaqabsacuacwab" +
    "yacaccccbecagcak" +
    "cbmcaocascbuccwc" +
    "cyccaebceaeeaieb" +
    "kebmeboeaqeauebw" +
    "ecyebagacgaggaig" +
    "akgbmgaogaqgasga" +
    "wgbygcaibciaeiai" +
    "ibkibmiboiaqiaui" +
    "bwicyicakcckbeka" +
    "gkakkbmkaokaskbu" +
    "kcwkcykbamccmcem" +
    "bgmaimammaqmbsmc" +
    "umcwmbym")
r(5089, "Tile Fighter", layout="0bfaahaatabvadcc" +
    "becakcbmcbocaqcb" +
    "wcdycbaecceaiebk" +
    "ebmeboebqeasecye" +
    "bAebagbigckgamga" +
    "ogcqgbsgbAgcchae" +
    "haghauhawhcyhbai" +
    "biickiamiaoicqib" +
    "sibAibakcckaikbk" +
    "kbmkbokbqkaskcyk" +
    "bAkdcmbemakmbmmb" +
    "omaqmbwmcymbfoah" +
    "oatobvohnhonepaf" +
    "pAfpahpAhpajpAjo" +
    "nk")
r(5090, "Tilepiles", layout="0aaaacaaeaagaaia" +
    "aobaqbasbaubayba" +
    "AbaCbaEbahcajcal" +
    "cacdaedardatdaxd" +
    "azdaBdakeameaoea" +
    "ffahfaufawfayfan" +
    "gapgargaihakhaxh" +
    "azhaqiasiauiajja" +
    "ljanjaAjaCjatkav" +
    "kaxkaelaglailakl" +
    "aolaqlawmaymaAma" +
    "CmaEmabnadnafnah" +
    "najnhbahdahfahha" +
    "hpbhrbhtbhzbhBbh" +
    "Dbhichkchddhsdhy" +
    "dhAdhlehnehgfhvf" +
    "hxfhoghqghjhhyhh" +
    "rihtihkjhmjhBjhu" +
    "khwkhflhhlhjlhpl" +
    "hxmhzmhBmhDmhcnh" +
    "enhgnhinocaoeaog" +
    "aoqbosboAboCbojc" +
    "ozdomeowfopgosio" +
    "ljovkogloiloymoA" +
    "moCmodnofnohnvda" +
    "vfavrbvBbvhlvzmv" +
    "BmvenvgnCeaCAmCf" +
    "n")
r(5091, "Time Tunnel", layout="0aaabcaceaegaeia" +
    "ekaemacoabqaasaa" +
    "acccceeceoccqcas" +
    "caaecceeeeeoecqe" +
    "aseaagccgeegeogc" +
    "qgasgaaiccieeieo" +
    "icqiasiaakbckcek" +
    "egkeikekkemkcokb" +
    "qkaskvcdvqdwcfwq" +
    "fvchvqh")
r(5092, "Tomb", layout="0eaabcabeabgabia" +
    "bkabmaboabqaesab" +
    "accccceccgccicck" +
    "ccmccoccqcbscaae" +
    "dcebeeageaieakea" +
    "meboedqeasebagcc" +
    "gcegeggaigakgemg" +
    "cogcqgbsgdaibcib" +
    "eidgiaiiakidmibo" +
    "ibqidsibgkaikakk" +
    "bmkaimakmhjevfcv" +
    "hcvjcvlcvncCgcCi" +
    "cCkcCmc")
#
# r(5093, "Tower and Walls", layout="0ekadmaeoadqaesa" +
#    "dkccmccoccqcdscd" +
#    "aeecedeeegedieek" +
#    "ecmedoecqeesedue" +
#    "ewedyeeAedCedkgc" +
#    "mgcogcqgdsgekidm" +
#    "ieoidqiesi")
r(5094, "Traditional Reviewed", layout="0acaaeaaiaakaama" +
    "aoaaqaasaawaayaa" +
    "gcaicbkccmccocbq" +
    "cascaucaeeagebie" +
    "bkecmecoebqebsea" +
    "ueaweacgaegbggci" +
    "gckgcmgcogcqgcsg" +
    "bugawgaygaahaAha" +
    "ciaeibgiciickicm" +
    "icoicqicsibuiawi" +
    "ayiaekagkbikbkkc" +
    "mkcokbqkbskaukaw" +
    "kagmaimbkmcmmcom" +
    "bqmasmaumacoaeoa" +
    "ioakoamoaooaqoas" +
    "oawoayovnfvlhwnh" +
    "vphvnj")
r(5095, "Tree of Life", layout="0ababdacfadhacja" +
    "blaanaapabractad" +
    "vacxabzaaBaaccaA" +
    "caadbfdajdaldand" +
    "apdardatdbxdaCda" +
    "ceaAeaafaefagfai" +
    "fbkfbsfaufawfayf" +
    "aCfacgamgaqgaAga" +
    "ehaihauhayhalibo" +
    "iariagjawjblkaok" +
    "brkaambcmcembgma" +
    "imclmaomcrmaumbw" +
    "mcymbAmaCmacoago" +
    "cloaoocroawoaAoa" +
    "iqakqamqcoqaqqas" +
    "qauqhoaicdimdiqd" +
    "iAdhdfiffhhfixfh" +
    "zfilqirq")
#
r(5096, "Twin Temples", layout="0aaaacaaeaagaaia" +
    "akaaqaasaauaawaa" +
    "yaaAaaacakcaqcaA" +
    "camdaodaaeakeaqe" +
    "aAeagfaifamfaofa" +
    "sfaufaagakgaqgaA" +
    "gamhaohaaiakiaqi" +
    "aAiaakackaekagka" +
    "ikakkaqkaskaukaw" +
    "kaykaAkhbbhdbhfb" +
    "hhbhjbhrbhtbhvbh" +
    "xbhzbhbdhjdhldhp" +
    "dhrdhzdhbfhffhvf" +
    "hzfhbhhjhhlhhphh" +
    "rhhzhhbjhdjhfjhh" +
    "jhjjhrjhtjhvjhxj" +
    "hzjoccoecogcoico" +
    "scoucowcoycokdoq" +
    "doceoieoseoyeocg" +
    "oigosgoygokhoqho" +
    "cioeiogioiiosiou" +
    "iowioyivddvfdvhd" +
    "vjdvrdvtdvvdvxdv" +
    "dfvhfvjfvrfvtfvx" +
    "fvdhvfhvhhvjhvrh" +
    "vthvvhvxhCeeCgeC" +
    "ueCweCegCggCugCw" +
    "g")
r(5097, "Vi", layout="0aaaaEaaacaccaCc" +
    "aEcbaeaceaeeaAea" +
    "CebEecagbcgaegag" +
    "gaygaAgbCgcEgcai" +
    "bcibeiagiaiiawia" +
    "yibAibCicEicakcc" +
    "kbekbgkaikakkauk" +
    "awkbykbAkcCkcEkd" +
    "amccmcembgmbimak" +
    "mammasmaumbwmbym" +
    "cAmcCmdEmeaodcoc" +
    "eocgobiobkoamoao" +
    "oaqoasobuobwocyo" +
    "cAodCoeEo")
r(5098, "Victory Arrow", layout="0ataaabbcbbebbgb" +
    "bibbkbambavbaxca" +
    "adamdbvdazdadebf" +
    "ebheajeaBeaafamf" +
    "aofbvfbxfbzfaDfa" +
    "dgajgaqgaahagham" +
    "haohbshbuhbwhbyh" +
    "bAhbChbEhadiajia" +
    "qiaajamjaojbvjbx" +
    "jbzjaDjadkbfkbhk" +
    "ajkaBkaalamlbvla" +
    "zlaxmaanbcnbenbg" +
    "nbinbknamnavnato" +
    "hachmchaehmehdfh" +
    "jfhaghmghoghdhhj" +
    "hhqhhaihmihoihdj" +
    "hjjhakhmkhamhmmo" +
    "dbofbohbojboadom" +
    "doafomfoahonhoph" +
    "orhothovhoxhozho" +
    "Bhoajomjoalomlod" +
    "nofnohnojn")
r(5099, "Wavelets", layout="0agaaqaaAaagcaqc" +
    "aAccaeaeeaieaoea" +
    "seayeaCecGeaggaq" +
    "gaAgcaiaeiaiiaoi" +
    "asiayiaCicGiagka" +
    "qkaAkcamaemaimao" +
    "masmaymaCmcGmago" +
    "aqoaAoagqaqqaAqh" +
    "gbhqbhAbhdehjehn" +
    "ehtehxehDehghhqh" +
    "hAhhdihjihnihtih" +
    "xihDihgjhqjhAjhd" +
    "mhjmhnmhtmhxmhDm" +
    "hgphqphApogcoqco" +
    "Acoceokeomeoueow" +
    "eoEeoggoqgoAgoci" +
    "okiomiouiowioEio" +
    "gkoqkoAkocmokmom" +
    "moumowmoEmogooqo" +
    "oAovgdvqdvAdvbev" +
    "levvevFevgfvqfvA" +
    "fvghvqhvAhvbivli" +
    "vvivFivgjvqjvAjv" +
    "glvqlvAlvbmvlmvv" +
    "mvFmvgnvqnvAn")
r(5100, "Well", layout="0aiaakaamaaoaagc" +
    "aicakcamcaocaqca" +
    "cebeeegeeieekeem" +
    "eeoeeqebseaueaaf" +
    "awfacgbegeggaiga" +
    "kgamgaogeqgbsgau" +
    "gaahawhacibeiegi" +
    "aiiakiamiaoieqib" +
    "siauiaajawjackbe" +
    "kegkeikekkemkeok" +
    "eqkbskaukbimakma" +
    "mmbomaioakoamoao" +
    "ohcfhufhchhuhhcj" +
    "huj")
# r(5101, "What a Pyramid", layout="0aaaacaaeaagaaia" +
#    "akaamaaoaaqaasaa" +
#    "uaawaaacaccbecbg" +
#    "cbicbkcbmcbocbqc" +
#    "bscaucawcaceaeeb" +
#    "geciedkedmecoebq" +
#    "easeaueaegbggdig" +
#    "bkgbmgdogbqgasga" +
#    "eibgidiibkibmido" +
#    "ibqiasiackaekbgk" +
#    "cikdkkdmkcokbqka" +
#    "skaukaamacmbembg" +
#    "mbimbkmbmmbombqm" +
#    "bsmaumawmaaoacoa" +
#    "eoagoaioakoamoao" +
#    "oaqoasoauoawo")
r(5102, "Yummy", layout="0aoaaibakbbmbbqb" +
    "asbaubaocagdbidb" +
    "kdbmdbqdbsdbudaw" +
    "daoeaefbgfcifckf" +
    "dmfdqfcsfcufbwfa" +
    "yfaogaahachbehcg" +
    "hbihakhashbuhcwh" +
    "byhaAhaChaoiaejb" +
    "gjcijckjdmjdqjcs" +
    "jcujbwjayjaokagl" +
    "bilbklbmlbqlbslb" +
    "ulawlaomainaknbm" +
    "nbqnasnaunaooiob" +
    "iodkofkohkojioli" +
    "on")
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.games.mahjongg.mahjongg import r

# test
# r(5991, "AAA 1", ncards=4, layout="0daa")
# r(5992, "AAA 2", ncards=8, layout="0daadca")
# r(5993, "AAA 3", ncards=20, layout="0daaCabdacKbbdca" +
#    "Ccbdcc")
# r(5994, "AAA 4", ncards=20, layout="0daaDabdacdcaDcb" +
#    "dcc")

# ************************************************************************
# * game definitions
# ************************************************************************

r(5401, "Taipei", layout="0aagabbabdabjabl" +
    "hccacfachhckadba" +
    "ddhdehdghdiadjad" +
    "lhecaefoegaehhek" +
    "afcifehfgvfgifia" +
    "fkagahgcageaggog" +
    "gagihgkagmhhaahc" +
    "ohehhfvhfhhhvhho" +
    "hiahkhhmaiahidai" +
    "eaigoigCigaiihij" +
    "aimhjbajcojehjfv" +
    "jfJjghjhvjhojiaj" +
    "khjlakahkdakeakg" +
    "okgCkgQkgakihkja" +
    "kmhlbalcolehlfvl" +
    "fJlghlhvlholialk" +
    "hllamahmdameamgo" +
    "mgCmgamihmjammhn" +
    "aanconehnfvnfhnh" +
    "vnhoniankhnmaoah" +
    "ocaoeaogoogaoiho" +
    "kaomapcipehpgvpg" +
    "ipiapkhqcaqfoqga" +
    "qhhqkarbardhrehr" +
    "ghriarjarlhscasf" +
    "ashhskatbatdatja" +
    "tlaug")
r(5402, "Hare", layout="0aacaamacabccace" +
    "ackbcmacobeacecb" +
    "eebekcembeoofavf" +
    "cofeofkvfmofobga" +
    "cgcbgebgkcgmbgoa" +
    "iabicbiebikbimai" +
    "oakcakebkhakkakm" +
    "amebmgbmiamkbogo" +
    "ohboicqfcqhcqjas" +
    "ejsfasgjshasijsj" +
    "askCtgCtibuddufd" +
    "uhdujbulovdCvgCv" +
    "iovlbwddwfdwhdwj" +
    "bwlcyfcyhcyjbAhb" +
    "Ch")
r(5403, "Horse", layout="0bafbahbajbcdbch" +
    "bclaedbefbehbeja" +
    "elagfaghagjaifhi" +
    "gaihhiiaijakfhkg" +
    "akhhkiakjbmecmgc" +
    "mibmkcodcofcohco" +
    "jcolcqdcqfvqgcqh" +
    "vqicqjcqlbsbcsfv" +
    "sgcshvsicsjbsnot" +
    "botnbubcudcufvug" +
    "cuhvuicujculbunb" +
    "wbcwdcwfcwhcwjcw" +
    "lbwnbycayfbyhayj" +
    "bymaAbaAnaCaaCo")
r(5404, "Rat", layout="0aaabacoadbaeaag" +
    "bcacccccebcgvddo" +
    "dgbeacecceebegag" +
    "abgcbggagmbicbie" +
    "aigaimckeckgckia" +
    "kmblcblkcmevmfcm" +
    "gvmhcmibmmamobnc" +
    "Cngbnkhnocoevofc" +
    "ogvohcoibomaoobp" +
    "cbpkcqecqgcqiaqm" +
    "bscbseasgasmauab" +
    "ucbugaumbwacwccw" +
    "ebwgvxdoxgbyacyc" +
    "cyebygaAabAcoAdb" +
    "AeaAg")
r(5405, "Tiger", layout="0baabacbambaobca" +
    "bccbcmbcobebaegh" +
    "ehaeibenbgbbggbg" +
    "ibgnaibbidcifcih" +
    "dijbilainakdhkea" +
    "kfokfhkgakhpkhhk" +
    "iakjokjhkkaklbme" +
    "pmfbmgomhbmiomjb" +
    "mkboeoofbogoohbo" +
    "ipojbokbqeoqfbqg" +
    "pqhbqioqjbqkbsdd" +
    "sfcshcsjbslbubbu" +
    "dbuhbulbunbwbbwi" +
    "bwnbybbygbynbAbb" +
    "AibAnbCbbCgbCn")
r(5406, "Ram", layout="0aacaaeaagaaihbe" +
    "hbghbibccaceocea" +
    "cgaciociackadaod" +
    "chdehdihdkheabec" +
    "aeepeeaeioeiaeka" +
    "faofchfehfihfkhg" +
    "abgcageogeaggagi" +
    "ogiagkahahhehhgh" +
    "hibicaieaigaiibk" +
    "cblgbmcbmeamione" +
    "hniankanmcocboev" +
    "oebogaoiooihokho" +
    "mbooopehpiapkapm" +
    "bqcbqeaqibrgbscb" +
    "ucaueaugauiavahv" +
    "ehvghvihwabwcawe" +
    "oweawgawiowiawka" +
    "xaoxchxehxihxkhy" +
    "abycayepyeayioyi" +
    "aykazaozchzehzih" +
    "zkbAcaAeoAeaAgaA" +
    "ioAiaAkhBehBghBi" +
    "aCcaCeaCgaCi")
r(5407, "Wedges", layout="0aagbaicakdamaca" +
    "acibckccmbeaaeca" +
    "ekbemcgabgcageag" +
    "mdiacicbieaigeka" +
    "dkcckebkgakiakoh" +
    "lofmaemcdmecmgbm" +
    "iamkammamoomohno" +
    "eoaeocdoecogaoia" +
    "oodqadqccqeaqgcs" +
    "acscaseasmbuaauc" +
    "aukbumawaawibwkc" +
    "wmaygbyicykdym")
r(5408, "Monkey", layout="0aaahabaacoachad" +
    "aaeaakbcaaceackh" +
    "clacmocmhcnacood" +
    "abeabeoofoagahgb" +
    "agcaghbgobicbigb" +
    "iiaimhinaioojgbk" +
    "cdkebkgvkgdkibkk" +
    "bkmolgdmebmgvmgd" +
    "miongdoebogvogdo" +
    "iaokholaomaooopg" +
    "hpobqcdqebqgvqgd" +
    "qiaqooqoorghroas" +
    "ahsbascbsgasmaso" +
    "auaaughuhauiawih" +
    "wjawkowkhwlawmby" +
    "maAchAdaAeoAehAf" +
    "vAfaAgoAgCAghAhv" +
    "AhaAioAiCAihAjvA" +
    "jaAkoAkhAlaAmaCa" +
    "hCbaCc")
r(5409, "Rooster", layout="0aaaaagabchcccce" +
    "ccgadcvdfadiceec" +
    "egaeohfoageagoog" +
    "ohhoaiehifaigaim" +
    "aiohjmbkeokfbkgo" +
    "khbkiakkakmamccm" +
    "evmfcmgvmhcmiamk" +
    "anahncCnghoaaoco" +
    "occoevofcogvohco" +
    "iapaopahpchqaaqc" +
    "oqcbqeoqfbqgvqgo" +
    "qhbqiaqkaqmaraor" +
    "ahrchrmhsaascbsg" +
    "oshbsiaskasmasoa" +
    "taotahtohuaaufhu" +
    "gauhauoavabweowf" +
    "bwgowhbwivxgayab" +
    "ycoydbyeoyfbygoy" +
    "hbyihzaaAaaAeaAj" +
    "hAkaAlhBaaCaaCeh" +
    "CfaCgaCl")
r(5410, "Dog", layout="0aaeaaghbehbgacc" +
    "aceoceacgocgacia" +
    "ckhdchdehdghdihd" +
    "kaecoecaeeaegaei" +
    "aekhfcagcaichida" +
    "ieoiehifaigvjebk" +
    "ackcckeckgbkibkk" +
    "vlcoliolkbmacmcc" +
    "mgbmibmkamoonavn" +
    "conkboacoccoecog" +
    "bokaomaooopavpco" +
    "pkbqacqccqgbqibq" +
    "kvrcoriorkbsacsc" +
    "csecsgbsibskvtea" +
    "uchudaueouehufau" +
    "gawchxcaycoycaye" +
    "aygayiaykhzchzeh" +
    "zghzihzkaAcaAeoA" +
    "eaAgoAgaAiaAkhBe" +
    "hBgaCeaCg")
r(5411, "Snake", layout="0bagbaiobhbcgbci" +
    "bdebecbegbfebgcb" +
    "habicbiicikcimbj" +
    "avjlbkcbkebkgbki" +
    "ckkckmakooleolgo" +
    "livllhlobmcbmebm" +
    "gbmicmkcmmamoomo" +
    "vnlhnocokcomaooo" +
    "oovplhpobqcbqebq" +
    "gbqicqkcqmaqoore" +
    "orgorivrlbscbseb" +
    "sgbsicskcsmbtabu" +
    "cbvabwcbwebwgbwi" +
    "bwkbycbyebygbyib" +
    "ykbAjaCj")
r(5412, "Boar", layout="0aacaaehafaagoag" +
    "hahaaiaakhbchbka" +
    "ccoccaciackockac" +
    "mhdchdkhdmaecaee" +
    "aekoekaemoemhfkh" +
    "fmagiagkogkagmhh" +
    "kaiiaikakcbkgbki" +
    "akmolgolibmcbmeb" +
    "mgbmibmkbmmoncon" +
    "epngpnionkonmano" +
    "aoabocvocboevoeb" +
    "ogboibokvokbomvo" +
    "mhooopcopeppgppi" +
    "opkopmapobqcbqeb" +
    "qgbqibqkbqmorgor" +
    "iascbsgbsiasmaui" +
    "aukhvkawiawkowka" +
    "wmhxkhxmaycayeay" +
    "koykaymoymhzchzk" +
    "hzmaAcoAcaAiaAko" +
    "AkaAmhBchBkaCcaC" +
    "ehCfaCgoCghChaCi" +
    "aCk")
r(5413, "Ox", layout="0aahabeabkbcgoch" +
    "bciaeaaecbegbeia" +
    "emaeohfbhfnagaag" +
    "cagebggbgiagkagm" +
    "agoaicbiebigbiib" +
    "ikaimakcbkeckgck" +
    "ibkkakmbmecmgcmi" +
    "bmkaodioeaofjoga" +
    "ohjoiaojiokaolcq" +
    "edqgdqicqkcsedsg" +
    "dsicskaucbuecugc" +
    "uibukaumawcbwecw" +
    "gcwibwkawmayaayc" +
    "ayebygbyiaykayma" +
    "yohzbhznaAaaAcaA" +
    "haAmaAo")
r(5414, "Bridge 2", layout="0daadacdaedagdai" +
    "dakdamdaocccccec" +
    "cgccicckccmbeebe" +
    "gbeibekaggagiaih" +
    "hjhakhokhhlhvlha" +
    "mfamhomhCmhhnhvn" +
    "hJnhanjaofaohooh" +
    "Cohhphvphaqhoqhh" +
    "rhashaugauibwebw" +
    "gbwibwkcyccyecyg" +
    "cyicykcymdAadAcd" +
    "AedAgdAidAkdAmdA" +
    "o")

# r(5501, "Big X", layout="0aacaamhbchbmacb" +
#    "occacdaclocmacnh" +
#    "dbhddhdlhdnaeaae" +
#    "coedaeeaekoelaem" +
#    "aeohfchfehfkhfma" +
#    "gbagdogeagfagjog" +
#    "kaglagnhhdhhfhhj" +
#    "hhlaicaieoifaiga" +
#    "iioijaikaimhjehj" +
#    "ghjihjkakdakfokg" +
#    "akhokiakjaklhlfh" +
#    "lhhljameamgomgam" +
#    "iomiamkhnfhnhhnj" +
#    "aofoofaohoohaojo" +
#    "ojhpfhphhpjaqeaq" +
#    "goqgaqioqiaqkhrf" +
#    "hrhhrjasdasfosga" +
#    "shosiasjaslhteht" +
#    "ghtihtkaucaueouf" +
#    "augauioujaukaumh" +
#    "vdhvfhvjhvlawbaw" +
#    "doweawfawjowkawl" +
#    "awnhxchxehxkhxma" +
#    "yaaycoydayeaykoy" +
#    "laymayohzbhzdhzl" +
#    "hznaAboAcaAdaAlo" +
#    "AmaAnhBchBmaCcaC" +
#    "m")
# r(5502, "Axis", layout="0bafcahbajbbdvbh" +
#    "bblcchCchbdcvdhb" +
#    "dmcehCehbfbvfhbf" +
#    "ncghahaahohiahio" +
#    "ajabjhajohkabkfb" +
#    "kjhkoalabldbllal" +
#    "ohmacmhhmoanaanc" +
#    "vnhanmanoiobcohi" +
#    "onapbwphapniqbcq" +
#    "hiqnaraarcvrharm" +
#    "arohsacshhsoatab" +
#    "tdbtlatohuabufbu" +
#    "jhuoavabvhavohwa" +
#    "hwoaxaaxocyhbzbv" +
#    "zhbzncAhCAhbBcvB" +
#    "hbBmcChCChbDdvDh" +
#    "bDlbEfcEhbEj")
# r(5503, "Cobweb", layout="0aacaafhagaahoah" +
#    "haiaajaamacbhcca" +
#    "cdaclhcmacnadfhd" +
#    "gadhodhhdiadjaea" +
#    "aeohfaafcafeafha" +
#    "fkafmhfoagaogaag" +
#    "oogohhaahcahhahm" +
#    "hhoaiaoiaaiooioh" +
#    "jaajdajhajlhjoak" +
#    "aakoalealhalkama" +
#    "amoancanfhnganhh" +
#    "nianjanmaoahoboo" +
#    "gooihonaooopbapc" +
#    "bpgvpgbpivpiapmo" +
#    "pnaqahqboqgoqihq" +
#    "naqoarcarfhrgarh" +
#    "hriarjarmasaasoa" +
#    "teathatkauaauohv" +
#    "aavdavhavlhvoawa" +
#    "owaawoowohxaaxca" +
#    "xhaxmhxoayaoyaay" +
#    "ooyohzaazcazeazh" +
#    "azkazmhzoaAaaAoa" +
#    "BfhBgaBhoBhhBiaB" +
#    "jaCbhCcaCdaClhCm" +
#    "aCnaEcaEfhEgaEho" +
#    "EhhEiaEjaEm")
# r(5504, "Pyramids", layout="0aaaaacaakaamhbb" +
#    "abeabgabihblacaa" +
#    "ccackacmhdbadead" +
#    "gadihdlaeaaecaek" +
#    "aemaffhfgafhahba" +
#    "heahiahlhibhiehi" +
#    "ihilajbojbajdoje" +
#    "ajfajhojiajjajlo" +
#    "jlhkbvkbhkevkehk" +
#    "ghkivkihklvklalb" +
#    "olbClbaldoleClea" +
#    "lfolgalholiClial" +
#    "jallollCllhmbvmb" +
#    "hmevmehmgvmghmiv" +
#    "mihmlvmlanbonbCn" +
#    "bandoneCneanfong" +
#    "anhoniCnianjanlo" +
#    "nlCnlhobvobhoevo" +
#    "ehoghoivoiholvol" +
#    "apbopbapdopeapfa" +
#    "phopiapjaploplhq" +
#    "bhqehqihqlarbare" +
#    "ariarlatfhtgatha" +
#    "uaaucaukaumhvbav" +
#    "eavgavihvlawaawc" +
#    "awkawmhxbaxeaxga" +
#    "xihxlayaaycaykay" +
#    "m")
# r(5505, "Wicker", layout="0bafbakbbcbbhbbm" +
#    "bcebcjbdbbdgbdlb" +
#    "edbeibenbfabffbf" +
#    "kbgcbghbgmbhebhj" +
#    "bibbigbilbjdbjib" +
#    "jnbkabkfbkkblcbl" +
#    "hblmbmebmjbnbbng" +
#    "bnlbodboibonbpab" +
#    "pfbpkbqcbqhbqmbr" +
#    "ebrjbsbbsgbslbtd" +
#    "btibtnbuabufbukb" +
#    "vcbvhbvmbwebwjbx" +
#    "bbxgbxlbydbyibyn" +
#    "bzfbzkbAh")

r(5801, "Faro", name="Double Mahjongg Faro", ncards=288, layout="0aaaha" +
    "baachadaae" +
    "oaehafaagiahaaih" +
    "ajaakoakhalaamha" +
    "naaoobcvbhobmacb" +
    "hccvccacdacgichC" +
    "chaciaclhcmvcmac" +
    "nodcCdcvdhodmCdm" +
    "aebhecvecaedheea" +
    "efcehCehaejhekae" +
    "lhemvemaenofcvfh" +
    "ofmbgcagfhggagho" +
    "ghhgiagjbgmahaah" +
    "ohiahioajapjaajc" +
    "cjebjhcjkajmajop" +
    "johkahkcokhhkmhk" +
    "oalaalcqlcalfhlg" +
    "alhvlhhlialjalmq" +
    "lmalohmcomhCmhhm" +
    "manbqncandhneanf" +
    "bnhvnhanjhnkanlq" +
    "nmannhocooeoohoo" +
    "khomapcppcCpdbpe" +
    "vpebphwphbpkvpkC" +
    "plapmppmhqcoqeoq" +
    "hoqkhqmarbqrcard" +
    "hrearfbrhvrharjh" +
    "rkarlqrmarnhscos" +
    "hCshhsmataatcqtc" +
    "atfhtgathvthhtia" +
    "tjatmqtmatohuahu" +
    "couhhumhuoavapva" +
    "avccvebvhcvkavma" +
    "vopvohwahwoaxaax" +
    "obycayfhygayhoyh" +
    "hyiayjbymozcvzho" +
    "zmaAbhAcvAcaAdhA" +
    "eaAfcAhCAhaAjhAk" +
    "aAlhAmvAmaAnoBcC" +
    "BcvBhoBmCBmaCbhC" +
    "cvCcaCdaCgiChCCh" +
    "aCiaClhCmvCmaCno" +
    "DcvDhoDmaEahEbaE" +
    "chEdaEeoEehEfaEg" +
    "iEhaEihEjaEkoEkh" +
    "ElaEmhEnaEo")
# r(5802, "Big Square", name="Double Mahjongg Big Square", ncards=288,
# layout="0daadacdaedagdai" +
#    "dakdcadccdcedcgd" +
#    "cidckdeadecdeede" +
#    "gdeidekdgadgcdge" +
#    "dggdgidgkdiadicd" +
#    "iedigdiidikdkadk" +
#    "cdkedkgdkidkkdma" +
#    "dmcdmedmgdmidmkd" +
#    "oadocdoedogdoido" +
#    "kdqadqcdqedqgdqi" +
#    "dqkdsadscdsedsgd" +
#    "sidskduaducduedu" +
#    "gduidukdwadwcdwe" +
#    "dwgdwidwk")
r(5803, "Two Squares", name="Double Mahjongg Two Squares", ncards=288,
        layout="0daadacdaedagdai" +
    "dakdcadccdcedcgd" +
    "cidckdeadecdeede" +
    "gdeidekdgadgcdge" +
    "dggdgidgkdiadicd" +
    "iedigdiidikdkadk" +
    "cdkedkgdkidkkdoa" +
    "docdoedogdoidokd" +
    "qadqcdqedqgdqidq" +
    "kdsadscdsedsgdsi" +
    "dskduaducduedugd" +
    "uidukdwadwcdwedw" +
    "gdwidwkdyadycdye" +
    "dygdyidyk")
# r(5804, "Rows", name="Double Mahjongg Rows", ncards=288,
# layout="0daadacCaddaeCaf" +
#    "dagCahdaidakdcad" +
#    "ckeeadeceeeeegde" +
#    "ieekegaegkeiadic" +
#    "eieeigdiieikekae" +
#    "kkemadmcemeemgdm" +
#    "iemkeoaeokeqadqc" +
#    "eqeeqgdqieqkesae" +
#    "skeuaduceueeugdu" +
#    "ieukewaewkeyadyc" +
#    "eyeeygdyieykdAad" +
#    "AkdCadCcCCddCeCC" +
#    "fdCgCChdCidCk")
r(5805, "Twin Picks", name="Double Mahjongg Twin Picks", ncards=288,
        layout="0aacaaeaagaaiaak" +
    "aamhbdhbfhbhhbjh" +
    "blacaaccaceoceac" +
    "gocgaciociackock" +
    "acmacohdbhddhdfv" +
    "dfhdhvdhhdjvdjhd" +
    "lhdnaeaaecoecaee" +
    "oeeaegoegCegaeio" +
    "eiCeiaekoekaemoe" +
    "maeohfbhfdvfdhff" +
    "vffhfhvfhhfjvfjh" +
    "flvflhfnagaagcog" +
    "cageogeCgeaggogg" +
    "CggagiogiCgiagko" +
    "gkCgkagmogmagohh" +
    "bhhdvhdhhfvhfhhh" +
    "vhhhhjvhjhhlvhlh" +
    "hnaiaaicoicaieoi" +
    "eaigoigCigaiioii" +
    "Ciiaikoikaimoima" +
    "iohjbhjdhjfvjfhj" +
    "hvjhhjjvjjhjlhjn" +
    "akaakcakeokeakgo" +
    "kgakiokiakkokkak" +
    "makohldhlfhlhhlj" +
    "hllamcameamgamia" +
    "mkammapaapcapeap" +
    "gapiapkapmapoasc" +
    "aseasgasiaskasmh" +
    "tdhtfhthhtjhtlau" +
    "aaucaueoueaugoug" +
    "auiouiaukoukauma" +
    "uohvbhvdhvfvvfhv" +
    "hvvhhvjvvjhvlhvn" +
    "awaawcowcaweowea" +
    "wgowgCwgawiowiCw" +
    "iawkowkawmowmawo" +
    "hxbhxdvxdhxfvxfh" +
    "xhvxhhxjvxjhxlvx" +
    "lhxnayaaycoycaye" +
    "oyeCyeaygoygCyga" +
    "yioyiCyiaykoykCy" +
    "kaymoymayohzbhzd" +
    "vzdhzfvzfhzhvzhh" +
    "zjvzjhzlvzlhznaA" +
    "aaAcoAcaAeoAeaAg" +
    "oAgCAgaAioAiCAia" +
    "AkoAkaAmoAmaAohB" +
    "bhBdhBfvBfhBhvBh" +
    "hBjvBjhBlhBnaCaa" +
    "CcaCeoCeaCgoCgaC" +
    "ioCiaCkoCkaCmaCo" +
    "hDdhDfhDhhDjhDla" +
    "EcaEeaEgaEiaEkaE" +
    "m")
r(5806, "Roost", name="Double Mahjongg Roost", ncards=288,
        layout="0aaahabaacoachad" +
    "vadaaeoaehafvafa" +
    "agoaghahvahaaioa" +
    "ihajaakaamaaoCbf" +
    "hblhbnacbhccacdo" +
    "cdhcevceacfocfhc" +
    "gvcgachochhciacj" +
    "aclocmacnhdkhdma" +
    "eiaekoelaemaeoaf" +
    "aafcafehfjhflvfl" +
    "hfnhgchgeaghagjo" +
    "gkaglCglogmagnah" +
    "bohcahdoheahfhhi" +
    "hhkvhlhhmhibhidv" +
    "iehifaiioijaikoi" +
    "laimajaajcojdaje" +
    "Cjeojfajghjjvjkh" +
    "jlajohkcvkdhkevk" +
    "fhkgakjokkaklalb" +
    "olcaldolealfClfo" +
    "lgalhhlkblnhmbhm" +
    "dvmehmfvmghmhamk" +
    "omnanaancondaneo" +
    "nfangCngonhanian" +
    "mhnnanohochoevof" +
    "hogvohhoiapbapdo" +
    "peapfopgaphCphop" +
    "iapjhpkaploplhpm" +
    "apnhqchqevqfhqgv" +
    "qhhqiaraarcordar" +
    "eorfargCrgorhari" +
    "armhrnarohsbhsdv" +
    "sehsfvsghshaskos" +
    "natbotcatdoteatf" +
    "Ctfotgathhtkbtnh" +
    "ucvudhuevufhugau" +
    "joukaulavaavcovd" +
    "aveCveovfavghvjv" +
    "vkhvlavohwbhwdvw" +
    "ehwfawiowjawkowl" +
    "awmaxboxcaxdoxea" +
    "xfhxihxkvxlhxmhy" +
    "chyeayhayjoykayl" +
    "Cyloymaynazaazca" +
    "zehzjhzlvzlhznaA" +
    "iaAkoAlaAmaAohBk" +
    "hBmaCbhCcaCdoCdh" +
    "CevCeaCfoCfhCgvC" +
    "gaChoChhCiaCjaCl" +
    "oCmaCnCDfhDlhDna" +
    "EahEbaEcoEchEdvE" +
    "daEeoEehEfvEfaEg" +
    "oEghEhvEhaEioEih" +
    "EjaEkaEmaEo")
r(5807, "Castle", name="Double Mahjongg Big Castle", ncards=288,
        layout="0eaadacdaeeageai" +
    "dakdameaodcadcoc" +
    "ddvdecdfvdgcdhCd" +
    "hvdicdjvdkcdldea" +
    "deoafdaflcgacgoa" +
    "hdahlciacioajdaj" +
    "lckahkdhklckoald" +
    "elfblheljallcmah" +
    "mdhmlcmoandbnfbn" +
    "janleoahodoofooj" +
    "holeooapdbpfvpfb" +
    "pjvpjapleqahqdoq" +
    "foqjhqleqoardbrf" +
    "brjarlcsahsdhslc" +
    "soatdetfbthetjat" +
    "lcuahudhulcuoavd" +
    "avlcwacwoaxdaxlc" +
    "yacyoazdazldAadA" +
    "ocBdvBecBfvBgcBh" +
    "CBhvBicBjvBkcBld" +
    "CadCoeEadEcdEeeE" +
    "geEidEkdEmeEo")
r(5808, "Eight Squares", name="Double Mahjongg Eight Squares", ncards=288,
        layout="0daadacdaedahdaj" +
    "daldcadccdcedchd" +
    "cjdcldeadecdeede" +
    "hdejdeldhadhcdhe" +
    "dhhdhjdhldjadjcd" +
    "jedjhdjjdjldladl" +
    "cdledlhdljdlldoa" +
    "docdoedohdojdold" +
    "qadqcdqedqhdqjdq" +
    "ldsadscdsedshdsj" +
    "dsldvadvcdvedvhd" +
    "vjdvldxadxcdxedx" +
    "hdxjdxldzadzcdze" +
    "dzhdzjdzl")
r(5809, "Big Flying Dragon", name="Double Mahjongg Big Flying Dragon",
        ncards=288, layout="0aajacaaciackacs" +
    "aeaaegaeihejaeka" +
    "emaesagaageaggbg" +
    "ibgkagmagoagsaia" +
    "aicaiebigbiibikb" +
    "imaioaiqaisakabk" +
    "cbkebkgbkibkkbkm" +
    "bkobkqaksbmabmcc" +
    "mecmgcmicmkcmmcm" +
    "obmqbmsboaboccoe" +
    "dogdoidokdomcoob" +
    "oqbosbqabqccqedq" +
    "geqieqkdqmcqobqq" +
    "bqsJrjbsabsccsed" +
    "sgesieskdsmcsobs" +
    "qbssbuabuccuedug" +
    "duidukdumcuobuqb" +
    "usbwabwccwecwgcw" +
    "icwkcwmcwobwqbws" +
    "ayabycbyebygbyib" +
    "ykbymbyobyqaysaA" +
    "aaAcaAebAgbAibAk" +
    "bAmaAoaAqaAsaCaa" +
    "CeaCgbCibCkaCmaC" +
    "oaCsaEaaEgaEihEj" +
    "aEkaEmaEsaGaaGia" +
    "GkaGsaIaaIjaIsaK" +
    "j")
r(5810, "Sphere", name="Double Mahjongg Sphere", ncards=288,
        layout="0aajaalaanabhhbk" +
    "hbmabpacfhciacjo" +
    "ckaclocmacnhcoac" +
    "raddhdgadhodivdk" +
    "hdlvdmodoadphdqa" +
    "dtaefoegveihejae" +
    "koekaemoemhenveo" +
    "oeqaerafchfdhffh" +
    "fhafiafohfphfrhf" +
    "tafuageogeaggpgg" +
    "pgihgjpgkbglpgmh" +
    "gnpgoagqpgqagsog" +
    "sahbhhchhfhhhahj" +
    "ahnhhphhrhhuahva" +
    "idoidvieaifoigai" +
    "hoiihijoikbiloim" +
    "hinoioaipoiqairv" +
    "isaitoitajahjbhj" +
    "dhjfhjhvjlhjphjr" +
    "hjthjvajwakcokcv" +
    "kdakeokeakgokgak" +
    "iokiakkokkakmokm" +
    "akookoakqokqakso" +
    "ksvktakuokualahl" +
    "bhldhlfvlfhlhvlh" +
    "hljvljhllvllhlnv" +
    "lnhlpvlphlrvlrhl" +
    "thlvalwamcomcvmd" +
    "ameomeamgomgamio" +
    "miamkomkammommam" +
    "oomoamqomqamsoms" +
    "vmtamuomuanahnbh" +
    "ndhnfhnhvnlhnphn" +
    "rhnthnvanwaodood" +
    "voeaofoogaohooih" +
    "ojookboloomhonoo" +
    "oaopooqaorvosaot" +
    "ootapbhpchpfhpha" +
    "pjapnhpphprhpuap" +
    "vaqeoqeaqgpqgpqi" +
    "hqjpqkbqlpqmhqnp" +
    "qoaqqpqqaqsoqsar" +
    "chrdhrfhrhariaro" +
    "hrphrrhrtaruasfo" +
    "sgvsihsjaskoskas" +
    "mosmhsnvsoosqasr" +
    "atdhtgathotivtkh" +
    "tlvtmotoatphtqat" +
    "taufhuiaujoukaul" +
    "oumaunhuoauravhh" +
    "vkhvmavpawjawlaw" +
    "n")

# ----------------------------------------------------------------------

r(5901, "Happy New Year", name="Half Mahjongg Happy New Year", ncards=72,
        layout="0aafaajaanaceaci" +
    "acmbedbehaelofdo" +
    "fhhflbgdbghagloh" +
    "dohhaibbidaighih" +
    "aiiailhimainojma" +
    "kaakeckhakjbkmbk" +
    "oolmambbmdamghmh" +
    "amiamlhmmamnondo" +
    "nhbodbohaolopdop" +
    "hhplbqdbqhaqlase" +
    "asiasmaufaujaun")
# r(5902, "K 2", name="Half Mahjongg K 2", ncards=72,
# layout="0aagabcabehbfobg" +
#    "hbhabiabkacgvcga" +
#    "dbidgadlaegvegbf" +
#    "aifgbfmaggbhaihg" +
#    "bhmaigbjahjgbjma" +
#    "kgokgblahlgblmam" +
#    "gbnaingbnmaogbpa" +
#    "ipgbpmaqgvqgarbi" +
#    "rgarlasgvsgatcat" +
#    "ehtfotghthatiatk" +
#    "aug")
# r(5903, "Abstract", name="Half Mahjongg Abstract", ncards=72,
# layout="0aaaaagabcabebdd" +
#    "adgadioedhehafch" +
#    "fdafeafhagahhaah" +
#    "dahgaiahjaojbbjc" +
#    "ajfakaalcamfamha" +
#    "nbhncandhngaogbo" +
#    "iapdhqdaqiarcord" +
#    "arehrihsdasgasia" +
#    "tdauaaufhvbavcav" +
#    "iawaawehxeaxiayc" +
#    "ayebyghzdaAdaAha" +
#    "BbaBfhCfaCiaDcaD" +
#    "eaDghDhaEaaEi")
r(5904, "Smile", name="Half Mahjongg Smile", ncards=72,
        layout="0bagoahbaibbebbk" +
    "bccbcmbebbenaffb" +
    "fjbgahgfbgoahfbh" +
    "kbiabiobjlbkabko" +
    "bllbmabmoanfbnkb" +
    "oahofbooapfbpjbq" +
    "bbqnbscbsmbtebtk" +
    "bugouhbui")
r(5905, "Wall", name="Half Mahjongg Wall", ncards=72,
        layout="0eaabacbaebagbai" +
    "bakbameaoacaacoa" +
    "eaaeoagaagoaiaai" +
    "oakaakoamaamoaoa" +
    "aooaqaaqoasaasoa" +
    "uaauoawaawoayaay" +
    "oaAaaAoaCaaCoeEa" +
    "bEcbEebEgbEibEkb" +
    "EmeEo")

# ----------------------------------------------------------------------

# r(5601, "Skomoroh 1", ncards=28, layout="0aacaaeaaghbdhbf" +
#    "acaacdoceacfacih" +
#    "ddhdfaebaeeoeeae" +
#    "hhfdhffagaagdoge" +
#    "agfagihhdhhfaica" +
#    "ieaig")
# r(5602, "Skomoroh 2", ncards=116, layout="0aaeaaghahaaiaak" +
#    "abaaboacfbchacja" +
#    "daadoaeghehaeiaf" +
#    "aafocghahaahcahf" +
#    "vhhahjahmahohidc" +
#    "ihhilajaajdajfwj" +
#    "hajjajlajohkdhkg" +
#    "akhokhhkihklalaa" +
#    "lcalewlhalkalmal" +
#    "ohmfamgimhamihmj" +
#    "anaancanewnhanka" +
#    "nmanohodhogaohoo" +
#    "hhoiholapaapdapf" +
#    "wphapjaplapohqdc" +
#    "qhhqlaraarcarfvr" +
#    "harjarmarocshata" +
#    "atoaughuhauiavaa" +
#    "voawfbwhawjaxaax" +
#    "oayeayghyhayiayk")
# r(5603, "Skomoroh 3", ncards=132, layout="0aachadaaeoaeXae" +
#    "hafyafaagoagXagh" +
#    "ahaaiabaabkhcahc" +
#    "kadaadeadgadkhea" +
#    "hefhekafaafeafga" +
#    "fkhgahgfhgkahaah" +
#    "eahgahkhiahifhik" +
#    "ajaajeajgajkhkah" +
#    "kfhkkalaalealgal" +
#    "khmahmfhmkanaane" +
#    "onfangankhofXofa" +
#    "pbapdapfspfaphap" +
#    "jhqfXqfaraareorf" +
#    "argarkhsahsfhska" +
#    "taateatgatkhuahu" +
#    "fhukavaaveavgavk" +
#    "hwahwfhwkaxaaxea" +
#    "xgaxkhyahyfhykaz" +
#    "aazeazgazkhAahAf" +
#    "hAkaBaaBeaBgaBkh" +
#    "CahCkaDaaDkaEchE" +
#    "daEeoEeXEehEfyEf" +
#    "aEgoEgXEghEhaEi")
# r(5604, "Skomoroh 4", ncards=52, layout="0aajaalaanabhabp" +
#    "acfacnacraddadla" +
#    "dtaejafcafuagiah" +
#    "bbhoahvaiiajaajw" +
#    "akjalaalwamkamma" +
#    "naanwaonapaapwaq" +
#    "oarbbriarvasoatc" +
#    "atuaunavdavlavta" +
#    "wfawjawraxhaxpay" +
#    "jaylayn")
# r(5605, "Skomoroh 5", ncards=208, layout="0aahaajaalaanaap" +
#    "hbihbkoblhbmhboa" +
#    "ccaceacgaciackac" +
#    "macoacqacsacuaec" +
#    "aeuagdagjaglagna" +
#    "gthhkhhmaieaijai" +
#    "loilainaishjkhjm" +
#    "akfakjakloklakna" +
#    "krhlkhlmameamgam" +
#    "jamlomlamnamqams" +
#    "anchndhnkhnmhnta" +
#    "nuaoeaohaojaoloo" +
#    "laonaopaosapchpd" +
#    "hpkhpmhptapuaqea" +
#    "qhaqjaqlaqnaqpaq" +
#    "saraarchrdhrtaru" +
#    "arwaseasgasiaska" +
#    "smasoasqassataht" +
#    "batchtdhtfithitj" +
#    "itlitnitphtrhtta" +
#    "tuhtvatwaueaugau" +
#    "iaukaumauoauqaus" +
#    "avaavchvdhvtavua" +
#    "vwaweawhawjawlaw" +
#    "nawpawsaxchxdhxk" +
#    "hxmhxtaxuayeayha" +
#    "yjayloylaynaypay" +
#    "sazchzdhzkhzmhzt" +
#    "azuaAeaAgaAjaAlo" +
#    "AlaAnaAqaAshBkhB" +
#    "maCfaCjaCloClaCn" +
#    "aCrhDkhDmaEeaEja" +
#    "EloElaEnaEshFkhF" +
#    "maGdaGjaGlaGnaGt" +
#    "aIcaIuaKcaKeaKga" +
#    "KiaKkaKmaKoaKqaK" +
#    "saKuhLihLkoLlhLm" +
#    "hLoaMhaMjaMlaMna" +
#    "Mp")
# r(5606, "Skomoroh 6", layout="0aadaafaahaajaal" +
#    "aanaapadaaddadfa" +
#    "dhadjadladnadpad" +
#    "sheehegheihekhem" +
#    "heoafaafdaffoffa" +
#    "fhofhafjofjaflof" +
#    "lafnofnafpafshge" +
#    "hggvgghgivgihgkv" +
#    "gkhgmvgmhgoahaCh" +
#    "hChjChlahsaidaif" +
#    "oifaihoihJiiaijo" +
#    "ijJikailoilainoi" +
#    "naipajahjehjgvjg" +
#    "CjhhjivjihjkvjkC" +
#    "jlhjmvjmhjoajsak" +
#    "dakfokfakhokhJki" +
#    "akjokjJkkaklokla" +
#    "knoknakpalaClhCl" +
#    "jCllalshmehmgvmg" +
#    "hmivmihmkvmkhmmv" +
#    "mmhmoanaandanfon" +
#    "fanhonhanjonjanl" +
#    "onlannonnanpansh" +
#    "oehoghoihokhomho" +
#    "oapaapdapfaphapj" +
#    "aplapnappapsasda" +
#    "sfashasjaslasnas" +
#    "p")
# r(5607, "Skomoroh 7", ncards=56, layout="0aabaadaafaahaaj" +
#    "aapaaraatablabwa" +
#    "daadmadwafaafnaf" +
#    "wahaahnahwajfajh" +
#    "ajmajwakdakjalbd" +
#    "llalvamnamtanaan" +
#    "kanpanrapaapjapw" +
#    "araarjarwataatka" +
#    "twavaavlawdawfaw" +
#    "hawnawpawrawtawv")
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.games.mahjongg.mahjongg import AbstractMahjonggGame, \
        Mahjongg_RowStack, \
        comp_cardset
from pysollib.hint import AbstractHint
from pysollib.layout import Layout
from pysollib.mfxutil import kwdefault
from pysollib.mygettext import _
from pysollib.mygettext import ungettext
from pysollib.pysoltk import MfxCanvasLine, MfxCanvasText
from pysollib.settings import TOOLKIT
from pysollib.stack import \
        AbstractFoundationStack, \
        InitialDealTalonStack
from pysollib.util import ANY_SUIT

from six.moves import range


class Shisen_Hint(AbstractHint):
    TOP_MATCHING = False
    # FIXME: no intelligence whatsoever is implemented here

    def computeHints(self):
        game = self.game
        # get free stacks
        stacks = []
        for r in game.s.rows:
            if r.cards:
                stacks.append(r)
        # find matching tiles
        i = 0
        for r in stacks:
            for t in stacks[i+1:]:
                # if game.cardsMatch(r.cards[0], t.cards[0]):
                if r.acceptsCards(t, t.cards):
                    # simple scoring...
                    if self.TOP_MATCHING:
                        score = 2000 - r.rown - t.rown
                    else:
                        score = 1000 + r.rown + t.rown
                    self.addHint(score, 1, r, t)
            i += 1


class NotShisen_Hint(Shisen_Hint):
    TOP_MATCHING = True


# ************************************************************************
# * Shisen-Sho
# ************************************************************************


class Shisen_Foundation(AbstractFoundationStack):
    def __init__(self, x, y, game, suit=ANY_SUIT, **cap):
        kwdefault(cap, max_move=0, max_accept=0, max_cards=game.NCARDS)
        AbstractFoundationStack.__init__(self, x, y, game, suit, **cap)

    def acceptsCards(self, from_stack, cards):
        # We do not accept any cards - pairs will get
        # delivered by _dropPairMove() below.
        return 0

    def basicIsBlocked(self):
        return 1

    def initBindings(self):
        pass


class Shisen_RowStack(Mahjongg_RowStack):

    def basicIsBlocked(self):
        return 0

    def acceptsCards(self, from_stack, cards):
        if not self.game.cardsMatch(self.cards[0], cards[-1]):
            return 0

        cols, rows = self.game.L
        game_cols = self.game.cols
        x1, y1 = self.coln+1, self.rown+1
        x2, y2 = from_stack.coln+1, from_stack.rown+1
        dx, dy = x2 - x1, y2 - y1

        a = []
        for i in range(cols+2):
            a.append([5]*(rows+2))

        def can_move(x, y, nx, ny, direct, d, direct_chng_cnt):
            if nx == x2 and ny == y2:
                return 1
            if nx < 0 or ny < 0 or nx > cols+1 or ny > rows+1:
                return 0
            if nx in (0, cols+1) or ny in (0, rows+1) \
                    or not game_cols[nx-1][ny-1].cards:
                if direct_chng_cnt == 0:
                    return 1
                elif direct_chng_cnt == 1:
                    if direct != d:
                        if d == 1 and dy > 0:
                            return 1
                        elif d == 2 and dy < 0:
                            return 1
                        elif d == 3 and dx > 0:
                            return 1
                        elif d == 4 and dx < 0:
                            return 1
                    else:
                        return 1
                elif direct_chng_cnt == 2:
                    if direct != d:
                        if d in (1, 2) and x == x2:
                            return 1
                        elif y == y2:
                            return 1
                    else:
                        if d == 1 and y < y2:
                            return 1
                        elif d == 2 and y > y2:
                            return 1
                        elif d == 3 and x < x2:
                            return 1
                        elif d == 4 and x > x2:
                            return 1
                elif direct_chng_cnt == 3:
                    if direct == d:
                        return 1

            return 0

        res_path = [None]

        def do_accepts(x, y, direct, direct_chng_cnt, path):
            # if direct_chng_cnt > 3:
            #    return
            if a[x][y] < direct_chng_cnt:
                return
            # if res_path[0]:
            #    return
            a[x][y] = direct_chng_cnt
            if x == x2 and y == y2:
                res_path[0] = path
                return

            if can_move(x, y, x, y+1, direct, 1, direct_chng_cnt):  # 1
                # dcc = direct == 1 and direct_chng_cnt or direct_chng_cnt+1
                p = path[:]
                if direct == 1:
                    dcc = direct_chng_cnt
                else:
                    dcc = direct_chng_cnt+1
                    p.append((x, y))
                do_accepts(x, y+1, 1, dcc, p)
            if can_move(x, y, x, y-1, direct, 2, direct_chng_cnt):  # 2
                # dcc = direct == 2 and direct_chng_cnt or direct_chng_cnt+1
                p = path[:]
                if direct == 2:
                    dcc = direct_chng_cnt
                else:
                    dcc = direct_chng_cnt+1
                    p.append((x, y))
                do_accepts(x, y-1, 2, dcc, p)
            if can_move(x, y, x+1, y, direct, 3, direct_chng_cnt):  # 3
                # dcc = direct == 3 and direct_chng_cnt or direct_chng_cnt+1
                p = path[:]
                if direct == 3:
                    dcc = direct_chng_cnt
                else:
                    dcc = direct_chng_cnt+1
                    p.append((x, y))
                do_accepts(x+1, y, 3, dcc, p)
            if can_move(x, y, x-1, y, direct, 4, direct_chng_cnt):  # 4
                # dcc = direct == 4 and direct_chng_cnt or direct_chng_cnt+1
                p = path[:]
                if direct == 4:
                    dcc = direct_chng_cnt
                else:
                    dcc = direct_chng_cnt+1
                    p.append((x, y))
                do_accepts(x-1, y, 4, dcc, p)

        do_accepts(x1, y1, 0, 0, [])
        # from pprint import pprint
        # pprint(a)

        if a[x2][y2] > 3:
            return None

        res_path = res_path[0]
        res_path.append((x2, y2))
        # print res_path
        return res_path

    def fillStack(self):
        self.game.fillStack(self)

    def moveMove(self, ncards, to_stack, frames=-1, shadow=-1):
        assert ncards == 1 and to_stack in self.game.s.rows
        if to_stack.cards:
            self._dropPairMove(ncards, to_stack, frames=-1, shadow=shadow)
        else:
            Mahjongg_RowStack.moveMove(self, ncards, to_stack, frames=frames,
                                       shadow=shadow)

    def _dropPairMove(self, n, other_stack, frames=-1, shadow=-1):
        game = self.game
        old_state = game.enterState(game.S_FILL)
        f = game.s.foundations[0]
        game.updateStackMove(game.s.talon, 2 | 16)            # for undo
        if not game.demo:
            if game.app.opt.shisen_show_hint:
                self.drawArrow(other_stack, game.app.opt.timeouts['hint'])
            game.playSample("droppair", priority=200)
        #
        game.moveMove(n, self, f, frames=frames, shadow=shadow)
        game.moveMove(n, other_stack, f, frames=frames, shadow=shadow)
        self.fillStack()
        other_stack.fillStack()
        game.updateStackMove(game.s.talon, 1 | 16)            # for redo
        game.leaveState(old_state)

    def drawArrow(self, other_stack, sleep):
        game = self.game
        images = game.app.images
        cs = game.app.cardset
        path = self.acceptsCards(other_stack, [other_stack.cards[-1]])
        # print path
        x0, y0 = game.XMARGIN, game.YMARGIN
        cardw, cardh = images.CARDW, images.CARDH
        if cs.version >= 6:
            cardw -= cs.SHADOW_XOFFSET
            cardh -= cs.SHADOW_YOFFSET
        coords = []
        dx = game._delta_x
        xf, yf = images._xfactor, images._yfactor
        for x, y in path:
            if x == 0:
                coords.append(6)
            elif x == game.L[0]+1:
                coords.append(int(round(xf * (x0+cardw*(x-1)+10+dx))))
            else:
                coords.append(int(round(xf * (x0+cardw/2+cardw*(x-1)+dx))))
            if y == 0:
                coords.append(6)
            elif y == game.L[1]+1:
                coords.append(int(round(yf * (y0+cardh*(y-1)+6))))
            else:
                coords.append(int(round(yf * (y0+cardh/2+cardh*(y-1)))))
        # print coords
        # s1 = min(cardw/2, cardh/2, 30)
        # w = min(s1/3, 7)
        # s2 = min(w, 10)
        w = 7
        arrow = MfxCanvasLine(game.canvas,
                              coords,
                              {'width': w,
                               'fill': game.app.opt.colors['hintarrow'],
                               # 'arrow': 'last',
                               # 'arrowshape': (s1, s1, s2)
                               }
                              )
        game.canvas.update_idletasks()
        if TOOLKIT == "kivy":
            arrow.delete_deferred(sleep)
            return
        game.sleep(sleep)
        if arrow is not None:
            arrow.delete()
        game.canvas.update_idletasks()


class AbstractShisenGame(AbstractMahjonggGame):
    Hint_Class = NotShisen_Hint  # Shisen_Hint
    RowStack_Class = Shisen_RowStack

    # NCARDS = 144
    GRAVITY = True

    def createGame(self):
        cols, rows = self.L
        assert cols*rows == self.NCARDS

        # start layout
        l, s = Layout(self), self.s
        # dx, dy = 3, -3

        cs = self.app.cardset
        if cs.version >= 6:
            dx = l.XOFFSET
            dy = -l.YOFFSET
            d_x = cs.SHADOW_XOFFSET
            d_y = cs.SHADOW_YOFFSET
            self._delta_x, self._delta_y = dx, -dy
        else:
            dx = 3
            dy = -3
            d_x = 0
            d_y = 0
            self._delta_x, self._delta_y = 0, 0

        font = self.app.getFont("canvas_default")

        # width of self.texts.info
        # ti_width = Font(self.canvas, font).measure(_('Remaining'))
        ti_width = 80

        # set window size
        dxx, dyy = abs(dx), abs(dy)
        cardw, cardh = l.CW - d_x, l.CH - d_y
        w = l.XM+dxx + cols*cardw+d_x + l.XM+ti_width+l.XM
        h = l.YM+dyy + rows*cardh+d_y + l.YM
        self.setSize(w, h)
        self.XMARGIN = l.XM+dxx
        self.YMARGIN = l.YM+dyy

        # set game extras
        self.check_dist = l.CW*l.CW + l.CH*l.CH     # see _getClosestStack()

        #
        self.cols = [[] for i in range(cols)]
        cl = range(cols)
        if dx > 0:
            cl = reversed(cl)
        for col in cl:
            for row in range(rows):
                x = l.XM + dxx + col * cardw
                y = l.YM + dyy + row * cardh
                stack = self.RowStack_Class(x, y, self)
                stack.CARD_XOFFSET = 0
                stack.CARD_YOFFSET = 0
                stack.coln, stack.rown = col, row
                s.rows.append(stack)
                self.cols[col].append(stack)
        # from pprint import pprint
        # pprint(self.cols)

        # create other stacks
        y = l.YM + dyy
        ivx = -l.XS-self.canvas.xmargin
        if TOOLKIT == 'kivy':
            ivx = -1000
        s.foundations.append(Shisen_Foundation(ivx, y, self))
        self.texts.info = MfxCanvasText(self.canvas,
                                        self.width - l.XM - ti_width, y,
                                        anchor="nw", font=font)
        # the Talon is invisble
        s.talon = InitialDealTalonStack(-l.XS-self.canvas.xmargin,
                                        self.height-dyy, self)

        # Define stack groups
        l.defaultStackGroups()

    def fillStack(self, stack):
        if not self.GRAVITY:
            return
        to_stack = stack
        for from_stack in self.cols[stack.coln][stack.rown+1::-1]:
            if not from_stack.cards:
                continue
            self.moveMove(1, from_stack, to_stack, frames=0)
            to_stack = from_stack

    def updateText(self):
        if self.preview > 1 or self.texts.info is None:
            return

        if self.app.opt.shisen_show_matching:
            # find matching tiles
            stacks = self.s.rows
            f, i = 0, 0
            for r in stacks:
                i = i + 1
                if not r.cards:
                    continue
                for t in stacks[i:]:
                    if not t.cards:
                        continue
                    if r.acceptsCards(t, t.cards):
                        f += 1
            if f == 0:
                f = _('No Free\nMatching\nPairs')
            else:
                f = ungettext('%d Free\nMatching\nPair',
                              '%d Free\nMatching\nPairs',
                              f) % f
        else:
            f = ''

        t = len(self.s.foundations[0].cards)
        r1 = ungettext('%d\nTile\nRemoved\n\n',
                       '%d\nTiles\nRemoved\n\n',
                       t) % t
        r2 = ungettext('%d\nTile\nRemaining\n\n',
                       '%d\nTiles\nRemaining\n\n',
                       self.NCARDS - t) % (self.NCARDS - t)

        t = r1 + r2 + f
        self.texts.info.config(text=t)

    def drawHintArrow(self, from_stack, to_stack, ncards, sleep):
        from_stack.drawArrow(to_stack, sleep)

    def _shuffleHook(self, cards):
        return cards

    def canShuffle(self):
        return False


class Shisen_18x8(AbstractShisenGame):
    L = (18, 8)


class Shisen_14x6(AbstractShisenGame):
    L = (14, 6)
    NCARDS = 84


class Shisen_24x12(AbstractShisenGame):
    L = (24, 12)
    NCARDS = 288


class Shisen_18x8_NoGravity(AbstractShisenGame):
    L = (18, 8)
    GRAVITY = False


class Shisen_14x6_NoGravity(AbstractShisenGame):
    L = (14, 6)
    NCARDS = 84
    GRAVITY = False


class Shisen_24x12_NoGravity(AbstractShisenGame):
    L = (24, 12)
    NCARDS = 288
    GRAVITY = False


# ************************************************************************
# * Not Shisen-Sho
# ************************************************************************

class NotShisen_RowStack(Shisen_RowStack):
    def acceptsCards(self, from_stack, cards):
        if not self.game.cardsMatch(self.cards[0], cards[-1]):
            return 0
        if self.coln != from_stack.coln and self.rown != from_stack.rown:
            return 0
        return [(self.coln+1, self.rown+1),
                (from_stack.coln+1, from_stack.rown+1)]


class NotShisen_14x6(AbstractShisenGame):
    Hint_Class = NotShisen_Hint
    RowStack_Class = NotShisen_RowStack
    L = (14, 6)
    NCARDS = 84


class NotShisen_18x8(AbstractShisenGame):
    Hint_Class = NotShisen_Hint
    RowStack_Class = NotShisen_RowStack
    L = (18, 8)


class NotShisen_24x12(AbstractShisenGame):
    Hint_Class = NotShisen_Hint
    RowStack_Class = NotShisen_RowStack
    L = (24, 12)
    NCARDS = 288


# ************************************************************************
# * register a Shisen-Sho type game
# ************************************************************************

def r(id, gameclass, name, rules_filename="shisensho.html"):
    decks, ranks, trumps = comp_cardset(gameclass.NCARDS)
    gi = GameInfo(id, gameclass, name,
                  GI.GT_SHISEN_SHO, 4*decks, 0, GI.SL_MOSTLY_SKILL,
                  category=GI.GC_MAHJONGG, short_name=name,
                  suits=list(range(3)), ranks=list(range(ranks)),
                  trumps=list(range(trumps)),
                  si={"decks": decks, "ncards": gameclass.NCARDS})
    gi.ncards = gameclass.NCARDS
    gi.rules_filename = rules_filename
    registerGame(gi)
    return gi


r(11001, Shisen_14x6, "Shisen-Sho 14x6")
r(11002, Shisen_18x8, "Shisen-Sho 18x8")
r(11003, Shisen_24x12, "Shisen-Sho 24x12")
r(11004, Shisen_14x6_NoGravity, "Shisen-Sho (No Gravity) 14x6")
r(11005, Shisen_18x8_NoGravity, "Shisen-Sho (No Gravity) 18x8")
r(11006, Shisen_24x12_NoGravity, "Shisen-Sho (No Gravity) 24x12")
r(11011, NotShisen_14x6, "Not Shisen-Sho 14x6", "notshisensho.html")
r(11012, NotShisen_18x8, "Not Shisen-Sho 18x8", "notshisensho.html")
r(11013, NotShisen_24x12, "Not Shisen-Sho 24x12", "notshisensho.html")


del r
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

# This layouts converted from Kyodai Mahjongg game
# http://www.kyodai.com/index.en.html
# http://files.cyna.net/layouts.zip

from pysollib.games.mahjongg.mahjongg import r

# ************************************************************************
# * game definitions
# ************************************************************************

#
r(5200, "Another Round", ncards=140, layout="0aagaaihbhacfach" +
    "acjhdghdiaecaeea" +
    "egoehaeiaekaemhf" +
    "dhffhfhhfjhflaga" +
    "agcageogeaggogga" +
    "giogiagkogkagmag" +
    "ohhbhhdhhfhhhhhj" +
    "hhlhhnaiaaicoica" +
    "ieoieaigoigaiioi" +
    "iaikoikaimoimaio" +
    "hjbhjdhjfhjhhjjh" +
    "jlhjnakaakcakeak" +
    "gakiakkakmakoama" +
    "amcammamoaoaaoca" +
    "oeaogaoiaokaomao" +
    "ohpbhpdhpfhphhpj" +
    "hplhpnaqaaqcoqca" +
    "qeoqeaqgoqgaqioq" +
    "iaqkoqkaqmoqmaqo" +
    "hrbhrdhrfhrhhrjh" +
    "rlhrnasaascaseos" +
    "easgosgasiosiask" +
    "oskasmasohtdhtfh" +
    "thhtjhtlaucaueau" +
    "gouhauiaukaumhvg" +
    "hviawfawhawjhxha" +
    "ygayi")
r(5201, "Aqab's", layout="0caedagcaicccbcg" +
    "cckceabegcembgga" +
    "hdahjbigbkabkeck" +
    "gbkibkmbmabmccme" +
    "dmgcmibmkbmmboac" +
    "ocdoedogdoicokbo" +
    "mbqabqccqedqgcqi" +
    "bqkbqmbsabsecsgb" +
    "sibsmbugawdbwgaw" +
    "jcyabygcymcAcbAg" +
    "cAkcCedCgcCi")
#
r(5202, "Big Mountain", layout="0aaaaaqaeihfiagh" +
    "ogiagjhhhvhihhja" +
    "igoihaiiCiioijai" +
    "khjgvjhhjivjjhjk" +
    "akfokgakhCkhokia" +
    "kjCkjokkaklhlfvl" +
    "ghlhvlihljvlkhll" +
    "ameomfamgomhCmha" +
    "miomjCmjamkomlam" +
    "mhnehngvnghnivni" +
    "hnkvnkhnmaodaofo" +
    "ofaohoohCohaojoo" +
    "jCojaoloolaonhpe" +
    "hpgvpghpivpihpkv" +
    "pkhpmaqdaqfoqfaq" +
    "hoqhCqhaqjoqjCqj" +
    "aqloqlaqnhrehrgv" +
    "rghrivrihrkvrkhr" +
    "maseosfasgoshCsh" +
    "asiosjCsjaskosla" +
    "smhtfvtghthvtiht" +
    "jvtkhtlaufougauh" +
    "CuhouiaujCujouka" +
    "ulhvgvvhhvivvjhv" +
    "kawgowhawiCwiowj" +
    "awkhxhvxihxjayho" +
    "yiayjhziaAiaGaaG" +
    "q")
#
r(5203, "Bridge", layout="0aaaaacaaeaagaai" +
    "hbahbchbehbghbio" +
    "caoccoceocgociwd" +
    "avdcvdevdgwdioeb" +
    "oedoefoehvfahfcv" +
    "fchfevfehfgvfgvf" +
    "iogbagdogdagfogf" +
    "oghvhahhcvhchhev" +
    "hehhgvhgvhioibai" +
    "doidaifoifoihvja" +
    "hjcvjchjevjehjgv" +
    "jgvjiokbokdokfok" +
    "hvlavlcvlevlgvli" +
    "CmaCmivnavncvnev" +
    "ngvniooboodoofoo" +
    "hvpahpcvpchpevpe" +
    "hpgvpgvpioqbaqdo" +
    "qdaqfoqfoqhvrahr" +
    "cvrchrevrehrgvrg" +
    "vriosbasdosdasfo" +
    "sfoshvtahtcvtcht" +
    "evtehtgvtgvtioub" +
    "oudoufouhwvavvcv" +
    "vevvgwviowaowcow" +
    "eowgowihxahxchxe" +
    "hxghxiayaaycayea" +
    "ygayi")
r(5204, "Butterfly 2", layout="0aaeaagabcabiadb" +
    "adjhefvefaenafaa" +
    "feofeafgofgaflaf" +
    "phgdvgdwgfhghvgh" +
    "ahaaheoheahgohga" +
    "hkahqhifvifcinbj" +
    "bbjjajqblcbliblq" +
    "bmocndcnhcnmapbb" +
    "pdapfbphapjbplap" +
    "nhqbpqdiqfpqhiqj" +
    "pqlhqnarbbrdarfb" +
    "rharjbrlarnctdct" +
    "hctmbuobvcbvibvq" +
    "bxbbxjaxqhyfvyfc" +
    "ynazaazeozeazgoz" +
    "gazkazqhAdvAdwAf" +
    "hAhvAhaBaaBeoBea" +
    "BgoBgaBlaBphCfvC" +
    "faCnaDbaDjaFcaFi" +
    "aGeaGg")
r(5205, "ChessMania", layout="0aaaaacaaeaagaaj" +
    "aalaanaapacaacgb" +
    "cmaeaaegaejaelae" +
    "naepaibbidaifbih" +
    "aijbilainbipbkba" +
    "kdbkfakhbkjaklbk" +
    "nakpambbmdamfbmh" +
    "amjbmlamnbmponfo" +
    "nhonjonlbobaodbo" +
    "faohbojaolbonaop" +
    "opfppioplaqbbqda" +
    "qfbqhaqjbqlaqnbq" +
    "porforlbsbasdbsf" +
    "ashbsjaslbsnaspa" +
    "ubbudaufbuhaujbu" +
    "launbupbwbawdbwf" +
    "awhbwjawlbwnawpa" +
    "BaaBcaBgaBjaBlaB" +
    "paDabDdaDgaDjbDm" +
    "aDpaFaaFeaFgaFja" +
    "FnaFp")
r(5206, "Cross", layout="0baebagbaiaccdce" +
    "bcgdciackaeacecd" +
    "eebegdeicekaemcg" +
    "adgcdgebggdgidgk" +
    "cgmbiabicaiebiga" +
    "iibikbimbkabkcak" +
    "ebkgakibkkbkmcma" +
    "dmcdmebmgdmidmkc" +
    "mmaoacocdoebogdo" +
    "icokaomaqcdqebqg" +
    "dqiaqkbsebsgbsi")
r(5207, "Cupido's Heart", layout="0aadaalbbfbbjcch" +
    "addadlbefcehbejc" +
    "ghdhfdidcihdjbdj" +
    "jckhdkldlacmhdmn" +
    "dnbdodcohdopeqed" +
    "qqdsddspdtbdundv" +
    "adwldxbdxjdyddyh" +
    "dzfcAhaCecChaCkb" +
    "EfcEhbEjcGh")
r(5208, "Diamond", ncards=140, layout="0aaiaakacgbcibck" +
    "acmaeebegceicekb" +
    "emaeoagcbgecggdg" +
    "idgkcgmbgoagqaia" +
    "bicciedigeiieikd" +
    "imciobiqaisakabk" +
    "cckedkgekiekkdkm" +
    "ckobkqaksamcbmec" +
    "mgdmidmkcmmbmoam" +
    "qaoebogcoicokbom" +
    "aooaqgbqibqkaqma" +
    "siask")
r(5209, "Dragon 2", layout="0bafbbdobeobgbbh" +
    "bcfbcmbdkodlodnb" +
    "dobecaegbemofcbg" +
    "abgcbghbgjagloha" +
    "vhbohcbiabicbijb" +
    "ilojbbjhojjojlbk" +
    "bbkfokhbkjvkjbkl" +
    "vklolbolfblholjo" +
    "llbmbcmdbmfbmjbm" +
    "lboioojbokaoohpo" +
    "bqhbqjaqobrforho" +
    "rjasdosfbshvshbs" +
    "jvsjbslbsnhtdbtf" +
    "othotjaubaudbuhb" +
    "ujbwgbwkbwmbydoy" +
    "ebyfbymayohzobAc" +
    "aAobBjbCdoCebCfo" +
    "CgbCh")
r(5210, "Empty Pyramids", layout="0aaiabghbiabkacc" +
    "acehcgocihckacma" +
    "coadghdiadkaeiah" +
    "iaighiiaikajehjg" +
    "ojihjkajmakchkeo" +
    "kgvkiokkhkmakoal" +
    "ahlcolevlgClivlk" +
    "olmhloalqhmaamch" +
    "meomgvmiomkhmmam" +
    "ohmqonahncanehng" +
    "onihnkanmhnoonqv" +
    "oaoochoeaoghoiao" +
    "khomooovoqCpavpc" +
    "opehpgapiopihpko" +
    "pmvpoCpqvqaoqchq" +
    "eaqghqiaqkhqmoqo" +
    "vqqorahrcarehrgo" +
    "rihrkarmhroorqhs" +
    "aaschseosgvsiosk" +
    "hsmasohsqatahtco" +
    "tevtgCtivtkotmht" +
    "oatqauchueougvui" +
    "oukhumauoavehvgo" +
    "vihvkavmawghwiaw" +
    "kaxiaAiaBghBiaBk" +
    "aCcaCehCgoCihCka" +
    "CmaCoaDghDiaDkaE" +
    "i")
r(5211, "Fish face", layout="0bajbciocjbckvdj" +
    "behoeibejoekbelc" +
    "ggcgmchichkcifci" +
    "ncjhcjlckebkjcko" +
    "clgclmcmebmiomjb" +
    "mkcmocnccnqcoebo" +
    "ioojbokcoobpbcpg" +
    "cpmbprcqebqjcqoa" +
    "racrhcrlarsbsfbs" +
    "nbtiotjbtkbugbum" +
    "bwhbwlbyibykcAjc" +
    "BhcBlbDgbDmaFfaF" +
    "n")
r(5212, "Floating City", layout="0oagoaiocdocfoch" +
    "ocjoclocphdahdch" +
    "dmhdoaeboebaedae" +
    "faehaejaelaenoen" +
    "hfahfcvfchfmvfmh" +
    "foagbagnahdvheah" +
    "fahhahjvhkahlaib" +
    "ainvjgvjiakbCkha" +
    "knhlfhlhhljambam" +
    "damfomgamhCmhomi" +
    "amjamlamnomphnfh" +
    "nhhnjjoaaobCobao" +
    "dCodaofCofoogaoh" +
    "CohooiaojCojaolC" +
    "olaonConjooCopoo" +
    "qhpfhphhpjaqbaqd" +
    "aqfoqgaqhCqhoqia" +
    "qjaqlaqnoqphrfhr" +
    "hhrjasbCshasnvtg" +
    "vtiaubaunavdvvea" +
    "vfavhavjvvkavlaw" +
    "bawnhxahxcvxchxm" +
    "vxmhxoayboybayda" +
    "yfayhayjaylaynoy" +
    "nhzahzchzmhzooAd" +
    "oAfoAhoAjoAloApo" +
    "CgoCi")
# r(5213, "Flowers 2", layout="0aaiacgbciackadc" +
#    "adoaeiafabfcafea" +
#    "fmbfoafqahcahoai" +
#    "haijhjiakfakhakj" +
#    "aklhlghlihlkamda" +
#    "mfamhomhamjomjam" +
#    "lamnhnehnghnivni" +
#    "hnkhnmaobaodaofo" +
#    "ofaohoohaojoojao" +
#    "loolaonaophpchpe" +
#    "hpgvpghpivpihpkv" +
#    "pkhpmhpoaqbaqdoq" +
#    "daqfoqfaqhoqhCqh" +
#    "aqjoqjCqjaqloqla" +
#    "qnoqnaqphrchrehr" +
#    "gvrghrivrihrkvrk" +
#    "hrmhroasbasdasfo" +
#    "sfashoshasjosjas" +
#    "loslasnasphtehtg" +
#    "htivtihtkhtmauda" +
#    "ufauhouhaujoujau" +
#    "launhvghvihvkawf" +
#    "awhawjawlhxiayha" +
#    "yjazcazoaBabBcaB" +
#    "eaBmbBoaBqaCiaDc" +
#    "aDoaEgbEiaEkaGi")
# r(5214, "Full Vision 3", layout="0aaeaagaaihbehbi" +
#    "acbhccacdacfhcga" +
#    "chacjhckaclacnhc" +
#    "oacpaeahebaecaee" +
#    "aegaeiaekhelaema" +
#    "gbhgcagdagfhggag" +
#    "hagjhgkaglagnhgo" +
#    "agphhehhiaieaiga" +
#    "iiainhioaiphjgak" +
#    "eakgakiaknhkoakp" +
#    "hlehliambhmcamda" +
#    "mfhmgamhamjhmkam" +
#    "lamnhmoampaoahob" +
#    "aocaoehofaogaoia" +
#    "okholaomaqbhqcaq" +
#    "daqfhqgaqhaqjhqk" +
#    "aqlaqnhqoaqphreh" +
#    "riaseasgasiasnhs" +
#    "oasphtgaueaugaui" +
#    "aunhuoauphvehvia" +
#    "wbhwcawdawfhwgaw" +
#    "hawjhwkawlawnhwo" +
#    "awpayahybaycayea" +
#    "ygayiaykhylaymaA" +
#    "bhAcaAdaAfhAgaAh" +
#    "aAjhAkaAlaAnhAoa" +
#    "AphBehBiaCeaCgaC" +
#    "i")
r(5215, "Hidden Words", layout="0haahachaehaghal" +
    "abaabcobdabeabga" +
    "bjablbbnabphcahc" +
    "chceocghchhckhcq" +
    "adgadmodohefheih" +
    "emheoafgafjofjaf" +
    "lafnafphgfogghgk" +
    "hgmhgohichiehikh" +
    "inajaojaajcojdaj" +
    "eajghjhajjajlajn" +
    "ajphkbhkfokjhklh" +
    "kpalaalghlialjal" +
    "mombhmchmehmnana" +
    "ancanebnganjanla" +
    "nnbnphochoiholhq" +
    "chqfhqihqkaraarc" +
    "arearjhschshhslh" +
    "snhspatgatjatlat" +
    "natphuchuhhunava" +
    "avcaveavjhvkhwdh" +
    "wfhxihxmhxqayahy" +
    "baycayeaygayjayl" +
    "aynhyoayphzfhzka" +
    "AabAdaAghAhaAjaA" +
    "maAphBlhBnhBqaCa" +
    "hCbaCghCiaCjaCph" +
    "DfhDp")
r(5216, "Hovercraft", layout="0aadaafaahaajjbg" +
    "dccdceacgdcidckj" +
    "dgaedaefaehaejhf" +
    "gagfpggaghhhgaig" +
    "ajajjgajmhkaakgh" +
    "kmalaolaalmolmhm" +
    "avmaemghmmvmmana" +
    "onaCnaenceneenie" +
    "nkanmonmCnmhoavo" +
    "aeoghomvomapaopa" +
    "apmopmhqaaqghqma" +
    "rajrgarmasghtgau" +
    "fpugauhhvgawdawf" +
    "awhawjjxgdycdyea" +
    "ygdyidykjzgaAdaA" +
    "faAhaAj")
r(5217, "Hurdles", layout="0aaaaacaaeaagaai" +
    "aakaamaaohbahbch" +
    "behbghbihbkhbmhb" +
    "oacaocaaccoccace" +
    "oceacgocgaciocia" +
    "ckockacmocmacooc" +
    "ohdahdchdehdghdi" +
    "hdkhdmhdoaeaaeca" +
    "eeaegaeiaekaemae" +
    "oagaagcageaggagi" +
    "agkagmagohhahhch" +
    "hehhghhihhkhhmhh" +
    "oaiaoiaaicoicaie" +
    "oieaigoigaiioiia" +
    "ikoikaimoimaiooi" +
    "ohjahjchjehjghji" +
    "hjkhjmhjoakaakca" +
    "keakgakiakkakmak" +
    "oamaamcameamgami" +
    "amkammamohnahnch" +
    "nehnghnihnkhnmhn" +
    "oaoaooaaocoocaoe" +
    "ooeaogoogaoiooia" +
    "okookaomoomaoooo" +
    "ohpahpchpehpghpi" +
    "hpkhpmhpoaqaaqca" +
    "qeaqgaqiaqkaqmaq" +
    "o")
r(5218, "Tornado", layout="0babaadaambaoabi" +
    "begbekofdbfeoffa" +
    "fiofioflbfmofnbg" +
    "chgibgoahaahiohi" +
    "ahqhibhiihipajba" +
    "jeijfajgvjgajioj" +
    "iajkvjkijlajmajp" +
    "hkbhkihkpalcalia" +
    "lohmchmoandinean" +
    "fanianlinmannapb" +
    "ipdapevpeipfapga" +
    "pkiplapmvpmipnap" +
    "pardirearfariarl" +
    "irmarnhschsoatca" +
    "tiatohubhuihupav" +
    "baveivfavgvvgavi" +
    "oviavkvvkivlavma" +
    "vphwbhwihwpaxaax" +
    "ioxiaxqbychyibyo" +
    "ozdbzeozfaziozio" +
    "zlbzmoznbAgbAkaD" +
    "ibEbaEdaEmbEo")
#
r(5219, "IloveU", layout="0caddafcahdaldan" +
    "dapdcbcciceacejc" +
    "gacgkdibcilckdck" +
    "mcmecmndngdnpcoe" +
    "concqdcqmdsbcslc" +
    "uacukcwacwjdybcy" +
    "idzldzndzpcAddAf" +
    "cAhdBpdDldDndDp")
r(5220, "Inazuma", layout="0caaaaocaqcccacm" +
    "ccoacqceebeiaekc" +
    "emaeoagacggcgkag" +
    "mciaaicciibimaka" +
    "ckcakeckkamccmea" +
    "mgcmmaoecogaoico" +
    "ocqaaqgdqiaqkcqq" +
    "cscasicskasmcuea" +
    "ukcumauocwgawmcw" +
    "oawqbyecyiayocyq" +
    "aAecAgcAkaAqaCcc" +
    "CeaCgbCicCmaEacE" +
    "caEecEocGaaGccGq")
r(5221, "JPs", layout="0baabakbbmbcabck" +
    "bcobdmbdqbeabeob" +
    "fqbgabhobhqbiabi" +
    "cbiebigbiibikbim" +
    "bjobkabkcbkebkgb" +
    "kibkkbkmamqbqabq" +
    "cbqebqgbqibqkbqm" +
    "bqobqqbsabscbseb" +
    "sgbsibskbsmbsobs" +
    "qbuabuhbujbwabwh" +
    "bwjaxqbyabyhbyjb" +
    "AabAcbAgbAibCabC" +
    "cbCebCgbCibEabEc" +
    "bEebEgbEibGe")
r(5222, "Japan", ncards=96, layout="0baabacbaebagbai" +
    "bcaacebcibeaaeeb" +
    "eibgabgcbgebggbg" +
    "iahoajkajoalgali" +
    "alkhllalmaloangb" +
    "nibnkanmapebpgbp" +
    "iapkapmbrebrgari" +
    "arkatehtfatgatia" +
    "vaavcavebwibwoax" +
    "aaxcbxmbyiaykaza" +
    "bAgbAibAkbAmbAob" +
    "CiaCkbDmbEibEo")
r(5223, "Krebs", layout="0aaaaacaaeaagbai" +
    "balaanaapaaraata" +
    "caactaeaaetagaag" +
    "taiaCikaitvjkaka" +
    "CkjokkCklaktvljh" +
    "lkvllamaCmiomjam" +
    "kCmkomlCmmamtvni" +
    "hnjvnkhnlvnmaoaC" +
    "ohooiaojCojookao" +
    "lColoomConaotvph" +
    "hpivpjhpkvplhpmv" +
    "pnbqaCqgoqhaqiCq" +
    "ioqjaqkCqkoqlaqm" +
    "CqmoqnCqobqtvrhh" +
    "rivrjhrkvrlhrmvr" +
    "nCshosiasjCsjosk" +
    "aslCslosmCsnbtav" +
    "tihtjvtkhtlvtmbt" +
    "tCuioujaukCukoul" +
    "Cumavavvjhvkvvla" +
    "vtCwjowkCwlaxavx" +
    "kaxtCykazaaztaBa" +
    "aBtaDaaDtaFaaFta" +
    "HaaHcaHeaHgdHidH" +
    "laHnaHpaHraHt")
r(5224, "Kumo", layout="0caadaccaecagbai" +
    "bamdaqdcacccaceb" +
    "cgbckdcoceaaecce" +
    "ebeidembeqcgabgc" +
    "cggdgkbgobiabied" +
    "iibimbiqbkcdkgck" +
    "kbkockqbmadmebmi" +
    "cmmamocmqdocbogb" +
    "okaomcoodoqdqabq" +
    "ebqicqkcqmdqocqq")
r(5225, "Kyodai 14", layout="0aaiachhciacjodi" +
    "aefhegaehheiveia" +
    "ejhekaelofhCfiof" +
    "jagchgdagehgfagg" +
    "hghagivgihgjagkh" +
    "glagmhgnagoohiai" +
    "bhicaidaihhiiaij" +
    "ainhioaipakcbkgo" +
    "khbkivkiokjbkkak" +
    "ohlchloamcbmfbml" +
    "amoaoahobaochoda" +
    "oeooehofvofaogoo" +
    "ghohvohaoiooihoj" +
    "vojaokookholvola" +
    "omoomhonaoohopao" +
    "qaqcbqfbqlaqohrc" +
    "hroascbsgoshbsiv" +
    "siosjbskasoaubhu" +
    "caudauhhuiaujaun" +
    "huoaupoviawchwda" +
    "wehwfawghwhawivw" +
    "ihwjawkhwlawmhwn" +
    "awooxhCxioxjayfh" +
    "ygayhhyivyiayjhy" +
    "kayloziaAhhAiaAj" +
    "aCi")
r(5226, "Kyodai 17", layout="0daacaccaecagcai" +
    "cakdamccaccgccmc" +
    "eacegcemcgacgccg" +
    "ecggcgicgkcgmcia" +
    "digcimckadkgckmc" +
    "macmccmecmgcmicm" +
    "kcmmcoacogcomcqa" +
    "cqgcqmdsacsccsec" +
    "sgcsicskdsm")
#
r(5227, "Kyodai 18", layout="0daidchdcjdegdek" +
    "dgfdgldiedimdkda" +
    "kidkndmcamhamjdm" +
    "odobaogaoiaokdop" +
    "dqaaqfaqhaqjaqld" +
    "qqdsbasgasiaskds" +
    "pducauhaujduodwd" +
    "awidwndyedymdAfd" +
    "AldCgdCkdEhdEjdG" +
    "i")
r(5228, "Kyodai 20", layout="0aaeaagaaiaakaam" +
    "aaohbjacdaciacka" +
    "cpaecbehbelaeqag" +
    "baggagmagraiaaif" +
    "higaihoihhiiviia" +
    "ijoijCijhikvikai" +
    "loilhimainaisaka" +
    "akebkjakoaksamaa" +
    "mdcmhamjcmlampam" +
    "saoahobaocoochod" +
    "vodaoeooeCoehofv" +
    "ofaogooghohaoiko" +
    "jaokholaomoomhon" +
    "vonaoooooCoohopv" +
    "opaoqooqhoraosaq" +
    "aaqdcqhaqjcqlaqp" +
    "aqsasaasebsjasoa" +
    "ssauaaufhugauhou" +
    "hhuivuiaujoujCuj" +
    "hukvukauloulhuma" +
    "unausawbawgawmaw" +
    "raycbyhbylayqaAd" +
    "aAiaAkaAphBjaCea" +
    "CgaCiaCkaCmaCo")
#
r(5229, "Kyodai 23", layout="0aaehbeacdoceacf" +
    "hdevdeaecaeeoeea" +
    "eghfdvfehffagaag" +
    "cageogeaggagihhb" +
    "hhdhhfhhhaiaaico" +
    "icaieoieaigoigai" +
    "ihjbhjdvjdhjfvjf" +
    "hjhakaakcokcakeo" +
    "keCkeakgokgakihl" +
    "bhldvldhlfvlfhlh" +
    "amaamcomcameomea" +
    "mgomgamihnbhndhn" +
    "fhnhaoaaocaoeooe" +
    "aogaoihpdhpfaqaa" +
    "qcaqeoqeaqgaqihr" +
    "bhrdhrfhrhasaasc" +
    "oscaseoseasgosga" +
    "sihtbhtdvtdhtfvt" +
    "fhthauaaucoucaue" +
    "oueCueaugougauih" +
    "vbhvdvvdhvfvvfhv" +
    "hawaawcowcaweowe" +
    "awgowgawihxbhxdh" +
    "xfhxhayaaycayeoy" +
    "eaygayihzdvzehzf" +
    "aAcaAeoAeaAghBev" +
    "BeaCdoCeaCfhDeaE" +
    "e")
#
r(5230, "Kyodai 24", layout="0aaaiabaacaaejaf" +
    "aagaaiiajaakvbci" +
    "bdCbfibhvbiacaic" +
    "baccacevceicfacg" +
    "vcgaciicjackvdci" +
    "ddCddCdfidhCdhvd" +
    "iaeaiebaecaeevee" +
    "iefaegvegaeiieja" +
    "ekvfcifdCfdifhCf" +
    "hvfiagaigbagcage" +
    "vgeigfaggvggagii" +
    "gjagkvhcihdChdih" +
    "hChhvhiaiaiibaic" +
    "aievieiifaigviga" +
    "iiiijaikvjcijdCj" +
    "dCjfijhCjhvjiaka" +
    "ikbakcakevkeikfa" +
    "kgvkgakiikjakkvl" +
    "cildClfilhvliama" +
    "imbamcamejmfamga" +
    "miimjamk")
r(5231, "Kyodai 25", layout="0cagbaicakbcgbck" +
    "odgodkbegbekcggc" +
    "gkbieoifbigciibi" +
    "koilbimbkiolicma" +
    "bmicmqboabogdoib" +
    "okboqcqabqcoqdbq" +
    "edqgdqkbqmoqnbqo" +
    "cqqbsabsgdsibskb" +
    "sqcuabuicuqovibw" +
    "ibyeoyfbygcyibyk" +
    "oylbymcAgcAkbCgb" +
    "CkoDgoDkbEgbEkcG" +
    "gbGicGk")
#
r(5232, "Kyodai 26", layout="0aahhbhacgacihdg" +
    "hdiaefaehaejhffh" +
    "fhhfjageaggagiag" +
    "khhehhghhihhkaid" +
    "aifaihaijailhjdh" +
    "jhhjlakcakeakgak" +
    "iakkakmhlchlehlg" +
    "hlihlkhlmambamda" +
    "mfamhamjamlamnhn" +
    "bhnfhnhhnjhnnaoa" +
    "aocaoeaogaoiaoka" +
    "omaoohpahpchpehp" +
    "ghpihpkhpmhpoaqa" +
    "aqcaqeaqgaqiaqka" +
    "qmaqohrahrchrehr" +
    "ghrihrkhrmhroasa" +
    "ascaseasgasiaska" +
    "smasohtbhtfhthht" +
    "jhtnaubaudaufauh" +
    "aujaulaunhvchveh" +
    "vghvihvkhvmawcaw" +
    "eawgawiawkawmhxd" +
    "hxhhxlaydayfayha" +
    "yjaylhzehzghzihz" +
    "kaAeaAgaAiaAkhBf" +
    "hBhhBjaCfaChaCjh" +
    "DghDiaEgaEihFhaG" +
    "h")
#
r(5233, "Kyodai 27", layout="0aagacfhcgachaee" +
    "hefaegoeghehaeiv" +
    "fgagdhgeagfogfhg" +
    "gCggaghoghhgiagj" +
    "vhfvhhaichidaieo" +
    "iehifCifaigoighi" +
    "hCihaiioiihijaik" +
    "vjevjgvjiakbhkca" +
    "kdokdhkeCkeakfok" +
    "fhkgCkgakhokhhki" +
    "Ckiakjokjhkkaklv" +
    "ldvlfvlhvljamahm" +
    "bamcomchmdameome" +
    "hmfCmfamgomghmhC" +
    "mhamiomihmjamkom" +
    "khmlammvndvnfvnh" +
    "vnjaobhocaodoodh" +
    "oeCoeaofoofhogCo" +
    "gaohoohhoiCoiaoj" +
    "oojhokaolvpevpgv" +
    "piaqchqdaqeoqehq" +
    "fCqfaqgoqghqhCqh" +
    "aqioqihqjaqkvrfv" +
    "rhasdhseasfosfhs" +
    "gCsgashoshhsiasj" +
    "vtgauehufaugough" +
    "uhauiawfhwgawhay" +
    "g")
#
r(5234, "Kyodai 28", layout="0baibbgbbkbcebci" +
    "bcmbdcbdobeabeib" +
    "eqbgacggvghcgiCg" +
    "ivgjcgkbgqbiacif" +
    "ciicilbiqbkackea" +
    "khakjckmbkqhlhhl" +
    "jbmacmdamgamiomi" +
    "amkcmnbmqhnhhnjb" +
    "oacoeaohaojcombo" +
    "qbqacqfcqicqlbqq" +
    "bsacsgvshcsiCsiv" +
    "sjcskbsqbuabuibu" +
    "qbvcbvobwebwibwm" +
    "bxgbxkbyi")
#
r(5235, "Kyodai 41", layout="0CaeCagCaivbevbg" +
    "vbiCcdoceocgociC" +
    "cjvddhdevdfhdgCd" +
    "gvdhhdivdjCecaee" +
    "oeeCeeaegoegaeio" +
    "eiCeiCekCfavfbof" +
    "chfdvfdhffvffCfg" +
    "hfhvfhhfjvfjofkv" +
    "flCfmCgdageogeag" +
    "goggagiogiCgjCha" +
    "vhbohchhdvhdhhfv" +
    "hfChghhhvhhhhjvh" +
    "johkvhlChmCicaie" +
    "oieCieaigoigaiio" +
    "iiCiiCikCjavjboj" +
    "chjdvjdhjfvjfCjg" +
    "hjhvjhhjjvjjojkv" +
    "jlCjmCkdakeokeak" +
    "gokgakiokiCkjCla" +
    "vlbolchldvldhlfv" +
    "lfClghlhvlhhljvl" +
    "jolkvllClmCmcame" +
    "omeCmeamgomgamio" +
    "miCmiCmkvndhnevn" +
    "fhngCngvnhhnivnj" +
    "CodooeoogooiCojv" +
    "pevpgvpiCqeCqgCq" +
    "i")
#
r(5236, "Kyodai 42", layout="0oaboadCagoajoal" +
    "hbahbcvbchbeobfv" +
    "bgobhhbihbkvbkhb" +
    "macbacdacjaclhdb" +
    "hddodevdfCdgvdho" +
    "dihdjhdlaecaekhf" +
    "chfeoffvfgofhhfi" +
    "hfkagdCggagjhhdh" +
    "hfhhhhhjaieaiihj" +
    "ehjghjiakfCkgakh" +
    "hlfvlghlhCmfamgo" +
    "mgCmhhnfvnghnhao" +
    "gCoghpfhphCqcvqd" +
    "oqeCqeaqgoqgoqiC" +
    "qivqjCqkhrfhrhas" +
    "gCsghtfvtghthCuf" +
    "augougCuhhvfvvgh" +
    "vhawfCwgawhhxehx" +
    "ghxiayeayihzdhzf" +
    "hzhhzjaAdCAgaAjh" +
    "BchBeoBfvBgoBhhB" +
    "ihBkaCcaCkhDbhDd" +
    "oDevDfCDgvDhoDih" +
    "DjhDlaEbaEdaEjaE" +
    "lhFahFcvFchFeoFf" +
    "vFgoFhhFihFkvFkh" +
    "FmoGboGdCGgoGjoG" +
    "l")
r(5237, "Lattice", layout="0aaiacebciacmaec" +
    "beeaegbeiaekbema" +
    "eoagecgiagmaicbi" +
    "eaigciiaikbimaio" +
    "akeckiakmamcbmeb" +
    "mgdmibmkbmmamobo" +
    "eeoibomaqabqccqe" +
    "eqgdqieqkcqmbqoa" +
    "qqbseesibsmaucbu" +
    "ebugduibukbumauo" +
    "awecwiawmaycbyea" +
    "ygcyiaykbymayoaA" +
    "ecAiaAmaCcbCeaCg" +
    "bCiaCkbCmaCoaEeb" +
    "EiaEmaGi")
#
# r(5238, "Leo", layout="0aapabiablhbphcf" +
#    "acghchhclacnocpa" +
#    "djodladpvdpheeae" +
#    "fheiaelvelhepCep" +
#    "ofihflCflafnofph" +
#    "gdagevgiagjoglag" +
#    "pvgphhiChiahlvhl" +
#    "hhpChphicaidoiih" +
#    "ilCilainoipvjiaj" +
#    "jojlajpvjpbkabkc" +
#    "hkiCkiaklvklhkpC" +
#    "kpolbolihllalnol" +
#    "pbmabmcvmiamjoml" +
#    "ampvmphnianlhnpo" +
#    "oiholaonoophpfap" +
#    "hapjappaqfhqiaql" +
#    "hqphrdarnasehsqh" +
#    "tcatpaudbumhuphv" +
#    "bcvgavqawccwlhwq" +
#    "hxbcxjaxpayccylh" +
#    "yphzbczgazqaAdbA" +
#    "mhAqhBcaBpaCehCp" +
#    "hDeaDgaDohEgaEia" +
#    "EmhEohFiaFkhFmhG" +
#    "k")
#
r(5239, "Loose Ends", layout="0aaaoabaaioapaaq" +
    "hbahbihbqacbocca" +
    "chociacjocoacphd" +
    "bhdivdihdpaecoed" +
    "aegaeioeiaekoena" +
    "eohfchfivfihfoag" +
    "dogeaghogiagjogm" +
    "agnhhdhhivhihhna" +
    "ieoifaiioiioilai" +
    "mhjfhjihjlakgokg" +
    "akiakkokkhlholih" +
    "ljamahmbamcomchm" +
    "dvmdameomehmfvmf" +
    "amgvmhamiCmivmja" +
    "mkhmlvmlammommhm" +
    "nvmnamoomohmpamq" +
    "hnhonihnjaogooga" +
    "oiaokookhpfhpihp" +
    "laqeoqfaqioqioql" +
    "aqmhrdhrivrihrna" +
    "sdoseashosiasjos" +
    "masnhtchtivtihto" +
    "aucoudaugauiouia" +
    "ukounauohvbhvivv" +
    "ihvpawbowcawhowi" +
    "awjowoawphxahxih" +
    "xqayaoybayioypay" +
    "q")
r(5240, "Mini Traditional", ncards=48, layout="0aaeacdacfhdeaec" +
    "aeeoeeaeghfdvfeh" +
    "ffagbagdogeagfag" +
    "hhhchhevhehhgaia" +
    "aicoicaieoieaigo" +
    "igaiihjchjevjehj" +
    "gakbakdokeakfakh" +
    "hldvlehlfamcameo" +
    "meamghneaodaofaq" +
    "e")
r(5241, "Mini-Layout", ncards=8, layout="0aabaadacahcbhcd" +
    "aceaebaed")
r(5242, "Mission Impossible", layout="0baabamaapccaccm" +
    "acpdeacecbeeaegb" +
    "eicekdemaepcgacg" +
    "magpbiabimaipakp" +
    "bmacmcdmeemgdmic" +
    "mkbmmampcocaopdq" +
    "eaqpcscaspbuacuc" +
    "dueeugduicukbuma" +
    "upawpbyabycbyeby" +
    "gbyibykbymaypcAa" +
    "cAgaApdCadCgaCpe" +
    "EaaEp")
#
r(5243, "Multi X", layout="0aaaaaiaaqhbbhbh" +
    "hbjhbpoccocgocko" +
    "covddvdfvdlvdnce" +
    "eCeecemCemvfdvff" +
    "vflvfnogcoggogko" +
    "gohhbhhhhhjhhpai" +
    "aaiiaiqhjbojcvjd" +
    "Cjevjfojghjhojih" +
    "jjojkvjlCjmvjnoj" +
    "ohjpakaakiakqhlb" +
    "hlhhljhlpomcomgo" +
    "mkomovndvnfvnlvn" +
    "ncoeCoecomComvpd" +
    "vpfvplvpnoqcoqgo" +
    "qkoqohrbhrhhrjhr" +
    "pasaasiasqhtbotc" +
    "vtdCtevtfotghtho" +
    "tihtjotkvtlCtmvt" +
    "notohtpauaauiauq" +
    "hvbhvhhvjhvpowco" +
    "wgowkowovxdvxfvx" +
    "lvxncyeCyecymCym" +
    "vzdvzfvzlvznoAco" +
    "AgoAkoAohBbhBhhB" +
    "jhBpaCaaCiaCq")
# r(5244, "New Layout 2", layout="0CabCadCafacapca" +
#    "hccvccacepcehcgv" +
#    "cgheaveaaecpeche" +
#    "eveeaegpegCfaCfc" +
#    "CfeCfgagapgahgcv" +
#    "gcagepgehggvggCh" +
#    "aChcCheChghiavia" +
#    "aicpichievieaigp" +
#    "igakaqkahkcwkcak" +
#    "eqkehkgwkghmawma" +
#    "amcqmchmewmeamgq" +
#    "mgaoaqoahocwocao" +
#    "eqoehogwoghqavqa" +
#    "aqcpqchqevqeaqgp" +
#    "qgCraCrcCreCrgas" +
#    "apsahscvscasepse" +
#    "hsgvsgCtaCtcCteC" +
#    "tghuavuaaucpuchu" +
#    "evueaugpugawapwa" +
#    "hwcvwcawepwehwgv" +
#    "wgCybCydCyf")
r(5245, "Okie's Nitemare", layout="0aaoaaqbbeabmhbp" +
    "acoacqcddbdgadmh" +
    "dpaeoaeqbfccffaf" +
    "mhfpagoagqbhehhp" +
    "aiiaioaiqhjihjqa" +
    "kiakqalohlqammhm" +
    "oamqandankhnmano" +
    "onohnqaobaoihoka" +
    "ompomhooaoqapghp" +
    "iapkopkhpmapoopo" +
    "hpqaqabqcoqdbqeo" +
    "qfhqgaqioqihqkvq" +
    "kCqlaqmpqmhqoaqq" +
    "arghriarkorkhrma" +
    "roorohrqasbasihs" +
    "kasmpsmhsoasqatd" +
    "atkhtmatootohtqa" +
    "umhuoauqavohvqaw" +
    "iawqhxihxqbyeayi" +
    "ayoayqhzpbAccAfa" +
    "AoaAqaBmhBpcCdbC" +
    "gaCoaCqaDmhDpbEe" +
    "aEoaEqaFmhFpaGoa" +
    "Gq")
r(5246, "Orbital", ncards=84, layout="0dafdahdajdchceh" +
    "bghbihbkhclablfb" +
    "ljclocnabncbnebn" +
    "kbnmcnocpabpfbpj" +
    "cpobqhbshbuhcwhd" +
    "yhdAfdAhdAj")
r(5247, "Owl", layout="0baebagbaibakbam" +
    "bcdbcncecbejbeoc" +
    "gbbghcgjbglbgpci" +
    "cbijbiobkdbkncla" +
    "blpbmebmmcnbanpc" +
    "odaofbohbojbolbo" +
    "nhopipfappoppcqd" +
    "aqfbqhbqjbqlbqnh" +
    "qpcrbarpbsebsmct" +
    "abtpbudbuncwcbwj" +
    "bwocybbyhcyjbylb" +
    "ypcAcbAjbAobCdbC" +
    "nbEebEgbEibEkbEm")
r(5248, "Pantheon", layout="0baebcebdgbdqbee" +
    "aeiaekaemaeobfcb" +
    "fgbfqbgebhcbiebj" +
    "cojdbjgbjqbkabke" +
    "akiakkakmakoolbb" +
    "lcoldblgblqbmabm" +
    "eonbbncboaoodboe" +
    "opbbpcbpgbpqbqab" +
    "qeaqiaqkaqmaqoor" +
    "bbrcbrgbrqbsaosd" +
    "bseotbbtcbuabueo" +
    "vbbvcovdbvgbvqbw" +
    "abweawiawkawmawo" +
    "bxcoxdbxgbxqbyeb" +
    "zcbAebBcbBgbBqbC" +
    "eaCiaCkaCmaCobDg" +
    "bDqbEebGe")
#
r(5249, "Papillon", layout="0bagbaibakobhobj" +
    "bcfbchbcjbclodho" +
    "djbecbeebegbeibe" +
    "kbembeoofdofnbgd" +
    "bgnbiebimojeojmb" +
    "kdbkfbklbknbmcbm" +
    "gbmkbmobobbohboj" +
    "bopopibqabqibqqo" +
    "ribsbbshbsjbspbu" +
    "cbugbukbuobwdbwf" +
    "bwlbwnoxeoxmbyeb" +
    "ymbAdbAnoBdoBnbC" +
    "cbCebCgbCibCkbCm" +
    "bCooDhoDjbEfbEhb" +
    "EjbEloFhoFjbGgbG" +
    "ibGk")
r(5250, "Pyramid 1", layout="0aagaaiaceacghch" +
    "aciackaecbeebegb" +
    "eibekaemagabgcbg" +
    "ecggcgibgkbgmago" +
    "aiabicciecigvihc" +
    "iicikbimaioakabk" +
    "cckedkgdkickkbkm" +
    "akoamabmccmedmgd" +
    "micmkbmmamoaoabo" +
    "ccoecogvohcoicok" +
    "bomaooaqabqcbqec" +
    "qgcqibqkbqmaqoas" +
    "cbsebsgbsibskasm" +
    "aueaughuhauiauka" +
    "wgawi")
r(5251, "Pyramid 2", layout="0aaeaagaaiaccbce" +
    "bcgbciackaeabecb" +
    "eeoefbegoehbeibe" +
    "kaemagacgcdgedgg" +
    "dgicgkagmbiadice" +
    "ieeigeiidikbimbk" +
    "adkcekeekgekidkk" +
    "bkmamacmcdmedmgd" +
    "micmkammaoabocbo" +
    "eoofbogoohboibok" +
    "aomaqcbqebqgbqia" +
    "qkaseasgasi")
#
r(5252, "Quad", layout="0baabacbaeaagbai" +
    "bakbamobbobdobjo" +
    "blbcabccvccbceac" +
    "gbcibckvckbcmodb" +
    "oddodjodlbeabecv" +
    "ecbeeaegbeibekve" +
    "kbemofbofdofjofl" +
    "bgabgcbgeaggbgib" +
    "gkbgmaiaaicaiebi" +
    "gaiiaikaimbkabkc" +
    "bkeakgbkibkkbkmo" +
    "lboldoljollbmabm" +
    "cvmcbmeamgbmibmk" +
    "vmkbmmonbondonjo" +
    "nlboabocvocboeao" +
    "gboibokvokbomopb" +
    "opdopjoplbqabqcb" +
    "qeaqgbqibqkbqm")
#
r(5253, "Rectangle", layout="0daadacdaedagdca" +
    "dccdcedcgdeadecd" +
    "eedegdgadgcdgedg" +
    "gdiadicdiedigdka" +
    "dkcdkedkgdmadmcd" +
    "medmgdoadocdoedo" +
    "gdqadqcdqedqg")
r(5254, "Reindeer", ncards=64, layout="0haeabdocchdbadn" +
    "aecheehemaffafla" +
    "fohgkahfahhahjaj" +
    "fajjalfalhaljall" +
    "hmmanfanjonnaooa" +
    "pfaphapjarfarjas" +
    "latfathatjhtmoua" +
    "hufounhvbhvjavoa" +
    "wchwfawkhxdaxghx" +
    "hhxlayioymazevzn" +
    "aAiaBchBdaBgaBoh" +
    "CbhChaCioDaoDivE" +
    "h")
r(5255, "Rings", layout="0aahabfhbhabjacd" +
    "hcfachochhcjaclh" +
    "ddadfodfhdhvdhad" +
    "jodjhdlaebaedhef" +
    "aehoehhejaelaenh" +
    "fcaffhfhafjhfmag" +
    "caghagmhhchhmaic" +
    "aihaimhjcajfhjha" +
    "jjhjmakbakdhkfak" +
    "hokhhkjaklaknhld" +
    "alfolfhlhvlhaljo" +
    "ljhllamdhmfamhom" +
    "hhmjamlanfhnhanj" +
    "aoaaohaooaqaaqha" +
    "qoarfhrharjasdhs" +
    "fashoshhsjaslhtd" +
    "atfotfhthvthatjo" +
    "tjhtlaubaudhufau" +
    "houhhujaulaunhvc" +
    "avfhvhavjhvmawca" +
    "whawmhxchxmaycay" +
    "haymhzcazfhzhazj" +
    "hzmaAbaAdhAfaAho" +
    "AhhAjaAlaAnhBdaB" +
    "foBfhBhvBhaBjoBj" +
    "hBlaCdhCfaChoChh" +
    "CjaClaDfhDhaDjaE" +
    "h")
r(5256, "River Bridge", ncards=116, layout="0aafaalacfachacj" +
    "aclhdfhdhhdjhdlo" +
    "efoehoejoelvffvf" +
    "loggogiogkvhfhhh" +
    "hhjvhloigaiioiio" +
    "ikvjfhjhhjjvjlaj" +
    "oakcokgakiokiokk" +
    "akmakqalavlfhlhh" +
    "ljvllomgamiomiom" +
    "kvnfhnhhnjvnloog" +
    "aoiooiookvpfhphh" +
    "pjvploqgaqioqioq" +
    "kvrfhrhhrjvrlosg" +
    "asiosioskvtfhthh" +
    "tjvtlaucougauiou" +
    "ioukauoavavvfhvh" +
    "hvjvvlavmavqowga" +
    "wiowiowkvxfhxhhx" +
    "jvxloygoyioykvzf" +
    "vzloAfoAhoAjoAlh" +
    "BfhBhhBjhBlaCfaC" +
    "haCjaClaEfaEl")
#
r(5257, "Roman Arena", layout="0CaaCacCaeCagCai" +
    "vbbvbdvbfvbhCcao" +
    "ccoceocgCcivdbhd" +
    "dadehdfvdhCeaoec" +
    "oegCeivfbhfdafeh" +
    "ffvfhCgaogcoggCg" +
    "ivhbhhdahehhfvhh" +
    "CiaoicoigCiivjbh" +
    "jdajehjfvjhCkaok" +
    "cokgCkivlbhldale" +
    "hlfvlhCmaomcCmcC" +
    "meomgCmgCmivnbhn" +
    "dvndanehnfvnfvnh" +
    "CoaoocooeCoeoogC" +
    "oivpbhpdvpdapehp" +
    "fvpfvphCqaoqcCqc" +
    "CqeoqgCqgCqivrbh" +
    "rdarehrfvrhCsaos" +
    "cosgCsivtbhtdate" +
    "htfvthCuaoucougC" +
    "uivvbhvdavehvfvv" +
    "hCwaowcowgCwivxb" +
    "hxdaxehxfvxhCyao" +
    "ycoygCyivzbhzdaz" +
    "ehzfvzhCAaoAcoAe" +
    "oAgCAivBbvBdvBfv" +
    "BhCCaCCcCCeCCgCC" +
    "i")
r(5258, "Rugby", layout="0aafaahaceacgaci" +
    "aecaeeaegaeiaeka" +
    "gaagcagehgfagghg" +
    "hagiagkagmaiaaic" +
    "hidaiehifaighiha" +
    "iihijaikaimakahk" +
    "bakchkdakeikfakg" +
    "ikhakihkjakkhkla" +
    "kmamahmbamchmdam" +
    "eimfamgvmgimhami" +
    "hmjamkhmlammondo" +
    "njaoahobaochodao" +
    "evoeiofaogvogioh" +
    "aoivoihojaokhola" +
    "omopdopjaqahqbaq" +
    "chqdaqeiqfaqgvqg" +
    "iqhaqihqjaqkhqla" +
    "qmasahsbaschsdas" +
    "eisfasgishasihsj" +
    "askhslasmauaauch" +
    "udauehufaughuhau" +
    "ihujaukaumawaawc" +
    "awehwfawghwhawia" +
    "wkawmaycayeaygay" +
    "iaykaAeaAgaAiaCf" +
    "aCh")
r(5259, "Shapeshifter", layout="0aaoacmhcnacoaek" +
    "hemaenheoaepagih" +
    "gkaglogmhgnagohg" +
    "paiaaighiiaijoij" +
    "hilaimoinbiohjaa" +
    "kaokaakehkgakhok" +
    "hhkjakkokkokmhkn" +
    "akohkphlavlaamao" +
    "maamchmeamfomghm" +
    "hamiomiomkhmlamm" +
    "omnbmohnavnavngv" +
    "nivnkaoaooaCoaho" +
    "caodooehofaogoog" +
    "CogooiCoihojaoko" +
    "okCokoomhonaooho" +
    "phpavpavpgvpivpk" +
    "aqaoqaaqchqeaqfo" +
    "qghqhaqioqioqkhq" +
    "laqmoqnbqohravra" +
    "asaosaasehsgasho" +
    "shhsjaskoskosmhs" +
    "nasohsphtaauaaug" +
    "huiaujoujhulaumo" +
    "unbuoawihwkawlow" +
    "mhwnawohwpaykhym" +
    "aynhyoaypaAmhAna" +
    "AoaCo")
#
r(5260, "Space Bridge", layout="0aaaaacaaeaagaai" +
    "aakaamaaoaaqhbbh" +
    "bdhbfhbhhbjhblhb" +
    "nhbpacaoccoceocg" +
    "ociockocmocoacqh" +
    "dbvddvdfvdivdlvd" +
    "nhdpaeaoecCeeCei" +
    "Cemoeoaeqhfbvfdv" +
    "fnhfpagaogcogoag" +
    "qhhbhhpaiaoicoio" +
    "aiqhjbajfajlhjpa" +
    "kaokchkghkkokoak" +
    "qhlbvldClealholh" +
    "aljoljClmvlnhlpa" +
    "maomchmivmiomoam" +
    "qhnbanhonhanjonj" +
    "hnpaoaoochoghoko" +
    "ooaoqhpbapfaplhp" +
    "paqaoqcoqoaqqhrb" +
    "vrdvrnhrpasaoscC" +
    "seCsiCsmosoasqht" +
    "bvtdvtfvtivtlvtn" +
    "htpauaoucoueougo" +
    "uioukoumouoauqhv" +
    "bhvdhvfhvhhvjhvl" +
    "hvnhvpawaawcawea" +
    "wgawiawkawmawoaw" +
    "q")
r(5261, "Space Shuttle", layout="0aalaanacibckbcm" +
    "aeebegbeibekbemb" +
    "gcbgecggcgicgkcg" +
    "mbiacicciedigdii" +
    "dikdimckadkcekee" +
    "kgekiekkekmbmacm" +
    "ccmedmgdmidmkdmm" +
    "bocboecogcoicokc" +
    "omaqebqgbqibqkbq" +
    "masibskbsmaulaun")
r(5262, "Stage 1", layout="0aaebagaaiaccbce" +
    "ccgbciackaeabecc" +
    "eevefcegvehceibe" +
    "kaemagacgcdgedgg" +
    "dgicgkagmaiadicd" +
    "iedigdiidikaimak" +
    "adkcdkedkgdkidkk" +
    "akmamacmcdmedmgd" +
    "micmkammaoabocco" +
    "evofcogvohcoibok" +
    "aomaqcbqecqgbqia" +
    "qkasebsgasi")
r(5263, "Stage 2", layout="0aafaahaceacgaci" +
    "aeeaegaeiagcbgeb" +
    "ggbgiagkaiabicci" +
    "ecigciibikaimbka" +
    "ckcckeckgckickkb" +
    "kmbmaombbmcomdbm" +
    "epmfbmgpmhbmiomj" +
    "bmkomlbmmboaoobb" +
    "ocoodboepofbogpo" +
    "hboioojbokoolbom" +
    "bqacqccqecqgcqic" +
    "qkbqmasabsccsecs" +
    "gcsibskasmaucbue" +
    "bugbuiaukaweawga" +
    "wiayeaygayiaAfaA" +
    "h")
r(5264, "Stairs 2", layout="0aaadacaaedagaai" +
    "dakacadccacedcga" +
    "cidckbeadecbeede" +
    "gbeidekbgacgcbge" +
    "cggbgicgkciacicc" +
    "iecigciicikckabk" +
    "cckebkgckibkkdma" +
    "bmcdmebmgdmibmkd" +
    "oaaocdoeaogdoiao" +
    "kdqaaqcdqeaqgdqi" +
    "aqk")
r(5265, "Stairs 3", layout="0eaeeageaieakeam" +
    "dcfdchdcjdclcegc" +
    "eicekbgabghbgjbg" +
    "qaicaiiaioalfali" +
    "allhmibnaanibnqa" +
    "ocioiaoobpaapibp" +
    "qhqiarfariarlauc" +
    "auiauobwabwhbwjb" +
    "wqcygcyicykdAfdA" +
    "hdAjdAleCeeCgeCi" +
    "eCkeCm")
r(5266, "Stargate", layout="0hagobeabgobgobi" +
    "hcehcghcjoddadeo" +
    "dgadiodkhechelaf" +
    "cofcafgpfgafkofm" +
    "hgbhgghgnahaohap" +
    "hgahmohohiahilhi" +
    "pajaojavjcvjevjg" +
    "vjivjkajoojphkav" +
    "kaokdokfokhokjhk" +
    "palaolaClavlchle" +
    "hlghlivlkolpalqh" +
    "mavmaomdamfamhom" +
    "jhmpanaonaCnavnc" +
    "hnehnivnkanopnph" +
    "oavoaoodaofaohoo" +
    "jhopapaopaCpavpc" +
    "hpehpghpivpkoppa" +
    "pqhqavqaoqdoqfoq" +
    "hoqjhqparaoravrc" +
    "vrevrgvrivrkaroo" +
    "rphsahslhspataot" +
    "aptgatmotohubhug" +
    "hunavcovcavgpvga" +
    "vkovmhwchwloxdax" +
    "eoxgaxioxkhyehyg" +
    "hyjozeazgozgozih" +
    "Ag")
#
r(5267, "Sukis", layout="0aaaaacaaeaagaai" +
    "aakaamaaoaaqhbbh" +
    "bfhbjhbnacaaccac" +
    "eacgaciackacmaco" +
    "acqafaafcafeafga" +
    "fiafkafmafoafqhg" +
    "bhgpahaahcaheahg" +
    "ahiahkahmahoahqa" +
    "kahkbakcakeakgak" +
    "iakkakmakoakqhlp" +
    "amaamcameamgamia" +
    "mkammamoamqapaap" +
    "capeapgapiapkapm" +
    "apoapqhqbhqparaa" +
    "rcareargariarkar" +
    "maroarqauaaucaue" +
    "augauiaukaumauoa" +
    "uqhvpawahwbawcaw" +
    "eawgawiawkawmawo" +
    "awqazaazcazeazga" +
    "ziazkazmazoazqhA" +
    "bhApaBaaBcaBeaBg" +
    "aBiaBkaBmaBoaBqa" +
    "EaaEcaEeaEgaEiaE" +
    "kaEmaEoaEqhFbhFf" +
    "hFjhFnaGaaGcaGea" +
    "GgaGiaGkaGmaGoaG" +
    "q")
#
r(5268, "Temple 1", layout="0aaaaaeaaiabchbd" +
    "abghbhacahcbocca" +
    "cehcfocgaciadchd" +
    "dodeadghdhaeaheb" +
    "oecaeehefoegaeia" +
    "fchfdpfeafghfhag" +
    "ahgbogcagehgfogg" +
    "agiahchhdvhdohev" +
    "hfahghhhaiahiboi" +
    "caiehifoigaiiajc" +
    "hjdvjdojeCjevjfa" +
    "jghjhakahkbokcak" +
    "ehkfokgakialchld" +
    "vldoleClevlfalgh" +
    "lhamahmbomcamehm" +
    "fomgamianchndvnd" +
    "oneCnevnfanghnha" +
    "oahoboocaoehofoo" +
    "gaoiapchpdvpdope" +
    "vpfapghphaqahqbo" +
    "qcaqehqfoqgaqiar" +
    "chrdprearghrhasa" +
    "hsboscasehsfosga" +
    "siatchtdoteatght" +
    "hauahuboucauehuf" +
    "ougauiavchvdavgh" +
    "vhawaaweawi")
#
r(5269, "Temple 2", layout="0aacaagaakabahbb" +
    "abehbfabihbjacco" +
    "cchcdacgocghchac" +
    "kadahdbadeodehdf" +
    "adiodihdjaecoech" +
    "edaegoeghehaekaf" +
    "ahfbafeofehffafi" +
    "ofihfjagcogchgda" +
    "ggpgghghagkahahh" +
    "bahephehhfahiohi" +
    "hhjaicoichidaigp" +
    "ighihaikajahjbaj" +
    "epjehjfajiojihjj" +
    "akcokchkdakgpkgh" +
    "khakkalahlbalepl" +
    "ehlfaliolihljamc" +
    "omchmdamgpmghmha" +
    "mkanahnbaneonehn" +
    "fanionihnjaocooc" +
    "hodaogooghohaoka" +
    "pahpbapeopehpfap" +
    "iopihpjaqcoqchqd" +
    "aqgoqghqhaqkarah" +
    "rbareorehrfarior" +
    "ihrjaschsdasghsh" +
    "askataateati")
r(5270, "Totally Random-Made", layout="0aaevajaaoabbhbh" +
    "obioceCceacgaclC" +
    "clpcmhddvddwdhhd" +
    "moecaedCedoeghej" +
    "oenhffafgCfhafjo" +
    "fjCfkvfmagaCgfvg" +
    "gvgjhgkCgnahfohh" +
    "Chjahlohlahoaibh" +
    "ichieaihvihhiioj" +
    "cajdojeCjiojjwjl" +
    "ojookmhkovkoClcC" +
    "lfvlgolhvliCljpl" +
    "khlmvlmalpClpvmd" +
    "hmghmjammCmmCnco" +
    "ndCnganhCniankho" +
    "dvodaoeCoehofhoh" +
    "vohvokoolvomaooC" +
    "phopibplCpnvqhar" +
    "ahreorfCrharkhrl" +
    "ormasfashvsiCsjh" +
    "tfCthotiatjptnht" +
    "oaucoufhuhvuhauo" +
    "hvbavgovjCvjavkv" +
    "vkhwghwjawnawpbx" +
    "daxjoxkayfaymayo" +
    "aCdaCiaEiaFe")
r(5271, "Trika", layout="0hagaahiaiaajhak" +
    "abfablhceicihcma" +
    "ddoddodfadhvdhCd" +
    "iadjvdjodladnodn" +
    "heeieihemaffaflh" +
    "ggaghigiagjhgkci" +
    "iakgokghkhakioki" +
    "hkjakkokkhlfhlla" +
    "meomeamiammommhn" +
    "dhnnaocoocaogaoi" +
    "aokaooooohpbhphh" +
    "pjhppaqapqaaqehq" +
    "faqioqihqlaqmaqq" +
    "pqqhrbhrhhrjhrpa" +
    "scoscasgasiaskas" +
    "oosohtdhtnaueoue" +
    "auiaumoumhvfhvla" +
    "wgowghwhawiowihw" +
    "jawkowkcyihAgaAh" +
    "iAiaAjhAkaBfaBlh" +
    "CeiCihCmaDdoDdoD" +
    "faDhvDhCDiaDjvDj" +
    "oDlaDnoDnhEeiEih" +
    "EmaFfaFlhGgaGhiG" +
    "iaGjhGk")
r(5272, "Twin", layout="0aaeaagaaibccbce" +
    "bcgbcibckaeabecc" +
    "eecegceibekaemag" +
    "abgccgedggcgibgk" +
    "agmaiabicciecigc" +
    "iibikaimbkcbkebk" +
    "gbkibkkbmebmgbmi" +
    "bocboebogboiboka" +
    "qabqccqecqgcqibq" +
    "kaqmasabsccsedsg" +
    "csibskasmauabucc" +
    "uecugcuibukaumbw" +
    "cbwebwgbwibwkaye" +
    "aygayi")
#
r(5273, "Two Domes", layout="0aaiabghbiabkace" +
    "hcghckacmhdeodho" +
    "djhdmaecoefveioe" +
    "laeohfdvfgvfkhfn" +
    "agbogeCghCgjogma" +
    "gphhcvhfvhlhhoai" +
    "aoidCigCikoinaiq" +
    "hjcvjfajhvjlhjoa" +
    "kbokeCkhCkjokmak" +
    "phldvlgvlkhlnamc" +
    "omfvmiomlamohneo" +
    "nhonjhnmaoehogho" +
    "kaomapghpiapkaqe" +
    "hqgoqhaqivqioqjh" +
    "qkaqmarghriarkas" +
    "ehsghskasmhteoth" +
    "otjhtmaucoufvuio" +
    "ulauohvdvvgvvkhv" +
    "nawboweCwhCwjowm" +
    "awphxcvxfvxlhxoa" +
    "yaoydCygCykoynay" +
    "qhzcvzfazhvzlhzo" +
    "aAboAeCAhCAjoAma" +
    "AphBdvBgvBkhBnaC" +
    "coCfvCioClaCohDe" +
    "oDhoDjhDmaEehEgh" +
    "EkaEmaFghFiaFkaG" +
    "i")
#
r(5274, "Vagues", layout="0aacCaeaagCaiaak" +
    "Camhbcvbehbgvbih" +
    "bkvbmoccoceocgoc" +
    "iockocmvdchdevdg" +
    "hdivdkhdmCecaeeC" +
    "egaeiCekaemvfchf" +
    "evfghfivfkhfmaga" +
    "ogcogeoggogiogko" +
    "gmagohhahhcvhehh" +
    "gvhihhkvhmhhooia" +
    "aicCieaigCiiaikC" +
    "imoiovjahjcvjehj" +
    "gvjihjkvjmvjoCka" +
    "okcokeokgokiokko" +
    "kmCkovlavlchlevl" +
    "ghlivlkhlmvlooma" +
    "CmcameCmgamiCmka" +
    "mmomohnavnchnevn" +
    "ghnivnkhnmhnoaoa" +
    "oocooeoogooiooko" +
    "omaoohpcvpehpgvp" +
    "ihpkvpmaqcCqeaqg" +
    "CqiaqkCqmhrcvreh" +
    "rgvrihrkvrmoscos" +
    "eosgosioskosmvtc" +
    "htevtghtivtkhtmC" +
    "ucaueCugauiCukau" +
    "m")
r(5275, "Well2", layout="0aaaaacaaeaagaai" +
    "aakaamaaoacacccc" +
    "ceccgccicckccmac" +
    "oaeadecdeedegdei" +
    "dekdemaeoagadgcd" +
    "gedgkdgmagoaiadi" +
    "cdiedikdimaioaka" +
    "dkcdkedkgdkidkkd" +
    "kmakoamacmccmecm" +
    "gcmicmkcmmamoaoa" +
    "aocaoeaogaoiaoka" +
    "omaoo")
#
r(5276, "Whatever", layout="0oaeoaghbdhbfhbh" +
    "hcbaceoceacgocgh" +
    "cjadcadiheboeeoe" +
    "ghejafcafihgboge" +
    "ogghgjahcwhfahio" +
    "iahiboicoieoigoi" +
    "ihijoikajcvjdwjf" +
    "vjhajiokahkbokcC" +
    "kdokeokgCkhokihk" +
    "jokkalcvldwlfvlh" +
    "aliomahmbvmbomcC" +
    "mdomeomgCmhomihm" +
    "jvmjomkancvndwnf" +
    "vnhaniooahobvobo" +
    "ocCodooeoogCohoo" +
    "ihojvojookapcvpd" +
    "wpfvphapioqahqbo" +
    "qcCqdoqeoqgCqhoq" +
    "ihqjoqkarcvrdwrf" +
    "vrhariosahsbosco" +
    "seosgosihsjoskat" +
    "cwtfatihuboueoug" +
    "hujavcavihwboweo" +
    "wghwjaxcaxihybay" +
    "eoyeaygoyghyjhzd" +
    "hzfhzhoAeoAg")
r(5277, "Win", layout="0aaeaahaakaanbed" +
    "begbejbembepbheb" +
    "hhbhkbhnbhqbjdbj" +
    "gbjjbjmbjpbmcbme" +
    "bmgbmibmkbmmbmoc" +
    "occoicoocqbcqhcq" +
    "ncsbcshcsncuacuc" +
    "cuecugcuicukcumc" +
    "wbcwhcwncybcyhcy" +
    "ncAccAicAocCccCe" +
    "cCgcCicCkcCmcCo")
r(5278, "X-Files", layout="0aaaaaiaaqhbiacb" +
    "acgaciociackacph" +
    "dibecaeiaeoegdeg" +
    "neieeiidimdkfckl" +
    "ekpelbbmgbmkaocb" +
    "ohooibojaooaqahq" +
    "baqcoqchqdaqeaqi" +
    "aqmhqnaqooqohqpa" +
    "qqascbshosibsjas" +
    "obugbukewbcwfcwl" +
    "ewpdyeeyidymeAde" +
    "AnaCcaCiaCohDiaE" +
    "baEgaEioEiaEkaEp" +
    "hFiaGaaGiaGq")
r(5279, "X-Shape", layout="0aaibbabbqcdabdc" +
    "bdocdqaeicfacfcb" +
    "febfmcfocfqchabh" +
    "cchebhgbhkchmbho" +
    "chqbjabjecjgbjic" +
    "jkbjmbjqblgdlibl" +
    "kbnabnecngbnicnk" +
    "bnmbnqcpabpccpeb" +
    "pgbpkcpmbpocpqcr" +
    "acrcbrebrmcrocrq" +
    "asictabtcbtoctqb" +
    "vabvqawi")
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##
from . import mahjongg1  # noqa: F401
from . import mahjongg2  # noqa: F401
from . import mahjongg3  # noqa: F401
from . import shisensho  # noqa: F401
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.mfxutil import KwStruct
from pysollib.mygettext import _
from pysollib.tile.basetilemfxdialog import BaseTileMfxDialog
from pysollib.ui.tktile.solverdialog import BaseSolverDialog, solver_dialog

from .tkwidget import PysolCombo


# ************************************************************************
# *
# ************************************************************************

class SolverDialog(BaseSolverDialog, BaseTileMfxDialog):
    def _createGamesVar(self, frame, row):
        cb = PysolCombo(frame, values=tuple(self.gamenames),
                        selectcommand=self.gameSelected,
                        state='readonly', width=40)
        cb.grid(row=row, column=1, sticky='ew', padx=2, pady=2)
        return cb

    def _createPresetVar(self, frame, row):
        cb = PysolCombo(frame, values=tuple(self.presets), state='readonly',
                        selectcommand=self._OnAssignToPreset)
        cb.grid(row=row, column=1, sticky='ew', padx=2, pady=2)
        cb.current(0)
        return cb

    def _createShowProgressButton(self, frame):
        return self._calcToolkit().Checkbutton(
            frame, variable=self.progress_var,
            text=_('Show progress'))

    def initKw(self, kw):
        strings = [_('&Start'), _('&Play'), _('&New'), 'sep', _('&Close'), ]
        kw = KwStruct(kw,
                      strings=strings,
                      default=0,
                      )
        return self._calc_MfxDialog().initKw(self, kw)

    def connectGame(self, game):
        name = self.app.getGameTitleName(game.id)
        if name in self.gamenames:
            self.start_button.config(state='normal')
            i = self.gamenames.index(name)
            self.games_var.current(i)
        else:
            self.start_button.config(state='disabled')
            self.games_var.current(0)
        self.play_button.config(state='disabled')


solver_dialog = solver_dialog


def create_solver_dialog(parent, game):
    global solver_dialog
    try:
        solver_dialog.top.wm_deiconify()
        solver_dialog.top.tkraise()
    except Exception:
        # traceback.print_exc()
        solver_dialog = SolverDialog(parent, game)
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

# imports
import os
import sys

from pysollib.mygettext import _

import six
from six.moves import tkinter
from six.moves import tkinter_ttk as ttk

from .tkwidget import MfxTooltip

if __name__ == '__main__':
    d = os.path.abspath(os.path.join(sys.path[0], os.pardir, os.pardir))
    sys.path.append(d)
    import gettext
    gettext.install('pysol', d, unicode=True)

# ************************************************************************
# *
# ************************************************************************


class MfxStatusbar:
    def __init__(self, top, row, column, columnspan):
        self.top = top
        self._show = True
        self._widgets = []
        self._tooltips = []
        #
        self._row = row
        self._column = column
        self._columnspan = columnspan
        self._label_column = 0
        #
        self.padx = 1
        self.label_relief = 'sunken'
        self.top_frame = ttk.Frame(self.top)
        self.top_frame.grid(row=self._row, column=self._column,
                            columnspan=self._columnspan, sticky='ew')
        self.frame = ttk.Frame(self.top_frame)
        self.frame.pack(side='left', expand=True, fill='both', padx=0, pady=1)

    # util
    def _createLabel(self, name, expand=False, width=0, tooltip=None):
        frame = ttk.Frame(self.frame, borderwidth=1, relief=self.label_relief)
        frame.grid(row=0, column=self._label_column,
                   sticky='nsew', padx=self.padx)
        if expand:
            self.frame.grid_columnconfigure(self._label_column,
                                            weight=1)
        self._label_column += 1
        setattr(self, name + '_frame', frame)
        self._widgets.append(frame)
        label = ttk.Label(frame, width=width, anchor='center')
        label.pack(expand=True, fill='both')
        setattr(self, name + '_label', label)
        self._widgets.append(label)
        if tooltip:
            b = MfxTooltip(label)
            self._tooltips.append(b)
            b.setText(tooltip)
        return label

    def _createSizegrip(self):
        sg = ttk.Sizegrip(self.top_frame)
        sg.pack(side='right', anchor='se')

    #
    # public methods
    #

    def updateText(self, **kw):
        for k, v in kw.items():
            label = getattr(self, k + '_label')
            text = six.text_type(v)
            width = label['width']
            if width and len(text) > width:
                label['width'] = len(text)
            label['text'] = text

    def config(self, name, show):
        frame = getattr(self, name + '_frame')
        if show:
            frame.grid()
        else:
            frame.grid_remove()

    def configLabel(self, name, **kw):
        if 'fg' in kw:
            kw['foreground'] = kw['fg']
            del kw['fg']
        label = getattr(self, name + '_label')
        label.config(**kw)

    def show(self, show=True, resize=False):
        if self._show == show:
            return False
        if resize:
            self.top.wm_geometry('')    # cancel user-specified geometry
        if not show:
            # hide
            self.top_frame.grid_forget()
        else:
            # show
            self.top_frame.grid(row=self._row, column=self._column,
                                columnspan=self._columnspan, sticky='ew')
        self._show = show
        return True

    def hide(self, resize=False):
        self.show(False, resize)

    def destroy(self):
        for w in self._tooltips:
            if w:
                w.destroy()
        self._tooltips = []
        for w in self._widgets:
            if w:
                w.destroy()
        self._widgets = []


class PysolStatusbar(MfxStatusbar):
    def __init__(self, top):
        MfxStatusbar.__init__(self, top, row=4, column=0, columnspan=3)
        #
        for n, t, w in (
            ('stuck',       _("'You Are Stuck' indicator"), 3),
            ('time',        _('Playing time'),            10),
            ('moves',       _('Moves/Total moves'),       10),
            ('gamenumber',  _('Game number'),             26),
            ('stats',       _('Games played: won/lost'),  12),
                ):
            self._createLabel(n, tooltip=t, width=w)
        #
        label = self._createLabel('info', expand=True)
        label.config(padding=(8, 0))
        self._createSizegrip()


class HelpStatusbar(MfxStatusbar):
    def __init__(self, top):
        MfxStatusbar.__init__(self, top, row=3, column=0, columnspan=3)
        label = self._createLabel('info', expand=True)
        label.config(justify='left', anchor='w', padding=(8, 0))


class HtmlStatusbar(MfxStatusbar):
    def __init__(self, top, row, column, columnspan):
        MfxStatusbar.__init__(self, top, row=row, column=column,
                              columnspan=columnspan)
        label = self._createLabel('url', expand=True)
        label.config(justify='left', anchor='w', padding=(8, 0))
        self._createSizegrip()


# ************************************************************************
# *
# ************************************************************************


class TestStatusbar(PysolStatusbar):
    def __init__(self, top, args):
        PysolStatusbar.__init__(self, top)
        # test some settings
        self.updateText(moves=999, gamenumber='#0123456789ABCDEF0123')
        self.updateText(info='Some info text.')


def statusbar_main(args):
    tk = tkinter.Tk()
    TestStatusbar(tk, args)
    tk.mainloop()
    return 0


if __name__ == '__main__':
    sys.exit(statusbar_main(sys.argv))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.mfxutil import KwStruct
from pysollib.mygettext import _

from six.moves import tkinter
from six.moves import tkinter_ttk as ttk

from .tkwidget import MfxDialog


class PlayerOptionsDialog(MfxDialog):
    def __init__(self, parent, title, app, **kw):
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.createBitmaps(top_frame, kw)
        self.app = app
        #
        self.update_stats_var = tkinter.BooleanVar()
        self.update_stats_var.set(app.opt.update_player_stats != 0)
        self.confirm_var = tkinter.BooleanVar()
        self.confirm_var.set(app.opt.confirm != 0)
        self.win_animation_var = tkinter.BooleanVar()
        self.win_animation_var.set(app.opt.win_animation != 0)
        #
        frame = ttk.Frame(top_frame)
        frame.pack(expand=True, fill='both', padx=5, pady=10)
        widget = ttk.Label(frame, text=_("\nPlease enter your name"),
                           takefocus=0)
        widget.grid(row=0, column=0, columnspan=2, sticky='ew', padx=0, pady=5)
        #
        w = kw.get("e_width", 30)    # width in characters
        names = self.app.getAllUserNames()
        self.player_var = ttk.Combobox(frame, width=w, values=tuple(names))
        self.player_var.current(names.index(app.opt.player))
        self.player_var.grid(row=1, column=0, sticky='ew', padx=0, pady=5)
        #
        widget = ttk.Checkbutton(frame, variable=self.confirm_var,
                                 text=_("Confirm quit"))
        widget.grid(row=2, column=0, columnspan=2, sticky='ew', padx=0, pady=5)
        widget = ttk.Checkbutton(frame, variable=self.update_stats_var,
                                 text=_("Update statistics and logs"))
        widget.grid(row=3, column=0, columnspan=2, sticky='ew', padx=0, pady=5)
        #  widget = ttk.Checkbutton(frame, variable=self.win_animation_var,
        #                               text="Win animation")
        #  widget.pack(side='top', padx=kw.padx, pady=kw.pady)
        frame.columnconfigure(0, weight=1)
        #
        self.player = self.player_var.get()
        self.confirm = self.confirm_var.get()
        self.update_stats = self.update_stats_var.get()
        self.win_animation = self.win_animation_var.get()
        #
        focus = self.createButtons(bottom_frame, kw)
        self.mainloop(focus, kw.timeout)

    def mDone(self, button):
        self.button = button
        self.player = self.player_var.get()
        self.confirm = self.confirm_var.get()
        self.update_stats = self.update_stats_var.get()
        self.win_animation = self.win_animation_var.get()
        raise SystemExit

    def initKw(self, kw):
        kw = KwStruct(kw,
                      strings=(_("&OK"), _("&Cancel")), default=0,
                      padx=10, pady=10,
                      )
        return MfxDialog.initKw(self, kw)
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

import os

from pysollib.mfxutil import Image, ImageOps, ImageTk
from pysollib.mygettext import _, n_
from pysollib.settings import TITLE
from pysollib.ui.tktile.menubar import MfxMenu, createToolbarMenu
from pysollib.ui.tktile.tkconst import EVENT_HANDLED
from pysollib.ui.tktile.tkutil import loadImage
from pysollib.util import IMAGE_EXTENSIONS
from pysollib.winsystems import TkSettings

from six.moves import tkinter
from six.moves import tkinter_ttk as ttk

from .tkwidget import MfxTooltip


class AbstractToolbarButton:
    def __init__(self, parent, toolbar, toolbar_name, position):
        self.toolbar = toolbar
        self.toolbar_name = toolbar_name
        self.position = position
        self.visible = False

    def show(self, orient, force=False):
        if self.visible and not force:
            return
        self.visible = True
        if orient == 'horizontal':
            padx, pady = TkSettings.toolbar_button_padding
            self.grid(row=0,
                      column=self.position,
                      padx=padx, pady=pady,
                      sticky='nsew')
        else:
            pady, padx = TkSettings.toolbar_button_padding
            self.grid(row=self.position,
                      column=0,
                      padx=padx, pady=pady,
                      sticky='nsew')

    def hide(self):
        if not self.visible:
            return
        self.visible = False
        self.grid_forget()


class ToolbarCheckbutton(AbstractToolbarButton, ttk.Checkbutton):
    def __init__(self, parent, toolbar, toolbar_name, position, **kwargs):
        kwargs['style'] = 'Toolbutton'
        ttk.Checkbutton.__init__(self, parent, **kwargs)
        AbstractToolbarButton.__init__(
            self, parent, toolbar, toolbar_name, position)


class ToolbarButton(AbstractToolbarButton, ttk.Button):
    def __init__(self, parent, toolbar, toolbar_name, position, **kwargs):
        kwargs['style'] = 'Toolbutton'
        ttk.Button.__init__(self, parent, **kwargs)
        AbstractToolbarButton.__init__(
            self, parent, toolbar, toolbar_name, position)


class ToolbarSeparator(ttk.Separator):
    def __init__(self, parent, toolbar, position, **kwargs):
        kwargs['orient'] = 'vertical'
        ttk.Separator.__init__(self, parent, **kwargs)
        self.toolbar = toolbar
        self.position = position
        self.visible = False

    def show(self, orient, force=False):
        if self.visible and not force:
            return
        self.visible = True
        if orient == 'horizontal':
            padx, pady = 4, 6
            self.config(orient='vertical')
            self.grid(row=0,
                      column=self.position,
                      padx=padx, pady=pady,
                      sticky='nsew')
        else:
            padx, pady = 4, 6
            self.config(orient='horizontal')
            self.grid(row=self.position,
                      column=0,
                      padx=pady, pady=padx,
                      sticky='nsew')

    def hide(self):
        if not self.visible:
            return
        self.visible = False
        self.grid_forget()


class ToolbarLabel(tkinter.Message):
    def __init__(self, parent, toolbar, toolbar_name, position, **kwargs):
        tkinter.Message.__init__(self, parent, **kwargs)
        self.toolbar = toolbar
        self.toolbar_name = toolbar_name
        self.position = position
        self.visible = False

    def show(self, orient, force=False):
        if self.visible and not force:
            return
        self.visible = True
        padx, pady = TkSettings.toolbar_label_padding
        if orient == 'horizontal':
            self.grid(row=0,
                      column=self.position,
                      padx=padx, pady=pady,
                      sticky='nsew')
        else:
            self.grid(row=self.position,
                      column=0,
                      padx=padx, pady=pady,
                      sticky='nsew')

    def hide(self):
        if not self.visible:
            return
        self.visible = False
        self.grid_forget()


# ************************************************************************
# * Note: Applications should call show/hide after constructor.
# ************************************************************************

class PysolToolbarTk:

    def __init__(self, top, menubar, dir,
                 size=0, relief='flat', compound='none'):
        self.top = top
        self.menubar = menubar
        self.side = -1
        self._tooltips = []
        self._widgets = []
        self.dir = dir
        self.size = size
        self.compound = compound
        self.orient = 'horizontal'
        #
        self.frame = ttk.Frame(top, class_='Toolbar',
                               relief=TkSettings.toolbar_relief,
                               borderwidth=TkSettings.toolbar_borderwidth)
        #
        for label, f, t in (
            (n_("New"),      self.mNewGame,   _("New game")),
            (n_("Restart"),  self.mRestart,   _("Restart the\ncurrent game")),
            (None,           None,            None),
            (n_("Open"),     self.mOpen,      _("Open a\nsaved game")),
            (n_("Save"),     self.mSave,      _("Save game")),
            (None,           None,            None),
            (n_("Undo"),     self.mUndo,      _("Undo last move")),
            (n_("Redo"),     self.mRedo,      _("Redo last move")),
            (n_("Autodrop"), self.mDrop,      _("Auto drop cards")),
            (n_("Shuffle"),  self.mShuffle,   _("Shuffle tiles")),
            (n_("Pause"),    self.mPause,     _("Pause game")),
            (None,           None,            None),
            (n_("Statistics"), self.mPlayerStats, _("View statistics")),
            (n_("Rules"),    self.mHelpRules, _("Rules for this game")),
            (None,           None,            None),
            (n_("Quit"),     self.mQuit,      _("Quit %s") % TITLE),
                ):
            if label is None:
                sep = self._createSeparator()
                sep.bind("<3>", self.rightclickHandler)
            elif label == 'Pause':
                self._createButton(label, f, check=True, tooltip=t)
            else:
                self._createButton(label, f, tooltip=t)
        self.pause_button.config(variable=menubar.tkopt.pause)

        self.popup = MfxMenu(master=None, label=n_('Toolbar'), tearoff=0)
        createToolbarMenu(menubar, self.popup)

        position = len(self._widgets)
        self.frame.rowconfigure(position, weight=1)
        self.frame.columnconfigure(position, weight=1)
        #
        self._createLabel("player", label=n_('Player'),
                          tooltip=_("Player options"))
        #
        self.player_label.bind("<1>", self.mOptPlayerOptions)
        self.frame.bind("<3>", self.rightclickHandler)
        #
        self.setCompound(compound, force=True)

    def config(self, w, v):
        if w == 'player':
            # label
            if v:
                self.player_label.show(orient=self.orient)
            else:
                self.player_label.hide()
        else:
            # button
            widget = getattr(self, w+'_button')
            if v:
                widget.show(orient=self.orient)
            else:
                widget.hide()
        #
        prev_visible = None
        last_visible = None
        for w in self._widgets:
            if isinstance(w, ToolbarSeparator):
                if prev_visible is None or isinstance(prev_visible,
                                                      ToolbarSeparator):
                    w.hide()
                else:
                    w.show(orient=self.orient)
            if w.visible:
                prev_visible = w
                if not isinstance(w, ToolbarLabel):
                    last_visible = w
        if isinstance(last_visible, ToolbarSeparator):
            last_visible.hide()

    # util
    def _loadImage(self, name):
        file = os.path.join(self.dir, name)
        image = None
        for ext in IMAGE_EXTENSIONS:
            file = os.path.join(self.dir, name+ext)
            if os.path.isfile(file):
                image = loadImage(file=file)
                break
        return image

    def _createSeparator(self):
        position = len(self._widgets)
        sep = ToolbarSeparator(self.frame,
                               position=position,
                               toolbar=self,
                               takefocus=0)
        sep.show(orient=self.orient)
        self._widgets.append(sep)
        return sep

    def _createDisabledButtonImage(self, tkim):
        # grayscale and light-up image
        if not tkim:
            return None
        im = tkim._pil_image
        dis_im = ImageOps.grayscale(im)
        # color = '#ffffff'
        # factor = 0.6
        color = '#dedede'
        factor = 0.7
        sh = Image.new(dis_im.mode, dis_im.size, color)
        tmp = Image.blend(dis_im, sh, factor)
        dis_im = Image.composite(tmp, im, im)
        dis_tkim = ImageTk.PhotoImage(image=dis_im)
        return dis_tkim

    def _setButtonImage(self, button, name):
        image = self._loadImage(name)
        setattr(self, name + "_image", image)
        if Image:
            dis_image = self._createDisabledButtonImage(image)
            if dis_image:
                setattr(self, name + "_disabled_image", dis_image)
                button.config(image=(image, 'disabled', dis_image))
        else:
            button.config(image=image)

    def _createButton(self, label, command, check=False, tooltip=None):
        name = label.lower()
        position = len(self._widgets)
        kw = {
            'position': position,
            'toolbar': self,
            'toolbar_name': name,
            'command': command,
            'takefocus': 0,
            'text': _(label),
            }

        if check:
            button = ToolbarCheckbutton(self.frame, **kw)
        else:
            button = ToolbarButton(self.frame, **kw)
        self._setButtonImage(button, name)
        button.show(orient=self.orient)
        setattr(self, name + "_button", button)
        self._widgets.append(button)
        if tooltip:
            b = MfxTooltip(button)
            self._tooltips.append(b)
            b.setText(tooltip)
        return button

    def _createLabel(self, name, label=None, tooltip=None):
        aspect = (400, 300)[self.getSize() != 0]
        position = len(self._widgets)+1
        label = ToolbarLabel(self.frame,
                             position=position,
                             toolbar=self,
                             toolbar_name=name,
                             relief="ridge",
                             justify="center",
                             aspect=aspect)
        label.show(orient=self.orient)
        setattr(self, name + "_label", label)
        self._widgets.append(label)
        if tooltip:
            b = MfxTooltip(label)
            self._tooltips.append(b)
            b.setText(tooltip)
        return label

    def _busy(self):
        if not self.side or not self.game or not self.menubar:
            return 1
        self.game.stopDemo()
        self.game.interruptSleep()
        return self.game.busy

    #
    # public methods
    #

    def show(self, side=1, resize=1):
        if self.side == side:
            return 0
        if resize:
            self.top.wm_geometry("")    # cancel user-specified geometry
        if not side:
            # hide
            self.frame.grid_forget()
        else:
            # show
            pack_func = self.frame.grid_configure

            if side == 1:
                # top
                padx, pady = TkSettings.horizontal_toolbar_padding
                pack_func(row=0, column=1, sticky='ew', padx=padx, pady=pady)
            elif side == 2:
                # bottom
                padx, pady = TkSettings.horizontal_toolbar_padding
                pack_func(row=2, column=1, sticky='ew', padx=padx, pady=pady)
            elif side == 3:
                # left
                padx, pady = TkSettings.vertical_toolbar_padding
                pack_func(row=1, column=0, sticky='ns', padx=padx, pady=pady)
            else:
                # right
                padx, pady = TkSettings.vertical_toolbar_padding
                pack_func(row=1, column=2, sticky='ns', padx=padx, pady=pady)
            # set orient
            orient = side in (1, 2) and 'horizontal' or 'vertical'
            self._setOrient(orient)
        self.side = side
        return 1

    def hide(self, resize=1):
        self.show(0, resize)

    def destroy(self):
        for w in self._tooltips:
            if w:
                w.destroy()
        self._tooltips = []
        for w in self._widgets:
            if w:
                w.destroy()
        self._widgets = []

    def setCursor(self, cursor):
        if self.side:
            self.frame.config(cursor=cursor)
            self.frame.update_idletasks()

    def updateText(self, **kw):
        for name in kw.keys():
            label = getattr(self, name + "_label")
            label["text"] = kw[name]

    def updateImages(self, dir, size):
        if dir == self.dir and size == self.size:
            return 0
        if not os.path.isdir(dir):
            return 0
        self.dir, self.size = dir, size
        data = []
        for w in self._widgets:
            if not isinstance(w, (ToolbarButton, ToolbarCheckbutton)):
                continue
            name = w.toolbar_name
            data.append((name, w))
        label = self.player_label
        aspect = (400, 300)[size != 0]
        label.config(aspect=aspect)
        for name, w in data:
            self._setButtonImage(w, name)
        self.setCompound(self.compound, force=True)
        return 1

    def setCompound(self, compound, force=False):
        if not force and self.compound == compound:
            return False
        for w in self._widgets:
            if not isinstance(w, (ToolbarButton, ToolbarCheckbutton)):
                continue
            w.config(compound=compound)
        self.compound = compound
        return True

    def _setOrient(self, orient='horizontal', force=False):
        if not force and self.orient == orient:
            return False
        for w in self._widgets:
            if w.visible:
                w.show(orient=orient, force=True)
        self.orient = orient
        return True

    #
    # Mouse event handlers
    #

    def rightclickHandler(self, event):
        if self._busy():
            return EVENT_HANDLED
        if self.popup:
            self.popup.tk_popup(event.x_root, event.y_root)
        return EVENT_HANDLED

    def getSize(self):
        if self.compound == 'text':
            return 0
        size = self.size
        comp = int(self.compound in ('top', 'bottom'))
        return int((size+comp) != 0)
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.ui.tktile.selecttree import BaseSelectDialogTreeCanvas
from pysollib.ui.tktile.selecttree import BaseSelectDialogTreeLeaf
from pysollib.ui.tktile.selecttree import BaseSelectDialogTreeNode

from .tktree import MfxTreeInCanvas, MfxTreeLeaf, MfxTreeNode

# ************************************************************************
# * Nodes
# ************************************************************************


class SelectDiagCommon:
    def _calc_MfxTreeNode(self):
        return MfxTreeNode

    def _calc_MfxTreeInCanvas(self):
        return MfxTreeInCanvas

    def _calc_MfxTreeLeaf(self):
        return MfxTreeLeaf


class SelectDialogTreeLeaf(SelectDiagCommon,
                           BaseSelectDialogTreeLeaf, MfxTreeLeaf):
    pass


class SelectDialogTreeNode(SelectDiagCommon,
                           BaseSelectDialogTreeNode, MfxTreeNode):
    pass

# ************************************************************************
# * Canvas that shows the tree (left side)
# ************************************************************************


class SelectDialogTreeCanvas(SelectDiagCommon,
                             BaseSelectDialogTreeCanvas, MfxTreeInCanvas):
    pass
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.mfxutil import KwStruct
from pysollib.mygettext import _

from six.moves import tkinter
from six.moves import tkinter_ttk as ttk

from .tkwidget import MfxDialog, PysolScale


class TimeoutsDialog(MfxDialog):
    def __init__(self, parent, title, app, **kw):
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        # self.createBitmaps(top_frame, kw)

        frame = ttk.Frame(top_frame)
        frame.pack(expand=True, fill='both', padx=5, pady=10)
        frame.columnconfigure(0, weight=1)

        self.demo_sleep_var = tkinter.DoubleVar()
        self.demo_sleep_var.set(app.opt.timeouts['demo'])
        self.hint_sleep_var = tkinter.DoubleVar()
        self.hint_sleep_var.set(app.opt.timeouts['hint'])
        self.raise_card_sleep_var = tkinter.DoubleVar()
        self.raise_card_sleep_var.set(app.opt.timeouts['raise_card'])
        self.highlight_piles_sleep_var = tkinter.DoubleVar()
        self.highlight_piles_sleep_var.set(app.opt.timeouts['highlight_piles'])
        self.highlight_cards_sleep_var = tkinter.DoubleVar()
        self.highlight_cards_sleep_var.set(app.opt.timeouts['highlight_cards'])
        self.highlight_samerank_sleep_var = tkinter.DoubleVar()
        self.highlight_samerank_sleep_var.set(
            app.opt.timeouts['highlight_samerank'])
        #
        lframe = ttk.LabelFrame(frame, text=_('Set delays in seconds'),
                                padding=(10, 5))
        lframe.pack(expand=True, fill='both', padx=4)
        row = 0
        for title, var in (
            (_('Demo:'),                self.demo_sleep_var),
            (_('Hint:'),                self.hint_sleep_var),
            (_('Raise card:'),          self.raise_card_sleep_var),
            (_('Highlight piles:'),     self.highlight_piles_sleep_var),
            (_('Highlight cards:'),     self.highlight_cards_sleep_var),
            (_('Highlight same rank:'), self.highlight_samerank_sleep_var),
                ):
            ttk.Label(
                lframe, text=title, anchor='w').grid(
                    row=row, column=0, sticky='we')
            widget = PysolScale(lframe, from_=0.2, to=9.9, value=var.get(),
                                resolution=0.1, orient='horizontal',
                                length="3i", variable=var, takefocus=0)
            widget.grid(row=row, column=1)
            row += 1
        #
        focus = self.createButtons(bottom_frame, kw)
        self.mainloop(focus, kw.timeout)
        #
        self.demo_timeout = self.demo_sleep_var.get()
        self.hint_timeout = self.hint_sleep_var.get()
        self.raise_card_timeout = self.raise_card_sleep_var.get()
        self.highlight_piles_timeout = self.highlight_piles_sleep_var.get()
        self.highlight_cards_timeout = self.highlight_cards_sleep_var.get()
        self.highlight_samerank_timeout = \
            self.highlight_samerank_sleep_var.get()

    def initKw(self, kw):
        kw = KwStruct(kw,
                      strings=(_("&OK"), _("&Cancel")), default=0,
                      padx=10, pady=10,
                      )
        return MfxDialog.initKw(self, kw)
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

import os

from pysollib.mfxutil import KwStruct
from pysollib.mygettext import _
from pysollib.pysolaudio import pysolsoundserver
from pysollib.settings import TITLE
from pysollib.ui.tktile.tkconst import EVENT_HANDLED

from six.moves import tkinter
from six.moves import tkinter_ttk as ttk

from .tkwidget import MfxDialog, MfxMessageDialog
from .tkwidget import PysolScale


class SoundOptionsDialog(MfxDialog):

    def __init__(self, parent, title, app, **kw):
        self.app = app
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.createBitmaps(top_frame, kw)
        #
        self.saved_opt = app.opt.copy()
        self.sound = tkinter.BooleanVar()
        self.sound.set(app.opt.sound != 0)
        self.sound_mode = tkinter.BooleanVar()
        self.sound_mode.set(app.opt.sound_mode != 0)
        self.sample_volume = tkinter.IntVar()
        self.sample_volume.set(app.opt.sound_sample_volume)
        self.music_volume = tkinter.IntVar()
        self.music_volume.set(app.opt.sound_music_volume)
        self.samples = [
            ('areyousure',    _('Are You Sure'),   tkinter.BooleanVar()),

            ('deal',          _('Deal'),           tkinter.BooleanVar()),
            ('dealwaste',     _('Deal waste'),     tkinter.BooleanVar()),

            ('turnwaste',     _('Turn waste'),     tkinter.BooleanVar()),
            ('startdrag',     _('Start drag'),     tkinter.BooleanVar()),

            ('drop',          _('Drop'),           tkinter.BooleanVar()),
            ('droppair',      _('Drop pair'),      tkinter.BooleanVar()),
            ('autodrop',      _('Auto drop'),      tkinter.BooleanVar()),

            ('flip',          _('Flip'),           tkinter.BooleanVar()),
            ('autoflip',      _('Auto flip'),      tkinter.BooleanVar()),
            ('move',          _('Move'),           tkinter.BooleanVar()),
            ('nomove',        _('No move'),        tkinter.BooleanVar()),

            ('undo',          _('Undo'),           tkinter.BooleanVar()),
            ('redo',          _('Redo'),           tkinter.BooleanVar()),

            ('autopilotlost', _('Autopilot lost'), tkinter.BooleanVar()),
            ('autopilotwon',  _('Autopilot won'),  tkinter.BooleanVar()),

            ('gamefinished',  _('Game finished'),  tkinter.BooleanVar()),
            ('gamelost',      _('Game lost'),      tkinter.BooleanVar()),
            ('gamewon',       _('Game won'),       tkinter.BooleanVar()),
            ('gameperfect',   _('Perfect game'),   tkinter.BooleanVar()),
            ]

        #
        frame = ttk.Frame(top_frame)
        frame.pack(expand=True, fill='both', padx=5, pady=5)
        frame.columnconfigure(1, weight=1)
        #
        row = 0
        w = ttk.Checkbutton(frame, variable=self.sound,
                            text=_("Sound enabled"))
        w.grid(row=row, column=0, columnspan=2, sticky='ew')
        #
        if os.name == "nt" and pysolsoundserver:
            row += 1
            w = ttk.Checkbutton(frame, variable=self.sound_mode,
                                text=_("Use DirectX for sound playing"),
                                command=self.mOptSoundDirectX)
            w.grid(row=row, column=0, columnspan=2, sticky='ew')
        #
        if app.audio.CAN_PLAY_MUSIC:  # and app.startup_opt.sound_mode > 0:
            row += 1
            ttk.Label(frame, text=_('Sample volume:'), anchor='w'
                      ).grid(row=row, column=0, sticky='ew')
            w = PysolScale(frame, from_=0, to=128, resolution=1,
                           orient='horizontal', takefocus=0,
                           length="3i",  # label=_('Sample volume'),
                           variable=self.sample_volume)
            w.grid(row=row, column=1, sticky='w', padx=5)
            row += 1
            ttk.Label(frame, text=_('Music volume:'), anchor='w'
                      ).grid(row=row, column=0, sticky='ew')
            w = PysolScale(frame, from_=0, to=128, resolution=1,
                           orient='horizontal', takefocus=0,
                           length="3i",  # label=_('Music volume'),
                           variable=self.music_volume)
            w.grid(row=row, column=1, sticky='w', padx=5)

        else:
            # remove "Apply" button
            kw.strings[1] = None
        #
        frame = ttk.LabelFrame(top_frame, text=_('Enable samples'))
        frame.pack(expand=True, fill='both', padx=5, pady=5)
        frame.columnconfigure(0, weight=1)
        frame.columnconfigure(1, weight=1)
        #
        row = 0
        col = 0
        for n, t, v in self.samples:
            v.set(app.opt.sound_samples[n])
            w = ttk.Checkbutton(frame, text=t, variable=v)
            w.grid(row=row, column=col, sticky='ew', padx=3, pady=1)
            if col == 1:
                col = 0
                row += 1
            else:
                col = 1
        #
        top_frame.columnconfigure(1, weight=1)
        #
        focus = self.createButtons(bottom_frame, kw)
        self.mainloop(focus, kw.timeout)

    def initKw(self, kw):
        strings = [_("&OK"), _("&Apply"), _("&Cancel"), ]
        kw = KwStruct(kw,
                      strings=strings,
                      default=0,
                      )
        return MfxDialog.initKw(self, kw)

    def mDone(self, button):
        if button == 0 or button == 1:
            self.app.opt.sound = self.sound.get()
            self.app.opt.sound_mode = int(self.sound_mode.get())
            self.app.opt.sound_sample_volume = self.sample_volume.get()
            self.app.opt.sound_music_volume = self.music_volume.get()
            for n, t, v in self.samples:
                self.app.opt.sound_samples[n] = v.get()
        elif button == 2:
            self.app.opt = self.saved_opt
        if self.app.audio:
            self.app.audio.updateSettings()
            if button == 1:
                self.app.audio.playSample("drop", priority=1000)
        if button == 1:
            return EVENT_HANDLED
        return MfxDialog.mDone(self, button)

    def mCancel(self, *event):
        return self.mDone(2)

    def wmDeleteWindow(self, *event):
        return self.mDone(0)

    def mOptSoundDirectX(self, *event):
        # print self.sound_mode.get()
        MfxMessageDialog(
            self.top, title=_("Sound preferences info"),
            text=_("""\
Changing DirectX settings will take effect
the next time you restart """)+TITLE,
            bitmap="warning",
            default=0, strings=(_("&OK"),))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.tile.basetilemfxdialog import BaseTileMfxDialog
from pysollib.ui.tktile.colorsdialog import BaseColorsDialog

# ************************************************************************
# *
# ************************************************************************


class ColorsDialog(BaseColorsDialog, BaseTileMfxDialog):
    pass
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

import os
import time

from pysollib.mfxutil import KwStruct
from pysollib.mfxutil import format_time
from pysollib.mygettext import _
from pysollib.settings import TOP_TITLE
from pysollib.stats import ProgressionFormatter, PysolStatsFormatter
from pysollib.ui.tktile.tkutil import bind, loadImage

from six.moves import tkinter
from six.moves import tkinter_font
from six.moves import tkinter_ttk as ttk

from .tkwidget import MfxDialog, MfxMessageDialog


# ************************************************************************
# *
# ************************************************************************

class StatsDialog(MfxDialog):
    SELECTED_TAB = 0

    def __init__(self, parent, title, app, player, gameid, **kw):

        kw = self.initKw(kw)
        title = _('Statistics')
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)

        self.font = app.getFont('default')
        self.tkfont = tkinter_font.Font(parent, self.font)
        self.font_metrics = self.tkfont.metrics()
        style = ttk.Style(parent)
        heading_font = style.lookup('Heading', 'font')  # treeview heading
        self.heading_tkfont = tkinter_font.Font(parent, heading_font)

        self.selected_game = None

        top_frame, bottom_frame = self.createFrames(kw)
        notebook = ttk.Notebook(top_frame)
        notebook.pack(expand=True, fill='both', padx=10, pady=10)

        self.notebook_tabs = []

        single_frame = SingleGameFrame(self, notebook, app, player, gameid)
        notebook.add(single_frame, text=_('Current game'))
        self.notebook_tabs.append(single_frame._w)

        all_frame = AllGamesFrame(self, notebook, app, player)
        notebook.add(all_frame, text=_('All games'))
        self.all_games_frame = all_frame
        self.notebook_tabs.append(all_frame._w)

        top_frame = TopFrame(self, notebook, app, player, gameid)
        notebook.add(top_frame, text=TOP_TITLE)
        self.notebook_tabs.append(top_frame._w)

        if player is not None:
            progr_frame = ProgressionFrame(self, notebook, app, player, gameid)
            notebook.add(progr_frame, text=_('Progression'))
            self.notebook_tabs.append(progr_frame._w)

        if StatsDialog.SELECTED_TAB < len(self.notebook_tabs):
            notebook.select(StatsDialog.SELECTED_TAB)
        bind(notebook, '<<NotebookTabChanged>>', self.tabChanged)
        # notebook.enableTraversal()
        self.notebook = notebook

        focus = self.createButtons(bottom_frame, kw)
        self.tabChanged()               # configure buttons state
        self.mainloop(focus, kw.timeout)

    def initKw(self, kw):
        kw = KwStruct(
            kw,
            strings=((_("&Play this game"), 401),
                     "sep", _("&OK"),
                     (_("&Reset..."), 500)),
            default=0,
            separator=False,
        )
        return MfxDialog.initKw(self, kw)

    def tabChanged(self, *args):
        w = self.notebook.select()
        run_button = self.buttons[0]
        indx = self.notebook_tabs.index(w)
        if indx == 1:                   # "All games"
            g = self.all_games_frame.getSelectedGame()
            if g is None:
                run_button.config(state='disabled')
            else:
                run_button.config(state='normal')
        else:
            run_button.config(state='disabled')
        reset_button = self.buttons[2]
        if indx in (0, 1):              # "Current game" or "All games"
            reset_button.config(state='normal')
        else:
            reset_button.config(state='disabled')

    def mDone(self, button):
        self.selected_game = self.all_games_frame.getSelectedGame()
        w = self.notebook.select()
        indx = self.notebook_tabs.index(w)
        StatsDialog.SELECTED_TAB = indx
        if button == 500:               # "Reset..."
            assert indx in (0, 1)
            if indx == 0:               # "Current game"
                button = 302
            else:                       # "All games"
                button = 301
        MfxDialog.mDone(self, button)


SingleGame_StatsDialog = AllGames_StatsDialog = Top_StatsDialog = \
        ProgressionDialog = StatsDialog


# ************************************************************************
# *
# ************************************************************************

class SingleGameFrame(ttk.Frame):
    def __init__(self, dialog, parent, app, player, gameid, **kw):
        ttk.Frame.__init__(self, parent)

        self.oval_width = 120
        self.oval_height = 60

        left_label = ttk.Label(self, image=app.gimages.logos[5])
        left_label.pack(side='left', expand=True, fill='both')
        self.right_frame = ttk.Frame(self)
        self.right_frame.pack(side='right', expand=True)

        self.dialog = dialog
        self.app = app
        self.parent = parent
        self.player = player or _("Demo games")
        #
        self._calc_tabs()
        #
        won, lost = app.stats.getStats(player, gameid)
        self.createPieChart(app, won, lost, _("Total"))
        won, lost = app.stats.getSessionStats(player, gameid)
        self.createPieChart(app, won, lost, _("Current session"))
        #

    #
    # helpers
    #

    def _calc_tabs(self):
        #
        font = self.dialog.tkfont
        t0 = self.oval_width+70
        t = ''
        for i in (_("Won:"),
                  _("Lost:"),
                  _("Total:")):
            if len(i) > len(t):
                t = i
        t1 = font.measure(t)
        #  t1 = max(font.measure(_("Won:")),
        #           font.measure(_("Lost:")),
        #           font.measure(_("Total:")))
        t1 += 10
        # t2 = font.measure('99999')+10
        t2 = 45
        # t3 = font.measure('100%')+10
        t3 = 45
        tx = (t0, t0+t1+t2, t0+t1+t2+t3, t0+t1+t2+t3+20)
        #
        ls = self.dialog.font_metrics['linespace']
        ls += 5
        # ls = max(ls, 20)
        ty = (5, 5+ls, 5+2*ls+15, max(85, 5+3*ls+15))
        #
        self.tab_x, self.tab_y = tx, ty

    def _getPwon(self, won, lost):
        pwon, plost = 0.0, 0.0
        if won + lost > 0:
            pwon = float(won) / (won + lost)
            pwon = min(max(pwon, 0.00001), 0.99999)
            plost = 1.0 - pwon
        return pwon, plost

    def _createChartInit(self, text):
        frame = ttk.LabelFrame(self.right_frame, text=text)
        frame.pack(side='top', fill='both', expand=False, padx=20, pady=10)
        style = ttk.Style(self.parent)
        fg = style.lookup('.', 'foreground') or None  # use default if fg == ''
        bg = style.lookup('.', 'background') or None
        self.fg = fg
        #
        w, h = self.tab_x[-1], max(self.tab_y[-1], self.oval_height+40)
        c = tkinter.Canvas(frame, width=w, height=h,
                           bg=bg, highlightthickness=0)
        c.pack(fill='both', expand=True)
        self.canvas = c

    def _createChartTexts(self, tx, ty, won, lost):
        c, tfont, fg = self.canvas, self.dialog.font, self.fg
        pwon, plost = self._getPwon(won, lost)
        #
        x = tx[0]
        dy = int(self.dialog.font_metrics['ascent']) - 10
        dy //= 2
        c.create_text(x, ty[0]-dy, text=_("Won:"),
                      anchor="nw", font=tfont, fill=fg)
        c.create_text(x, ty[1]-dy, text=_("Lost:"),
                      anchor="nw", font=tfont, fill=fg)
        c.create_text(x, ty[2]-dy, text=_("Total:"),
                      anchor="nw", font=tfont, fill=fg)
        x = tx[1] - 16
        c.create_text(x, ty[0]-dy, text="%d" % won,
                      anchor="ne", font=tfont, fill=fg)
        c.create_text(x, ty[1]-dy, text="%d" % lost,
                      anchor="ne", font=tfont, fill=fg)
        c.create_text(x, ty[2]-dy, text="%d" % (won + lost),
                      anchor="ne", font=tfont, fill=fg)
        y = ty[2] - 11
        c.create_line(tx[0], y, x, y, fill=fg)
        if won + lost > 0:
            x = tx[2]
            pw = int(round(100.0 * pwon))
            c.create_text(x, ty[0]-dy, text="%d%%" % pw,
                          anchor="ne", font=tfont, fill=fg)
            c.create_text(x, ty[1]-dy, text="%d%%" % (100-pw),
                          anchor="ne", font=tfont, fill=fg)

    def createPieChart(self, app, won, lost, text):
        # c, tfont, fg = self._createChartInit(frame, 300, 100, text)
        #
        self._createChartInit(text)
        c, tfont = self.canvas, self.dialog.font
        pwon, plost = self._getPwon(won, lost)
        #
        # tx = (160, 250, 280)
        # ty = (21, 41, 75)
        #
        tx, ty = self.tab_x, self.tab_y
        x0, y0 = 20, 10                 # base coords
        w = self.oval_width
        h = self.oval_height
        d = 9                           # delta
        if won + lost > 0:
            # s, ewon, elost = 90.0, -360.0 * pwon, -360.0 * plost
            s, ewon, elost = 0.0, 360.0 * pwon, 360.0 * plost
            c.create_arc(x0, y0+d, x0+w, y0+h+d, fill="#007f00",
                         start=s, extent=ewon)
            c.create_arc(x0, y0+d, x0+w, y0+h+d, fill="#7f0000",
                         start=s+ewon, extent=elost)
            c.create_arc(x0, y0,   x0+w, y0+h,   fill="#00ff00",
                         start=s, extent=ewon)
            c.create_arc(x0, y0,   x0+w, y0+h,   fill="#ff0000",
                         start=s+ewon, extent=elost)
            x, y = tx[0] - 25, ty[0]
            c.create_rectangle(x, y, x+10, y+10, fill="#00ff00")
            y = ty[1]
            c.create_rectangle(x, y, x+10, y+10, fill="#ff0000")
        else:
            c.create_oval(x0, y0+d, x0+w, y0+h+d, fill="#7f7f7f")
            c.create_oval(x0, y0,   x0+w, y0+h,   fill="#f0f0f0")
            c.create_text(x0+w//2, y0+h//2, text=_("No games"),
                          anchor="center", font=tfont, fill="#bfbfbf")
        #
        self._createChartTexts(tx, ty, won, lost)


# ************************************************************************
# *
# ************************************************************************

class TreeFormatter(PysolStatsFormatter):
    MAX_ROWS = 10000

    def __init__(self, app, tree, parent_window, font, w, h):
        self.app = app
        self.tree = tree
        self.parent_window = parent_window
        self.tkfont = font
        self.gameid = None
        self.gamenumber = None
        self._tabs = None
        self.w = w
        self.h = h

    def _calc_tabs(self, arg):
        if self.parent_window.tree_tabs:
            self._tabs = self.parent_window.tree_tabs
            return
        tw = 20*self.w
        # tw = 160
        self._tabs = [tw]
        measure = self.tkfont.measure
        for t in arg[1:]:
            tw = measure(t)+8
            self._tabs.append(tw)
        self._tabs.append(10)
        self.parent_window.tree_tabs = self._tabs

    def createHeader(self, player, header):
        i = 0
        for column in ('#0',) + self.parent_window.COLUMNS:
            text = header[i]
            self.tree.heading(
                column, text=text,
                command=lambda par=self.parent_window, col=column:
                    par.headerClick(col))
            self.tree.column(column, width=16)
            i += 1

    def resizeHeader(self, player, header, tree_width=0):
        if self._tabs is not None:
            return
        self._calc_tabs(header)
        # set first column width
        if tree_width != 0:
            tab = tree_width - sum(self._tabs[1:])
            tab = min(tree_width, self._tabs[0])
        else:
            tab = self._tabs[0]
        self.tree.column('#0', width=tab)
        # other column
        i = 1
        for column in self.parent_window.COLUMNS:
            tab = self._tabs[i]
            self.tree.column(column, width=tab)
            i += 1

    def writeStats(self, player, sort_by='name'):
        header = self.getStatHeader()
        tree_width = self.tree.winfo_width()
        self.resizeHeader(player, header, tree_width)

        for result in self.getStatResults(player, sort_by):
            # result == [name, won+lost, won, lost, time, moves, perc, id]
            t1, t2, t3, t4, t5, t6, t7, t8 = result
            id = self.tree.insert("", "end", text=t1,
                                  values=(t2, t3, t4, t5, t6, t7))
            self.parent_window.tree_items.append(id)
            self.parent_window.games[id] = t8

        total, played, won, lost, time_, moves, perc = self.getStatSummary()
        text = _("Total (%(played)d out of %(total)d games)") % {
            'played': played, 'total': total}
        id = self.tree.insert("", "end", text=text,
                              values=(won+lost, won, lost, time_, moves, perc))
        self.parent_window.tree_items.append(id)
        return 1

    def writeLog(self, player, prev_games):
        if not player or not prev_games:
            return 0
        num_rows = 0
        for result in self.getLogResults(player, prev_games):
            t1, t2, t3, t4, t5, t6 = result
            id = self.tree.insert("", "end", text=t1, values=(t2, t3, t4))
            self.parent_window.tree_items.append(id)
            num_rows += 1
            if num_rows > self.MAX_ROWS:
                break
        return 1

    def writeFullLog(self, player):
        prev_games = self.app.stats.prev_games.get(player)
        return self.writeLog(player, prev_games)

    def writeSessionLog(self, player):
        prev_games = self.app.stats.session_games.get(player)
        return self.writeLog(player, prev_games)


# ************************************************************************
# *
# ************************************************************************

class AllGamesFrame(ttk.Frame):

    COLUMNS = ('played', 'won', 'lost', 'time', 'moves', 'percent')

    def __init__(self, dialog, parent, app, player, **kw):
        ttk.Frame.__init__(self, parent)
        #
        self.dialog = dialog
        self.app = app
        self.CHAR_H = self.dialog.font_metrics['linespace']
        self.CHAR_W = self.dialog.tkfont.measure('M')
        #
        self.player = player
        self.sort_by = 'name'
        self.tree_items = []
        self.tree_tabs = None
        self.games = {}                 # tree_itemid: gameid
        #
        frame = ttk.Frame(self)
        frame.pack(fill='both', expand=True, padx=10, pady=10)
        vsb = ttk.Scrollbar(frame)
        vsb.grid(row=0, column=1, sticky='ns')
        self.tree = ttk.Treeview(frame, columns=self.COLUMNS,
                                 selectmode='browse')
        self.tree.grid(row=0, column=0, sticky='nsew')
        self.tree.config(yscrollcommand=vsb.set)
        vsb.config(command=self.tree.yview)
        frame.rowconfigure(0, weight=1)
        frame.columnconfigure(0, weight=1)
        hsb = ttk.Scrollbar(frame, orient='horizontal')
        hsb.grid(row=1, column=0, sticky='ew')
        self.tree.config(xscrollcommand=hsb.set)
        hsb.config(command=self.tree.xview)
        bind(self.tree, '<<TreeviewSelect>>', self.treeviewSelected)
        #
        self.formatter = TreeFormatter(self.app, self.tree, self,
                                       self.dialog.heading_tkfont,
                                       self.CHAR_W, self.CHAR_H)
        self.createHeader(player)
        bind(self.tree, '<Map>', self.mapEvent)

    def getSelectedGame(self):
        sel = self.tree.selection()
        if sel and len(sel) == 1:
            if sel[0] in self.games:
                return self.games[sel[0]]
        return None

    def treeviewSelected(self, *args):
        sel = self.tree.selection()
        run_button = self.dialog.buttons[0]
        if sel and len(sel) == 1:
            if sel[0] not in self.games:  # "Total"
                run_button.config(state='disabled')
            else:
                run_button.config(state='normal')
        else:
            run_button.config(state='disabled')

    def mapEvent(self, *args):
        if not self.tree_items:
            self.fillTreeview(self.player)

    def headerClick(self, column):
        if column == '#0':
            sort_by = 'name'
        else:
            sort_by = column
        if self.sort_by == sort_by:
            return
        self.sort_by = sort_by
        self.fillTreeview(self.player)

    def createHeader(self, player):
        header = self.formatter.getStatHeader()
        self.formatter.createHeader(player, header)

    def fillTreeview(self, player):
        if self.tree_items:
            self.tree.delete(tuple(self.tree_items))
            self.tree_items = []
        self.formatter.writeStats(player, sort_by=self.sort_by)
        if self.dialog.buttons:
            run_button = self.dialog.buttons[0]
            run_button.config(state='disabled')


# ************************************************************************
# *
# ************************************************************************

class LogDialog(MfxDialog):
    SELECTED_TAB = 0

    def __init__(self, parent, title, app, player, **kw):

        self.font = app.getFont('default')
        self.tkfont = tkinter_font.Font(parent, self.font)
        style = ttk.Style(parent)
        heading_font = style.lookup('Heading', 'font')  # treeview heading
        self.heading_tkfont = tkinter_font.Font(parent, heading_font)
        self.font_metrics = self.tkfont.metrics()

        self.CHAR_H = self.font_metrics['linespace']
        self.CHAR_W = self.tkfont.measure('M')

        kw = self.initKw(kw)
        title = _('Log')
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)

        # self.selected_game = None

        top_frame, bottom_frame = self.createFrames(kw)
        notebook = ttk.Notebook(top_frame)
        notebook.pack(expand=True, fill='both', padx=10, pady=10)

        self.notebook_tabs = []

        full_frame = FullLogFrame(self, notebook, app, player)
        notebook.add(full_frame, text=_('Full log'))
        self.notebook_tabs.append(full_frame._w)

        session_frame = SessionLogFrame(self, notebook, app, player)
        notebook.add(session_frame, text=_('Session log'))
        self.notebook_tabs.append(session_frame._w)

        notebook.select(LogDialog.SELECTED_TAB)
        #  bind(notebook, '<<NotebookTabChanged>>', self.tabChanged)

        self.notebook = notebook

        focus = self.createButtons(bottom_frame, kw)
        # self.tabChanged()               # configure buttons state
        self.mainloop(focus, kw.timeout)

    def initKw(self, kw):
        kw = KwStruct(kw,
                      strings=(_("&OK"),
                               (_("&Save to file"), 500)),
                      default=0,
                      width=76*self.CHAR_W,
                      separator=False,
                      )
        return MfxDialog.initKw(self, kw)

    def mDone(self, button):
        # self.selected_game = self.all_games_frame.getSelectedGame()
        w = self.notebook.select()
        indx = self.notebook_tabs.index(w)
        LogDialog.SELECTED_TAB = indx
        if button == 500:               # "Save to file"
            assert indx in (0, 1)
            if indx == 0:               # "Full log"
                button = 203
            else:                       # "Session log"
                button = 204
        MfxDialog.mDone(self, button)


FullLog_StatsDialog = SessionLog_StatsDialog = LogDialog


# ************************************************************************
# *
# ************************************************************************

class FullLogFrame(AllGamesFrame):

    COLUMNS = ('gamenumber', 'date', 'status')

    def __init__(self, dialog, parent, app, player, **kw):
        AllGamesFrame.__init__(self, dialog, parent, app, player, **kw)
        header = ('', '99999999999999999999', '9999-99-99  99:99',
                  'XXXXXXXXXXXX')
        self.formatter.resizeHeader(player, header)

    def createHeader(self, player):
        header = self.formatter.getLogHeader()
        self.formatter.createHeader(player, header)

    def fillTreeview(self, player):
        if self.tree_items:
            return
        self.formatter.writeFullLog(player)

    def treeviewSelected(self, *args):
        pass

    def headerClick(self, column):
        pass


class SessionLogFrame(FullLogFrame):
    def fillTreeview(self, player):
        if self.tree_items:
            return
        self.formatter.writeSessionLog(player)


# ************************************************************************
# *
# ************************************************************************

class Status_StatsDialog(MfxMessageDialog):
    def __init__(self, parent, game):
        stats, gstats = game.stats, game.gstats
        w1 = w2 = ""
        n = 0
        for s in game.s.foundations:
            n = n + len(s.cards)
        w1 = (_("Highlight piles: ") + str(stats.highlight_piles) + "\n" +
              _("Highlight cards: ") + str(stats.highlight_cards) + "\n" +
              _("Highlight same rank: ") +
              str(stats.highlight_samerank) + "\n")
        if game.s.talon:
            if game.gameinfo.redeals != 0:
                w2 = w2 + _("\nRedeals: ") + str(game.s.talon.round - 1)
            w2 = w2 + _("\nCards in Talon: ") + str(len(game.s.talon.cards))
        if game.s.waste and game.s.waste not in game.s.foundations:
            w2 = w2 + _("\nCards in Waste: ") + str(len(game.s.waste.cards))
        if game.s.foundations:
            w2 = w2 + _("\nCards in Foundations: ") + str(n)
        #
        date = time.strftime(
            "%Y-%m-%d %H:%M", time.localtime(game.gstats.start_time))
        MfxMessageDialog.__init__(
            self, parent, title=_("Game status"),
            text=game.getTitleName() + "\n" +
            game.getGameNumber(format=1) + "\n" +
            _("Playing time: ") + game.getTime() + "\n" +
            _("Started at: ") + date + "\n\n" +
            _("Moves: ") + str(game.moves.index) + "\n" +
            _("Undo moves: ") + str(stats.undo_moves) + "\n" +
            _("Bookmark moves: ") + str(gstats.goto_bookmark_moves) + "\n" +
            _("Demo moves: ") + str(stats.demo_moves) + "\n" +
            _("Total player moves: ") + str(stats.player_moves) + "\n" +
            _("Total moves in this game: ") + str(stats.total_moves) + "\n" +
            _("Hints: ") + str(stats.hints) + "\n" +
            "\n" +
            w1 + w2,
            strings=((_("&Statistics..."), 101),
                     'sep',
                     _("&OK")),
            image=game.app.gimages.logos[3],
            image_side="left", image_padx=20,
            padx=20,
            )


# ************************************************************************
# *
# ************************************************************************

class _TopDialog(MfxDialog):
    def __init__(self, parent, title, app, gameid, top, **kw):
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.createBitmaps(top_frame, kw)

        cnf = {'master': top_frame,
               'padding': (4, 1),
               }
        frame = ttk.Frame(**cnf)
        frame.pack(expand=True, fill='both', padx=10, pady=10)
        frame.columnconfigure(0, weight=1)
        cnf['master'] = frame
        cnf['text'] = _('N')
        label = ttk.Label(**cnf)
        label.grid(row=0, column=0, sticky='ew')
        if gameid == 'all':
            cnf['text'] = _('Game')
            label = ttk.Label(**cnf)
            label.grid(row=0, column=1, sticky='ew')
        cnf['text'] = _('Game number')
        label = ttk.Label(**cnf)
        label.grid(row=0, column=2, sticky='ew')
        cnf['text'] = _('Started at')
        label = ttk.Label(**cnf)
        label.grid(row=0, column=3, sticky='ew')
        cnf['text'] = _('Result')
        label = ttk.Label(**cnf)
        label.grid(row=0, column=4, sticky='ew')

        row = 1
        for i in top:
            # N
            cnf['text'] = str(row)
            label = ttk.Label(**cnf)
            label.grid(row=row, column=0, sticky='ew')
            if gameid == 'all':
                name = app.getGameTitleName(i.gameid)
                if name is None:
                    name = _("** UNKNOWN %d **") % i.gameid
                cnf['text'] = name
                label = ttk.Label(**cnf)
                label.grid(row=row, column=1, sticky='ew')
            # Game number
            cnf['text'] = '#'+str(i.game_number)
            label = ttk.Label(**cnf)
            label.grid(row=row, column=2, sticky='ew')
            # Start time
            t = time.strftime(
                '%Y-%m-%d %H:%M', time.localtime(i.game_start_time))
            cnf['text'] = t
            label = ttk.Label(**cnf)
            label.grid(row=row, column=3, sticky='ew')
            # Result
            if isinstance(i.value, float):
                # time
                s = format_time(i.value)
            else:
                # moves
                s = str(i.value)
            cnf['text'] = s
            label = ttk.Label(**cnf)
            label.grid(row=row, column=4, sticky='ew')
            row += 1

        focus = self.createButtons(bottom_frame, kw)
        self.mainloop(focus, kw.timeout)

    def initKw(self, kw):
        kw = KwStruct(kw, strings=(_('&OK'),), default=0, separator=True)
        return MfxDialog.initKw(self, kw)


class TopFrame(ttk.Frame):
    def __init__(self, dialog, parent, app, player, gameid):
        ttk.Frame.__init__(self, parent)

        self.app = app
        self.dialog = dialog

        left_label = ttk.Label(self, image=app.gimages.logos[5])
        left_label.pack(side='left', expand=True, fill='both')

        frame = ttk.LabelFrame(self, text=_('Current game'),
                               padding=(10, 5, 10, 10))
        frame.pack(side='top', expand=True, fill='x', padx=10, pady=10)
        # frame.columnconfigure(0, weight=1)
        if not self.createTopFrame(frame, player, gameid):
            ttk.Label(frame, text=_('No TOP for this game')
                      ).pack(padx=10, pady=10)

        frame = ttk.LabelFrame(self, text=_('All games'),
                               padding=(10, 5, 10, 10))
        frame.pack(side='top', expand=True, fill='x', padx=10, pady=10)
        # frame.columnconfigure(0, weight=1)
        if not self.createTopFrame(frame, player, 'all'):
            ttk.Label(frame, text=_('No TOP for all games')
                      ).pack(padx=10, pady=10)

    def createTopFrame(self, frame, player, gameid):
        app = self.app

        cond = (player not in app.stats.games_stats or
                gameid not in app.stats.games_stats[player] or
                not app.stats.games_stats[player][gameid].time_result.top)
        if cond:
            return False

        ttk.Label(frame, text=_('Minimum')
                  ).grid(row=0, column=1, padx=5, pady=5)
        ttk.Label(frame, text=_('Maximum')
                  ).grid(row=0, column=2, padx=5, pady=5)
        ttk.Label(frame, text=_('Average')
                  ).grid(row=0, column=3, padx=5, pady=5)
        # ttk.Label(frame, text=_('Total')).grid(row=0, column=4)

        s = app.stats.games_stats[player][gameid]

        row = 1
        ll = [
            (_('Playing time:'),
             format_time(s.time_result.min),
             format_time(s.time_result.max),
             format_time(s.time_result.average),
             format_time(s.time_result.total),
             s.time_result.top,
             ),
            (_('Moves:'),
             s.moves_result.min,
             s.moves_result.max,
             round(s.moves_result.average, 2),
             s.moves_result.total,
             s.moves_result.top,
             ),
            (_('Total moves:'),
             s.total_moves_result.min,
             s.total_moves_result.max,
             round(s.total_moves_result.average, 2),
             s.total_moves_result.total,
             s.total_moves_result.top,
             ),
            ]
        #  if s.score_result.min:
        #      ll.append(('Score:',
        #                 s.score_result.min,
        #                 s.score_result.max,
        #                 round(s.score_result.average, 2),
        #                 s.score_result.top,
        #                 ))
        #  if s.score_casino_result.min:
        #      ll.append(('Casino Score:',
        #                 s.score_casino_result.min,
        #                 s.score_casino_result.max,
        #                 round(s.score_casino_result.average, 2), ))
        for l, min, max, avr, tot, top in ll:
            ttk.Label(frame, text=l
                      ).grid(row=row, column=0, padx=5, pady=5)
            ttk.Label(frame, text=str(min)
                      ).grid(row=row, column=1, padx=5, pady=5)
            ttk.Label(frame, text=str(max)
                      ).grid(row=row, column=2, padx=5, pady=5)
            ttk.Label(frame, text=str(avr)
                      ).grid(row=row, column=3, padx=5, pady=5)
            # ttk.Label(frame, text=str(tot)).grid(row=row, column=4)

            def command(gameid=gameid, top=top):
                self.showTop(gameid, top)
            b = ttk.Button(frame, text=TOP_TITLE+' ...',
                           width=10, command=command)
            b.grid(row=row, column=5)
            row += 1
        return True

    def showTop(self, gameid, top):
        _TopDialog(self.dialog.top, TOP_TITLE, self.app, gameid, top)


# ************************************************************************
# *
# ************************************************************************

class ProgressionFrame(ttk.Frame):

    def __init__(self, dialog, parent, app, player, gameid, **kw):
        ttk.Frame.__init__(self, parent)

        self.mapped = False

        self.dialog = dialog
        self.app = app
        self.player = player
        self.gameid = gameid
        self.items = []
        self.formatter = ProgressionFormatter(app, player, gameid)

        frame = ttk.Frame(self)
        frame.pack(expand=True, fill='both', padx=5, pady=10)
        frame.columnconfigure(0, weight=1)

        # constants
        w = dialog.tkfont.measure('M') * 42
        w = max(w, 500)
        w = min(w, 600)
        self.canvas_width, self.canvas_height = w, 250
        cond = parent.winfo_screenwidth() < 800 or \
            parent.winfo_screenheight() < 600
        if cond:
            self.canvas_width, self.canvas_height = 400, 200
        self.xmargin, self.ymargin = 10, 10
        self.graph_dx, self.graph_dy = 10, 10
        self.played_color = '#ff7ee9'
        self.won_color = '#00dc28'
        self.percent_color = 'blue'
        # create canvas
        self.canvas = canvas = tkinter.Canvas(frame, bg='#dfe8ff', bd=0,
                                              highlightthickness=1,
                                              highlightbackground='black',
                                              width=self.canvas_width,
                                              height=self.canvas_height)
        canvas.pack(side='left', padx=5)

        # right frame
        right_frame = ttk.Frame(frame)
        right_frame.pack(side='left', fill='x', padx=5)
        self.all_games_variable = var = tkinter.StringVar()
        var.set('all')
        b = ttk.Radiobutton(right_frame, text=_('All games'),
                            variable=var, value='all',
                            command=self.updateGraph)
        b.pack(fill='x', expand=True, padx=3, pady=1)
        b = ttk.Radiobutton(right_frame, text=_('Current game'),
                            variable=var, value='current',
                            command=self.updateGraph)
        b.pack(fill='x', expand=True, padx=3, pady=1)
        label_frame = ttk.LabelFrame(right_frame, text=_('Statistics for'))
        label_frame.pack(side='top', fill='x', pady=10)
        self.variable = var = tkinter.StringVar()
        var.set('week')
        for v, t in (
            ('week',  _('Last 7 days')),
            ('month', _('Last month')),
            ('year',  _('Last year')),
            ('all',   _('All time')),
                ):
            b = ttk.Radiobutton(label_frame, text=t, variable=var,
                                value=v, command=self.updateGraph)
            b.pack(fill='x', expand=True, padx=3, pady=1)
        label_frame = ttk.LabelFrame(right_frame, text=_('Show graphs'))
        label_frame.pack(side='top', fill='x')
        self.played_graph_var = tkinter.BooleanVar()
        self.played_graph_var.set(True)
        b = ttk.Checkbutton(label_frame, text=_('Played'),
                            command=self.updateGraph,
                            variable=self.played_graph_var)
        b.pack(fill='x', expand=True, padx=3, pady=1)
        self.won_graph_var = tkinter.BooleanVar()
        self.won_graph_var.set(True)
        b = ttk.Checkbutton(label_frame, text=_('Won'),
                            command=self.updateGraph,
                            variable=self.won_graph_var)
        b.pack(fill='x', expand=True, padx=3, pady=1)
        self.percent_graph_var = tkinter.BooleanVar()
        self.percent_graph_var.set(True)
        b = ttk.Checkbutton(label_frame, text=_('% won'),
                            command=self.updateGraph,
                            variable=self.percent_graph_var)
        b.pack(fill='x', expand=True, padx=3, pady=1)

        # self.createGraph()
        bind(canvas, '<Map>', self.createGraph)

    def createGraph(self, event):
        if self.mapped:
            return
        self.mapped = True

        canvas = self.canvas

        self.text_height = self.dialog.font_metrics['linespace']
        measure = self.dialog.tkfont.measure
        self.text_width_1 = measure('XX.XX')
        self.text_width_2 = measure('XX.XX.XX')

        dir = os.path.join('images', 'stats')
        try:
            fn = self.app.dataloader.findImage('progression', dir)
            self.bg_image = loadImage(fn)
            canvas.create_image(0, 0, image=self.bg_image, anchor='nw')
        except Exception:
            pass
        #
        tw = max(measure(_('Games/day')),
                 measure(_('Games/week')),
                 measure(_('% won')))
        self.left_margin = self.xmargin+tw//2
        self.right_margin = self.xmargin+tw//2
        self.top_margin = 15+self.text_height
        self.bottom_margin = 15+self.text_height+10+self.text_height
        #
        x0, y0 = self.left_margin, self.canvas_height-self.bottom_margin
        x1, y1 = self.canvas_width-self.right_margin, self.top_margin
        canvas.create_rectangle(x0, y0, x1, y1, fill='white')
        # horizontal axis
        canvas.create_line(x0, y0, x1, y0, width=3)

        # left vertical axis
        canvas.create_line(x0, y0, x0, y1, width=3)
        t = _('Games/day')
        self.games_text_id = canvas.create_text(x0-4, y1-4, anchor='s', text=t)

        # right vertical axis
        canvas.create_line(x1, y0, x1, y1, width=3)
        canvas.create_text(x1+4, y1-4, anchor='s', text=_('% won'))

        # caption
        d = self.text_height
        x, y = self.xmargin, self.canvas_height-self.ymargin
        canvas.create_rectangle(x, y, x+d, y-d, outline='black',
                                fill=self.played_color)
        x += d+5
        canvas.create_text(x, y, anchor='sw', text=_('Played'))
        x += measure(_('Played'))+20
        canvas.create_rectangle(x, y, x+d, y-d, outline='black',
                                fill=self.won_color)
        x += d+5
        canvas.create_text(x, y, anchor='sw', text=_('Won'))
        x += measure(_('Won'))+20
        canvas.create_rectangle(x, y, x+d, y-d, outline='black',
                                fill=self.percent_color)
        x += d+5
        canvas.create_text(x, y, anchor='sw', text=_('% won'))

        self.updateGraph()

    def updateGraph(self, *args):
        interval = self.variable.get()
        canvas = self.canvas
        if self.items:
            canvas.delete(*self.items)
        self.items = []

        all_games = (self.all_games_variable.get() == 'all')
        result = self.formatter.getResults(interval, all_games)

        if interval in ('week', 'month'):
            t = _('Games/day')
        else:
            t = _('Games/week')
        canvas.itemconfig(self.games_text_id, text=t)

        graph_width = self.canvas_width-self.left_margin-self.right_margin
        graph_height = self.canvas_height-self.top_margin-self.bottom_margin
        dx = (graph_width-2*self.graph_dx)//(len(result)-1)
        graph_dx = (graph_width-(len(result)-1)*dx)//2
        dy = (graph_height-self.graph_dy)//5
        x0, y0 = self.left_margin, self.canvas_height-self.bottom_margin
        x1, y1 = self.canvas_width-self.right_margin, self.top_margin
        td = self.text_height//2

        # vertical scale
        x = x0+graph_dx
        xx = -100                       # coord. of prev. text
        for res in result:
            text = res[0]
            text_width = 0
            if text is not None:
                if len(text) == 5:      # day.month
                    text_width = self.text_width_1
                else:                   # day.month.year
                    text_width = self.text_width_2
            if text is not None and x > xx+text_width+4:
                # id = canvas.create_line(x, y0, x, y0-5, width=3)
                # self.items.append(id)
                id = canvas.create_line(x, y0, x, y1, stipple='gray50')
                self.items.append(id)
                id = canvas.create_text(x, y0+td, anchor='n', text=text)
                self.items.append(id)
                xx = x
            else:
                id = canvas.create_line(x, y0, x, y0-3, width=1)
                self.items.append(id)
            x += dx

        # horizontal scale
        max_games = max([i[1] for i in result])
        games_delta = max_games//5+1
        percent = 0
        games = 0
        for y in range(y0, y1, -dy):
            if y != y0:
                id = canvas.create_line(x0, y, x1, y, stipple='gray50')
                self.items.append(id)
            id = canvas.create_text(x0-td, y, anchor='e', text=str(games))
            self.items.append(id)
            id = canvas.create_text(x1+td, y, anchor='w', text=str(percent))
            self.items.append(id)
            games += games_delta
            percent += 20

        # draw result
        games_resolution = float(dy)/games_delta
        percent_resolution = float(dy)/20
        played_coords = []
        won_coords = []
        percent_coords = []
        x = x0+graph_dx
        for res in result:
            played, won = res[1], res[2]
            y = y0 - int(games_resolution*played)
            played_coords += [x, y]
            y = y0 - int(games_resolution*won)
            won_coords += [x, y]
            if played > 0:
                percent = int(100.*won/played)
            else:
                percent = 0
            y = y0 - int(percent_resolution*percent)
            percent_coords += [x, y]
            x += dx
        if self.played_graph_var.get():
            id = canvas.create_line(fill=self.played_color, width=3,
                                    *played_coords)
            self.items.append(id)
        if self.won_graph_var.get():
            id = canvas.create_line(fill=self.won_color, width=3,
                                    *won_coords)
            self.items.append(id)
        if self.percent_graph_var.get():
            id = canvas.create_line(fill=self.percent_color, width=3,
                                    *percent_coords)
            self.items.append(id)
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

import os
import sys

from pysollib.mfxutil import Struct
from pysollib.mygettext import _
from pysollib.ui.tktile.tkhtml import Base_HTMLViewer

from six.moves import tkinter
from six.moves import tkinter_ttk as ttk

from .statusbar import HtmlStatusbar
from .tkwidget import MfxMessageDialog

if __name__ == '__main__':
    d = os.path.abspath(os.path.join(sys.path[0], '..', '..'))
    sys.path.append(d)
    import gettext
    gettext.install('pysol', d, unicode=True)

# ************************************************************************
# *
# ************************************************************************


class HTMLViewer(Base_HTMLViewer):
    symbols_fn = {}  # filenames, loaded in Application.loadImages3
    symbols_img = {}

    def _calc_MfxMessageDialog(self):
        return MfxMessageDialog

    def __init__(self, parent, app=None, home=None):
        self.parent = parent
        self.app = app
        self.home = home
        self.url = None
        self.history = Struct(
            list=[],
            index=0,
        )
        self.visited_urls = []
        # need to keep a reference because of garbage collection
        self.images = {}
        self.defcursor = parent["cursor"]
        # self.defcursor = 'xterm'
        self.handcursor = "hand2"

        frame = ttk.Frame(parent, width=640, height=440)
        frame.pack(expand=True, fill='both')
        frame.grid_propagate(False)

        # create buttons
        button_width = 8
        self.homeButton = ttk.Button(frame, text=_("Index"),
                                     width=button_width,
                                     command=self.goHome)
        self.homeButton.grid(row=0, column=0, sticky='w')
        self.backButton = ttk.Button(frame, text=_("Back"),
                                     width=button_width,
                                     command=self.goBack)
        self.backButton.grid(row=0, column=1, sticky='w')
        self.forwardButton = ttk.Button(frame, text=_("Forward"),
                                        width=button_width,
                                        command=self.goForward)
        self.forwardButton.grid(row=0, column=2, sticky='w')
        self.closeButton = ttk.Button(frame, text=_("Close"),
                                      width=button_width,
                                      command=self.destroy)
        self.closeButton.grid(row=0, column=3, sticky='e')

        # create text widget
        text_frame = ttk.Frame(frame)
        text_frame.grid(row=1, column=0, columnspan=4,
                        sticky='nsew', padx=1, pady=1)
        vbar = ttk.Scrollbar(text_frame)
        vbar.pack(side='right', fill='y')
        self.text = tkinter.Text(text_frame,
                                 fg='black', bg='white',
                                 bd=1, relief='sunken',
                                 cursor=self.defcursor,
                                 wrap='word', padx=10)
        self.text.pack(side='left', fill='both', expand=True)
        self.text["yscrollcommand"] = vbar.set
        vbar["command"] = self.text.yview

        # statusbar
        self.statusbar = HtmlStatusbar(frame, row=2, column=0, columnspan=4)

        frame.columnconfigure(2, weight=1)
        frame.rowconfigure(1, weight=1)

        # load images
        for name, fn in self.symbols_fn.items():
            self.symbols_img[name] = self.getImage(fn)

        self.initBindings()


# ************************************************************************
# *
# ************************************************************************


def tkhtml_main(args):
    try:
        url = args[1]
    except Exception:
        url = os.path.join(os.pardir, os.pardir, "data", "html", "index.html")
    top = tkinter.Tk()
    top.tk.call("package", "require", "tile")
    top.wm_minsize(400, 200)
    viewer = HTMLViewer(top)
    viewer.app = None
    viewer.display(url)
    top.mainloop()
    return 0


if __name__ == "__main__":
    sys.exit(tkhtml_main(sys.argv))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.mygettext import _, n_
from pysollib.settings import TITLE
from pysollib.ui.tktile.findcarddialog import connect_game_find_card_dialog
from pysollib.ui.tktile.findcarddialog import destroy_find_card_dialog
from pysollib.ui.tktile.menubar import MfxMenu, PysolMenubarTkCommon
from pysollib.ui.tktile.solverdialog import connect_game_solver_dialog
from pysollib.util import CARDSET

from six.moves import tkinter_ttk as ttk

from .selectgame import SelectGameDialog, SelectGameDialogWithPreview
from .selecttile import SelectTileDialogWithPreview
from .soundoptionsdialog import SoundOptionsDialog
from .tkwidget import MfxMessageDialog

# ************************************************************************
# * - create menubar
# * - update menubar
# * - menu actions
# ************************************************************************


class PysolMenubarTk(PysolMenubarTkCommon):
    def __init__(self, app, top, progress=None):
        PysolMenubarTkCommon.__init__(self, app, top, progress)

    def _setOptions(self):
        PysolMenubarTkCommon._setOptions(self)
        tkopt, opt = self.tkopt, self.app.opt
        tkopt.theme.set(opt.tile_theme)

    def _connect_game_find_card_dialog(self, game):
        return connect_game_find_card_dialog(game)

    def _destroy_find_card_dialog(self):
        return destroy_find_card_dialog()

    def _connect_game_solver_dialog(self, game):
        return connect_game_solver_dialog(game)

    def _calcWizardDialog(self):
        from .wizarddialog import WizardDialog
        return WizardDialog

    def _calcSelectGameDialog(self):
        return SelectGameDialog

    def _calcSelectGameDialogWithPreview(self):
        return SelectGameDialogWithPreview

    def _calcSoundOptionsDialog(self):
        return SoundOptionsDialog

    def _calcSelectTileDialogWithPreview(self):
        return SelectTileDialogWithPreview

    def _calc_MfxMessageDialog(self):
        return MfxMessageDialog

    #
    # create the menubar
    #

    def mSelectCardsetDialog(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        key = self.app.nextgame.cardset.index
        cs = self.app.selectCardset(_("Select ")+CARDSET, key)
        if not cs:
            return
        self.app.nextgame.cardset = cs
        self._cancelDrag()
        self.game.endGame(bookmark=1)
        self.game.quitGame(bookmark=1)

    #
    # Tile (ttk)
    #

    def mOptTheme(self, *event):
        theme = self.tkopt.theme.get()
        self.app.opt.tile_theme = theme
        self._calc_MfxMessageDialog()(
            self.top, title=_("Change theme"),
            text=_("""\
These settings will take effect
the next time you restart %(app)s""") % {'app': TITLE},
            bitmap="warning",
            default=0, strings=(_("&OK"),))

    def createThemesMenu(self, menu):
        submenu = MfxMenu(menu, label=n_("Set t&heme"))
        all_themes = list(ttk.Style(self.top).theme_names())
        all_themes.sort()
        #
        tn = {
            'default':     n_('Default'),
            'classic':     n_('Classic'),
            'alt':         n_('Revitalized'),
            'winnative':   n_('Windows native'),
            'xpnative':    n_('XP Native'),
            'aqua':        n_('Aqua'),
            }
        for t in all_themes:
            try:
                n = tn[t]
            except KeyError:
                n = t.capitalize()
            submenu.add_radiobutton(label=n, variable=self.tkopt.theme,
                                    value=t, command=self.mOptTheme)
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

import os

from pysollib.ui.tktile.tkutil import bind

from six.moves import tkinter

from .tkwidget import MfxScrolledCanvas


class MfxTreeBaseNode:
    def __init__(self, tree, parent_node, text, key):
        self.tree = tree
        self.parent_node = parent_node
        self.text = text
        self.key = key
        # state
        self.selected = 0
        self.subnodes = None
        # canvas item ids
        self.symbol_id = None
        self.text_id = None
        self.textrect_id = None

    def registerKey(self):
        if self.key is not None:
            lst = self.tree.keys.get(self.key, [])
            lst.append(self)
            self.tree.keys[self.key] = lst

    def whoami(self):
        if self.parent_node is None:
            return (self.text, )
        else:
            return self.parent_node.whoami() + (self.text, )

    def draw(self, x, y, lastx=None, lasty=None):
        canvas, style = self.tree.canvas, self.tree.style
        topleftx = x + style.distx
        toplefty = y - style.height // 2  # +++
        # draw the horizontal line
        if lastx is not None:
            canvas.create_line(
                x, y, topleftx, y, stipple=style.linestyle,
                fill=style.linecolor)
        # draw myself - ugly, ugly...
        self.selected = 0
        self.symbol_id = -1
        self.drawSymbol(topleftx, toplefty)
        linestart = style.distx + style.width + 5
        self.text_id = -1
        self.drawText(x + linestart, y)
        return x, y, x, y + style.disty

    #
    #
    #

    def drawText(self, x, y):
        canvas, style = self.tree.canvas, self.tree.style
        if self.selected:
            fg, bg = style.text_selected_fg, style.text_selected_bg
        else:
            fg, bg = style.text_normal_fg, style.text_normal_bg
        #
        if self.tree.nodes.get(self.text_id) is self:
            canvas.itemconfig(self.text_id, fill=fg)
        else:
            # note: I don't use Label + canvas.create_window here
            #   because it doesn't propagate events to the canvas
            #   and has some other re-display annoyances
            # print 'style.font:', style.font
            self.text_id = canvas.create_text(x+1, y, text=self.text,
                                              anchor="w", justify="left",
                                              font=style.font,
                                              fill=fg)
            self.tree.nodes[self.text_id] = self
        #
        if self.tree.nodes.get(self.textrect_id) is self:
            try:
                # _tkinter.TclError: unknown option "-fill" ???
                canvas.itemconfig(self.textrect_id, fill=bg)
            except tkinter.TclError:
                pass
        elif self.selected:
            b = canvas.bbox(self.text_id)
            self.textrect_id = canvas.create_rectangle(
                b[0]-1, b[1]-1, b[2]+1, b[3]+1,
                fill=bg, outline="")
            canvas.tag_lower(self.textrect_id, self.text_id)
            self.tree.nodes[self.textrect_id] = self

    def updateText(self):
        if self.tree.nodes.get(self.text_id) is self:
            self.drawText(-1, -1)

    #
    #
    #

    def drawSymbol(self, x, y, **kw):
        canvas, style = self.tree.canvas, self.tree.style
        color = kw.get("color")
        if color is None:
            if self.selected:
                color = "darkgreen"
            else:
                color = "green"
        # note: rectangle outline is one pixel
        if self.tree.nodes.get(self.symbol_id) is self:
            canvas.itemconfig(self.symbol_id, fill=color)
        else:
            self.symbol_id = canvas.create_rectangle(
                x+1, y+1, x + style.width, y + style.height, fill=color)
            self.tree.nodes[self.symbol_id] = self

    def updateSymbol(self):
        if self.tree.nodes.get(self.symbol_id) is self:
            self.drawSymbol(-1, -1)


# ************************************************************************
# * Terminal and non-terminal nodes
# ************************************************************************

class MfxTreeLeaf(MfxTreeBaseNode):
    def drawText(self, x, y):
        if self.text_id < 0:
            self.registerKey()
        MfxTreeBaseNode.drawText(self, x, y)


class MfxTreeNode(MfxTreeBaseNode):
    def __init__(self, tree, parent_node, text, key, expanded=0):
        MfxTreeBaseNode.__init__(self, tree, parent_node, text, key)
        self.expanded = expanded

    def drawChildren(self, x, y, lastx, lasty):
        # get subnodes
        self.subnodes = self.tree.getContents(self)
        # draw subnodes
        lx, ly = lastx, lasty
        nx, ny = x, y
        for node in self.subnodes:
            # update tree
            node.tree = self.tree
            # draw node
            lx, ly, nx, ny = node.draw(nx, ny, lx, ly)
        # draw the vertical line
        if self.subnodes:
            style = self.tree.style
            dy = (style.disty-style.width)//2
            y = y-style.disty//2-dy
            self.tree.canvas.create_line(x, y, nx, ly,
                                         stipple=style.linestyle,
                                         fill=style.linecolor)
        return ny

    def draw(self, x, y, ilastx=None, ilasty=None):
        # draw myself
        lx, ly, nx, ny = MfxTreeBaseNode.draw(self, x, y, ilastx, ilasty)
        if self.expanded:
            style = self.tree.style
            childx = nx + style.distx + style.width // 2
            childy = ny
            clastx = nx + style.distx + style.width // 2
            clasty = ly + style.height // 2
            ny = self.drawChildren(childx, childy, clastx, clasty)
        return lx, ly, x, ny

    #
    #
    #

    def drawSymbol(self, x, y, **kw):
        color = kw.get("color")
        if color is None:
            if self.expanded:
                color = "red"
            else:
                color = "pink"
        MfxTreeBaseNode.drawSymbol(self, x, y, color=color)


# ************************************************************************
# *
# ************************************************************************

class MfxTreeInCanvas(MfxScrolledCanvas):
    class Style:
        def __init__(self):
            self.distx = 16
            self.disty = 18
            self.width = 16         # width of symbol
            self.height = 16        # height of symbol
            self.originx = 0
            self.originy = 0
            self.text_normal_fg = "black"
            self.text_normal_bg = "white"
            self.text_selected_fg = "white"
            self.text_selected_bg = "#00008b"       # "darkblue"
            self.font = None
            self.linestyle = "gray50"
            self.linecolor = "black"

    def __init__(self, parent, rootnodes, **kw):
        kw['bd'] = 0
        kw['bg'] = 'white'
        MfxScrolledCanvas.__init__(self, parent, **kw)
        #
        self.rootnodes = rootnodes
        self.updateNodesWithTree(self.rootnodes, self)
        self.selection_key = None
        self.nodes = {}
        self.keys = {}
        #
        self.style = self.Style()
        # self.style.text_normal_fg = self.canvas.cget("insertbackground")
        # self.style.text_normal_fg = \
        #   self.canvas.option_get('foreground', '') or \
        #   self.canvas.cget("insertbackground")
        # self.style.text_normal_bg = self.canvas.option_get(
        #   'background', self.canvas.cget("background"))
        #
        bind(self.canvas, "<ButtonPress-1>", self.singleClick)
        bind(self.canvas, "<Double-Button-1>", self.doubleClick)
        # bind(self.canvas, "<ButtonRelease-1>", xxx)
        self.pack(fill='both', expand=True)

    def destroy(self):
        for node in self.keys.get(self.selection_key, []):
            node.selected = 0
        MfxScrolledCanvas.destroy(self)

    def findNode(self, event=None):
        id = self.canvas.find_withtag('current')
        if id:
            return self.nodes.get(id[0])
        return None

    #
    # draw nodes
    #

    def draw(self):
        nx, ny = self.style.originx, self.style.originy
        # Account for initial offsets, see topleft[xy] in BaseNode.draw().
        # We do this so that our bounding box always starts at (0,0)
        # and the yscrollincrement works nicely.
        nx -= self.style.distx
        ny += self.style.height // 2
        for node in self.rootnodes:
            # update tree
            node.tree = self
            # draw
            try:
                lx, ly, nx, ny = node.draw(nx, ny, None, None)
            except tkinter.TclError:
                # FIXME: Tk bug ???
                raise
        # set scroll region
        bbox = self.canvas.bbox("all")
        # self.canvas.config(scrollregion=bbox)
        # self.canvas.config(scrollregion=(0,0,bbox[2],bbox[3]))
        dx, dy = 8, 0  # margins
        self.canvas.config(scrollregion=(-dx, -dy, bbox[2]+dx, bbox[3]+dy))
        self.canvas.config(yscrollincrement=self.style.disty)

    def clear(self):
        self.nodes = {}
        self.keys = {}
        self.canvas.delete("all")

    def redraw(self):
        oldcur = self.canvas["cursor"]
        self.canvas["cursor"] = "watch"
        self.canvas.update_idletasks()
        self.clear()
        self.draw()
        self.updateSelection(self.selection_key)
        self.canvas["cursor"] = oldcur

    #
    #
    #

    def getContents(self, node):
        # Overload this, supposed to return a list of subnodes of node.
        pass

    def singleClick(self, event=None):
        # Overload this if you want to know when a node is clicked on.
        pass

    def doubleClick(self, event=None):
        # Overload this if you want to know when a node is d-clicked on.
        self.singleClick(event)

    #
    #
    #

    def updateSelection(self, key):
        l1 = self.keys.get(self.selection_key, [])
        l2 = self.keys.get(key, [])
        for node in l1:
            if node.selected and node not in l2:
                node.selected = 0
                node.updateSymbol()
                node.updateText()
        for node in l2:
            if not node.selected:
                node.selected = 1
                node.updateSymbol()
                node.updateText()
        self.selection_key = key

    def updateNodesWithTree(self, nodes, tree):
        for node in nodes:
            node.tree = tree
            if node.subnodes:
                self.updateNodesWithTree(node.subnodes, tree)


# ************************************************************************
# *
# ************************************************************************


class DirectoryBrowser(MfxTreeInCanvas):
    def __init__(self, parent, dirs):
        nodes = []
        if isinstance(dirs, str):
            dirs = (dirs,)
        for dir in dirs:
            self.addNode(nodes, None, dir, dir)
        # note: best results if height is a multiple of style.disty
        MfxTreeInCanvas.__init__(self, parent, nodes, height=25*18)
        self.draw()

    def addNode(self, list, node, filename, text):
        try:
            if os.path.isdir(filename):
                list.append(MfxTreeNode(self, node, text, key=filename))
            else:
                list.append(MfxTreeLeaf(self, node, text, key=filename))
        except EnvironmentError:
            pass

    def getContents(self, node):
        # use cached values
        if node.subnodes is not None:
            return node.subnodes
        #
        dir = node.key
        print("Getting %s" % dir)
        try:
            filenames = os.listdir(dir)
            filenames.sort()
        except EnvironmentError:
            return ()
        contents = []
        for filename in filenames:
            self.addNode(contents, node, os.path.join(dir, filename), filename)
        # print "gotten"
        return contents

    def singleClick(self, event=None):
        node = self.findNode(event)
        if not node:
            return
        print("Clicked node %s %s" % (node.text, node.key))
        if isinstance(node, MfxTreeLeaf):
            self.updateSelection(key=node.key)
        elif isinstance(node, MfxTreeNode):
            node.expanded = not node.expanded
            self.redraw()
        return "break"


if __name__ == "__main__":
    tk = tkinter.Tk()
    if os.name == "nt":
        app = DirectoryBrowser(tk, ("c:\\", "c:\\windows"))
    else:
        app = DirectoryBrowser(tk, ("/", "/home"))
    tk.mainloop()
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

from pysollib.mfxutil import KwStruct
from pysollib.mygettext import _
from pysollib.ui.tktile.tkutil import bind

from six.moves import tkinter
from six.moves import tkinter_font
from six.moves import tkinter_ttk as ttk

from .tkwidget import MfxDialog
from .tkwidget import PysolScale


# ************************************************************************
# *
# ************************************************************************

class FontChooserDialog(MfxDialog):
    def __init__(self, parent, title, init_font, **kw):
        # print init_font
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.createBitmaps(top_frame, kw)

        self.font_family = 'Helvetica'
        self.font_size = 12
        self.font_weight = 'normal'
        self.font_slant = 'roman'

        if init_font is not None:
            assert 2 <= len(init_font) <= 4
            assert isinstance(init_font[1], int)
            self.font_family, self.font_size = init_font[:2]
            if len(init_font) > 2:
                if init_font[2] in ['bold', 'normal']:
                    self.font_weight = init_font[2]
                elif init_font[2] in ['italic', 'roman']:
                    self.font_slant = init_font[2]
                else:
                    raise ValueError('invalid font style: '+init_font[2])
                if len(init_font) > 3:
                    if init_font[3] in ['bold', 'normal']:
                        self.font_weight = init_font[3]
                    elif init_font[2] in ['italic', 'roman']:
                        self.font_slant = init_font[3]
                    else:
                        raise ValueError('invalid font style: '+init_font[3])

        # self.family_var = tkinter.StringVar()
        self.weight_var = tkinter.BooleanVar()
        self.weight_var.set(self.font_weight == 'bold')
        self.slant_var = tkinter.BooleanVar()
        self.slant_var.set(self.font_slant == 'italic')
        self.size_var = tkinter.IntVar()
        self.size_var.set(self.font_size)
        #
        frame = ttk.Frame(top_frame)
        frame.pack(expand=True, fill='both', padx=5, pady=10)
        frame.columnconfigure(0, weight=1)
        # frame.rowconfigure(1, weight=1)
        self.entry = ttk.Entry(frame)
        self.entry.grid(row=0, column=0, columnspan=2, sticky='news')
        self.entry.insert('end', _('abcdefghABCDEFGH'))
        self.list_box = tkinter.Listbox(frame, width=36, exportselection=False)
        sb = ttk.Scrollbar(frame)
        self.list_box.configure(yscrollcommand=sb.set)
        sb.configure(command=self.list_box.yview)
        self.list_box.grid(row=1, column=0, sticky='news')  # rowspan=4
        sb.grid(row=1, column=1, sticky='ns')
        bind(self.list_box, '<<ListboxSelect>>', self.fontupdate)
        # self.list_box.focus()
        cb1 = ttk.Checkbutton(frame, text=_('Bold'),
                              command=self.fontupdate,
                              variable=self.weight_var)
        cb1.grid(row=2, column=0, columnspan=2, sticky='we')
        cb2 = ttk.Checkbutton(frame, text=_('Italic'),
                              command=self.fontupdate,
                              variable=self.slant_var)
        cb2.grid(row=3, column=0, columnspan=2, sticky='we')

        sc = PysolScale(frame, from_=6, to=40, resolution=1,
                        label=_('Size:'), orient='horizontal',
                        command=self.fontupdate, variable=self.size_var)
        sc.grid(row=4, column=0, columnspan=2, sticky='news')
        #
        font_families = list(tkinter_font.families())
        font_families.sort()
        selected = -1
        n = 0
        self.list_box.insert('end', *font_families)
        for font in font_families:
            if font.lower() == self.font_family.lower():
                selected = n
                break
            n += 1
        if selected >= 0:
            self.list_box.select_set(selected)
            self.list_box.see(selected)
        #
        focus = self.createButtons(bottom_frame, kw)
        self.mainloop(focus, kw.timeout)

        self.font = (self.font_family, self.font_size,
                     self.font_slant, self.font_weight)

    def fontupdate(self, *args):
        if self.list_box.curselection():
            self.font_family = self.list_box.get(self.list_box.curselection())
        self.font_weight = self.weight_var.get() and 'bold' or 'normal'
        self.font_slant = self.slant_var.get() and 'italic' or 'roman'
        self.font_size = self.size_var.get()
        self.entry.configure(font=(self.font_family, self.font_size,
                                   self.font_slant, self.font_weight))

    def initKw(self, kw):
        kw = KwStruct(kw,
                      strings=(_("&OK"), _("&Cancel")),
                      default=0,
                      )
        return MfxDialog.initKw(self, kw)

# ************************************************************************
# *
# ************************************************************************


class FontsDialog(MfxDialog):
    def __init__(self, parent, title, app, **kw):
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.createBitmaps(top_frame, kw)

        frame = ttk.Frame(top_frame)
        frame.pack(expand=True, fill='both', padx=5, pady=10)
        frame.columnconfigure(0, weight=1)

        self.fonts = {}
        row = 0
        for fn, title in (  # ('default',        _('Default')),
                          ('sans',           _('HTML: ')),
                          ('small',          _('Small: ')),
                          ('fixed',          _('Fixed: ')),
                          ('canvas_default', _('Tableau default: ')),
                          ('canvas_fixed',   _('Tableau fixed: ')),
                          ('canvas_large',   _('Tableau large: ')),
                          ('canvas_small',   _('Tableau small: ')),
                          ):
            font = app.opt.fonts[fn]
            self.fonts[fn] = font
            ttk.Label(frame, text=title, anchor='w'
                      ).grid(row=row, column=0, sticky='we')
            if font:
                title = ' '.join(
                    [str(i) for i in font if i not in ('roman', 'normal')])
            elif font is None:
                title = 'Default'
            label = ttk.Label(frame, font=font, text=title)
            label.grid(row=row, column=1, padx=8)
            b = ttk.Button(frame, text=_('Change...'), width=10,
                           command=lambda label=label,
                           fn=fn: self.selectFont(label, fn))
            b.grid(row=row, column=2)
            row += 1
        #
        focus = self.createButtons(bottom_frame, kw)
        self.mainloop(focus, kw.timeout)

    def selectFont(self, label, fn):
        d = FontChooserDialog(self.top, _('Select font'), self.fonts[fn])
        if d.status == 0 and d.button == 0:
            self.fonts[fn] = d.font
            title = ' '.join(
                [str(i) for i in d.font if i not in ('roman', 'normal')])
            label.configure(font=d.font, text=title)

    def initKw(self, kw):
        kw = KwStruct(kw,
                      strings=(_('&OK'), _('&Cancel')),
                      default=0,
                      )
        return MfxDialog.initKw(self, kw)
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.mfxutil import KwStruct
from pysollib.mygettext import _
from pysollib.ui.tktile.selecttree import SelectDialogTreeData

import six
from six.moves import tkinter
from six.moves import tkinter_colorchooser
from six.moves import tkinter_ttk as ttk

from .selecttree import SelectDialogTreeCanvas
from .selecttree import SelectDialogTreeLeaf, SelectDialogTreeNode
from .tkwidget import MfxDialog, MfxScrolledCanvas


# ************************************************************************
# * Nodes
# ************************************************************************

class SelectTileLeaf(SelectDialogTreeLeaf):
    pass


class SelectTileNode(SelectDialogTreeNode):
    def _getContents(self):
        contents = []
        for obj in self.tree.data.all_objects:
            if self.select_func(obj):
                node = SelectTileLeaf(
                    self.tree, self, text=obj.name, key=obj.index)
                contents.append(node)
        return contents or self.tree.data.no_contents


# ************************************************************************
# * Tree database
# ************************************************************************

class SelectTileData(SelectDialogTreeData):
    def __init__(self, manager, key):
        SelectDialogTreeData.__init__(self)
        self.all_objects = manager.getAllSortedByName()
        self.all_objects = [obj for obj in self.all_objects if not obj.error]
        self.all_objects = [tile for tile in self.all_objects
                            if tile.index > 0 and tile.filename]
        self.no_contents = [SelectTileLeaf(
            None, None, _("(no tiles)"), key=None), ]
        e1 = isinstance(key, str) or len(self.all_objects) <= 17
        e2 = 1
        self.rootnodes = (
            SelectTileNode(None, _("Solid Colors"), (
                SelectTileLeaf(None, None, _("Blue"), key="#0082df"),
                SelectTileLeaf(None, None, _("Green"), key="#008200"),
                SelectTileLeaf(None, None, _("Navy"), key="#000086"),
                SelectTileLeaf(None, None, _("Olive"), key="#868200"),
                SelectTileLeaf(None, None, _("Orange"), key="#f79600"),
                SelectTileLeaf(None, None, _("Teal"), key="#008286"),
            ), expanded=e1),
            SelectTileNode(
                None, _("All Backgrounds"),
                lambda tile: 1, expanded=e2),
        )


# ************************************************************************
# * Canvas that shows the tree
# ************************************************************************

class SelectTileTree(SelectDialogTreeCanvas):
    data = None


# ************************************************************************
# * Dialog
# ************************************************************************

class SelectTileDialogWithPreview(MfxDialog):
    Tree_Class = SelectTileTree
    TreeDataHolder_Class = SelectTileTree
    TreeData_Class = SelectTileData

    def __init__(self, parent, title, app, manager, key=None, **kw):
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.createBitmaps(top_frame, kw)
        #
        if key is None:
            key = manager.getSelected()
        self.app = app
        self.manager = manager
        self.key = key
        self.table_color = app.opt.colors['table']
        if self.TreeDataHolder_Class.data is None:
            self.TreeDataHolder_Class.data = self.TreeData_Class(manager, key)
        #
        self.top.wm_minsize(400, 200)
        if self.top.winfo_screenwidth() >= 800:
            w1, w2 = 200, 400
        else:
            w1, w2 = 200, 300
        font = app.getFont("default")
        padx, pady = 4, 4
        frame = ttk.Frame(top_frame)
        frame.pack(fill='both', expand=True,
                   padx=kw.padx-padx, pady=kw.pady-pady)
        self.tree = self.Tree_Class(self, frame, key=key, default=kw.default,
                                    font=font, width=w1)
        self.tree.frame.pack(side="left", fill='both', expand=False,
                             padx=padx, pady=pady)
        self.preview = MfxScrolledCanvas(frame, width=w2, hbar=0, vbar=0)
        self.preview.pack(side="right", fill='both', expand=True,
                          padx=padx, pady=pady)
        self.preview.canvas.preview = 1
        # create a preview of the current state
        self.preview_key = -1
        self.updatePreview(key)
        #
        focus = self.createButtons(bottom_frame, kw)
        focus = self.tree.frame
        self.mainloop(focus, kw.timeout)

    def destroy(self):
        self.tree.updateNodesWithTree(self.tree.rootnodes, None)
        self.tree.destroy()
        self.preview.unbind_all()
        MfxDialog.destroy(self)

    def initKw(self, kw):
        kw = KwStruct(kw,
                      strings=((_("&Solid color..."), 10),
                               'sep', _("&OK"), _("&Cancel"),),
                      default=0,
                      resizable=True,
                      font=None,
                      padx=10, pady=10,
                      )
        return MfxDialog.initKw(self, kw)

    def mDone(self, button):
        if button == 0:        # "OK" or double click
            if isinstance(self.tree.selection_key, six.string_types):
                self.key = str(self.tree.selection_key)
            else:
                self.key = self.tree.selection_key
            self.tree.n_expansions = 1  # save xyview in any case
        if button == 10:        # "Solid color..."
            try:
                c = tkinter_colorchooser.askcolor(
                    master=self.top,
                    initialcolor=self.table_color,
                    title=_("Select table color"))
            except tkinter.TclError:
                pass
            else:
                if c and c[1]:
                    color = str(c[1])
                    self.key = color.lower()
                    self.table_color = self.key
                    self.tree.updateSelection(self.key)
                    self.updatePreview(self.key)
            return
        MfxDialog.mDone(self, button)

    def updatePreview(self, key):
        if key == self.preview_key:
            return
        canvas = self.preview.canvas
        canvas.deleteAllItems()
        if isinstance(key, six.string_types):
            # solid color
            canvas.config(bg=key)
            canvas.setTile(None)
            canvas.setTextColor(None)
            self.preview_key = key
            self.table_color = key
        else:
            # image
            tile = self.manager.get(key)
            if tile:
                if self.preview.setTile(self.app, key):
                    return
            self.preview_key = -1
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

from pysollib.ui.tktile.tkconst import EVENT_HANDLED
from pysollib.ui.tktile.tkutil import makeToplevel, setTransient

from six.moves import tkinter
from six.moves import tkinter_ttk as ttk

# ************************************************************************
# * a simple progress bar
# ************************************************************************


class PysolProgressBar:
    def __init__(self, app, parent, title=None, images=None, color="blue",
                 width=300, height=25, show_text=1, norm=1):
        self.parent = parent
        self.percent = 0
        self.top = makeToplevel(parent, title=title)
        self.top.wm_protocol("WM_DELETE_WINDOW", self.wmDeleteWindow)
        self.top.wm_group(parent)
        self.top.wm_resizable(False, False)
        self.top.config(cursor="watch")
        #
        self.frame = ttk.Frame(self.top, relief='flat', borderwidth=0)
        self.progress = ttk.Progressbar(self.frame, maximum=100, length=250)
        # style = ttk.Style(self.progress)
        # style.configure('TProgressbar', background=color)
        if images:
            self.f1 = ttk.Label(self.frame, image=images[0])
            self.f1.pack(side='left', ipadx=8, ipady=4)
            self.progress.pack(side='left', expand=True, fill='x')
            self.f2 = ttk.Label(self.frame, image=images[1])
            self.f2.pack(side='left', ipadx=8, ipady=4)
        else:
            self.progress.pack(expand=True, fill='x')
        self.frame.pack(expand=True, fill='both')
        if 1:
            setTransient(self.top, None, relx=0.5, rely=0.5)
        else:
            self.update(percent=0)
        self.norm = norm
        self.steps_sum = 0

    def wmDeleteWindow(self):
        return EVENT_HANDLED

    def destroy(self):
        if self.top is None:        # already destroyed
            return
        self.top.wm_withdraw()
        self.top.quit()
        self.top.destroy()
        self.top = None

    def reset(self, percent=0):
        self.percent = percent

    def update(self, percent=None, step=1):
        self.steps_sum += step
        # print self.steps_sum
        step = step/self.norm
        if self.top is None:        # already destroyed
            return
        if percent is None:
            self.percent = self.percent + step
        elif percent > self.percent:
            self.percent = percent
        else:
            return
        self.percent = min(100, max(0, self.percent))
        self.progress.config(value=self.percent)
        # self.top.update_idletasks()
        self.top.update()


# ************************************************************************
# *
# ************************************************************************


class TestProgressBar:
    def __init__(self, parent):
        self.parent = parent
        self.progress = PysolProgressBar(
            None, parent, title="Progress", color="#008200")
        self.progress.pack(ipadx=10, ipady=10)
        self.progress.frame.after(1000, self.update)

    def update(self, event=None):
        if self.progress.percent >= 100:
            self.parent.after_idle(self.progress.destroy)
            return
        self.progress.update(step=1)
        self.progress.frame.after(30, self.update)


def progressbar_main(args):
    from pysollib.ui.tktile.tkutil import wm_withdraw
    tk = tkinter.Tk()
    wm_withdraw(tk)
    TestProgressBar(tk)
    tk.mainloop()
    return 0


if __name__ == "__main__":
    import sys
    sys.exit(progressbar_main(sys.argv))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

import locale
import os
import time
import traceback

from pysollib.mfxutil import KwStruct, destruct, kwdefault, openURL
from pysollib.mygettext import _
from pysollib.settings import WIN_SYSTEM
from pysollib.ui.tktile.tkcanvas import MfxCanvas
from pysollib.ui.tktile.tkutil import after, after_cancel
from pysollib.ui.tktile.tkutil import bind, unbind_destroy
from pysollib.ui.tktile.tkutil import makeToplevel, setTransient

import six
from six import PY2
from six.moves import tkinter
from six.moves import tkinter_font
from six.moves import tkinter_ttk as ttk

# ************************************************************************
# * abstract base class for the dialogs in this module
# ************************************************************************


class MfxDialog:  # ex. _ToplevelDialog
    img = {}
    button_img = {}

    def __init__(self, parent, title="", resizable=False, default=-1):
        self.parent = parent
        self.status = 0
        self.button = default
        self.timer = None
        self.buttons = []
        self.accel_keys = {}
        self.top = makeToplevel(parent, title=title)
        # self._frame = ttk.Frame(self.top)
        # self._frame.pack(expand=True, fill='both')
        self._frame = self.top
        self.top.wm_resizable(resizable, resizable)
        # w, h = self.top.winfo_screenwidth(), self.top.winfo_screenheight()
        # self.top.wm_maxsize(w-4, h-32)
        bind(self.top, "WM_DELETE_WINDOW", self.wmDeleteWindow)

    def mainloop(self, focus=None, timeout=0, transient=True):
        bind(self.top, "<Escape>", self.mCancel)
        bind(self.top, '<Alt-Key>', self.altKeyEvent)  # for accelerators
        if focus is not None:
            focus.focus()
        if transient:
            setTransient(self.top, self.parent)
            try:
                self.top.grab_set()
            except tkinter.TclError:
                if traceback:
                    traceback.print_exc()
                pass
            if timeout > 0:
                self.timer = after(self.top, timeout, self.mTimeout)
            try:
                self.top.mainloop()
            except SystemExit:
                pass
            self.destroy()

    def destroy(self):
        after_cancel(self.timer)
        unbind_destroy(self.top)
        self.top.destroy()
        self.top.update_idletasks()
        self.top = None
        self.parent = None

    def wmDeleteWindow(self, *event):
        self.status = 1
        raise SystemExit
        # return EVENT_HANDLED

    def mCancel(self, *event):
        self.status = 1
        raise SystemExit

    def mTimeout(self, *event):
        self.status = 2
        raise SystemExit

    def mDone(self, button):
        self.button = button
        raise SystemExit

    def altKeyEvent(self, event):
        widget = None
        if event.keysym in self.accel_keys:
            widget = self.accel_keys[event.keysym]
        else:
            key = event.char
            try:
                if os.name == 'nt':
                    key = six.text_type(key, locale.getpreferredencoding())
                else:
                    key = six.text_type(key, 'utf-8')
            except Exception:
                pass
            else:
                key = key.lower()
                widget = self.accel_keys.get(key)
        if widget is not None:
            widget.event_generate('<<Invoke>>')

    def initKw(self, kw):
        kw = KwStruct(kw,
                      timeout=0, resizable=False,
                      text="", justify="center",
                      strings=(_("&OK"),),
                      default=0,
                      width=0,
                      padx=20, pady=20,
                      bitmap=None, bitmap_side="left",
                      bitmap_padx=10, bitmap_pady=20,
                      image=None, image_side="left",
                      image_padx=10, image_pady=20,
                      )
        # default to separator if more than one button
        sep = len(kw.strings) > 1
        kwdefault(kw.__dict__, separator=sep)
        return kw

    def createFrames(self, kw):
        bottom_frame = ttk.Frame(self._frame, relief='flat', borderwidth=4)
        bottom_frame.pack(side='bottom', fill='both', expand=False)
        if kw.separator:
            separator = ttk.Separator(self._frame)
            separator.pack(side='bottom', fill='x')
        top_frame = ttk.Frame(self._frame)
        top_frame.pack(side='top', fill='both', expand=1)
        return top_frame, bottom_frame

    def createBitmaps(self, frame, kw):
        if kw.bitmap:  # in ("error", "info", "question", "warning")
            img = self.img.get(kw.bitmap)
            b = ttk.Label(frame, image=img)
            b.pack(side=kw.bitmap_side,
                   padx=kw.bitmap_padx, pady=kw.bitmap_pady)
        elif kw.image:
            b = ttk.Label(frame, image=kw.image)
            b.pack(side=kw.image_side, padx=kw.image_padx, pady=kw.image_pady)

    def createButtons(self, frame, kw):
        padx, pady = 4, 4
        xbutton = column = -1
        focus = None
        max_len = 0
        if 'sep' in kw.strings:
            sep_column = list(kw.strings).index('sep')
            strings = kw.strings[sep_column+1:]
        else:
            sep_column = 0
            strings = kw.strings
        for s in strings:
            if isinstance(s, tuple):
                s = s[0]
            if s:
                s = s.replace('&', '')
                max_len = max(max_len, len(s))
            # print s, len(s)
        if max_len > 12 and WIN_SYSTEM == 'x11':
            button_width = max_len
        elif max_len > 9:
            button_width = max_len+1
        elif max_len > 6:
            button_width = max_len+2
        else:
            button_width = 8
        #
        for s in kw.strings:
            if s is None:
                xbutton += 1
                continue
            if s == 'sep':
                column += 1
                continue
            if isinstance(s, tuple):
                assert len(s) == 2
                button = int(s[1])
                s = s[0]
            else:
                xbutton += 1
                button = xbutton
            accel_indx = s.find('&')
            button_img = None
            if MfxDialog.button_img:
                button_img = MfxDialog.button_img.get(s)
            s = s.replace('&', '')
            if button < 0:
                widget = ttk.Button(frame, text=s, state="disabled")
            else:
                widget = ttk.Button(
                    frame, text=s, default="normal",
                    command=lambda self=self, button=button:
                    self.mDone(button))
                if button == kw.default:
                    focus = widget
                    focus.config(default="active")
            self.buttons.append(widget)
            #
            column += 1
            if column >= sep_column:
                widget.config(width=button_width)
            else:
                widget.config(width=max(button_width, len(s)))
            if accel_indx >= 0:
                # key accelerator
                widget.config(underline=accel_indx)
                key = s[accel_indx]
                self.accel_keys[key.lower()] = widget
            #
            if button_img:
                widget.config(compound='left', image=button_img)
            widget.grid(
                column=column, row=0, sticky="nse", padx=padx, pady=pady)
        if focus is not None:
            def cb(event=None, w=focus):
                return w.event_generate('<<Invoke>>')
            bind(self.top, "<Return>", cb)
            bind(self.top, "<KP_Enter>", cb)
        # right justify
        frame.columnconfigure(sep_column, weight=1)
        return focus


# ************************************************************************
# * replacement for the tk_dialog script
# ************************************************************************

class MfxMessageDialog(MfxDialog):
    def __init__(self, parent, title, **kw):
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.createBitmaps(top_frame, kw)
        #
        self.button = kw.default
        msg = ttk.Label(top_frame, text=kw.text, justify=kw.justify,
                        width=kw.width)
        msg.pack(fill='both', expand=True, padx=kw.padx, pady=kw.pady)
        #
        focus = self.createButtons(bottom_frame, kw)
        self.mainloop(focus, kw.timeout)


# ************************************************************************
# *
# ************************************************************************

class MfxExceptionDialog(MfxMessageDialog):
    def __init__(self, parent, ex, title="Error", **kw):
        kw = KwStruct(kw, bitmap="error")
        text = kw.get("text", "")
        if not text.endswith("\n"):
            text = text + "\n"
        text = text + "\n"
        if isinstance(ex, EnvironmentError) and ex.filename is not None:
            t = "[Errno %s] %s:\n%s" % \
                (ex.errno, ex.strerror, repr(ex.filename))
        else:
            t = str(ex)
        if PY2:
            t = six.text_type(t, errors='replace')
        kw.text = text + t
        MfxMessageDialog.__init__(self, parent, title, **kw.getKw())


# ************************************************************************
# *
# ************************************************************************

class PysolAboutDialog(MfxMessageDialog):
    def __init__(self, app, parent, title, **kw):
        self._url = kw['url']
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.createBitmaps(top_frame, kw)
        #
        self.button = kw.default
        frame = ttk.Frame(top_frame)
        frame.pack(fill='both', expand=True, padx=kw.padx, pady=kw.pady)
        msg = ttk.Label(frame, text=kw.text, justify=kw.justify,
                        width=kw.width)
        msg.pack(fill='both', expand=True)

        # font_name = msg.lookup('TLabel', 'font')
        font_name = 'TkDefaultFont'
        font = tkinter_font.Font(parent, name=font_name, exists=True)
        font = font.copy()
        font.configure(underline=True)
        url_label = ttk.Label(frame, text=kw.url, font=font,
                              foreground='blue', cursor='hand2')
        url_label.pack()
        url_label.bind('<1>', self._urlClicked)
        #
        focus = self.createButtons(bottom_frame, kw)
        self.mainloop(focus, kw.timeout)

    def _urlClicked(self, event):
        openURL(self._url)


# ************************************************************************
# *
# ************************************************************************

class MfxSimpleEntry(MfxDialog):
    def __init__(self, parent, title, label, value, **kw):
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.createBitmaps(top_frame, kw)
        #
        self.value = value
        if label:
            label = ttk.Label(top_frame, text=label, takefocus=0)
            label.pack(pady=5)
        w = kw.get("e_width", 0)    # width in characters
        self.var = ttk.Entry(top_frame, exportselection=1, width=w)
        self.var.insert(0, value)
        self.var.pack(side='top', padx=kw.padx, pady=kw.pady)
        #
        focus = self.createButtons(bottom_frame, kw)
        focus = self.var
        self.mainloop(focus, kw.timeout)

    def initKw(self, kw):
        kw = KwStruct(kw,
                      strings=(_("&OK"), _("&Cancel")), default=0,
                      separator=False,
                      )
        return MfxDialog.initKw(self, kw)

    def mDone(self, button):
        self.button = button
        self.value = self.var.get()
        raise SystemExit


# ************************************************************************
# * a simple tooltip
# ************************************************************************

class MfxTooltip:
    last_leave_time = 0

    def __init__(self, widget):
        # private vars
        self.widget = widget
        self.text = None
        self.timer = None
        self.cancel_timer = None
        self.tooltip = None
        self.label = None
        self.bindings = []
        self.bindings.append(self.widget.bind("<Enter>", self._enter))
        self.bindings.append(self.widget.bind("<Leave>", self._leave))
        self.bindings.append(self.widget.bind("<ButtonPress>", self._leave))
        # user overrideable settings
        self.timeout = 800                    # milliseconds
        self.cancel_timeout = 5000
        self.leave_timeout = 400
        self.relief = 'solid'
        self.justify = 'left'
        self.fg = "#000000"
        self.bg = "#ffffe0"
        self.xoffset = 0
        self.yoffset = 4

    def setText(self, text):
        self.text = text

    def _unbind(self):
        if self.bindings and self.widget:
            self.widget.unbind("<Enter>", self.bindings[0])
            self.widget.unbind("<Leave>", self.bindings[1])
            self.widget.unbind("<ButtonPress>", self.bindings[2])
            self.bindings = []

    def destroy(self):
        self._unbind()
        self._leave()

    def _enter(self, *event):
        after_cancel(self.timer)
        after_cancel(self.cancel_timer)
        self.cancel_timer = None
        if time.time() - MfxTooltip.last_leave_time < self.leave_timeout/1000.:
            self._showTip()
        else:
            self.timer = after(self.widget, self.timeout, self._showTip)

    def _leave(self, *event):
        after_cancel(self.timer)
        after_cancel(self.cancel_timer)
        self.timer = self.cancel_timer = None
        if self.tooltip:
            self.label.destroy()
            destruct(self.label)
            self.label = None
            self.tooltip.destroy()
            destruct(self.tooltip)
            self.tooltip = None
            MfxTooltip.last_leave_time = time.time()

    def _showTip(self):
        self.timer = None
        if self.tooltip or not self.text:
            return
        #  if isinstance(self.widget, (ttk.Button, ttk.Checkbutton)):
        #      if self.widget["state"] == 'disabled':
        #          return
        # x = self.widget.winfo_rootx()
        x = self.widget.winfo_pointerx()
        y = self.widget.winfo_rooty() + self.widget.winfo_height()
        x += self.xoffset
        y += self.yoffset
        self.tooltip = tkinter.Toplevel()
        self.tooltip.wm_iconify()
        self.tooltip.wm_overrideredirect(1)
        self.tooltip.wm_protocol("WM_DELETE_WINDOW", self.destroy)
        self.label = tkinter.Label(self.tooltip, text=self.text,
                                   relief=self.relief, justify=self.justify,
                                   fg=self.fg, bg=self.bg, bd=1, takefocus=0)
        self.label.pack(ipadx=1, ipady=1)
        self.tooltip.wm_geometry("%+d%+d" % (x, y))
        self.tooltip.wm_deiconify()
        self.cancel_timer = after(
            self.widget, self.cancel_timeout, self._leave)
        # self.tooltip.tkraise()


# ************************************************************************
# * A canvas widget with scrollbars and some useful bindings.
# ************************************************************************

class MfxScrolledCanvas:
    def __init__(self, parent, hbar=True, vbar=True, propagate=0, **kw):
        kwdefault(kw, highlightthickness=0, bd=1, relief='sunken')
        self.parent = parent
        self.createFrame(kw)
        self.canvas = None
        self.hbar = None
        self.vbar = None
        self.hbar_show = False
        self.vbar_show = False
        self.createCanvas(kw)
        self.frame.grid_rowconfigure(0, weight=1)
        self.frame.grid_columnconfigure(0, weight=1)
        self.frame.grid_propagate(propagate)
        if hbar:
            self.createHbar()
            self.bindHbar()
        if vbar:
            self.createVbar()
            self.bindVbar()
        # self.canvas.focus_set()

    #
    #
    #

    def destroy(self):
        self.unbind_all()
        self.canvas.destroy()
        self.frame.destroy()

    def pack(self, **kw):
        self.frame.pack(**kw)

    def grid(self, **kw):
        self.frame.grid(**kw)

    #
    #
    #

    def setTile(self, app, i, force=False):
        tile = app.tabletile_manager.get(i)
        if tile is None or tile.error:
            return False
        # print i, tile
        if i == 0:
            assert tile.color
            assert tile.filename is None
        else:
            assert tile.color is None
            assert tile.filename
            assert tile.basename
        if not force:
            if (i == app.tabletile_index and
                    tile.color == app.opt.colors['table']):
                return False
        #
        if not self.canvas.setTile(tile.filename, tile.stretch,
                                   tile.save_aspect):
            tile.error = True
            return False

        if i == 0:
            self.canvas.config(bg=tile.color)
            # app.top.config(bg=tile.color)
        else:
            self.canvas.config(bg=app.top_bg)
            # app.top.config(bg=app.top_bg)

        self.canvas.setTextColor(app.opt.colors['text'])

        return True

    #
    #
    #

    def unbind_all(self):
        unbind_destroy(self.hbar)
        unbind_destroy(self.vbar)
        unbind_destroy(self.canvas)
        unbind_destroy(self.frame)

    def createFrame(self, kw):
        width = kw.get("width")
        height = kw.get("height")
        self.frame = ttk.Frame(self.parent, width=width, height=height)

    def createCanvas(self, kw):
        bd = kw['bd']
        kw['bd'] = 0
        relief = kw['relief']
        del kw['relief']
        frame = tkinter.Frame(self.frame, bd=bd, relief=relief)
        frame.grid(row=0, column=0, sticky="news")
        self.canvas = MfxCanvas(frame, **kw)
        self.canvas.pack(expand=True, fill='both')

    def createHbar(self):

        self.hbar = ttk.Scrollbar(self.frame, takefocus=0,
                                  orient="horizontal")
        self.canvas["xscrollcommand"] = self._setHbar
        self.hbar["command"] = self.canvas.xview
        self.hbar.grid(row=1, column=0, sticky="we")
        self.hbar.grid_remove()

    def createVbar(self):
        self.vbar = ttk.Scrollbar(self.frame, takefocus=0)
        self.canvas["yscrollcommand"] = self._setVbar
        self.vbar["command"] = self.canvas.yview
        self.vbar.grid(row=0, column=1, sticky="ns")
        self.vbar.grid_remove()

    def bindHbar(self, w=None):
        if w is None:
            w = self.canvas
        bind(w, "<KeyPress-Left>", self.unit_left)
        bind(w, "<KeyPress-Right>", self.unit_right)

    def bindVbar(self, w=None):
        if w is None:
            w = self.canvas
        bind(w, "<KeyPress-Prior>", self.page_up)
        bind(w, "<KeyPress-Next>", self.page_down)
        bind(w, "<KeyPress-Up>", self.unit_up)
        bind(w, "<KeyPress-Down>", self.unit_down)
        bind(w, "<KeyPress-Begin>", self.scroll_top)
        bind(w, "<KeyPress-Home>", self.scroll_top)
        bind(w, "<KeyPress-End>", self.scroll_bottom)
        # mousewheel support
        if WIN_SYSTEM == 'x11':
            bind(w, '<4>', self.mouse_wheel_up)
            bind(w, '<5>', self.mouse_wheel_down)
        # don't work on Linux
        # bind(w, '<MouseWheel>', self.mouse_wheel)

    def mouse_wheel(self, *args):
        print('MfxScrolledCanvas.mouse_wheel', args)

    def _setHbar(self, first, last):
        if self.canvas.busy:
            return
        sb = self.hbar
        if float(first) <= 0 and float(last) >= 1:
            sb.grid_remove()
            self.hbar_show = False
        else:
            if self.canvas.winfo_ismapped():
                sb.grid()
                self.hbar_show = True
        sb.set(first, last)

    def _setVbar(self, first, last):
        if self.canvas.busy:
            return
        sb = self.vbar
        if float(first) <= 0 and float(last) >= 1:
            sb.grid_remove()
            self.vbar_show = False
        else:
            if self.canvas.winfo_ismapped():
                sb.grid()
                self.vbar_show = True
        sb.set(first, last)

    def _xview(self, *args):
        if self.hbar_show:
            self.canvas.xview(*args)
        return 'break'

    def _yview(self, *args):
        if self.vbar_show:
            self.canvas.yview(*args)
        return 'break'

    def page_up(self, *event):
        return self._yview('scroll', -1, 'page')

    def page_down(self, *event):
        return self._yview('scroll', 1, 'page')

    def unit_up(self, *event):
        return self._yview('scroll', -1, 'unit')

    def unit_down(self, *event):
        return self._yview('scroll', 1, 'unit')

    def mouse_wheel_up(self, *event):
        return self._yview('scroll', -5, 'unit')

    def mouse_wheel_down(self, *event):
        return self._yview('scroll', 5, 'unit')

    def page_left(self, *event):
        return self._xview('scroll', -1, 'page')

    def page_right(self, *event):
        return self._xview('scroll', 1, 'page')

    def unit_left(self, *event):
        return self._xview('scroll', -1, 'unit')

    def unit_right(self, *event):
        return self._xview('scroll', 1, 'unit')

    def scroll_top(self, *event):
        return self._yview('moveto', 0)

    def scroll_bottom(self, *event):
        return self._yview('moveto', 1)


# ************************************************************************
# *
# ************************************************************************

class StackDesc:

    def __init__(self, game, stack):
        self.game = game
        self.stack = stack
        self.canvas = game.canvas
        self.bindings = []

        font = game.app.getFont('canvas_small')
        # print self.app.cardset.CARDW, self.app.images.CARDW
        cardw = game.app.images.getSize()[0]
        x, y = stack.x+cardw//2, stack.y
        text = stack.getHelp()+'\n'+stack.getBaseCard()
        text = text.strip()
        if text:
            frame = tkinter.Frame(self.canvas)
            self.frame = frame
            label = tkinter.Message(frame, font=font, text=text,
                                    width=cardw-8, relief='solid',
                                    fg='#000000', bg='#ffffe0', bd=1)
            label.pack()
            self.label = label
            self.id = self.canvas.create_window(x, y, window=frame, anchor='n')
            self.bindings.append(label.bind('<ButtonPress>',
                                            self._buttonPressEvent))
            # self.bindings.append(label.bind('<Enter>', self._enterEvent))
        else:
            self.id = None

    def _buttonPressEvent(self, *event):
        # self.game.deleteStackDesc()
        self.frame.tkraise()

    def _enterEvent(self, *event):
        self.frame.tkraise()

    def delete(self):
        if self.id:
            self.canvas.delete(self.id)
            for b in self.bindings:
                self.label.unbind('<ButtonPress>', b)


# ************************************************************************
# * ttk.Scale workaround (label and resolution)
# ************************************************************************

class MyPysolScale:
    def __init__(self, parent, **kw):
        if 'resolution' in kw:
            self.resolution = kw['resolution']
            del kw['resolution']
        else:
            self.resolution = 1
        if 'from_' in kw:
            kw['from_'] //= self.resolution
        if 'to' in kw:
            kw['to'] //= self.resolution
        if 'variable' in kw:
            self.variable = kw['variable']
            del kw['variable']
        else:
            self.variable = None
        value = None
        if 'value' in kw:
            value = kw['value']
            del kw['value']
        elif self.variable:
            value = self.variable.get()
        self.value = value
        self.command = command = None
        if 'command' in kw:
            command = kw['command']
        kw['command'] = self._scale_command
        if 'label' in kw:
            self.label_text = kw['label']
            width = len(self.label_text)+4
            # width = None
            del kw['label']
        else:
            self.label_text = None
            width = 3

        # create widgets
        side = 'left'  # 'top'
        self.frame = ttk.Frame(parent)
        self.label = ttk.Label(self.frame, anchor='w',
                               width=width, padding=(5, 0))
        self.label.pack(side=side, expand=False, fill='x')
        self.scale = ttk.Scale(self.frame, **kw)
        self.scale.pack(side=side, expand=True, fill='both', pady=4)

        if self.variable:
            self.variable.trace('w', self._trace_var)
        if value is not None:
            self._set_text(self._round(value))
            if self.variable:
                self.variable.set(value)
        self.command = command

    def _round(self, value):
        return int(round(float(value)/self.resolution))*self.resolution

    def _trace_var(self, *args):
        self.scale.set(float(self.variable.get())/self.resolution)

    def _set_text(self, v):
        if self.label_text:
            t = self.label_text+' '+str(v)
        else:
            t = str(v)
        self.label.configure(text=t)

    def _scale_command(self, value):
        v = self._round(float(value)*self.resolution)
        self._set_text(v)
        self.variable.set(v)
        if value != self.value and self.command:
            self.command(value)
        self.value = value

    def pack(self, **kw):
        self.frame.pack(**kw)

    def grid(self, **kw):
        self.frame.grid(**kw)

    def configure(self, **kw):
        self.scale.configure(**kw)
    config = configure

    def state(self, v):
        self.scale.state(statespec=(v,))
        self.label.state(statespec=(v,))

    def get(self):
        return self.variable.get()

    def set(self, v):
        self.variable.set(v)


class TkinterScale(tkinter.Scale):
    def __init__(self, parent, **kw):
        if 'value' in kw:
            del kw['value']
        tkinter.Scale.__init__(self, parent, **kw)


PysolScale = MyPysolScale
# PysolScale = TkinterScale


# ************************************************************************
# * ttk.Combobox workaround (clear selection)
# ************************************************************************

class PysolCombo(ttk.Combobox):
    def __init__(self, master=None, **kw):
        self._command = None
        if 'selectcommand' in kw:
            self._command = kw['selectcommand']
            del kw['selectcommand']
        ttk.Combobox.__init__(self, master, **kw)
        self.bind('<<ComboboxSelected>>', self._callback)

    def _callback(self, *args):
        # self.selection_clear()
        self.selection_range(0, 0)
        if self._command is not None:
            return self._command(*args)
        return None
from six.moves import tkinter_ttk as ttk

from .tkwidget import MfxDialog


class BaseTileMfxDialog(MfxDialog):
    def _calcToolkit(self):
        return ttk

    def _calc_MfxDialog(self):
        return MfxDialog
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

from pysollib.mfxutil import KwStruct
from pysollib.mygettext import _
from pysollib.wizardpresets import presets
from pysollib.wizardutil import WizardWidgets

import six
from six.moves import tkinter
from six.moves import tkinter_ttk as ttk

from .tkwidget import MfxDialog
from .tkwidget import PysolCombo, PysolScale


class WizardDialog(MfxDialog):
    def __init__(self, parent, title, app, **kw):
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.createBitmaps(top_frame, kw)

        frame = ttk.Frame(top_frame)
        frame.pack(expand=True, fill='both', padx=10, pady=10)
        frame.columnconfigure(0, weight=1)

        notebook = ttk.Notebook(frame)
        notebook.pack(expand=True, fill='both')

        for w in WizardWidgets:
            if isinstance(w, six.string_types):
                frame = ttk.Frame(notebook)
                notebook.add(frame, text=w, sticky='nsew', padding=5)
                frame.columnconfigure(1, weight=1)
                row = 0
                continue

            ttk.Label(frame, text=w.label).grid(row=row, column=0)

            if w.widget == 'preset':
                if w.variable is None:
                    w.variable = tkinter.StringVar()
                values = [_(v) for v in w.values]
                default = _(w.default)
                values.remove(default)
                values.sort()
                values.insert(0, default)

                def callback(e, w=w):
                    self.presetSelected(e, w)
                cb = PysolCombo(frame, values=tuple(values),
                                textvariable=w.variable,
                                exportselection=False,
                                selectcommand=callback,
                                state='readonly', width=32)
                cb.grid(row=row, column=1, sticky='ew', padx=2, pady=2)
            elif w.widget == 'entry':
                if w.variable is None:
                    w.variable = tkinter.StringVar()
                en = ttk.Entry(frame, textvariable=w.variable)
                en.grid(row=row, column=1, sticky='ew', padx=2, pady=2)
            elif w.widget == 'menu':
                if w.variable is None:
                    w.variable = tkinter.StringVar()
                values = [_(v) for v in w.values]
                cb = PysolCombo(frame, values=tuple(values),
                                textvariable=w.variable,
                                exportselection=False,
                                state='readonly', width=32)
                cb.grid(row=row, column=1, sticky='ew', padx=2, pady=2)
            elif w.widget == 'spin':
                if w.variable is None:
                    w.variable = tkinter.IntVar()
                else:
                    # delete all trace callbacks
                    for mod, cbname in w.variable.trace_vinfo():
                        w.variable.trace_vdelete(mod, cbname)
                from_, to = w.values
                # s = Spinbox(
                #   frame, textvariable=w.variable, from_=from_, to=to)
                s = PysolScale(frame, from_=from_, to=to, resolution=1,
                               orient='horizontal',
                               variable=w.variable)
                s.grid(row=row, column=1, sticky='ew', padx=2, pady=2)
            elif w.widget == 'check':
                if w.variable is None:
                    w.variable = tkinter.BooleanVar()
                ch = ttk.Checkbutton(frame, variable=w.variable,
                                     takefocus=False)
                ch.grid(row=row, column=1, sticky='ew', padx=2, pady=2)

            if w.current_value is None:
                v = w.default
            else:
                v = w.current_value
            if w.widget in ('menu', 'preset'):
                v = _(v)
            w.variable.set(v)

            row += 1

        focus = self.createButtons(bottom_frame, kw)
        self.mainloop(focus, kw.timeout)

    def presetSelected(self, e, w):
        n = e.widget.get()
        n = w.translation_map[n]
        p = presets[n]
        for w in WizardWidgets:
            if isinstance(w, six.string_types):
                continue
            if w.var_name in p:
                v = p[w.var_name]
            else:
                v = w.default
            if w.widget in ('menu', 'preset', 'entry'):
                v = _(v)
            w.variable.set(v)

    def initKw(self, kw):
        kw = KwStruct(kw,
                      strings=(_('&OK'), _('&Cancel')),
                      default=0,
                      separator=False,
                      )
        return MfxDialog.initKw(self, kw)
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

import pysollib.ui.tktile.gameinfodialog
from pysollib.tile.basetilemfxdialog import BaseTileMfxDialog


class GameInfoDialog(pysollib.ui.tktile.gameinfodialog.BaseGameInfoDialog,
                     BaseTileMfxDialog):
    True
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

# imports

# Toolkit imports
from pysollib.tile.basetilemfxdialog import BaseTileMfxDialog
from pysollib.ui.tktile.edittextdialog import BaseEditTextDialog

# ************************************************************************
# *
# ************************************************************************


class EditTextDialog(BaseEditTextDialog, BaseTileMfxDialog):

    def _calc_Resizable(self):
        return False
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

import os

from pysollib.mfxutil import KwStruct, USE_PIL
from pysollib.mygettext import _
from pysollib.resource import CSI
from pysollib.ui.tktile.selecttree import SelectDialogTreeData
from pysollib.ui.tktile.tkcanvas import MfxCanvasImage
from pysollib.ui.tktile.tkutil import loadImage
from pysollib.util import CARDSET

from six.moves import tkinter
from six.moves import tkinter_ttk as ttk

from .selecttree import SelectDialogTreeCanvas
from .selecttree import SelectDialogTreeLeaf, SelectDialogTreeNode
from .tkwidget import MfxDialog, MfxScrolledCanvas, PysolScale


# ************************************************************************
# * Nodes
# ************************************************************************

class SelectCardsetLeaf(SelectDialogTreeLeaf):
    pass


class SelectCardsetNode(SelectDialogTreeNode):
    def _getContents(self):
        contents = []
        for obj in self.tree.data.all_objects:
            if self.select_func(obj):
                node = SelectCardsetLeaf(
                    self.tree, self, text=obj.name, key=obj.index)
                contents.append(node)
        return contents or self.tree.data.no_contents


# ************************************************************************
# * Tree database
# ************************************************************************

class SelectCardsetData(SelectDialogTreeData):
    def __init__(self, manager, key):
        SelectDialogTreeData.__init__(self)
        self.all_objects = manager.getAllSortedByName()
        self.all_objects = [obj for obj in self.all_objects if not obj.error]
        self.no_contents = [SelectCardsetLeaf(
            None, None, _("(no cardsets)"), key=None), ]
        #
        select_by_type = None
        items = list(CSI.TYPE.items())
        items.sort(key=lambda x: x[1])
        nodes = []
        for key, name in items:
            if manager.registered_types.get(key):
                nodes.append(
                    SelectCardsetNode(
                        None, name, lambda cs, key=key: key == cs.si.type))
        if nodes:
            select_by_type = SelectCardsetNode(
                None, _("by Type"), tuple(nodes), expanded=1)
        #
        select_by_style = None
        items = list(CSI.STYLE.items())
        items.sort(key=lambda x: x[1])
        nodes = []
        for key, name in items:
            if manager.registered_styles.get(key):
                nodes.append(
                    SelectCardsetNode(
                        None, name, lambda cs, key=key: key in cs.si.styles))
        if nodes:
            nodes.append(
                SelectCardsetNode(
                    None, _("Uncategorized"), lambda cs: not cs.si.styles))
            select_by_style = SelectCardsetNode(
                None, _("by Style"), tuple(nodes))
        #
        select_by_nationality = None
        items = list(CSI.NATIONALITY.items())
        items.sort(key=lambda x: x[1])
        nodes = []
        for key, name in items:
            if manager.registered_nationalities.get(key):
                nodes.append(
                    SelectCardsetNode(
                        None, name,
                        lambda cs, key=key: key in cs.si.nationalities))
        if nodes:
            nodes.append(
                SelectCardsetNode(
                    None, _("Uncategorized"),
                    lambda cs: not cs.si.nationalities))
            select_by_nationality = SelectCardsetNode(
                None, _("by Nationality"), tuple(nodes))
        #
        select_by_date = None
        items = list(CSI.DATE.items())
        items.sort(key=lambda x: x[1])
        nodes = []
        for key, name in items:
            if manager.registered_dates.get(key):
                nodes.append(
                    SelectCardsetNode(
                        None, name, lambda cs, key=key: key in cs.si.dates))
        if nodes:
            nodes.append(
                SelectCardsetNode(
                    None, _("Uncategorized"), lambda cs: not cs.si.dates))
            select_by_date = SelectCardsetNode(
                None, _("by Date"), tuple(nodes))
        #
        self.rootnodes = [_f for _f in (
            SelectCardsetNode(
                None, _("All Cardsets"),
                lambda cs: 1, expanded=len(self.all_objects) <= 12),
            SelectCardsetNode(
                None, _("by Size"),
                (SelectCardsetNode(
                    None, _("Tiny cardsets"),
                    lambda cs: cs.si.size == CSI.SIZE_TINY),
                 SelectCardsetNode(
                    None, _("Small cardsets"),
                    lambda cs: cs.si.size == CSI.SIZE_SMALL),
                 SelectCardsetNode(
                    None, _("Medium cardsets"),
                    lambda cs: cs.si.size == CSI.SIZE_MEDIUM),
                 SelectCardsetNode(
                    None, _("Large cardsets"),
                    lambda cs: cs.si.size == CSI.SIZE_LARGE),
                 SelectCardsetNode(
                    None, _("XLarge cardsets"),
                    lambda cs: cs.si.size == CSI.SIZE_XLARGE),
                 ), expanded=1),
            select_by_type,
            select_by_style,
            select_by_date,
            select_by_nationality,
        ) if _f]


class SelectCardsetByTypeData(SelectDialogTreeData):
    def __init__(self, manager, key):
        SelectDialogTreeData.__init__(self)
        self.all_objects = manager.getAllSortedByName()
        self.no_contents = [SelectCardsetLeaf(None, None, _("(no cardsets)"),
                            key=None), ]
        #
        items = list(CSI.TYPE.items())
        items.sort(key=lambda x: x[1])
        nodes = []
        for key, name in items:
            if manager.registered_types.get(key):
                nodes.append(
                    SelectCardsetNode(
                        None, name, lambda cs, key=key: key == cs.si.type))
        select_by_type = SelectCardsetNode(
            None, _("by Type"), tuple(nodes), expanded=1)
        #
        self.rootnodes = [_f for _f in (
            select_by_type,
        ) if _f]


# ************************************************************************
# * Canvas that shows the tree
# ************************************************************************

class SelectCardsetTree(SelectDialogTreeCanvas):
    data = None


class SelectCardsetByTypeTree(SelectDialogTreeCanvas):
    data = None


# ************************************************************************
# * Dialog
# ************************************************************************

class SelectCardsetDialogWithPreview(MfxDialog):
    Tree_Class = SelectCardsetTree
    TreeDataHolder_Class = SelectCardsetTree
    TreeData_Class = SelectCardsetData

    def __init__(self, parent, title, app, manager, key=None, **kw):
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.createBitmaps(top_frame, kw)
        #
        if key is None:
            key = manager.getSelected()
        self.manager = manager
        self.key = key
        self.app = app
        self.cardset_values = None
        # padx, pady = kw.padx, kw.pady
        padx, pady = 5, 5
        if self.TreeDataHolder_Class.data is None:
            self.TreeDataHolder_Class.data = self.TreeData_Class(manager, key)
        #
        self.top.wm_minsize(400, 200)
        if self.top.winfo_screenwidth() >= 800:
            w1, w2 = 240, 400
        else:
            w1, w2 = 200, 300
        paned_window = ttk.PanedWindow(top_frame, orient='horizontal')
        paned_window.pack(expand=True, fill='both')
        left_frame = ttk.Frame(paned_window)
        right_frame = ttk.Frame(paned_window)
        paned_window.add(left_frame)
        paned_window.add(right_frame)
        font = app.getFont("default")
        self.tree = self.Tree_Class(self, left_frame, key=key,
                                    default=kw.default,
                                    font=font, width=w1)
        self.tree.frame.grid(row=0, column=0, sticky='nsew',
                             padx=padx, pady=pady)
        if USE_PIL:
            #
            var = tkinter.DoubleVar()
            var.set(app.opt.scale_x)
            self.scale_x = PysolScale(
                left_frame, label=_('Scale X:'),
                from_=0.5, to=4.0, resolution=0.1,
                orient='horizontal', variable=var,
                value=app.opt.scale_x,
                command=self._updateScale)
            self.scale_x.grid(
                row=1, column=0, sticky='ew', padx=padx, pady=pady)
            #
            var = tkinter.DoubleVar()
            var.set(app.opt.scale_y)
            self.scale_y = PysolScale(
                left_frame, label=_('Scale Y:'),
                from_=0.5, to=4.0, resolution=0.1,
                orient='horizontal', variable=var,
                value=app.opt.scale_y,
                command=self._updateScale)
            self.scale_y.grid(
                row=2, column=0, sticky='ew', padx=padx, pady=pady)
            #
            self.auto_scale = tkinter.BooleanVar()
            self.auto_scale.set(app.opt.auto_scale)
            check = ttk.Checkbutton(
                left_frame, text=_('Auto scaling'),
                variable=self.auto_scale,
                takefocus=False,
                command=self._updateAutoScale
                )
            check.grid(row=3, column=0, columnspan=2, sticky='ew',
                       padx=padx, pady=pady)
            #
            self.preserve_aspect = tkinter.BooleanVar()
            self.preserve_aspect.set(app.opt.preserve_aspect_ratio)
            self.aspect_check = ttk.Checkbutton(
                left_frame, text=_('Preserve aspect ratio'),
                variable=self.preserve_aspect,
                takefocus=False,
                # command=self._updateScale
                )
            self.aspect_check.grid(row=4, column=0, sticky='ew',
                                   padx=padx, pady=pady)
            self._updateAutoScale()
        #
        left_frame.rowconfigure(0, weight=1)
        left_frame.columnconfigure(0, weight=1)
        #
        self.preview = MfxScrolledCanvas(right_frame, width=w2)
        self.preview.setTile(app, app.tabletile_index, force=True)
        self.preview.pack(fill='both', expand=True, padx=padx, pady=pady)
        self.preview.canvas.preview = 1
        # create a preview of the current state
        self.preview_key = -1
        self.preview_images = []
        self.scale_images = []
        self.updatePreview(key)
        #
        focus = self.createButtons(bottom_frame, kw)
        focus = self.tree.frame
        self.mainloop(focus, kw.timeout)

    def destroy(self):
        self.tree.updateNodesWithTree(self.tree.rootnodes, None)
        self.tree.destroy()
        self.preview.unbind_all()
        self.preview_images = []
        MfxDialog.destroy(self)

    def initKw(self, kw):
        if USE_PIL:
            s = (_("&Info / Settings..."), 10)
        else:
            s = (_("&Info..."), 10)
        kw = KwStruct(kw,
                      strings=(s, 'sep',
                               _("&OK"), _("&Cancel"),),
                      default=0,
                      resizable=True,
                      )
        return MfxDialog.initKw(self, kw)

    def mDone(self, button):
        if button in (0, 1):            # Load/Cancel
            self.key = self.tree.selection_key
            self.tree.n_expansions = 1  # save xyview in any case
            if USE_PIL:
                auto_scale = bool(self.auto_scale.get())
                if button == 1:
                    self.app.menubar.tkopt.auto_scale.set(auto_scale)
                if auto_scale:
                    self.scale_values = (self.app.opt.scale_x,
                                         self.app.opt.scale_y,
                                         auto_scale,
                                         bool(self.preserve_aspect.get()))
                else:
                    self.scale_values = (self.scale_x.get(),
                                         self.scale_y.get(),
                                         auto_scale,
                                         self.app.opt.preserve_aspect_ratio)
        if button == 10:                # Info
            cs = self.manager.get(self.tree.selection_key)
            if not cs:
                return
            # title = CARDSET+" "+cs.name
            title = CARDSET.capitalize()+" "+cs.name
            d = CardsetInfoDialog(self.top, title=title, cardset=cs,
                                  images=self.preview_images)
            self.cardset_values = d.cardset_values
            return
        MfxDialog.mDone(self, button)

    def _updateAutoScale(self, v=None):
        if self.auto_scale.get():
            self.aspect_check.config(state='normal')
            self.scale_x.state('disabled')
            self.scale_y.state('disabled')
        else:
            self.aspect_check.config(state='disabled')
            self.scale_x.state('!disabled')
            self.scale_y.state('!disabled')

    def _updateScale(self, v):
        self.updatePreview()

    def updatePreview(self, key=None):
        if key == self.preview_key:
            return
        if key is None:
            key = self.key
        canvas = self.preview.canvas
        canvas.deleteAllItems()
        self.preview_images = []
        cs = self.manager.get(key)
        if not cs:
            self.preview_key = -1
            return
        names, columns = cs.getPreviewCardNames()
        try:
            # ???names, columns = cs.getPreviewCardNames()
            for n in names:
                f = os.path.join(cs.dir, n + cs.ext)
                self.preview_images.append(loadImage(file=f))
        except Exception:
            self.preview_key = -1
            self.preview_images = []
            return
        i, x, y, sx, sy, dx, dy = 0, 10, 10, 0, 0, cs.CARDW + 10, cs.CARDH + 10
        if USE_PIL:
            xf = self.scale_x.get()
            yf = self.scale_y.get()
            dx = int(dx*xf)
            dy = int(dy*yf)
            self.scale_images = []
        for image in self.preview_images:
            if USE_PIL:
                image = image.resize(xf, yf)
                self.scale_images.append(image)
            MfxCanvasImage(canvas, x, y, anchor="nw", image=image)
            sx, sy = max(x, sx), max(y, sy)
            i = i + 1
            if i % columns == 0:
                x, y = 10, y + dy
            else:
                x = x + dx
        canvas.config(scrollregion=(0, 0, sx+dx, sy+dy),
                      width=sx+dx, height=sy+dy)
        # canvas.config(xscrollincrement=dx, yscrollincrement=dy)
        canvas.event_generate('<Configure>')  # update bg image
        self.preview_key = key
        self.key = key


class SelectCardsetByTypeDialogWithPreview(SelectCardsetDialogWithPreview):
    Tree_Class = SelectCardsetByTypeTree
    TreeDataHolder_Class = SelectCardsetByTypeTree
    TreeData_Class = SelectCardsetByTypeData

# ************************************************************************
# * Cardset Info
# ************************************************************************


class CardsetInfoDialog(MfxDialog):
    def __init__(self, parent, title, cardset, images, **kw):
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.createBitmaps(top_frame, kw)
        frame = ttk.Frame(top_frame)
        frame.pack(fill="both", expand=True, padx=5, pady=10)
        #
        #
        row = 0
        info_frame = ttk.LabelFrame(frame, text=_('About cardset'))
        info_frame.grid(row=row, column=0, columnspan=2, sticky='ew',
                        padx=0, pady=5, ipadx=5, ipady=5)
        row += 1
        styles = nationalities = year = None
        if cardset.si.styles:
            styles = '\n'.join([CSI.STYLE[i] for i in cardset.si.styles])
        if cardset.si.nationalities:
            nationalities = '\n'.join([CSI.NATIONALITY[i]
                                       for i in cardset.si.nationalities])
        if cardset.year:
            year = str(cardset.year)
        frow = 0
        for n, t in (
            # ('Version:', str(cardset.version)),
            (_('Type:'),          CSI.TYPE[cardset.type]),
            (_('Styles:'),        styles),
            (_('Nationality:'),   nationalities),
            (_('Year:'),          year),
            # (_('Number of cards:'), str(cardset.ncards)),
            (_('Size:'), '%d x %d' % (cardset.CARDW, cardset.CARDH)),
                ):
            if t is not None:
                label = ttk.Label(info_frame, text=n,
                                  anchor='w', justify='left')
                label.grid(row=frow, column=0, sticky='nw', padx=4)
                label = ttk.Label(info_frame, text=t,
                                  anchor='w', justify='left')
                label.grid(row=frow, column=1, sticky='nw', padx=4)
                frow += 1
        if images:
            try:
                from random import choice
                im = choice(images)
                f = os.path.join(cardset.dir, cardset.backname)
                self.back_image = loadImage(file=f)  # store the image
                label = ttk.Label(info_frame, image=im, padding=5)
                label.grid(row=0, column=2, rowspan=frow+1, sticky='ne')
                label = ttk.Label(info_frame, image=self.back_image,
                                  padding=(0, 5, 5, 5))  # left margin = 0
                label.grid(row=0, column=3, rowspan=frow+1, sticky='ne')

                info_frame.columnconfigure(2, weight=1)
                info_frame.rowconfigure(frow, weight=1)
            except Exception:
                pass
        if USE_PIL:
            padx = 4
            pady = 0
            settings_frame = ttk.LabelFrame(frame, text=_('Settings'))
            settings_frame.grid(row=row, column=0, columnspan=2, sticky='ew',
                                padx=0, pady=5, ipadx=5, ipady=5)
            row += 1
            var = tkinter.IntVar()
            self.x_offset = PysolScale(
                settings_frame, label=_('X offset:'),
                from_=5, to=40, resolution=1,
                orient='horizontal', variable=var,
                value=cardset.CARD_XOFFSET,
                # command=self._updateScale
                )
            self.x_offset.grid(row=0, column=0, sticky='ew',
                               padx=padx, pady=pady)
            var = tkinter.IntVar()
            self.y_offset = PysolScale(
                settings_frame, label=_('Y offset:'),
                from_=5, to=40, resolution=1,
                orient='horizontal', variable=var,
                value=cardset.CARD_YOFFSET,
                # command=self._updateScale
                )
            self.y_offset.grid(row=1, column=0, sticky='ew',
                               padx=padx, pady=pady)
            row += 1

        # bg = top_frame["bg"]
        bg = 'white'
        text_w = tkinter.Text(frame, bd=1, relief="sunken", wrap="word",
                              padx=4, width=64, height=16, bg=bg)
        text_w.grid(row=row, column=0, sticky='nsew')
        sb = ttk.Scrollbar(frame)
        sb.grid(row=row, column=1, sticky='ns')
        text_w.configure(yscrollcommand=sb.set)
        sb.configure(command=text_w.yview)
        frame.columnconfigure(0, weight=1)
        frame.rowconfigure(1, weight=1)
        #
        text = ''
        f = os.path.join(cardset.dir, "COPYRIGHT")
        try:
            text = open(f).read()
        except Exception:
            pass
        if text:
            text_w.config(state="normal")
            text_w.insert("insert", text)
        text_w.config(state="disabled")
        #
        focus = self.createButtons(bottom_frame, kw)
        # focus = text_w
        self.mainloop(focus, kw.timeout)

    def initKw(self, kw):
        if USE_PIL:
            strings = (_("&Save"), _("&Cancel"))
        else:
            strings = (_("&OK"),)
        kw = KwStruct(kw,
                      strings=strings,
                      default=0,
                      resizable=True,
                      separator=True,
                      )
        return MfxDialog.initKw(self, kw)

    def mDone(self, button):
        if USE_PIL and button == 0:
            self.cardset_values = self.x_offset.get(), self.y_offset.get()
        else:
            self.cardset_values = None
        MfxDialog.mDone(self, button)
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

import os

from pysollib.gamedb import GI
from pysollib.mfxutil import KwStruct, Struct, destruct
from pysollib.mfxutil import format_time
from pysollib.mygettext import _
from pysollib.resource import CSI
from pysollib.ui.tktile.selecttree import SelectDialogTreeData
from pysollib.ui.tktile.tkutil import unbind_destroy

from six.moves import UserList
from six.moves import tkinter_ttk as ttk

from .selecttree import SelectDialogTreeCanvas
from .selecttree import SelectDialogTreeLeaf, SelectDialogTreeNode
from .tkwidget import MfxDialog, MfxScrolledCanvas

# ************************************************************************
# * Nodes
# ************************************************************************


class SelectGameLeaf(SelectDialogTreeLeaf):
    pass


class SelectGameNode(SelectDialogTreeNode):
    def _getContents(self):
        contents = []
        if isinstance(self.select_func, UserList):
            # key/value pairs
            for id, name in self.select_func:
                if id and name:
                    node = SelectGameLeaf(self.tree, self, name, key=id)
                    contents.append(node)
        else:
            for gi in self.tree.data.all_games_gi:
                if gi and self.select_func is None:
                    # All games
                    # name = '%s (%s)' % (gi.name, CSI.TYPE_NAME[gi.category])
                    name = gi.name
                    node = SelectGameLeaf(self.tree, self, name, key=gi.id)
                    contents.append(node)
                elif gi and self.select_func(gi):
                    name = gi.name
                    node = SelectGameLeaf(self.tree, self, name, key=gi.id)
                    contents.append(node)
        return contents or self.tree.data.no_games


# ************************************************************************
# * Tree database
# ************************************************************************

class SelectGameData(SelectDialogTreeData):
    def __init__(self, app):
        SelectDialogTreeData.__init__(self)
        self.all_games_gi = list(map(
            app.gdb.get,
            app.gdb.getGamesIdSortedByName()))
        self.no_games = [SelectGameLeaf(None, None, _("(no games)"), None), ]
        #
        s_by_type = s_oriental = s_special = s_original = s_contrib = \
            s_mahjongg = None
        g = []
        for data in (GI.SELECT_GAME_BY_TYPE,
                     GI.SELECT_ORIENTAL_GAME_BY_TYPE,
                     GI.SELECT_SPECIAL_GAME_BY_TYPE,
                     GI.SELECT_ORIGINAL_GAME_BY_TYPE,
                     GI.SELECT_CONTRIB_GAME_BY_TYPE,
                     ):
            gg = []
            for name, select_func in data:
                if name is None or not list(filter(
                        select_func, self.all_games_gi)):
                    continue
                gg.append(SelectGameNode(None, _(name), select_func))
            g.append(gg)

        def select_mahjongg_game(gi):
            return gi.si.game_type == GI.GT_MAHJONGG

        gg = None
        if list(filter(select_mahjongg_game, self.all_games_gi)):
            gg = SelectGameNode(None, _("Mahjongg Games"),
                                select_mahjongg_game)
        g.append(gg)
        if g[0]:
            s_by_type = SelectGameNode(None, _("French games"),
                                       tuple(g[0]), expanded=1)
        if g[1]:
            s_oriental = SelectGameNode(None, _("Oriental Games"),
                                        tuple(g[1]))
        if g[2]:
            s_special = SelectGameNode(None, _("Special Games"),
                                       tuple(g[2]))
        if g[3]:
            s_original = SelectGameNode(None, _("Original Games"),
                                        tuple(g[3]))
        # if g[4]:
        #   s_contrib = SelectGameNode(None, "Contributed Games", tuple(g[4]))
        if g[5]:
            s_mahjongg = g[5]
        #
        s_by_compatibility, gg = None, []
        for name, games in GI.GAMES_BY_COMPATIBILITY:
            def select_func(gi, games=games):
                return gi.id in games
            if name is None or not list(filter(
                    select_func, self.all_games_gi)):
                continue
            gg.append(SelectGameNode(None, name, select_func))
        if 1 and gg:
            s_by_compatibility = SelectGameNode(None, _("by Compatibility"),
                                                tuple(gg))
        #
        s_by_pysol_version, gg = None, []
        for name, games in GI.GAMES_BY_PYSOL_VERSION:
            def select_func(gi, games=games):
                return gi.id in games
            if name is None or not list(filter(
                    select_func, self.all_games_gi)):
                continue
            name = _("New games in v. %(version)s") % {'version': name}
            gg.append(SelectGameNode(None, name, select_func))
        if 1 and gg:
            s_by_pysol_version = SelectGameNode(None, _("by PySol version"),
                                                tuple(gg))
        s_by_inventors, gg = None, []
        for name, games in GI.GAMES_BY_INVENTORS:
            def select_func(gi, games=games):
                return gi.id in games
            if name is None or not list(filter(
                    select_func, self.all_games_gi)):
                continue
            gg.append(SelectGameNode(None, name, select_func))
        if 1 and gg:
            s_by_inventors = SelectGameNode(None, _("by Inventors"),
                                            tuple(gg))
        #
        ul_alternate_names = UserList(
            list(app.gdb.getGamesTuplesSortedByAlternateName()))
        #
        self.rootnodes = [_f for _f in (
            SelectGameNode(None, _("All Games"), None, expanded=0),
            SelectGameNode(None, _("Alternate Names"), ul_alternate_names),
            SelectGameNode(None, _("Popular Games"),
                           lambda gi: gi.si.game_flags & GI.GT_POPULAR),
            s_by_type,
            s_mahjongg,
            s_oriental,
            s_special,
            SelectGameNode(None, _("Custom Games"),
                           lambda gi: gi.si.game_type == GI.GT_CUSTOM),
            SelectGameNode(None, _('by Skill Level'), (
                SelectGameNode(None, _('Luck only'),
                               lambda gi: gi.skill_level == GI.SL_LUCK),
                SelectGameNode(None, _('Mostly luck'),
                               lambda gi: gi.skill_level == GI.SL_MOSTLY_LUCK),
                SelectGameNode(None, _('Balanced'),
                               lambda gi: gi.skill_level == GI.SL_BALANCED),
                SelectGameNode(
                    None, _('Mostly skill'),
                    lambda gi: gi.skill_level == GI.SL_MOSTLY_SKILL),
                SelectGameNode(None, _('Skill only'),
                               lambda gi: gi.skill_level == GI.SL_SKILL),
                )),
            SelectGameNode(None, _("by Game Feature"), (
                SelectGameNode(None, _("by Number of Cards"), (
                    SelectGameNode(None, _("32 cards"),
                                   lambda gi: gi.si.ncards == 32),
                    SelectGameNode(None, _("48 cards"),
                                   lambda gi: gi.si.ncards == 48),
                    SelectGameNode(None, _("52 cards"),
                                   lambda gi: gi.si.ncards == 52),
                    SelectGameNode(None, _("64 cards"),
                                   lambda gi: gi.si.ncards == 64),
                    SelectGameNode(None, _("78 cards"),
                                   lambda gi: gi.si.ncards == 78),
                    SelectGameNode(None, _("104 cards"),
                                   lambda gi: gi.si.ncards == 104),
                    SelectGameNode(None, _("144 cards"),
                                   lambda gi: gi.si.ncards == 144),
                    SelectGameNode(
                        None, _("Other number"),
                        lambda gi: gi.si.ncards not in (32, 48, 52,
                                                        64, 78, 104, 144)),
                )),
                SelectGameNode(None, _("by Number of Decks"), (
                    SelectGameNode(None, _("1 deck games"),
                                   lambda gi: gi.si.decks == 1),
                    SelectGameNode(None, _("2 deck games"),
                                   lambda gi: gi.si.decks == 2),
                    SelectGameNode(None, _("3 deck games"),
                                   lambda gi: gi.si.decks == 3),
                    SelectGameNode(None, _("4 deck games"),
                                   lambda gi: gi.si.decks == 4),
                )),
                SelectGameNode(None, _("by Number of Redeals"), (
                    SelectGameNode(None, _("No redeal"),
                                   lambda gi: gi.si.redeals == 0),
                    SelectGameNode(None, _("1 redeal"),
                                   lambda gi: gi.si.redeals == 1),
                    SelectGameNode(None, _("2 redeals"),
                                   lambda gi: gi.si.redeals == 2),
                    SelectGameNode(None, _("3 redeals"),
                                   lambda gi: gi.si.redeals == 3),
                    SelectGameNode(None, _("Unlimited redeals"),
                                   lambda gi: gi.si.redeals == -1),
                    SelectGameNode(
                        None, _("Other number of redeals"),
                        lambda gi: gi.si.redeals not in (-1, 0, 1, 2, 3)),
                )),
                s_by_compatibility,
            )),
            s_by_pysol_version,
            s_by_inventors,
            SelectGameNode(None, _("Other Categories"), (
                SelectGameNode(None, _("Games for Children (very easy)"),
                               lambda gi: gi.si.game_flags & GI.GT_CHILDREN),
                SelectGameNode(None, _("Games with Scoring"),
                               lambda gi: gi.si.game_flags & GI.GT_SCORE),
                SelectGameNode(
                    None, _("Games with Separate Decks"),
                    lambda gi: gi.si.game_flags & GI.GT_SEPARATE_DECKS),
                SelectGameNode(None, _("Open Games (all cards visible)"),
                               lambda gi: gi.si.game_flags & GI.GT_OPEN),
                SelectGameNode(None, _("Relaxed Variants"),
                               lambda gi: gi.si.game_flags & GI.GT_RELAXED),
            )),
            s_original,
            s_contrib,
        ) if _f]


# ************************************************************************
# * Canvas that shows the tree
# ************************************************************************

class SelectGameTreeWithPreview(SelectDialogTreeCanvas):
    data = None


class SelectGameTree(SelectGameTreeWithPreview):
    def singleClick(self, event=None):
        self.doubleClick(event)


# ************************************************************************
# * Dialog
# ************************************************************************

class SelectGameDialog(MfxDialog):
    Tree_Class = SelectGameTree
    TreeDataHolder_Class = SelectGameTreeWithPreview
    TreeData_Class = SelectGameData

    def __init__(self, parent, title, app, gameid, **kw):
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.createBitmaps(top_frame, kw)
        #
        self.app = app
        self.gameid = gameid
        self.random = None
        if self.TreeDataHolder_Class.data is None:
            self.TreeDataHolder_Class.data = self.TreeData_Class(app)
        #
        self.top.wm_minsize(200, 200)
        font = app.getFont("default")
        self.tree = self.Tree_Class(self, top_frame, key=gameid,
                                    font=font, default=kw.default)
        self.tree.frame.pack(fill='both', expand=True,
                             padx=kw.padx, pady=kw.pady)
        #
        focus = self.createButtons(bottom_frame, kw)
        focus = self.tree.frame
        self.mainloop(focus, kw.timeout)

    def initKw(self, kw):
        kw = KwStruct(kw,
                      strings=(None, None, _("&Cancel"),), default=0,
                      resizable=True,
                      separator=True,
                      )
        return MfxDialog.initKw(self, kw)

    def destroy(self):
        self.app = None
        self.tree.updateNodesWithTree(self.tree.rootnodes, None)
        self.tree.destroy()
        MfxDialog.destroy(self)

    def mDone(self, button):
        if button == 0:                 # Ok or double click
            self.gameid = self.tree.selection_key
            self.tree.n_expansions = 1  # save xyview in any case
        if button == 10:                # Rules
            doc = self.app.getGameRulesFilename(self.tree.selection_key)
            if not doc:
                return
            dir = os.path.join("html", "rules")
            from pysollib.help import help_html
            help_html(self.app, doc, dir, self.top)
            self.top.grab_release()  # Don't want the help window appear frozen
            return
        MfxDialog.mDone(self, button)


# ************************************************************************
# * Dialog
# ************************************************************************

class SelectGameDialogWithPreview(SelectGameDialog):
    Tree_Class = SelectGameTreeWithPreview

    def __init__(self, parent, title, app, gameid, bookmark=None, **kw):
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.createBitmaps(top_frame, kw)
        #
        self.app = app
        self.gameid = gameid
        self.bookmark = bookmark
        self.random = None
        if self.TreeDataHolder_Class.data is None:
            self.TreeDataHolder_Class.data = self.TreeData_Class(app)
        #
        self.top.wm_minsize(400, 200)
        sw = self.top.winfo_screenwidth()
        if sw >= 1100:
            w1, w2 = 250, 600
        elif sw >= 900:
            w1, w2 = 250, 500
        elif sw >= 800:
            w1, w2 = 220, 480
        else:
            w1, w2 = 200, 300
        # print sw, w1, w2
        w2 = max(200, min(w2, 10 + 12*(app.subsampled_images.CARDW+10)))
        # print sw, w1, w2
        # padx, pady = kw.padx, kw.pady
        # padx, pady = kw.padx/2, kw.pady/2
        padx, pady = 4, 4
        # PanedWindow
        paned_window = ttk.PanedWindow(top_frame, orient='horizontal')
        paned_window.pack(expand=True, fill='both', padx=8, pady=8)
        left_frame = ttk.Frame(paned_window)
        right_frame = ttk.Frame(paned_window)
        paned_window.add(left_frame)
        paned_window.add(right_frame)
        # Tree
        font = app.getFont("default")
        self.tree = self.Tree_Class(self, left_frame, key=gameid,
                                    default=kw.default, font=font, width=w1)
        self.tree.frame.pack(padx=padx, pady=pady, expand=True, fill='both')
        # LabelFrame
        info_frame = ttk.LabelFrame(right_frame, text=_('About game'))
        info_frame.grid(row=0, column=0, padx=padx, pady=pady,
                        ipadx=4, ipady=4, sticky='nws')
        stats_frame = ttk.LabelFrame(right_frame, text=_('Statistics'))
        stats_frame.grid(row=0, column=1, padx=padx, pady=pady,
                         ipadx=4, ipady=4, sticky='nws')
        # Info
        self.info_labels = {}
        for n, t, f, row in (
            ('name',        _('Name:'),             info_frame,   0),
            ('altnames',    _('Alternate names:'),  info_frame,   1),
            ('category',    _('Category:'),         info_frame,   2),
            ('type',        _('Type:'),             info_frame,   3),
            ('skill_level', _('Skill level:'),      info_frame,   4),
            ('decks',       _('Decks:'),            info_frame,   5),
            ('redeals',     _('Redeals:'),          info_frame,   6),
            #
            ('played',      _('Played:'),           stats_frame,  0),
            ('won',         _('Won:'),              stats_frame,  1),
            ('lost',        _('Lost:'),             stats_frame,  2),
            ('time',        _('Playing time:'),     stats_frame,  3),
            ('moves',       _('Moves:'),            stats_frame,  4),
            ('percent',     _('% won:'),            stats_frame,  5),
                ):
            title_label = ttk.Label(f, text=t, justify='left', anchor='w')
            title_label.grid(row=row, column=0, sticky='nw', padx=4)
            text_label = ttk.Label(f, justify='left', anchor='w')
            text_label.grid(row=row, column=1, sticky='nw', padx=4)
            self.info_labels[n] = (title_label, text_label)
        # info_frame.columnconfigure(1, weight=1)
        info_frame.rowconfigure(6, weight=1)
        stats_frame.rowconfigure(6, weight=1)
        # Canvas
        self.preview = MfxScrolledCanvas(right_frame, width=w2)
        self.preview.setTile(app, app.tabletile_index, force=True)
        self.preview.grid(row=1, column=0, columnspan=3,
                          padx=padx, pady=pady, sticky='nsew')
        right_frame.columnconfigure(1, weight=1)
        right_frame.rowconfigure(1, weight=1)
        #
        focus = self.createButtons(bottom_frame, kw)
        # set the scale factor
        self.preview.canvas.preview = 2
        # create a preview of the current game
        self.preview_key = -1
        self.preview_game = None
        self.preview_app = None
        self.updatePreview(gameid, animations=0)
        # focus = self.tree.frame
        self.mainloop(focus, kw.timeout)

    def initKw(self, kw):
        kw = KwStruct(kw,
                      strings=((_("&Rules"), 10), 'sep',
                               _("&Select"), _("&Cancel"),),
                      default=0,
                      )
        return SelectGameDialog.initKw(self, kw)

    def destroy(self):
        self.deletePreview(destroy=1)
        self.preview.unbind_all()
        SelectGameDialog.destroy(self)

    def deletePreview(self, destroy=0):
        self.preview_key = -1
        # clean up the canvas
        if self.preview:
            unbind_destroy(self.preview.canvas)
            self.preview.canvas.deleteAllItems()
            if destroy:
                self.preview.canvas.delete("all")
        #
        # for l in self.info_labels.values():
        #    l.config(text='')
        # destruct the game
        if self.preview_game:
            self.preview_game.endGame()
            self.preview_game.destruct()
            destruct(self.preview_game)
        self.preview_game = None
        # destruct the app
        if destroy:
            if self.preview_app:
                destruct(self.preview_app)
            self.preview_app = None

    def updatePreview(self, gameid, animations=10):
        if gameid == self.preview_key:
            return
        self.deletePreview()
        canvas = self.preview.canvas
        #
        gi = self.app.gdb.get(gameid)
        if not gi:
            self.preview_key = -1
            return
        #
        if self.preview_app is None:
            self.preview_app = Struct(
                # variables
                audio=self.app.audio,
                canvas=canvas,
                cardset=self.app.cardset.copy(),
                gamerandom=self.app.gamerandom,
                gdb=self.app.gdb,
                gimages=self.app.gimages,
                images=self.app.subsampled_images,
                menubar=None,
                miscrandom=self.app.miscrandom,
                opt=self.app.opt.copy(),
                startup_opt=self.app.startup_opt,
                stats=self.app.stats.new(),
                top=None,
                top_cursor=self.app.top_cursor,
                toolbar=None,
                # methods
                constructGame=self.app.constructGame,
                getFont=self.app.getFont,
            )
            self.preview_app.opt.shadow = 0
            self.preview_app.opt.shade = 0
        #
        self.preview_app.audio = None    # turn off audio for initial dealing
        if animations >= 0:
            self.preview_app.opt.animations = animations
        #
        if self.preview_game:
            self.preview_game.endGame()
            self.preview_game.destruct()
        # self.top.wm_title("Select Game - " +
        #   self.app.getGameTitleName(gameid))
        title = self.app.getGameTitleName(gameid)
        self.top.wm_title(_("Playable Preview - %(game)s") % {'game': title})
        #
        self.preview_game = gi.gameclass(gi)
        self.preview_game.createPreview(self.preview_app)
        #
        random = None
        if gameid == self.gameid:
            random = self.app.game.random.copy()
        if gameid == self.gameid and self.bookmark:
            self.preview_game.restoreGameFromBookmark(self.bookmark)
        else:
            self.preview_game.newGame(random=random, autoplay=1)
        gw, gh = self.preview_game.width, self.preview_game.height
        canvas.config(scrollregion=(0, 0, gw, gh))
        canvas.xview_moveto(0)
        canvas.yview_moveto(0)
        #
        self.preview_app.audio = self.app.audio
        if self.app.opt.animations:
            self.preview_app.opt.animations = 10
        else:
            self.preview_app.opt.animations = 0
        # save seed
        self.random = self.preview_game.random.copy()
        self.random.origin = self.random.ORIGIN_PREVIEW
        self.preview_key = gameid
        #
        self.updateInfo(gameid)
        #
        rules_button = self.buttons[0]
        if self.app.getGameRulesFilename(gameid):
            rules_button.config(state="normal")
        else:
            rules_button.config(state="disabled")

    def updateInfo(self, gameid):
        gi = self.app.gdb.get(gameid)
        # info
        name = gi.name
        altnames = '\n'.join(gi.altnames)
        category = _(CSI.TYPE[gi.category])
        type = ''
        if gi.si.game_type in GI.TYPE_NAMES:
            type = _(GI.TYPE_NAMES[gi.si.game_type])
        sl = {
            GI.SL_LUCK:         _('Luck only'),
            GI.SL_MOSTLY_LUCK:  _('Mostly luck'),
            GI.SL_BALANCED:     _('Balanced'),
            GI.SL_MOSTLY_SKILL: _('Mostly skill'),
            GI.SL_SKILL:        _('Skill only'),
            }
        skill_level = sl.get(gi.skill_level)
        if gi.redeals == -2:
            redeals = _('variable')
        elif gi.redeals == -1:
            redeals = _('unlimited')
        else:
            redeals = str(gi.redeals)
        # stats
        won, lost, time, moves = self.app.stats.getFullStats(
            self.app.opt.player, gameid)
        if won+lost > 0:
            percent = "%.1f" % (100.0*won/(won+lost))
        else:
            percent = "0.0"
        time = format_time(time)
        moves = str(round(moves, 1))
        for n, t in (
            ('name',        name),
            ('altnames',    altnames),
            ('category',    category),
            ('type',        type),
            ('skill_level', skill_level),
            ('decks',       gi.decks),
            ('redeals',     redeals),
            ('played',      won+lost),
            ('won',         won),
            ('lost',        lost),
            ('time',        time),
            ('moves',       moves),
            ('percent',     percent),
                ):
            title_label, text_label = self.info_labels[n]
            if t in ('', None):
                title_label.grid_remove()
                text_label.grid_remove()
            else:
                title_label.grid()
                text_label.grid()
            text_label.config(text=t)
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##
"""
A number of function that enhance PySol on MacOSX when it used as a normal
GUI application (as opposed to an X11 application).
"""
import sys

from six.moves.tkinter import TclError


def runningAsOSXApp():
    """ Returns True if-and-only-if running from the
    PySol.app bundle on OSX """
    return (sys.platform == 'darwin' and 'PySol.app' in sys.argv[0])


def hideTkConsole(root):
    try:
        root.tk.call('console', 'hide')
    except TclError:
        pass


def setupApp(app):
    """
    Perform setup for the OSX application bundle.
    """
    if not runningAsOSXApp():
        return
    hideTkConsole(app.top)
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

import os
import traceback

from pysollib.settings import TITLE
from pysollib.settings import TOOLKIT, USE_TILE
from pysollib.winsystems.common import \
        BaseTkSettings, \
        base_init_root_window, \
        get_font_name

if TOOLKIT == 'tk':
    if USE_TILE:
        from six.moves import tkinter_ttk as ttk


# ************************************************************************
# * Init root window
# ************************************************************************

def init_root_window(root, app):

    base_init_root_window(root, app)

    # root.self.wm_maxsize(9999, 9999) # unlimited
    if TOOLKIT == 'gtk':
        pass
    elif TOOLKIT == 'kivy':
        pass
    elif USE_TILE:
        f = os.path.join(app.dataloader.dir, 'tcl', 'menu8.4.tcl')
        if os.path.exists(f):
            try:
                root.tk.evalfile(f)
            except Exception:
                traceback.print_exc()
        f = 'clrpick8.5.tcl'
        f = os.path.join(app.dataloader.dir, 'tcl', f)
        if os.path.exists(f):
            try:
                root.tk.evalfile(f)
            except Exception:
                traceback.print_exc()
        f = 'fsdialog8.5.tcl'
        f = os.path.join(app.dataloader.dir, 'tcl', f)
        if os.path.exists(f):
            try:
                root.tk.evalfile(f)
            except Exception:
                traceback.print_exc()
            else:
                from six.moves import tkinter_tkfiledialog
                tkinter_tkfiledialog.Open.command = 'ttk::getOpenFile'
                tkinter_tkfiledialog.SaveAs.command = 'ttk::getSaveFile'
                tkinter_tkfiledialog.Directory.command = 'ttk::chooseDirectory'

        style = ttk.Style(root)
        color = style.lookup('.', 'background')
        if color:
            root.tk_setPalette(color)

        root.option_add('*Menu.borderWidth', 1, 60)
        root.option_add('*Menu.activeBorderWidth', 1, 60)
        color = style.lookup('.', 'background', ['active'])
        if color:
            root.option_add('*Menu.activeBackground', color, 60)

        root.option_add('*Listbox.background', 'white', 60)
        root.option_add('*Listbox.foreground', 'black', 60)
        root.option_add('*Text.background', 'white', 60)
        root.option_add('*Text.foreground', 'black', 60)
        root.option_add('*selectForeground', 'white', 60)
        root.option_add('*selectBackground', '#0a5f89', 60)
        root.option_add('*inactiveSelectBackground', '#0a5f89', 60)  # Tk-8.5

        color = style.lookup('TEntry', 'selectbackground', ['focus'])
        if color:
            root.option_add('*selectBackground', color, 60)
            root.option_add('*inactiveSelectBackground', color, 60)
        color = style.lookup('TEntry', 'selectforeground', ['focus'])
        if color:
            root.option_add('*selectForeground', color, 60)

        root.option_add('*selectBorderWidth', 0, 60)

        font = root.option_get('font', TITLE)
        if font:
            # use font from xrdb
            fn = get_font_name(font)
            if fn:
                # root.option_add('*font', font)
                style.configure('.', font=font)
                app.opt.fonts['default'] = fn
                # treeview heading
                f = root.tk.splitlist(root.tk.call('font', 'actual', fn))
                root.tk.call('font', 'configure', 'TkHeadingFont', *f)
        else:
            # use font from ttk settings
            font = style.lookup('.', 'font')
            if font:
                fn = get_font_name(font)
                if fn:
                    root.option_add('*font', font)
                    app.opt.fonts['default'] = fn
        if app.opt.tile_theme == 'clam':
            style.configure('TLabelframe', labeloutside=False,
                            labelmargins=(8, 0, 8, 0))

    #
    else:
        root.option_add('*Entry.background', 'white', 60)
        root.option_add('*Entry.foreground', 'black', 60)
        root.option_add('*Listbox.background', 'white', 60)
        root.option_add('*Listbox.foreground', 'black', 60)
        root.option_add('*Text.background', 'white', 60)
        root.option_add('*Text.foreground', 'black', 60)
        root.option_add('*selectForeground', 'white', 60)
        root.option_add('*selectBackground', '#0a5f89', 60)
        root.option_add('*inactiveSelectBackground', '#0a5f89', 60)  # Tk-8.5
        root.option_add('*selectBorderWidth', 0, 60)
        # root.option_add('*borderWidth', '1', 50)
        # root.option_add('*Button.borderWidth', '1', 50)
        root.option_add('*Scrollbar.elementBorderWidth', 1, 60)
        root.option_add('*Scrollbar.borderWidth', 1, 60)
        root.option_add('*Menu.borderWidth', 1, 60)
        root.option_add('*Menu.activeBorderWidth', 1, 60)
        # root.option_add('*Button.HighlightBackground', '#595d59')
        # root.option_add('*Button.HighlightThickness', '1')
        font = root.option_get('font', TITLE)
        if font:
            fn = get_font_name(font)
            app.opt.fonts['default'] = fn
        else:
            root.option_add('*font', 'helvetica 12', 60)
            app.opt.fonts['default'] = ('helvetica', 12,
                                        'roman', 'normal')


class TkSettings(BaseTkSettings):
    pass
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

from pysollib.settings import TOOLKIT, USE_TILE
from pysollib.winsystems.common import BaseTkSettings, base_init_root_window

if USE_TILE:
    from six.moves import tkinter_ttk as ttk


def init_root_window(root, app):
    base_init_root_window(root, app)
    if TOOLKIT == 'gtk':
        pass
    elif USE_TILE:
        theme = app.opt.tile_theme
        style = ttk.Style(root)
        if theme not in ('winnative', 'xpnative'):
            color = style.lookup('.', 'background')
            if color:
                root.tk_setPalette(color)
            # root.option_add('*Menu.foreground', 'black')
            root.option_add('*Menu.activeBackground', '#08246b')
            root.option_add('*Menu.activeForeground', 'white')
        if theme == 'winnative':
            style.configure('Toolbutton', padding=2)
    else:
        # root.option_add(...)
        pass


class TkSettings(BaseTkSettings):
    canvas_padding = (1, 1)
    horizontal_toolbar_padding = (1, 0)
    toolbar_relief = 'groove'
    toolbar_borderwidth = 2
    if USE_TILE:
        toolbar_button_padding = (2, 0)
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.macosx.appSupport import hideTkConsole
from pysollib.settings import TOOLKIT, USE_TILE
from pysollib.winsystems.common import BaseTkSettings, base_init_root_window


def init_root_window(root, app):
    base_init_root_window(root, app)
    if TOOLKIT == 'tk':
        hideTkConsole(root)
    if TOOLKIT == 'gtk':
        pass
    elif USE_TILE:
        pass
    else:                               # pure Tk
        # root.option_add(...)
        pass


class TkSettings(BaseTkSettings):
    pass
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

import os
import traceback

from pysollib.mfxutil import print_err
from pysollib.mygettext import _
from pysollib.settings import DEBUG
from pysollib.settings import TITLE
from pysollib.settings import TOOLKIT, USE_TILE
from pysollib.settings import VERSION

if TOOLKIT == 'tk':
    from pysollib.ui.tktile.tkutil import loadImage
    if USE_TILE:
        from six.moves import tkinter_ttk as ttk


def init_tile(app, top):
    # load available themes
    d = os.path.join(app.dataloader.dir, 'themes')
    if os.path.isdir(d):
        top.tk.eval('global auto_path; lappend auto_path {%s}' % d)
        for t in os.listdir(d):
            if os.path.exists(os.path.join(d, t, 'pkgIndex.tcl')):
                try:
                    top.tk.eval('package require ttk::theme::'+t)
                    # print 'load theme:', t
                except Exception:
                    traceback.print_exc()
                    pass


def set_theme(app, top, theme):
    # set theme
    style = ttk.Style(top)
    try:
        style.theme_use(theme)
    except Exception:
        print_err(_('invalid theme name: ') + theme)
        style.theme_use(app.opt.default_tile_theme)


def get_font_name(font):
    # create font name
    # i.e. "helvetica 12" -> ("helvetica", 12, "roman", "normal")

    if (TOOLKIT == 'kivy'):
        return "helvetica 12"

    from six.moves.tkinter_font import Font
    font_name = None
    try:
        f = Font(font=font)
    except Exception:
        print_err(_('invalid font name: ') + font)
        if DEBUG:
            traceback.print_exc()
    else:
        fa = f.actual()
        font_name = (fa['family'],
                     fa['size'],
                     fa['slant'],
                     fa['weight'])
    return font_name


def base_init_root_window(root, app):
    # root.wm_group(root)
    root.wm_title(TITLE + ' ' + VERSION)
    root.wm_iconname(TITLE + ' ' + VERSION)

    if TOOLKIT == 'tk':
        icons = [loadImage(img) for img in app.dataloader.findAllIconSizes()]
        if icons:
            try:
                root.wm_iconphoto(True, *icons)
            except AttributeError:
                root.tk.call('wm', 'iconphoto', root, '-default', *icons)

    # set minsize
    sw, sh = (root.winfo_screenwidth(), root.winfo_screenheight())
    if sw < 640 or sh < 480:
        root.wm_minsize(400, 300)
    else:
        root.wm_minsize(520, 360)

    if TOOLKIT == 'gtk':
        pass
    if TOOLKIT == 'kivy':
        pass
    elif USE_TILE:
        theme = app.opt.tile_theme
        init_tile(app, root)
        set_theme(app, root, theme)
    else:
        pass


class BaseTkSettings:
    canvas_padding = (0, 0)
    horizontal_toolbar_padding = (0, 0)
    vertical_toolbar_padding = (0, 1)
    toolbar_button_padding = (2, 2)
    toolbar_label_padding = (4, 4)
    if USE_TILE:
        toolbar_relief = 'flat'
        toolbar_borderwidth = 0
    else:
        toolbar_relief = 'raised'
        toolbar_button_relief = 'flat'
        toolbar_separator_relief = 'sunken'
        toolbar_borderwidth = 1
        toolbar_button_borderwidth = 1
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.settings import WIN_SYSTEM

if WIN_SYSTEM == 'win32':
    from pysollib.winsystems import win32 as gui
elif WIN_SYSTEM == 'aqua':
    from pysollib.winsystems import aqua as gui
else:                                   # 'x11'
    from pysollib.winsystems import x11 as gui

init_root_window = gui.init_root_window
TkSettings = gui.TkSettings
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#

# imports

# PySol imports
# from pysollib.mfxutil import KwStruct
# from pysollib.settings import TITLE

# Toolkit imports
# from tkconst import EVENT_HANDLED
# from tkwidget import MfxDialog

# ************************************************************************
# *
# ************************************************************************

solver_dialog = None


def create_solver_dialog(parent, game):
    pass


def connect_game_solver_dialog(game):
    pass


def destroy_solver_dialog():
    global solver_dialog
    solver_dialog = None


def reset_solver_dialog():
    pass
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#

# imports
import os
import sys

if __name__ == '__main__':
    d = os.path.abspath(os.path.join(sys.path[0], os.pardir, os.pardir))
    sys.path.append(d)
    import gettext
    gettext.install('pysol', d, unicode=True)

# PySol imports

# Toolkit imports
# from pysollib.settings import WIN_SYSTEM

# ************************************************************************
# *
# ************************************************************************
# statusbar not used.


class MfxStatusbar:
    def __init__(self, top, row, column, columnspan):
        pass

    def _createLabel(self, name, expand=False, width=0, tooltip=None):
        pass

    def show(self, on):
        pass

    def updateText(self, **kw):
        pass

    def config(self, a, b):
        pass


class PysolStatusbar(MfxStatusbar):
    def __init__(self, top):
        pass


class HelpStatusbar(MfxStatusbar):
    def __init__(self, top):
        MfxStatusbar.__init__(self, top, row=4, column=0, columnspan=3)
        # l = self._createLabel('info', expand=True)
        # l.config(justify='left', anchor='w', padx=8)


class HtmlStatusbar(MfxStatusbar):
    def __init__(self, top, row, column, columnspan):
        MfxStatusbar.__init__(self, top, row=row,
                              column=column, columnspan=columnspan)
        # l = self._createLabel('url', expand=True)
        # l.config(justify='left', anchor='w', padx=8)


# ************************************************************************
# *
# ************************************************************************
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#

# Toolkit imports
from pysollib.pysoltk import MfxDialog

# ************************************************************************
# *
# ************************************************************************
# not implemented with kivy.


class PlayerOptionsDialog(MfxDialog):
    def __init__(self, parent, title, app, **kw):
        pass

# ************************************************************************
# *
# ************************************************************************
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
# Copyright (C) 2016-2017 LB
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#

# imports
import os

# PySol imports
from pysollib.mygettext import _, n_
from pysollib.settings import TITLE
from pysollib.util import IMAGE_EXTENSIONS
from pysollib.winsystems import TkSettings

# ************************************************************************
# *
# ************************************************************************


class AbstractToolbarButton:
    def __init__(self, parent, toolbar, toolbar_name, position):
        self.toolbar = toolbar
        self.toolbar_name = toolbar_name
        self.position = position
        self.visible = False

    def show(self, orient, force=False):
        if self.visible and not force:
            return
        self.visible = True
        padx, pady = 2, 2
        if orient == 'horizontal':
            self.grid(row=0,
                      column=self.position,
                      ipadx=padx, ipady=pady,
                      sticky='nsew')
        else:
            self.grid(row=self.position,
                      column=0,
                      ipadx=padx, ipady=pady,
                      sticky='nsew')

    def hide(self):
        if not self.visible:
            return
        self.visible = False
        self.grid_forget()

# ************************************************************************


if True:
    from pysollib.kivy.LApp import LImage
    from pysollib.kivy.LApp import LBase
    # from LApp import LMainWindow
    from kivy.uix.boxlayout import BoxLayout
    # from kivy.uix.button import Button
    from kivy.uix.behaviors import ButtonBehavior
    # from kivy.uix.behaviors import ToggleButtonBehavior
    from kivy.uix.image import Image as KivyImage

# ************************************************************************


class MyButton(ButtonBehavior, KivyImage, LBase):
    def __init__(self, **kwargs):
        super(MyButton, self).__init__(**kwargs)
        # super(MyButton, self).__init__()
        self.src = None
        if ('image' in kwargs):
            self.src = kwargs['image'].source
        self.command = None
        if ('command' in kwargs):
            self.command = kwargs['command']
        self.source = self.src
        self.allow_stretch = True

    def on_press(self):
        self.allow_stretch = False

    def on_release(self):
        self.allow_stretch = True
        if (self.command is not None):
            self.command()


class MyCheckButton(ButtonBehavior, KivyImage, LBase):
    def __init__(self, **kwargs):
        super(MyCheckButton, self).__init__(**kwargs)
        # super(MyCheckButton, self).__init__()
        self.src = None
        if ('image' in kwargs):
            self.src = kwargs['image'].source
        self.command = None
        if ('command' in kwargs):
            self.command = kwargs['command']
        self.variable = None
        if ('variable' in kwargs):
            self.variable = kwargs['variable']
        self.win = None
        if ('win' in kwargs):
            self.win = kwargs['win']
        self.source = self.src
        self.allow_stretch = True
        self.checked = False

        # self.variable = self.win.app.menubar.tkopt.pause
        if self.variable:
            self.variable.bind(value=self.updateState)

    def updateState(self, obj, val):
        if (val):
            self.allow_stretch = False
        else:
            self.allow_stretch = True

    def isChecked(self):
        return self.checked

    def on_press(self):
        if self.win is None:
            return
        if self.win.app is None:
            return
        if self.win.app.game is None:
            return

        game = self.win.app.game
        if game.finished:
            return
        if game.demo:
            return

        # if self.win.app.menubar == None: return
        # mb = self.win.app.menubar

        if game.pause:
            self.allow_stretch = True
            self.checked = False
            if (self.command is not None):
                self.command()
        else:
            self.allow_stretch = False
            self.checked = True
            if (self.command is not None):
                self.command()

    def on_release(self):
        pass

# ************************************************************************
# * Note: Applications should call show/hide after constructor.
# ************************************************************************


class PysolToolbarTk(BoxLayout):
    def __init__(
            self,
            top,
            menubar,
            dir,
            size=0,
            relief='flat',
            compound='none'):

        super(PysolToolbarTk, self).__init__(orientation='vertical')
        self.size_hint = (0.05, 1.0)
        # self.size_hint=(None, 1.0)
        # self.width = 50
        self.win = top
        self.menubar = menubar
        self.dir = dir
        self.win.setTool(self, 3)

        for label, f, t in (
            (n_("New"),      self.mNewGame,   _("New game")),
            (n_("Restart"),  self.mRestart,   _("Restart the\ncurrent game")),
            (None,           None,            None),
            # (n_("Open"),     self.mOpen,      _("Open a\nsaved game")),
            # (n_("Save"),     self.mSave,      _("Save game")),
            (None,           None,            None),
            (n_("Undo"),     self.mUndo,      _("Undo last move")),
            (n_("Redo"),     self.mRedo,      _("Redo last move")),
            (n_("Autodrop"), self.mDrop,      _("Auto drop cards")),
            (n_("Shuffle"),  self.mShuffle,   _("Shuffle tiles")),
            (n_("Pause"),    self.mPause,     _("Pause game")),
            (None,           None,            None),
            # (n_("Statistics"), self.mPlayerStats, _("View statistics")),
            (n_("Rules"),    self.mHelpRules, _("Rules for this game")),
            (None,           None,            None),
            (n_("Quit"),     self.mHoldAndQuit,      _("Quit %s") % TITLE),
        ):
            if label is None:
                # sep = self._createSeparator()
                # sep.bind("<1>", self.clickHandler)
                # sep.bind("<3>", self.rightclickHandler)
                pass
            elif label == 'Pause':
                self._createButton(label, f, check=True, tooltip=t)
            else:
                self._createButton(label, f, tooltip=t)

            # hier gibt es noch ein 'player label' mit contextmenu, wo
            # der spielername gewählt und die spielstatistik etc.
            # angezeigt werden könnte (TBD):
            '''
        sep = self._createFlatSeparator()
        sep.bind("<1>", self.clickHandler)
        sep.bind("<3>", self.rightclickHandler)
        self._createLabel("player", label=n_('Player'),
                          tooltip=_("Player options"))
        #
        self.player_label.bind("<1>", self.mOptPlayerOptions)
        # self.player_label.bind("<3>", self.mOptPlayerOptions)
        self.popup = MfxMenu(master=None, label=n_('Toolbar'), tearoff=0)
        createToolbarMenu(menubar, self.popup)
        self.frame.bind("<1>", self.clickHandler)
        self.frame.bind("<3>", self.rightclickHandler)
        #
        self.setCompound(compound, force=True)
            '''

    def show(self, on, **kw):
        side = self.menubar.tkopt.toolbar.get()
        self.win.setTool(None, side)
        return False

    def mHoldAndQuit(self, *args):
        if not self._busy():
            self.menubar.mHoldAndQuit()
        return 1

    def getSize(self):
        return 0

    def updateText(self, **kw):
        pass

    def config(self, w, v):
        print('PysolToolbarTk: config %s, %s' % (w, v))
        # y = self.yy
        pass

    # Lokale.

    def _loadImage(self, name):
        file = os.path.join(self.dir, name)
        image = None
        for ext in IMAGE_EXTENSIONS:
            file = os.path.join(self.dir, name + ext)
            if os.path.isfile(file):
                image = LImage(source=file)
                # print('_loadImage: file=%s' % file)
                # image = Tkinter.PhotoImage(file=file)
                break
        return image

    def _createButton(self, label, command, check=False, tooltip=None):
        name = label.lower()
        image = self._loadImage(name)
        # position = len(self._widgets)
        button_relief = TkSettings.toolbar_button_relief
        bd = TkSettings.toolbar_button_borderwidth
        padx, pady = TkSettings.toolbar_button_padding
        kw = {
            'toolbar': self,
            'toolbar_name': name,
            'command': command,
            'takefocus': 0,
            'text': _(label),
            'bd': bd,
            'relief': button_relief,
            'padx': padx,
            'pady': pady,
            'overrelief': 'raised',
        }
        # print ('toolbar:  print %s' % self.win)
        # print ('toolbar:  print %s' % self.win.app)
        kw['win'] = self.win
        if image:
            kw['image'] = image
        if check:
            kw['offrelief'] = button_relief
            kw['indicatoron'] = False
            kw['selectcolor'] = ''

            button = MyCheckButton(**kw)
        else:
            button = MyButton(**kw)

        # button.show(orient=self.orient)
        setattr(self, name + "_image", image)
        setattr(self, name + "_button", button)
        # self._widgets.append(button)
        self.add_widget(button)

        # TBD: tooltip ev. auf basis einer statuszeile implementieren
        # if tooltip:
        #   b = MfxTooltip(button)
        #   self._tooltips.append(b)
        #   b.setText(tooltip)
        return button

    def _busy(self):
        # if not self.side or not self.game or not self.menubar:
        #   return 1
        if not self.game or not self.menubar:
            return 1
        print('_busy:')
        self.game.stopDemo()
        self.game.interruptSleep()
        return self.game.busy
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#

# imports
# import tkFont

# Toolkit imports
from pysollib.kivy.tktree import MfxTreeInCanvas, MfxTreeLeaf, MfxTreeNode

# ************************************************************************
# * Nodes
# ************************************************************************


class SelectDialogTreeLeaf(MfxTreeLeaf):
    def drawSymbol(self, x, y, **kw):
        pass
        '''
        if self.tree.nodes.get(self.symbol_id) is not self:
            self.symbol_id = self.tree.canvas.create_image(x, y,
               image=self.tree.data.img[2 + (self.key is None)], anchor="nw")
            self.tree.nodes[self.symbol_id] = self
        '''


class SelectDialogTreeNode(MfxTreeNode):
    def __init__(self, tree, text, select_func, expanded=0, parent_node=None):
        MfxTreeNode.__init__(self, tree, parent_node,
                             text, key=None, expanded=expanded)
        # callable or a tuple/list of MfxTreeNodes
        self.select_func = select_func

    def drawSymbol(self, x, y, **kw):
        pass
        '''
        if self.tree.nodes.get(self.symbol_id) is not self:
            self.symbol_id = self.tree.canvas.create_image(x, y,
                image=self.tree.data.img[self.expanded], anchor="nw")
            self.tree.nodes[self.symbol_id] = self
        '''
    def getContents(self):
        # cached values
        if self.subnodes is not None:
            return self.subnodes
        # print self.whoami()
        if isinstance(self.select_func, (tuple, list)):
            return self.select_func
        return self._getContents()

    def _getContents(self):
        # subclass
        return []


# ************************************************************************
# * Tree database
# ************************************************************************


class SelectDialogTreeData():
    img = []  # loaded in Application.loadImages3

    def __init__(self):
        self.tree_xview = (0.0, 1.0)
        self.tree_yview = (0.0, 1.0)


# ************************************************************************
# * Canvas that shows the tree (left side)
# ************************************************************************


class SelectDialogTreeCanvas(MfxTreeInCanvas):
    def __init__(self, dialog, parent, key, default,
                 font=None, width=-1, height=-1, hbar=2, vbar=3):
        pass
    # not needed with kivy


'''
'''
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#

# Toolkit imports
from pysollib.kivy.tkwidget import MfxDialog

# ************************************************************************
# *
# ************************************************************************


class TimeoutsDialog(MfxDialog):
    def __init__(self, parent, title, app, **kw):
        pass
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#

# Toolkit imports
from pysollib.pysoltk import MfxDialog

# ************************************************************************
# *
# ************************************************************************


class ColorsDialog(MfxDialog):
    def __init__(self, parent, title, app, **kw):
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)
        # not used in kivy version.
        return


'''end of file'''
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#
# imports
# import os
# import time

# Kivy
# from LApp import *
from kivy.graphics import Color
from kivy.graphics import Line
from kivy.uix.label import Label
from kivy.uix.widget import Widget

# PySol imports
# Toolkit imports
# from pysollib.mfxutil import format_time
# from pysollib.mfxutil import kwdefault, KwStruct
# from pysollib.mygettext import _, n_
# from pysollib.pysoltk import MfxScrolledCanvas
# from pysollib.stats import PysolStatsFormatter, ProgressionFormatter
# from pysollib.util import *
# from tkutil import bind, unbind_destroy, loadImage
from pysollib.kivy.LApp import LImage
from pysollib.mfxutil import KwStruct
from pysollib.mygettext import _
from pysollib.pysoltk import MfxDialog, MfxMessageDialog
from pysollib.settings import TOP_TITLE

# FIXME - this file a quick hack and needs a rewrite

# Note almoust not used in the kivy implementation. Only a simple text
# is displayed, for single user Statisics. The code from tk implementation was
# kept as an examlple what could eventually be done once ....

# ************************************************************************
# *
# ************************************************************************


class LPieChart(Widget):
    def __init__(self, prnt, args, **kw):
        super(LPieChart, self).__init__(**kw)
        self.prnt = prnt

        # print('width   %s' % kw['width'])
        # print('outline %s' % kw['outline'])
        # print('fill    %s' % kw['fill'])

        # width = 10.0
        # if ('width' in kw):
        #     width = float(kw['width'])

        bcolor = '#ffa000a0'
        if ('outline') in kw:
            bcolor = kw['outline']
        if (not bcolor or len(bcolor) < 7):
            bcolor = '#ffa000a0'

        fcolor = '#00aaff20'
        if ('fill') in kw:
            fcolor = kw['fill']
        if (not fcolor or len(fcolor) < 7):
            fcolor = '#00aaff20'

        self.group = None
        if 'group' in kw:
            self.group = kw['group']

        self.center = (0.0, 0.0)
        if ('center') in kw:
            self.center = kw['center']

        self.radius = (0.0, 0.0)
        if ('radius') in kw:
            self.radius = kw['radius']

        self.fcolor = (0.9, 0.1, 0.3, 0.5)
        self.bind(size=self.updateCanvas)
        self.bind(pos=self.updateCanvas)

    def updateCanvas(self, instance, value):

        self.canvas.clear()
        with self.canvas:
            Color(self.fcolor[0], self.fcolor[1],
                  self.fcolor[2], self.fcolor[3])

            center = (self.pos[0] + self.size[0] / 2.0,
                      self.pos[1] + self.size[1] / 2.0)
            radius = (self.size[0] * 0.45)
            radius2 = (self.size[1] * 0.45)
            if (radius > radius2):
                radius = radius2

            # Rectangle(pos=pos, size=size)
            Line(circle=(center[0], center[1], radius), width=2.0, close=True)

            # kreis kann nicht gefüllt werden !!! - man sollte eine Funktion
            # haben die einen geschlossenen pfad füllt.
            # TBD.vertices/Mesh. versuchen, kreis annähern.

            # Color(self.bcolor[0], self.bcolor[1],
            #    self.bcolor[2], self.bcolor[3])
            # Line(points=poly, width=border)


# ************************************************************************
# *
# ************************************************************************

class SingleGame_StatsDialog(MfxDialog):
    def __init__(self, parent, title, app, player, gameid, **kw):
        kw['size_hint'] = (0.5, 1)
        self.app = app
        self.selected_game = None
        kw = self.initKw(kw)
        print('SingleGame_StatsDialog: p=%s, g=%s, kw=%s' %
              (player, gameid, kw))
        if isinstance(kw, KwStruct):
            print('kw=%s' % kw.getKw())

        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.top_frame = top_frame

#        self.createBitmaps(top_frame, kw)
        #
        self.player = player or _("Demo games")
        self.top.wm_minsize(200, 200)
        self.button = kw.default
        #
        # createChart = self.create3DBarChart
        # createChart = self.createPieChart
        # createChart = self.createSimpleChart
        #         if parent.winfo_screenwidth() < 800
        #            or parent.winfo_screenheight() < 600:
        #             createChart = self.createPieChart
        #             createChart = self.createSimpleChart
        #
        self.font = self.app.getFont("default")
#        self.tk_font = tkFont.Font(self.top, self.font)
#        self.font_metrics = self.tk_font.metrics()
        self._calc_tabs()

        if (kw.image):
            image = LImage(texture=kw.image.texture, size_hint=(1, 1))
            self.top.add_widget(image)

        #
        won, lost = app.stats.getStats(player, gameid)
        pwon, plost = self._getPwon(won, lost)

        print('Stats(p): won=%s, lost=%s' % (won, lost))

        text1 = _('Total:\n' +
                  '   won: %(won)s ... %(percentwon)s%%\n' +
                  '   lost: %(lost)s ... %(percentlost)s%%\n\n') % dict(
            won=won, percentwon=int(round(100.0 * pwon)),
            lost=lost, percentlost=int(round(100.0 * plost)))

#        createChart(app, won, lost, _("Total"))
        won, lost = app.stats.getSessionStats(player, gameid)
        pwon, plost = self._getPwon(won, lost)

        print('Stats(s): won=%s, lost=%s' % (won, lost))

        text2 = _('Current Session:\n' +
                  '   won: %(won)s ... %(percentwon)s%%\n' +
                  '   lost: %(lost)s ... %(percentlost)s%%\n') % dict(
            won=won, percentwon=(round(100.0 * pwon)),
            lost=lost, percentlost=int(round(100.0 * plost)))
        # text2 = 'Current Session:\n   won=%s, lost=%s\n' % (won, lost)

#        createChart(app, won, lost, _("Current session"))

        self.top.add_widget(Label(text=text1 + text2))

        # self.top.add_widget(Button(text='reset', size_hint=(1, 0.15)))
        #
#        focus = self.createButtons(bottom_frame, kw)
#        self.mainloop(focus, kw.timeout)

    #
    # helpers
    #

    def _calc_tabs(self):
        return

    def _getPwon(self, won, lost):
        pwon, plost = 0.0, 0.0
        if won + lost > 0:
            pwon = float(won) / float(won + lost)
            pwon = min(max(pwon, 0.00001), 0.99999)
            plost = 1.0 - float(pwon)
        return pwon, plost

    def _createChartTexts(self, tx, ty, won, lost):
        c, tfont, fg = self.canvas, self.font, self.fg
        pwon, plost = self._getPwon(won, lost)
        #
        x = tx[0]
        dy = int(self.font_metrics['ascent']) - 10
        dy = dy / 2
        c.create_text(x, ty[0] - dy, text=_("Won:"),
                      anchor="nw", font=tfont, fill=fg)
        c.create_text(x, ty[1] - dy, text=_("Lost:"),
                      anchor="nw", font=tfont, fill=fg)
        c.create_text(x, ty[2] - dy, text=_("Total:"),
                      anchor="nw", font=tfont, fill=fg)
        x = tx[1] - 16
        c.create_text(x, ty[0] - dy, text="%d" %
                      won, anchor="ne", font=tfont, fill=fg)
        c.create_text(x, ty[1] - dy, text="%d" %
                      lost, anchor="ne", font=tfont, fill=fg)
        c.create_text(x, ty[2] - dy, text="%d" %
                      (won + lost), anchor="ne", font=tfont, fill=fg)
        y = ty[2] - 11
        c.create_line(tx[0], y, x, y, fill=fg)
        if won + lost > 0:
            x = tx[2]
            pw = int(round(100.0 * pwon))
            c.create_text(x, ty[0] - dy, text="%d%%" %
                          pw, anchor="ne", font=tfont, fill=fg)
            c.create_text(x, ty[1] - dy, text="%d%%" %
                          (100 - pw), anchor="ne", font=tfont, fill=fg)

    #
    # charts
    #

    def initKw(self, kw):
        kw = KwStruct(kw,
                      strings=(_("&OK"),
                               (_("&All games..."), 102),
                               (TOP_TITLE + "...", 105),
                               (_("&Reset..."), 302)), default=0,
                      image=self.app.gimages.logos[5],
                      padx=10, pady=10,
                      )
        return MfxDialog.initKw(self, kw)

# ************************************************************************
# *
# ************************************************************************


class AllGames_StatsDialog(MfxDialog):

    YVIEW = 0
    FONT_TYPE = "default"

    def __init__(self, parent, title, app, player, **kw):
        self.status = 0
        print('AllGames_StatsDialog')
        pass

# ************************************************************************
# *
# ************************************************************************


class FullLog_StatsDialog(AllGames_StatsDialog):
    pass


class SessionLog_StatsDialog(FullLog_StatsDialog):
    pass

# ************************************************************************
# *
# ************************************************************************


class Status_StatsDialog(MfxMessageDialog):
    def __init__(self, parent, game):
        self.status = 0
        pass

# ************************************************************************
# *
# ************************************************************************


class Top_StatsDialog(MfxDialog):
    def __init__(self, parent, title, app, player, gameid, **kw):
        pass

# ************************************************************************
# *
# ************************************************************************


class ProgressionDialog(MfxDialog):
    def __init__(self, parent, title, app, player, gameid, **kw):
        pass
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#

import formatter
import os
import sys

from kivy.uix.boxlayout import BoxLayout
from kivy.uix.button import Button
from kivy.uix.label import Label

import pysollib.htmllib2 as htmllib
from pysollib.kivy.LApp import LPopCommander
from pysollib.kivy.LApp import LScrollView
from pysollib.kivy.LApp import LTopLevel
from pysollib.kivy.LApp import get_platform
from pysollib.mfxutil import Struct, openURL
from pysollib.mygettext import _
from pysollib.pysoltk import MfxMessageDialog
from pysollib.settings import TITLE

REMOTE_PROTOCOLS = ("ftp:", "gopher:", "http:", "mailto:", "news:", "telnet:")

# ************************************************************************
# *
# ************************************************************************


if get_platform() == 'android':
    from jnius import autoclass
    from jnius import cast

    def startAndroidBrowser(www):
        # init java classes
        PythonActivity = autoclass('org.kivy.android.PythonActivity')
        Intent = autoclass('android.content.Intent')
        Uri = autoclass('android.net.Uri')
        # String = autoclass('java.lang.String') # get the Java object

        # prepare activity
        # PythonActivity.mActivity is the instance of the current Activity
        # BUT, startActivity is a method from the Activity class, not from our
        # PythonActivity.
        # We need to cast our class into an activity and use it
        currentActivity = cast(
            'android.app.Activity', PythonActivity.mActivity)

        # create the intent
        intent = Intent()
        intent.setAction(Intent.ACTION_VIEW)
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
        intent.setDataAndType(Uri.parse(www), "application/xhtml+xml")

        # start activity
        currentActivity.startActivity(intent)

# ************************************************************************
# *
# ************************************************************************


def cmp2(a, b):
    """python 3 replacement for python 2 cmp function"""
    return (a > b) - (a < b)


class tkHTMLWriter(formatter.NullWriter):
    def __init__(self, text, viewer, app):
        formatter.NullWriter.__init__(self)

        self.text = text
        self.viewer = viewer

        #
        if app:
            font = app.getFont("sans")
            fixed = app.getFont("fixed")
        else:
            font = ('helvetica', 12)
            fixed = ('courier', 12)
        size = font[1]
        sign = 1
        if size < 0:
            sign = -1
        self.fontmap = {
            "h1": (font[0], size + 12 * sign, "bold"),
            "h2": (font[0], size + 8 * sign, "bold"),
            "h3": (font[0], size + 6 * sign, "bold"),
            "h4": (font[0], size + 4 * sign, "bold"),
            "h5": (font[0], size + 2 * sign, "bold"),
            "h6": (font[0], size + 1 * sign, "bold"),
            "bold": (font[0], size, "bold"),
            "italic": (font[0], size, "italic"),
            "pre": fixed,
        }

        self.text.config(cursor=self.viewer.defcursor, font=font)
        for f in self.fontmap.keys():
            self.text.tag_config(f, font=self.fontmap[f])

        self.anchor = None
        self.anchor_mark = None
        self.font = None
        self.font_mark = None
        self.indent = ""
        self.text.label.bind(on_ref_press=self.refpress)

    '''
    def createCallback(self, href):
        class Functor:
            def __init__(self, viewer, arg):
                self.viewer = viewer
                self.arg = arg

            def __call__(self, *args):
                self.viewer.updateHistoryXYView()
                return self.viewer.display(self.arg)
        return Functor(self.viewer, href)
    '''

    def write(self, data):
        # print('writer: write %s' % data)
        self.text.insert("insert", data)

    def anchor_bgn(self, href, name, type):
        # print('writer: anchor_bgn %s - %s' % (href, name))
        if href:
            # self.text.update_idletasks()   # update display during parsing
            self.anchor = (href, name, type)
            self.anchor_mark = self.text.index("insert")
            self.write('[ref=' + href + ']')

            url = self.anchor[0]
            fg = '0000cc'
            u = self.viewer.normurl(url, with_protocol=False)
            if u in self.viewer.visited_urls:
                fg = '660099'
            self.write('[color=' + fg + '][i]')
            # self.text.tag_config(tag, foreground=fg, underline=1)

    def refpress(self, instance, value):
        # print('writer: refpress %s, %s' % (instance, value))
        pass

    def anchor_end(self):
        # print('writer: anchor_end')
        if self.anchor:

            self.anchor = None
            self.write('[/i][/color]')
            self.write('[/ref]')

    def anchor_enter(self, url):
        url = self.viewer.normurl(url)
        self.viewer.statusbar.updateText(url=url)
        self.text.config(cursor=self.viewer.handcursor)

    def anchor_leave(self, *args):
        self.viewer.statusbar.updateText(url='')
        self.text.config(cursor=self.viewer.defcursor)

    def new_font(self, font):
        # print('writer: new_font %s' % str(font))
        # end the current font
        if self.font:
            # print "end_font(%s)" % `self.font`
            self.text.tag_add(self.font, self.font_mark, "insert")
            self.font = None
        # start the new font
        if font:
            # print "start_font(%s)" % `font`
            self.font_mark = self.text.index("insert")
            if font[0] in self.fontmap:
                self.font = font[0]
            elif font[3]:
                self.font = "pre"
            elif font[2]:
                self.font = "bold"
            elif font[1]:
                self.font = "italic"
            else:
                self.font = None

    def new_margin(self, margin, level):
        # print('writer: new_margin %s, %s' % (margin, level))
        self.indent = "    " * level

    def send_label_data(self, data):
        # print('writer: send_label_data %s' % (data))
        # self.write(self.indent + data + " ")
        self.write(self.indent)
        if data == '*':  # <li>
            img = self.viewer.symbols_img.get('disk')
            if img:
                self.text.image_create(index='insert', image=img,
                                       padx=0, pady=0)
            else:
                self.write('*')
        else:
            self.write(data)
        self.write(' ')

    def send_paragraph(self, blankline):
        # print('writer: send_paragraph %s' % (blankline))
        self.write('\n' * blankline)

    def send_line_break(self):
        # print('writer: send_break')
        self.write('\n')

    def send_hor_rule(self, *args):
        if (args):
            pass
            # print('writer: send_hor_rule %s' % (args))
        # width = int(int(self.text["width"]) * 0.9)
        width = 20
        self.write("_" * width)
        self.write("\n")

    def send_literal_data(self, data):
        # print('writer: send_literal_data %s' % (data))
        self.write(data)

    def send_flowing_data(self, data):
        # print('writer: send_flowing_data %s' % (data))
        self.write(data)

# ************************************************************************
# *
# ************************************************************************


class tkHTMLParser(htmllib.HTMLParser):
    def anchor_bgn(self, href, name, type):
        self.formatter.flush_softspace()
        htmllib.HTMLParser.anchor_bgn(self, href, name, type)
        self.formatter.writer.anchor_bgn(href, name, type)

    def close(self):
        # print('tkHTMLParser1: close()')
        self.formatter.writer.text.applyBuffer()
        # label = self.formatter.writer.text.label
        # print('tkHTMLParser: label.refs %s' % str(label.refs))
        # print ('tkHTMLParser: label.refs %s' % str(Label.refs))

        # print('tkHTMLParser2: close()')
        htmllib.HTMLParser.close(self)

    def anchor_end(self):
        if self.anchor:
            self.anchor = None
        self.formatter.writer.anchor_end()

    def do_dt(self, attrs):
        self.formatter.end_paragraph(1)
        self.ddpop()

    def handle_image(self, src, alt, ismap, align, width, height):
        self.formatter.writer.viewer.showImage(
            src, alt, ismap, align, width, height)

# ************************************************************************
# *
# ************************************************************************


class HTMLButton(Button):
    def __init__(self, **kw):
        super(HTMLButton, self).__init__(**kw)

    def config(self, **kw):
        pass


class HTMLLabel(Label):
    def __init__(self, **kw):
        super(HTMLLabel, self).__init__(**kw)

        self.bind(size=self.onUpdate)
        self.bind(pos=self.onUpdate)
        self.bind(text=self.onUpdate)

    def onUpdate(self, instance, size):
        self.size_hint_y = None
        self.text_size = self.width, None
        self.texture_update()
        self.height = self.texture_size[1]


class HTMLText(LScrollView, LPopCommander):
    def __init__(self, **kw):
        super(HTMLText, self).__init__(**kw)

        self.label = HTMLLabel(text='', markup=True)
        self.tags = {}
        self.textbuffer = ''
        self.add_widget(self.label)
