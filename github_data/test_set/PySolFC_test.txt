
    def applyBuffer(self):
        # print('applybuffer:')
        self.label.text = self.textbuffer

    def config(self, **kw):
        # print('config: %s' % kw)
        pass

    def update_idletasks(self):
        pass

    def delete(self, val, val1):
        pass

    def insert(self, cmd, data):
        # print('insert text: %s' % data)
        self.textbuffer = self.textbuffer + data
        # self.label.text = self.textbuffer
        pass

    def index(self, cmd):
        # print('index: %s' % cmd)
        # was sollen wir hier zuruckgeben ?
        return 0

    def tag_add(self, font, fontmark, cmd):
        # print('tag_add: %s, %s, %s' % (font, fontmark, cmd))
        pass

    def tag_config(self, tag, **kw):
        # print('tag_config: %s, %s' % (tag, kw))
        # self.tags[tag] = kw

        # for t, k in self.tags:
        #    print('tagslist: %s, %s' % (t, k))

        pass

    def xview_moveto(self, xview):
        # print('xview_moveto: %s' % xview)
        pass

    def yview_moveto(self, yview):
        # print('yview_moveto: %s' % yview)
        pass


class HTMLViewer:
    symbols_fn = {}  # filenames, loaded in Application.loadImages3
    symbols_img = {}

    def make_pop_command(self, parent, title):
        def pop_command(event):
            if self.history.index > 1:
                self.goBack(event)
                return None
            del self.history.list
            self.history.index = 0
            parent.popWork(title)
        return pop_command

    def make_close_command(self, parent, title):
        def close_command(event):
            del self.history.list
            self.history.index = 0
            parent.popWork(title)
        return close_command

    def refpress(self, instance, value):
        # print('writer: refpress %s, %s' % (instance, value))
        self.updateHistoryXYView()
        return self.display(value)

    def __init__(self, parent, app=None, home=None):
        self.parent = parent
        self.app = app
        self.home = home
        self.url = None
        self.history = Struct(
            list=[],
            index=0,
        )
        self.visited_urls = []
        self.images = {}
        # need to keep a reference because of garbage collection
        self.defcursor = "default"
        # self.defcursor = parent["cursor"]
        # self.defcursor = 'xterm'
        self.handcursor = "hand2"

        self.title = _("Browser")
        self.window = None
        self.running = False

        # prüfen ob noch aktiv.

        if parent.workStack.peek(self.title) is not None:
            parent.popWork(self.title)

        pc = self.make_pop_command(parent, self.title)
        cc = self.make_close_command(parent, self.title)

        # neuen Dialog aufbauen.

        window = LTopLevel(app.top, self.title, size_hint=(1.8, 1.0))
        window.titleline.bind(on_press=cc)
        self.parent.pushWork(self.title, window)
        self.window = window
        self.running = True

        content = BoxLayout(orientation='vertical')
        # buttonline =
        #   BoxLayout(orientation='horizontal', size_hint=(1.0, 0.1))

        # create buttons
        self.homeButton = HTMLButton(text=_("Index"), on_release=self.goHome)
        self.backButton = HTMLButton(text=_("Back"), on_release=self.goBack)
        self.forwardButton = HTMLButton(
            text=_("Forward"), on_release=self.goForward)
        self.closeButton = HTMLButton(text=_("Close"), on_release=self.goHome)

        '''
        buttonline.add_widget(self.homeButton)
        buttonline.add_widget(self.backButton)
        buttonline.add_widget(self.forwardButton)
        buttonline.add_widget(self.closeButton)
        content.add_widget(buttonline)
        '''

        '''
        self.homeButton = Tkinter.Button(parent, text=_("Index"),
                                         width=button_width,
                                         command=self.goHome)
        self.homeButton.grid(row=0, column=0, sticky='w')
        self.backButton = Tkinter.Button(parent, text=_("Back"),
                                         width=button_width,
                                         command=self.goBack)
        self.backButton.grid(row=0, column=1, sticky='w')
        self.forwardButton = Tkinter.Button(parent, text=_("Forward"),
                                            width=button_width,
                                            command=self.goForward)
        self.forwardButton.grid(row=0, column=2, sticky='w')
        self.closeButton = Tkinter.Button(parent, text=_("Close"),
                                          width=button_width,
                                          command=self.destroy)
        self.closeButton.grid(row=0, column=3, sticky='e')
        '''

        # create text widget

        self.text = HTMLText(
            pop_command=pc, text="hallo", size_hint=(1.0, 1.0))
        self.text.label.bind(on_ref_press=self.refpress)
        content.add_widget(self.text)
        '''
        text_frame = Tkinter.Frame(parent)
        text_frame.grid(row=1, column=0, columnspan=4, sticky='nsew')
        text_frame.grid_propagate(False)
        vbar = Tkinter.Scrollbar(text_frame)
        vbar.pack(side='right', fill='y')
        self.text = Tkinter.Text(text_frame,
                                 fg='black', bg='white',
                                 bd=1, relief='sunken',
                                 cursor=self.defcursor,
                                 wrap='word', padx=10)
        self.text.pack(side='left', fill='both', expand=True)
        self.text["yscrollcommand"] = vbar.set
        vbar["command"] = self.text.yview
        '''

        self.window.content.add_widget(content)

        # statusbar
        # self.statusbar = HtmlStatusbar(parent, row=2, column=0, columnspan=4)

        # parent.columnconfigure(2, weight=1)
        # parent.rowconfigure(1, weight=1)

        # load images
        for name, fn in self.symbols_fn.items():
            self.symbols_img[name] = self.getImage(fn)

    def _yview(self, *args):
        self.text.yview(*args)
        return 'break'

    def page_up(self, *event):
        return self._yview('scroll', -1, 'page')

    def page_down(self, *event):
        return self._yview('scroll', 1, 'page')

    def unit_up(self, *event):
        return self._yview('scroll', -1, 'unit')

    def unit_down(self, *event):
        return self._yview('scroll', 1, 'unit')

    def scroll_top(self, *event):
        return self._yview('moveto', 0)

    def scroll_bottom(self, *event):
        return self._yview('moveto', 1)

    # locate a file relative to the current self.url
    def basejoin(self, url, baseurl=None, relpath=1):
        if baseurl is None:
            baseurl = self.url
        if 0:
            import urllib
            url = urllib.pathname2url(url)
            if relpath and self.url:
                url = urllib.basejoin(baseurl, url)
        else:
            url = os.path.normpath(url)
            if relpath and baseurl and not os.path.isabs(url):
                h1, t1 = os.path.split(url)
                h2, t2 = os.path.split(baseurl)
                if cmp2(h1, h2) != 0:
                    url = os.path.join(h2, h1, t1)
                url = os.path.normpath(url)
        return url

    def normurl(self, url, with_protocol=True):
        for p in REMOTE_PROTOCOLS:
            if url.startswith(p):
                break
        else:
            url = self.basejoin(url)
            if with_protocol:
                if os.name == 'nt':
                    url = url.replace('\\', '/')
                url = 'file://' + url
        return url

    def openfile(self, url):
        if url[-1:] == "/" or os.path.isdir(url):
            url = os.path.join(url, "index.html")
        url = os.path.normpath(url)
        if sys.version_info > (3,):
            import codecs
            return codecs.open(url, encoding='utf-8'), url
        return open(url, "rb"), url

    def display(self, url, add=1, relpath=1, xview=0, yview=0):
        # for some reason we have to stop the PySol demo
        # (is this a multithread problem with Tkinter ?)
        if self.app and self.app.game:
            self.app.game.stopDemo()
            # self.app.game._cancelDrag()
            # pass

        # ftp: and http: would work if we use urllib, but this widget is
        # far too limited to display anything but our documentation...
        for p in REMOTE_PROTOCOLS:
            if url.startswith(p):
                plat = get_platform()
                if plat == 'android':
                    print("Open url: %s (TBD)" % url)
                    startAndroidBrowser(url)
                elif not openURL(url):
                    return

        # locate the file relative to the current url
        url = self.basejoin(url, relpath=relpath)

        # read the file
        try:
            file = None
            if 0:
                import urllib
                file = urllib.urlopen(url)
            else:
                file, url = self.openfile(url)
            data = file.read()
            file.close()
            file = None
        except Exception:
            print("Open url(1) - Exception: %s" % url)
            if file:
                file.close()

            '''
            self.errorDialog(_("Unable to service request:\n") + url)
            '''
            return

        self.url = url
        if self.home is None:
            self.home = self.url
        if add:
            self.addHistory(self.url, xview=xview, yview=yview)

        # print self.history.index, self.history.list
        if self.history.index > 1:
            self.backButton.config(state="normal")
        else:
            self.backButton.config(state="disabled")
        if self.history.index < len(self.history.list):
            self.forwardButton.config(state="normal")
        else:
            self.forwardButton.config(state="disabled")

        old_c1, old_c2 = self.defcursor, self.handcursor
        self.defcursor = self.handcursor = "watch"
        self.text.config(cursor=self.defcursor)
        self.text.update_idletasks()
        # self.frame.config(cursor=self.defcursor)
        # self.frame.update_idletasks()
        self.text.config(state="normal")
        self.text.delete("1.0", "end")
        # self.images = {}
        self.text.textbuffer = ''
        writer = tkHTMLWriter(self.text, self, self.app)
        fmt = formatter.AbstractFormatter(writer)
        parser = tkHTMLParser(fmt)
        parser.feed(data)
        parser.close()
        self.text.config(state="disabled")
        if 0.0 <= xview <= 1.0:
            self.text.xview_moveto(xview)
        if 0.0 <= yview <= 1.0:
            self.text.yview_moveto(yview)
        # self.parent.wm_title(parser.title)
        self.window.titleline.text = parser.title
        self.parent.wm_iconname(parser.title)
        self.defcursor, self.handcursor = old_c1, old_c2
        self.text.config(cursor=self.defcursor)
        # self.frame.config(cursor=self.defcursor)

    def addHistory(self, url, xview=0, yview=0):
        if url not in self.visited_urls:
            self.visited_urls.append(url)
        if self.history.index > 0:
            u, xv, yv = self.history.list[self.history.index - 1]
            if cmp2(u, url) == 0:
                self.updateHistoryXYView()
                return
        del self.history.list[self.history.index:]
        self.history.list.append((url, xview, yview))
        self.history.index = self.history.index + 1

    def updateHistoryXYView(self):
        if self.history.index > 0:
            url, xview, yview = self.history.list[self.history.index - 1]
            self.history.list[self.history.index - 1] = (url, xview, yview)

    def goBack(self, *event):
        if self.history.index > 1:
            self.updateHistoryXYView()
            self.history.index = self.history.index - 1
            url, xview, yview = self.history.list[self.history.index - 1]
            self.display(url, add=0, relpath=0, xview=xview, yview=yview)

    def goForward(self, *event):
        if self.history.index < len(self.history.list):
            self.updateHistoryXYView()
            url, xview, yview = self.history.list[self.history.index]
            self.history.index = self.history.index + 1
            self.display(url, add=0, relpath=0, xview=xview, yview=yview)

    def goHome(self, *event):
        if self.home and cmp2(self.home, self.url) != 0:
            self.updateHistoryXYView()
            self.display(self.home, relpath=0)

    def errorDialog(self, msg):
        MfxMessageDialog(self.parent,
                         title=_("%s HTML Problem") % TITLE,
                         text=msg,
                         # bitmap="warning"
                         # FIXME: this interp don't have images
                         strings=(_("&OK"), ), default=0)

    def getImage(self, fn):
        if fn in self.images:
            return self.images[fn]
        else:
            return None

    def showImage(self, src, alt, ismap, align, width, height):
        url = self.basejoin(src)
        img = self.getImage(url)
        if img:
            self.text.image_create(index="insert", image=img, padx=0, pady=0)


# ************************************************************************
# *
# ************************************************************************

''
#!/usr/bin/python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 2017 LB
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#

from __future__ import division

import logging
import math
import traceback

from kivy.animation import Animation
from kivy.app import App
from kivy.base import EventLoop
from kivy.base import stopTouchApp
from kivy.cache import Cache
from kivy.clock import Clock
from kivy.config import Config
from kivy.core.audio import SoundLoader
from kivy.core.window import Window
from kivy.graphics import Color
from kivy.graphics import Line
from kivy.graphics import Rectangle
from kivy.graphics import Triangle
from kivy.properties import StringProperty
from kivy.uix.actionbar import ActionButton
from kivy.uix.actionbar import ActionPrevious
from kivy.uix.actionbar import ActionView
from kivy.uix.behaviors import ButtonBehavior
from kivy.uix.boxlayout import BoxLayout
from kivy.uix.button import Button
from kivy.uix.image import Image as KivyImage
from kivy.uix.label import Label
from kivy.uix.scrollview import ScrollView
from kivy.uix.treeview import TreeView
from kivy.uix.treeview import TreeViewLabel
from kivy.uix.widget import Widget
from kivy.utils import platform

from pysollib.kivy.androidperms import requestStoragePerm

if platform != 'android':
    Config.set('input', 'mouse', 'mouse,multitouch_on_demand')

# =============================================================================


def get_platform():
    return platform

# =============================================================================


def get_screen_ori():
    if get_platform() == 'android':
        from jnius import autoclass
        from jnius import cast
    else:
        logging.info("LApp: ori = unknown")
        return None

    PythonActivity = autoclass('org.kivy.android.PythonActivity')
    currentActivity = cast('android.app.Activity', PythonActivity.mActivity)

    # Display = autoclass('android.view.Display')
    # WindowManager = autoclass('android.view.WindowManager')

    wm = currentActivity.getWindowManager()
    d = wm.getDefaultDisplay()

    so = None
    if d.getWidth() > d.getHeight():
        so = 'landscape'
    else:
        so = 'portrait'

    logging.info("LApp: ori = %s" % so)
    return so

# =============================================================================
# kivy EventDispatcher passes keywords, that to not correspond to properties
# to the base classes. Finally they will reach 'object'. With python3 (but not
# python2) 'object' throws an exception 'takes no parameters' in that a
# situation. We therefore underlay a base class (right outside), which
# swallows up remaining keywords. Thus the keywords do not reach 'object' any
# more.


class LBase(object):
    def __init__(self, **kw):
        super(LBase, self).__init__()

# =============================================================================


class LPopCommander(LBase):
    def __init__(self, **kw):
        super(LPopCommander, self).__init__()
        self.pop_command = kw['pop_command']

    def pop(self):
        if self.pop_command is not None:
            self.pop_command(0)
            return True
        return False

# =============================================================================


class LAnimationMgr(object):
    def __init__(self, **kw):
        super(LAnimationMgr, self).__init__()
        self.animations = []
        self.widgets = {}

    def animEnd(self, anim, widget):
        # print('LAnimationMgr: animEnd = %s.%s' % (anim, widget))

        self.widgets[widget] = self.widgets[widget][1:]
        self.animations.remove(anim)
        if len(self.widgets[widget]) > 0:
            # start next animation on widget
            nanim = self.widgets[widget][0]
            self.animations.append(nanim)
            print('LAnimationMgr: animEnd, append = %s' % (nanim))
            nanim.start(widget)
        else:
            # no further animations for widget so stop
            del self.widgets[widget]

    def makeAnimStart(self, anim, spos, widget):
        def animStart(dt):
            widget.pos = spos
            # print('LAnimationMgr: animStart = %s ... %s' % (anim, dt))
            anim.start(widget)
        return animStart

    def checkRunning(self):
        return len(self.animations) > 0

    def create(self, spos, widget, **kw):
        x = 0.0
        y = 0.0
        duration = 0.2
        transition = 'in_out_quad'
        if 'x' in kw:
            x = kw['x']
        if 'y' in kw:
            y = kw['y']
        if 'duration' in kw:
            duration = kw['duration']
        if 'transition' in kw:
            transition = kw['transition']

        anim = Animation(x=x, y=y, duration=duration, transition=transition)
        anim.bind(on_complete=self.animEnd)
        if 'bindE' in kw:
            anim.bind(on_complete=kw['bindE'])
        if 'bindS' in kw:
            anim.bind(on_start=kw['bindS'])

        offset = duration / 3.0
        # offset = duration*1.2
        timedelay = offset * len(self.animations)
        # print('offset = %s'% offset)
        print('LAnimationMgr: timedelay = %s' % timedelay)

        if widget in self.widgets:
            # append additional animation to widget
            self.widgets[widget].append(anim)
        else:
            # setup first animation for widget
            self.animations.append(anim)
            self.widgets[widget] = [anim]
            Clock.schedule_once(self.makeAnimStart(
                anim, spos, widget), timedelay)


LAnimationManager = LAnimationMgr()

# =============================================================================

LSoundLoader = SoundLoader

# =============================================================================


class LBoxLayout(BoxLayout, LBase):
    def __init__(self, **kw):
        super(LBoxLayout, self).__init__(**kw)

    def winfo_screenwidth(self):
        return self.size[0]

    def winfo_screenheight(self):
        return self.size[1]

# =============================================================================


class LImage(KivyImage, LBase):

    def __init__(self, **kwargs):
        super(LImage, self).__init__(**kwargs)
        self.size = self.texture.size
        self.silent = False
        self.allow_stretch = True
        # self.keep_ratio = 0
        # self.size_hint = (1.0/9.0, 1.0/4.0)
        self.size_hint = (1.0, 1.0)
        # self.mipmap = True     # funktioniert nicht.

        self.corePos = None
        self.coreSize = None

        # logging.info('LImage: __init__() %s' % kwargs)

    def getHeight(self):
        return self.size[1]

    def getWidth(self):
        return self.size[0]

    def subsample(self, r):
        ''
        return LImage(texture=self.texture)
        '''
        if (self.source!=None):
            # logging.info("LImage: subsample, %d, %s " % (r , self.source))
            return LImage(source=self.source)
        elif (self.texture!=None):
            # logging.info("LImage: subsample, %d (texture) " % r)
            return LImage(texture=self.texture)
        '''
        return self

    def on_touch_down(self, touch):
        if self.silent:
            return False

        # print('LImage: touch_down on %s' % str(touch.pos))
        if self.collide_point(*touch.pos):
            if (self.source is not None):
                print('LImage match %s' % self.source)
            else:
                print('LImage match with texture')
            return True
        return False

    def on_touch_up(self, touch):
        if self.silent:
            return False

        # print('LImage: touch_up on %s' % str(touch.pos))
        if self.collide_point(*touch.pos):
            if (self.source is not None):
                print('LImage match %s' % self.source)
            else:
                print('LImage match with texture')
            return True
        return False

# =============================================================================


def addAnchorOffset(pos, size, anchor):
    # print ('MfxCanvas: anchor=%s' % (anchor))
    x = pos[0]
    y = pos[1]
    xa = 0
    ya = 0
    if anchor == "n":
        ya = -1
    elif anchor == "w":
        xa = -1
    elif anchor == "s":
        ya = 1
    elif anchor == "e":
        xa = 1
    elif anchor == "ne":
        ya = -1
        xa = 1
    elif anchor == "nw":
        ya = -1
        xa = -1
    elif anchor == "se":
        ya = 1
        xa = 1
    elif anchor == "sw":
        ya = 1
        xa = -1

    if xa == 0:
        x = x - size[0] / 2.0
    elif xa == 1:
        x = x - size[0]
    if ya == 0:
        y = y - size[1] / 2.0
    elif ya == 1:
        y = y - size[1]
    return (x, y)

# =============================================================================


def LColorToKivy(outline):
    if (outline[0] == '#'):
        outline = outline[1:]
    ou0 = float(int(outline[0:2], 16)) / 256.0
    ou1 = float(int(outline[2:4], 16)) / 256.0
    ou2 = float(int(outline[4:6], 16)) / 256.0
    ou3 = 1.0
    if len(outline) >= 8:
        ou3 = float(int(outline[6:8], 16)) / 256.0
    return ou0, ou1, ou2, ou3

# =============================================================================


class LText(Widget, LBase):
    text = StringProperty('')

    def __init__(self, canvas, x, y, **kwargs):
        super(LText, self).__init__(**kwargs)
        # super(LText, self).__init__()

        if 'text' not in kwargs:
            kwargs['text'] = 'X'

        font = 'helvetica'
        fontsize = 18.0
        if 'font' in kwargs:
            font = kwargs['font'][0]
            fontsize = kwargs['font'][1]
            del kwargs['font']

        self.anchor = 'nw'
        if 'anchor' in kwargs:
            self.anchor = kwargs['anchor']

        self.text = kwargs['text']
        self.coreFontSize = fontsize
        self.coreFont = font

        # print('LText: font = %s, font_size = %s' % (font, fontsize))
        # print('LText: text = %s' % (self.text))

        kwargs['font'] = font
        kwargs['font_size'] = fontsize

        class MyLabel(Label, LBase):
            pass

        self.label = MyLabel(**kwargs)
        self.label.texture_update()
        self.coreSize = self.label.texture_size
        self.corePos = (x, y)
        self.prnt = canvas

        # print('LText: corePos = %s, coreSize = %s'
        # % (self.corePos, self.coreSize))

        self.size = self.label.texture_size

        self.bind(size=self.updateCanvas)
        self.bind(pos=self.updateCanvas)
        self.bind(text=self.updateCanvas)

    def updateCanvas(self, inst, val):
        self.label.text = self.text
        self.label.texture_update()

        self.coreSize = self.label.texture_size
        cp = addAnchorOffset(self.corePos, self.coreSize, self.anchor)
        cs = self.coreSize

        pos, size = self.prnt.CoreToKivy(cp, cs)
        # print('LText: pos = %s, size = %s' % (pos, size))

        color = LColorToKivy(self.prnt._text_color)
        # print('LText: color = %s' % str(color))
        self.canvas.clear()
        with self.canvas:
            Color(color[0], color[1], color[2], color[3])
            Rectangle(texture=self.label.texture, pos=pos, size=size)

# =============================================================================


class LEvent(object):
    def __init__(self):
        self.x = 0
        self.y = 0
        self.cardid = -1
        self.char = False
        pass

# =============================================================================


class LLine(Widget, LBase):
    def __init__(self, canvas, args, **kw):
        super(LLine, self).__init__(**kw)

        print('kw = %s%s' % (args, kw))

        lwidth = 10
        fill = '#ee3344'
        ashape = ()
        arrow = 'none'

        self.prnt = canvas
        xmin = 100000
        ymin = 100000
        xmax = -100000
        ymax = -100000
        self.corePoly = []
        if isinstance(args[0], list):
            kww = args[1]
            if ('width' in kww):
                lwidth = kww['width']
            self.lwidth = lwidth
            if ('fill' in kww):
                fill = kww['fill']
            self.fill = fill
            if ('arrowshape' in kw):
                ashape = kw['arrowshape']
            self.ashape = ashape
            if ('arrow' in kw):
                arrow = kw['arrow']
            self.arrow = arrow

            pts = args[0]
            ipts = iter(pts)
            for x, y in zip(ipts, ipts):
                print('%s.%s' % (x, y))
                self.corePoly.append(x)
                self.corePoly.append(y)
                if x < xmin:
                    xmin = x
                if x > xmax:
                    xmax = x
                if y < ymin:
                    ymin = y
                if y > ymax:
                    ymax = y
        else:
            if ('width' in kw):
                lwidth = kw['width']
            self.lwidth = lwidth
            if ('fill' in kw):
                fill = kw['fill']
            self.fill = fill
            if ('arrowshape' in kw):
                ashape = kw['arrowshape']
            self.ashape = ashape
            if ('arrow' in kw):
                arrow = kw['arrow']
            self.arrow = arrow

            for i in range(0, 2):
                x = args[2 * i]
                y = args[2 * i + 1]
                self.corePoly.append(x)
                self.corePoly.append(y)
                if x < xmin:
                    xmin = x
                if x > xmax:
                    xmax = x
                if y < ymin:
                    ymin = y
                if y > ymax:
                    ymax = y

        print('width = %s' % self.lwidth)
        print('color = %s' % self.fill)
        print('arrow = %s' % self.arrow)
        print('ashape = %s' % str(self.ashape))

        self.alist = []
        if self.arrow == 'last':
            self.alist.append(self.corePoly[-2])
            self.alist.append(self.corePoly[-1])
            self.alist.append(self.corePoly[-4])
            self.alist.append(self.corePoly[-3])
        elif self.arrow != 'none':
            self.alist.append(self.corePoly[0])
            self.alist.append(self.corePoly[1])
            self.alist.append(self.corePoly[2])
            self.alist.append(self.corePoly[3])

        self.corePos = (xmin, ymin)
        self.coreSize = (xmax - xmin, ymax - ymin)
        self.pos = self.corePos
        self.size = self.coreSize

        self.bcolor = LColorToKivy(self.fill)

        self.bind(size=self.updateCanvas)
        self.bind(pos=self.updateCanvas)

    def updateCanvas(self, instance, value):
        # size = self.size
        # pos = self.pos

        # Linie:
        poly = None
        poly = []
        dmy, sxy = self.prnt.CoreToKivy(
            (0.0, 0.0), (self.lwidth, self.lwidth))
        wpoly = sxy[1]
        ipts = iter(self.corePoly)
        for x, y in zip(ipts, ipts):
            print('%s.%s' % (x, y))
            xy, dmy = self.prnt.CoreToKivy((x, y))
            poly.append(xy[0])
            poly.append(xy[1])

        def rot(x, y, a):
            x1 = x * math.cos(a) + y * math.sin(a)
            y1 = y * math.cos(a) - x * math.sin(a)
            return (x1, y1)

        # Pfeil:
        PI = 3.1415926
        atrio = None
        atrio = []
        if (len(self.ashape) > 2):
            dx = (self.alist[0] - self.alist[2])
            dy = (self.alist[1] - self.alist[3])
            if (dx == 0.0):
                if (dy > 0.0):
                    ang = -PI / 2.0
                else:
                    ang = PI / 2.0
            else:
                ang = math.atan(dy / dx)
            if (dx > 0.0):
                ang = ang + PI

            # (kante, winkel?)
            x = self.ashape[0] * math.cos(self.ashape[1] * PI / 360.0)
            y = 2.0 * self.ashape[0] * math.sin(self.ashape[1] * PI / 360.0)
            # (länge, breite?)
            # x = self.ashape[0]
            # y = self.ashape[1]
            o = self.ashape[2]
            axy, dmy = self.prnt.CoreToKivy((self.alist[0], self.alist[1]))
            dmy, asxy = self.prnt.CoreToKivy((0, 0), (x, y))
            dmy, aoff = self.prnt.CoreToKivy((0, 0), (o, o))
            print('asxy=%s' % str(asxy))

            x1, y1 = rot(-aoff[0], 0.0, ang)
            atrio.append(x1 + axy[0])
            atrio.append(y1 + axy[1])
            x1, y1 = rot(asxy[0] - aoff[0], asxy[1], ang)
            atrio.append(x1 + axy[0])
            atrio.append(y1 + axy[1])
            x1, y1 = rot(asxy[0] - aoff[0], -asxy[1], ang)
            atrio.append(x1 + axy[0])
            atrio.append(y1 + axy[1])

        self.canvas.clear()
        with self.canvas:
            Color(self.bcolor[0], self.bcolor[1],
                  self.bcolor[2], self.bcolor[3])
            Line(points=poly, width=wpoly, cap='none', joint='bevel')
            if (len(atrio) > 2):
                Triangle(points=atrio)

# =============================================================================


class LRectangle(Widget, LBase):
    def __init__(self, prnt, args, **kw):
        super(LRectangle, self).__init__(**kw)
        self.prnt = prnt

        # print('width   %s' % kw['width'])
        # print('outline %s' % kw['outline'])
        # print('fill    %s' % kw['fill'])

        width = 10.0
        if ('width' in kw):
            width = float(kw['width'])

        bcolor = '#ffa000a0'
        if ('outline') in kw:
            bcolor = kw['outline']
        if (not bcolor or len(bcolor) < 7):
            bcolor = '#ffa000a0'

        fcolor = '#00aaff20'
        if ('fill') in kw:
            fcolor = kw['fill']
        if (not fcolor or len(fcolor) < 7):
            fcolor = '#00aaff20'

        self.group = None
        if 'group' in kw:
            self.group = kw['group']

        xmin = float(args[0])
        ymin = float(args[1])
        xmax = float(args[2])
        ymax = float(args[3])

        # print ('LRectangle: min = %s.%s' % (xmin, ymin))
        # print ('LRectangle: max = %s.%s' % (xmax, ymax))
        # print ('LRectangle: border = %s' % (width))

        self.border = width
        self.fcolor = LColorToKivy(fcolor)
        self.bcolor = LColorToKivy(bcolor)

        self.corePos = (xmin, ymin)
        self.coreSize = (xmax - xmin, ymax - ymin)
        self.pos = self.corePos
        self.size = self.coreSize
        self.topleft = (xmin + width / 2.0, ymin + width / 2.0)
        self.bottomright = (xmax - width / 2.0, ymax - width / 2.0)
        self.poly = None

        self.bind(size=self.updateCanvas)
        self.bind(pos=self.updateCanvas)

    def updateCanvas(self, instance, value):
        # print('LRectangle: updateCanvas')

        pos, size = self.prnt.CoreToKivy(self.corePos, self.coreSize)
        bpos, dmy = self.prnt.CoreToKivy(self.topleft)
        tpos, dmy = self.prnt.CoreToKivy(self.bottomright)

        poly = [bpos[0], bpos[1],
                tpos[0], bpos[1],
                tpos[0], tpos[1],
                bpos[0], tpos[1],
                bpos[0], bpos[1]]

        dmy, brd = self.prnt.CoreToKivy(
            (0.0, 0.0), (self.border, self.border))
        border = brd[1]

        self.canvas.clear()
        with self.canvas:
            Color(self.fcolor[0], self.fcolor[1],
                  self.fcolor[2], self.fcolor[3])
            Rectangle(pos=pos, size=size)
            Color(self.bcolor[0], self.bcolor[1],
                  self.bcolor[2], self.bcolor[3])
            Line(points=poly, width=border)

    def on_touch_down(self, touch):
        if self.collide_point(*touch.pos):
            if self.group is not None:
                logging.info('LRectangle: self=%s group=%s' %
                             (self, self.group))
                if '<1>' in self.group.bindings:
                    # logging.info('LRectangle: size=%s' % (self.size))
                    ppos, psize = self.group.canvas.KivyToCore(touch.pos)
                    event = LEvent()
                    event.x = ppos[0]
                    event.y = ppos[1]
                    if touch.is_double_tap:
                        self.group.bindings['<Double-1>'](event)
                    else:
                        self.group.bindings['<1>'](event)
                    return True
        return False

    def on_touch_up(self, touch):
        if self.collide_point(*touch.pos):
            if self.group is not None:
                logging.info('LRectangle: self=%s group=%s' %
                             (self, self.group))
                if '<ButtonRelease-1>' in self.group.bindings:
                    ppos, psize = self.group.canvas.KivyToCore(touch.pos)
                    event = LEvent()
                    event.x = ppos[0]
                    event.y = ppos[1]
                    self.group.bindings['<ButtonRelease-1>'](event)
                    return True
        return False

# =============================================================================


class LImageItem(BoxLayout, LBase):
    def __init__(self, **kw):
        super(LImageItem, self).__init__(**kw)
        self.game = None
        self.card = None
        self.group = None
        if 'game' in kw:
            self.game = kw['game']
        if 'card' in kw:
            self.card = kw['card']
        if 'group' in kw:
            self.group = kw['group']
        self.dragstart = None
        # ev. noch globales cache für stacks->game und cards->stack
        # einrichten. Aber: stacks hängt vom jeweiligen spiel ab.

    def send_event_pressed_n(self, event, n):
        if self.group and n in self.group.bindings:
            self.group.bindings[n](event)

    def send_event_pressed(self, touch, event):

        if touch.is_double_tap:
            self.send_event_pressed_n(event, '<Double-1>')
        else:
            button = 'left'
            if 'button' in touch.profile:
                button = touch.button
            if button == 'left':
                self.send_event_pressed_n(event, '<1>')
                return
            if button == 'middle':
                self.send_event_pressed_n(event, '<2>')
                return
            if button == 'right':
                self.send_event_pressed_n(event, '<3>')
                return

    def on_touch_down(self, touch):

        if self.collide_point(*touch.pos):

            for c in self.children:
                # print('child at %s' % c)
                if (c.on_touch_down(touch) and self.game):
                    for stack in self.game.allstacks:
                        for i in range(len(stack.cards)):
                            if stack.cards[i] == self.card:
                                print('LCardImage: stack = %s' % stack)
                                print('LCardImage: touch = %s' % str(touch))
                                print('grab')
                                # grab the touch!
                                touch.grab(self)
                                ppos, psize = self.game.canvas.KivyToCore(
                                    touch.pos, self.size)
                                event = LEvent()
                                event.x = ppos[0]
                                event.y = ppos[1]
                                self.dragstart = touch.pos
                                event.cardid = i
                                self.send_event_pressed(touch, event)
                                return True

            if self.group is not None:
                print('LCardImage: self=%s group=%s' % (self, self.group))
                if '<1>' in self.group.bindings:
                    ppos, psize = self.group.canvas.KivyToCore(
                        touch.pos, self.size)
                    event = LEvent()
                    event.x = ppos[0]
                    event.y = ppos[1]
                    self.group.bindings['<1>'](event)
                    return True

            if self.card is None:
                return False
            if self.game is None:
                return False

        # print('LCardImage: touch_down on %s' % str(touch.pos))
        return False

    def send_event_released_1(self, event):
        if self.group and '<ButtonRelease-1>' in self.group.bindings:
            self.group.bindings['<ButtonRelease-1>'](event)

    def on_touch_up(self, touch):
        if touch.grab_current is self:
            # release my grabbed touch!
            print('ungrab')
            touch.ungrab(self)
            return True

        if self.collide_point(*touch.pos):

            for c in self.children:
                # print('child at %s' % c)

                if (c.on_touch_up(touch) and self.game):
                    for stack in self.game.allstacks:
                        for i in range(len(stack.cards)):
                            if stack.cards[i] == self.card:
                                print('LCardImage: stack = %s' % stack)
                                ppos, psize = self.game.canvas.KivyToCore(
                                    touch.pos, self.size)
                                event = LEvent()
                                event.x = ppos[0]
                                event.y = ppos[1]
                                event.cardid = i
                                self.send_event_released_1(event)
                                return True

            if self.group is not None:
                print('LCardImage: self=%s group=%s' % (self, self.group))
                if '<ButtonRelease-1>' in self.group.bindings:
                    ppos, psize = self.group.canvas.KivyToCore(
                        touch.pos, self.size)
                    event = LEvent()
                    event.x = ppos[0]
                    event.y = ppos[1]
                    self.group.bindings['<ButtonRelease-1>'](event)
                    return True

            if self.card is None:
                return False
            if self.game is None:
                return False

        # print('LCardImage: touch_up on %s' % str(touch.pos))
        return False

    def on_touch_move(self, touch):
        # behandeln nur wenn grabbed
        if touch.grab_current is not self:
            return False
        if 'pos' not in touch.profile:
            return False

        print('LCardImage: touch_move on %s' % str(touch.pos))

        for stack in self.game.allstacks:
            for i in range(len(stack.cards)):
                if stack.cards[i] == self.card:
                    print('LCardImage: stack = %s/%s' % (stack, touch))
                    ppos, psize = self.game.canvas.KivyToCore(
                        touch.pos, self.size)
                    event = LEvent()
                    event.x = ppos[0]
                    event.y = ppos[1]
                    event.cardid = i
                    stack._motionEventHandler(event)
                    return True

        # print('LCardImage: touch_move on %s' % str(touch.pos))
        return False

# =============================================================================
# Treeview


class LTreeRoot(TreeView, LBase):
    def __init__(self, **kw):
        super(LTreeRoot, self).__init__(**kw)
        self.kw = kw

    def closeLastNode(self):
        ret = False
        lastopen = None
        for ti in reversed(self.children):
            if isinstance(ti, LTreeNode):
                if ti.is_open:
                    lastopen = ti

        if lastopen is not None:
            self.toggle_node(lastopen)
            self.select_node(lastopen)
            ret = True

        return ret


class LTreeNode(ButtonBehavior, TreeViewLabel, LBase):

    # def __init__(self, gameview, **kw):
    def __init__(self, **kw):
        self.command = None
        if 'command' in kw:
            self.command = kw['command']
        self.variable = None
        if 'variable' in kw:
            self.variable = kw['variable']
        if 'value' in kw:
            self.value = kw['value']
        if ('text' in kw):
            self.title = kw['text']

        super(LTreeNode, self).__init__(markup=True, **kw)

        if self.variable:
            self.variable.bind(value=self.onVarChange)
            self.onVarChange(self.variable, self.variable.get())

        # self.gameview = gameview
        self.coreFont = self.font_size
        # self.scaleFont(self.gameview.size[1])
        # self.gameview.bind(size=self.scaleFontCB)
        # nicht skalieren!

        self.bind(on_release=self.on_released)
        self.bind(is_selected=self.onSelect)
        self.bind(is_open=self.onOpen)

    def onVarChange(self, instance, value):
        # print('LTreeNode: onVarChange(%s, %s, %s)'
        # % (instance, value, type(value)))
        if type(value) is bool:
            self.setCheck(value)
        if type(value) is int:
            self.setVal(value)
        if type(value) is str:
            self.setVal(value)
        # if type(value) is unicode:
        #     self.setVal(value)

    def setCheck(self, value):
        # print('LTreeNode: setCheck(%s)' % value)
        if value:
            # self.text = '+ '+self.title
            self.text = '[b]+[/b] ' + self.title
        else:
            self.text = '- ' + self.title
        self.texture_update()

    def setVal(self, value):
        # print('LTreeNode: setVal(%s)' % value)
        if value == self.value:
            # fs = str(int(self.font_size+2))
            # print ('%s.%s' % (self.font_size, fs))
            # self.text = '[size='+fs+'][b]'+self.title+'[/b][/size]'
            # self.text = 'o '+self.title
            self.text = '[b]o[/b] ' + self.title
            # self.text = u'\u25cf '+self.title  # unicode filled circle
        else:
            self.text = self.title
            self.text = u'    ' + self.title
            # self.text = u'\u25cb  '+self.title # unicode open circle
        self.texture_update()

    # font skalierung.

    def scaleFont(self, value):
        self.font_size = int(self.coreFont * value / 550.0)

    def scaleFontCB(self, instance, value):
        self.scaleFont(value[1])

    # benutzer interaktion.

    def onSelect(self, instance, val):
        if val:
            print('select %s' % self.title)
        else:
            print('deselect %s' % self.title)
        pass

    def collapseChildren(self, deep=False):

        def cc(p, n):
            for c in n.nodes:
                if c.is_open:
                    cc(p, c)
                    p.toggle_node(c)

        p = self.parent
        if p and isinstance(p, LTreeRoot):
            for n in self.nodes:
                if n.is_open:
                    # n.collapseChildren()   # ginge nur mit LTreeNode!
                    if deep:
                        cc(p, n)            # geht mit allen TreeViewNode
                    p.toggle_node(n)

    def collapseSiblings(self, deep=True):

        def cc(p, n):
            for c in n.nodes:
                if c.is_open:
                    cc(p, c)
                    p.toggle_node(c)

        p = self.parent
        if p and isinstance(p, LTreeRoot):
            # print('expand: LTreeRoot')
            for n in p.root.nodes:
                # print('expand: -> check %s' % n.title)
                if n != self and n.is_open and n.level >= self.level:
                    # print('expand: -> close %s' % n.title)
                    if deep:
                        cc(p, n)
                    p.toggle_node(n)

            pn = self.parent_node
            if pn and isinstance(pn, LTreeNode):
                # print('expand: LTreeNode')
                for n in pn.nodes:
                    # print('expand: -> check %s' % n.title)
                    if n != self and n.is_open and n.level >= self.level:
                        # print('expand: -> close %s' % n.title)
                        if deep:
                            cc(p, n)
                        p.toggle_node(n)

    def onOpen(self, instance, val):
        if val:
            # print('expand %s, %s' % (self.level, self.title))
            self.collapseSiblings(deep=False)
        else:
            # print('collapse %s, %s' % (self.level, self.title))
            pass

    def on_released(self, v):
        if self.command:
            Clock.schedule_once(self.commandCB, 0.1)
        else:
            Clock.schedule_once(self.toggleCB, 0.1)

    def commandCB(self, d):
        self.command()

    def toggleCB(self, d):
        # hier könnte der knoten ev. auch neu aufgebaut werden ?!
        self.parent.toggle_node(self)

# =============================================================================


class LTopLevelContent(BoxLayout, LBase):
    def __init__(self, **kw):
        super(LTopLevelContent, self).__init__(**kw)

        # beispiel zu canvas (hintergrund)
        with self.canvas.before:
            Color(0.45, 0.5, 0.5, 1.0)
            self.rect = Rectangle(pos=self.pos, size=self.size)
        self.bind(pos=self.update_rect)
        self.bind(size=self.update_rect)

    def update_rect(self, *args):
        self.rect.pos = self.pos
        self.rect.size = self.size

    def wm_minsize(self, w, h):
        pass

# =============================================================================


class LTopLine(ButtonBehavior, Label, LBase):

    def __init__(self, **kw):
        super(LTopLine, self).__init__(**kw)
        with self.canvas.before:
            Color(0.45, 0.3, 0.3, 1.0)
            self.rect = Rectangle(pos=self.pos, size=self.size)
        self.bind(pos=self.update_rect)
        self.bind(size=self.update_rect)

    def update_rect(self, *args):
        self.rect.pos = self.pos
        self.rect.size = self.size

    def on_press(self):
        print('press')

    def on_release(self):
        print('release')

# =============================================================================


class LTopLevel0(BoxLayout, LBase):
    def __init__(self, top, title=None, **kw):
        self.main = top
        super(LTopLevel0, self).__init__(
            orientation="vertical", **kw)

        # self.canvas.add(Color(0, 1, 0, 0.4))
        # self.canvas.add(Rectangle(pos=(100, 100), size=(100, 100)))

        self.size_hint = (0.5, 1.0)
        '''
        self.titleline = BoxLayout(
            orientation="horizontal", size_hint=[1.0, 0.15], **kw)
        self.button = Button(text="X", size_hint=[0.15, 1.0], **kw)
        if not title:
            title = '<>'
        self.title = Label(text=title, **kw)
        self.titleline.add_widget(self.title)
        self.titleline.add_widget(self.button)
        '''
        self.titleline = LTopLine(text=title, size_hint=[1.0, 0.15])
        self.title = title

        # self.content = BoxLayout(orientation="vertical", **kw)
        self.content = LTopLevelContent(orientation="vertical", **kw)
        self.add_widget(self.titleline)
        self.add_widget(self.content)
        '''
        self.button.bind(on_press=self.onClick)
        '''
        self.titleline.bind(on_press=self.onClick)
        self.main.pushWork(self.title, self)

    def onClick(self, event):
        print('LTopLevel: onClick')
        self.main.popWork(self.title)

# =============================================================================


class LTopLevel(BoxLayout, LBase):
    def __init__(self, parent, title=None, **kw):
        self.mainwindow = parent
        super(LTopLevel, self).__init__(
            orientation="vertical", **kw)

        if ('size_hint' not in kw):
            self.size_hint = (0.5, 1.0)
        else:
            del kw['size_hint']
        self.titleline = LTopLine(text=title, size_hint=(1.0, 0.10))

        self.content = LTopLevelContent(orientation="vertical", **kw)
        self.add_widget(self.titleline)
        self.add_widget(self.content)

    def processAndroidBack(self):
        ret = False
        # try to collapse the last open tree node
        # the treeview will be located inside of a scrollview
        # (-> menubar.py)
        for c in self.content.children:
            # print("childitem: %s" % str(c))
            if isinstance(c, LScrollView):
                for t in reversed(c.children):
                    # print("  childitem: %s" % str(t))
                    if isinstance(t, LTreeRoot):
                        ret = t.closeLastNode()
            if isinstance(c, BoxLayout):
                for t in reversed(c.children):
                    # print("  childitem: %s" % str(t))
                    if isinstance(t, LPopCommander):
                        ret = t.pop()
                    pass
        return ret


# =============================================================================


class LMenuBar(BoxLayout, LBase):
    def __init__(self, **kw):
        super(LMenuBar, self).__init__(**kw)
        self.menu = None
        self.size_hint = (1.0, 0.08)

    def setMenu(self, menu):
        print('LMenuBar: setMenu %s, %s' % (self, menu))

        # Letztes Menu entfernen
        last = self.menu
        if (last is not None):
            self.remove_widget(last)
            self.menu = None

        # Neues Menu einfügen
        if (menu is not None):
            self.add_widget(menu)
            self.menu = menu
            menu.setBar(self)

    def getMenu(self):
        return self.menu

# =============================================================================


class LMenu(ActionView, LBase):
    def __init__(self, prev, **kw):
        super(LMenu, self).__init__(**kw)

        class MyActionPrev(ActionPrevious, LBase):
            pass

        kw['app_icon'] = 'data/images/icons/48x48/pysol.png'
        kw['with_previous'] = prev
        kw['size_hint'] = (.01, 1)
        self.ap = MyActionPrev(**kw)
        self.add_widget(self.ap)
        self.bar = None
        self.uppermenu = None

    def addItem(self, mi):
        # print ('LMenu: addItem '+str(mi)+' '+str(self.bar))
        mi.setBar(self.bar)
        self.add_widget(mi)

    def setBar(self, bar):
        # print ('LMenu: setBar %s, %s' % (self, bar))
        self.bar = bar

    def prev(self, menu):
        # print ('LMenu: prev = %s' % menu)
        self.uppermenu = menu
        self.ap.bind(on_release=self.upper)
        pass

    def upper(self, event):
        print('upper')
        self.bar.setMenu(self.uppermenu)

    def delete(self, pos, mode):
        # print ('LMenu(%s): delete(%s, %s)' % (self, pos, mode))

        items = []
        menues = []
        for c in self.children:
            if (type(c) is LMenuItem):
                # print ('LMenu: to delete child %s' % c)
                items.append(c)
            elif (type(c) is LMenu):
                # print ('LMenu: to delete child %s' % c)
                menues.append(c)
            else:
                # print ('LMenu: unknown child %s' % c)
                pass

        for c in items:
            # print ('LMenu: delete child %s' % c)
            self.clear_widgets([c])
        for c in menues:
            # print ('LMenu: delete child %s' % c)
            self.clear_widgets([c])
            c.delete(pos, mode)

    # def __str__(self):
    #   return hex(id(self))

# =============================================================================


class LMenuItem(ActionButton, LBase):

    def __init__(self, menu, **kw):
        super(LMenuItem, self).__init__(**kw)
        # super(LMenuItem, self).__init__()
        self.bar = None
        self.submenu = None
        self.menu = menu
        self.menu.addItem(self)
        self.minimum_width = '200sp'
        if 'command' in kw:
            self.setCommand(kw['command'])
        if 'submenu' in kw:
            self.setSubMenu(kw['submenu'])

    def setBar(self, bar):
        # print ('LMenuItem: setBar %s, %s' % (self, bar))
        self.bar = bar

    def onClick(self, event):
        # print('LMenuItem: onClick')
        # print('LMenuItem: submenu vorh: '+str(self.submenu))
        self.bar.setMenu(self.submenu)
        return True

    def setSubMenu(self, submenu):
        # print('LMenuItem: setSubMenu')
        self.submenu = submenu
        # print('LMenuItem: setSubMenu: '+str(self.submenu))
        self.submenu.prev(self.menu)
        self.submenu.setBar(self.bar)
        self.bind(on_release=self.onClick)
        pass

    def setCommand(self, cmd):
        # print('LMenuItem: setCommand')
        self.bind(on_release=cmd)

    # def __str__(self):
    #   return hex(id(self))

# =============================================================================


class LScrollView(ScrollView, LBase):
    def __init__(self, **kw):
        super(LScrollView, self).__init__(**kw)
        self.delayDown = False
        self.touch = None

    def delayReset(self, dt):
        if not self.delayDown:
            return
        self.delayDown = False
        ScrollView.on_touch_down(self, self.touch)

    # Scroll ist original viel zu flink auf den Touchgeräten.
    # Wir versuchen das hier etwas abzuschwächen.

    def on_touch_down(self, touch):
        self.delayDown = True
        self.touch = touch
        Clock.schedule_once(self.delayReset, 0.15)

    def on_touch_up(self, touch):
        if self.delayDown:
            ScrollView.on_touch_down(self, self.touch)
        self.delayDown = False
        return ScrollView.on_touch_up(self, touch)

    def on_touch_move(self, touch):
        return ScrollView.on_touch_move(self, touch)

# =============================================================================


class LWorkWindow(Widget):
    def __init__(self):
        super(LWorkWindow, self).__init__()

        # beispiel zu canvas (hintergrund)
        with self.canvas.before:
            Color(0, 1, 1, 0.4)
            self.rect = Rectangle(pos=self.pos, size=self.size)
        self.bind(pos=self.update_rect)
        self.bind(size=self.update_rect)

    def update_rect(self, *args):
        self.rect.pos = self.pos
        self.rect.size = self.size

    def on_touch_down(self, touch):
        print('LWorkWindow: touch_down on %s' % str(touch.pos))
        # return True

# =============================================================================


class LTkBase:
    # Tk Emulation needs.
    def __init__(self):
        self.title = "default title"
        self.icontitle = "default title"
        logging.info("LTkBase: __init__()")
        self.sleeping = False
        self.in_loop = False
        self.screenSize = (1000, 1000)

    def cget(self, strg):
        return False

    def wm_title(self, strg):
        self.title = strg
        logging.info("LTkBase: wm_title %s" % strg)
        if (self.app):
            # self.app.top.topLine.text = strg
            self.app.top.getMenu().ap.title = strg

    def wm_iconname(self, strg):
        self.icontitle = strg
        logging.info("LTkBase: wm_iconname %s" % strg)

    def eval_screen_dim(self, size):
        self.screenSize = size
        if get_platform() == 'android':
            from jnius import autoclass
            from jnius import cast
        else:
            return

        PythonActivity = autoclass('org.kivy.android.PythonActivity')
        currentActivity = cast(
            'android.app.Activity', PythonActivity.mActivity)
        wm = currentActivity.getWindowManager()
        d = wm.getDefaultDisplay()

        self.screenSize = (d.getWidth(), d.getHeight())

    def winfo_screenwidth(self):
        logging.info("LTkBase: winfo_screenwidth %s" % str(self.size[0]))
        return self.size[0]

    def winfo_screenheight(self):
        logging.info("LTkBase: winfo_screenheight %s" % str(self.size[1]))
        return self.size[1]

    def winfo_screendepth(self):
        return 32

    def wm_minsize(self, x, y):
        pass

    def option_add(self, a, b, c):
        pass

    def option_get(self, a, b):
        return 0

    def wm_withdraw(self):
        logging.info("LTkBase: wm_withdraw")
        pass

    def busyUpdate(self):
        print('LTkBase: busyUpdate()')
        pass

    def grid_columnconfigure(self, a, weight):
        pass

    def grid_rowconfigure(self, a, weight):
        pass

    def connectApp(self, app):
        logging.info("LTkBase: connectApp %s" % str(app))
        self.app = app
        pass

    def wm_geometry(self, val):
        logging.info("LTkBase: wm_geometry %s" % str(val))
        pass

    def update_idletasks(self):
        logging.info("LTkBase: update_idletasks")
        try:
            if len(EventLoop.event_listeners) > 0:
                self.in_loop = True
                EventLoop.idle()
                self.in_loop = False
            else:
                logging.info("LTkBase: update_idletasks: terminating")
        except Exception:
            self.in_loop = False
            logging.info("LTkBase: update_idletasks: exception")

    def wm_state(self):
        return ""

    def wm_deiconify(self):
        pass

    def mainloop(self):
        logging.info("LTkBase: mainloop")
        pass

    def quit(self):
        logging.info("LTkBase: quit")
        stopTouchApp()

    def interruptSleep(self):
        logging.info('LTkBase: interruptSleep')
        self.update_idletasks()
        # self.sleep_var = 1
        return

    def mainquit(self):
        logging.info('LTkBase: mainquit')
        lapp = App.get_running_app()
        lapp.mainloop.send(None)    # Spielprozess verlassen
        return

    def onWakeUp(self, dt):
        self.sleeping = False

    def sleep(self, seconds):
        logging.info('LTkBase: sleep %s seconds' % seconds)
        self.sleeping = True
        Clock.schedule_once(self.onWakeUp, seconds)
        while self.sleeping:
            # time.sleep(0.05)
            self.in_loop = True
            EventLoop.idle()
            self.in_loop = False

    def waitCondition(self, condition):
        logging.info('LTkBase: wait condition start')
        while condition():
            self.in_loop = True
            EventLoop.idle()
            self.in_loop = False
        logging.info('LTkBase: wait condition end')

    def waitAnimation(self):
        self.waitCondition(LAnimationManager.checkRunning)

    def tkraise(self):
        pass

    def winfo_ismapped(self):
        return True
        # ???

# =============================================================================


class LStack:
    def __init__(self):
        self.items = []

    def isEmpty(self):
        return self.items == []

    def push(self, key, item):
        self.items.append((key, item))

    def pop(self, key):
        for i in range(len(self.items)):
            t = self.items[i]
            if (t[0] == key):
                self.items.pop(i)
                return t[1]
        return None

    def peek(self, key):
        for i in range(len(self.items)):
            t = self.items[i]
            if (t[0] == key):
                return t
        return None

    def size(self):
        return len(self.items)

# =============================================================================


class LMainWindow(BoxLayout, LTkBase):
    def __init__(self, **kw):
        super(LMainWindow, self).__init__(orientation='vertical')
        LTkBase.__init__(self)
        self.menuArea = LMenuBar()
        self.workContainer = LBoxLayout(orientation='horizontal')
        self.workContainerO = LBoxLayout(orientation='horizontal')
        self.workArea = None
        self.toolBar = None
        self.toolBarPos = 0
        self.bindings = {}
        self._w = '.'
        self.topLine = Button(
            size_hint=(1.0, 0.01),
            background_down='atlas:'
                            '//data/images/defaulttheme/action_item_down',
            background_normal='atlas:'
                              '//data/images/defaulttheme/action_item',
            border=(0, 0, 0, 0))
        self.topLine1 = Label(size_hint=(1.0, 0.01))

        self.add_widget(self.topLine)
        self.add_widget(self.menuArea)
        self.add_widget(self.topLine1)
        self.add_widget(self.workContainerO)
        self.workContainerO.add_widget(self.workContainer)
        # self.add_widget(Button(size_hint = (1.0, 0.01)))

        self.workStack = LStack()
        self.app = None

        '''
        from kivy.graphics import opengl_utils
        print('OPENGL support:')
        print(opengl_utils.gl_get_extensions())
        '''

        # self.touches = []

        # beispiel zu canvas (hintergrund)
        # with self.canvas.before:
        #   Color(0, 1, 0.7, 0.5)
        #   self.rect = Rectangle(pos=self.pos, size=self.size)
        # self.bind(pos=self.update_rect)
        # self.bind(size=self.update_rect)

    # def update_rect(self, *args):
    #   self.rect.pos = self.pos
    #   self.rect.size = self.size

    def on_motion(self, m):
        print('on_motion', m)
        pass

    # Events.

    def on_touch_down(self, touch):
        ret = False

        # print(dir(touch))

        # multitouch detection
        '''
        #print("MainWindow touch_down",touch.ox,touch.oy)
        #print("MainWindow touch_down",touch.sx,touch.sy)
        #print("MainWindow touch_down",touch.px,touch.py)
        self.touches.append(touch)
        print("touches cnt = ",len(self.touches))
        '''
        # multiclick detection
        '''
        if touch.is_double_tap:
            # print('Touch is a double tap !')
            # print(' - interval is', touch.double_tap_time)
            # print(' - distance betw. previous is', touch.double_tap_distance)
            # test the functions of Android back key
            ret = self.processAndroidBack()
            if (ret):
                return ret
        '''
        '''
        if touch.is_triple_tap:
            print('Touch is a triple tap !')
            print(' - interval is', touch.triple_tap_time)
            print(' - distance between previous is', touch.triple_tap_distance)
        '''
        # (Eventloop reentrancy check)
        if self.in_loop:
            return ret

        # (demo mode stop - nur auf spielfläche)
        if '<KeyPress>' in self.bindings:
            pgs = self.workStack.peek('playground')
            if pgs:
                pg = pgs[1]
                if pg.collide_point(*touch.pos):
                    event = LEvent()
                    event.char = True
                    self.bindings['<KeyPress>'](event)

        # standard notifikation:
        for c in self.children:
            ret = c.on_touch_down(touch)
            if ret:
                break
        return ret

    def on_touch_up(self, touch):
        ret = False
        # standard notifikation:
        for c in self.children:
            ret = c.on_touch_up(touch)
            if ret:
                break

        # multitouch support
        '''
        self.touches = [xx for xx in self.touches if xx != touch]
        print("touches cnt = ",len(self.touches))
        '''
        return ret

    # Menubar:

    def setMenu(self, menu):
        self.menuArea.setMenu(menu)

    def getMenu(self):
        return self.menuArea.getMenu()

    # Toolbar:

    def setTool(self, toolbar, pos=0):
        if (toolbar is not None):
            self.toolBar = toolbar
        self.toolBarPos = pos
        self.rebuildContainer()

    # Workarea:

    def removeContainer(self):
        self.workContainer.clear_widgets()
        self.workContainerO.clear_widgets()

    def buildContainer(self):
        if self.toolBar is not None and self.toolBarPos == 3:
            self.workContainerO.add_widget(self.toolBar)
        self.workContainerO.add_widget(self.workContainer)
        if self.toolBar is not None and self.toolBarPos == 4:
            self.workContainerO.add_widget(self.toolBar)
        for w in self.workStack.items:
            self.workContainer.add_widget(w[1])

    def rebuildContainer(self):
        self.removeContainer()
        self.buildContainer()

    def pushWork(self, key, widget):
        if (widget):
            self.workStack.push(key, widget)
            self.rebuildContainer()

    def popWork(self, key):
        w = None
        if self.workStack.size() > 0:
            w = self.workStack.pop(key)
            self.rebuildContainer()
        return w

    def setWork(self, key, widget):
        self.pushWork(key, widget)

    def getWork(self, key):
        return self.workStack.peek(key)

    def processAndroidBack(self):
        ret = False
        # try to close currently open popup windows, one by one
        r = range(len(self.workStack.items))
        rr = reversed(r)
        for i in rr:
            t = self.workStack.items[i]
            # print("stackkey:  %s" % str(t[0]))
            # print("stackitem: %s" % str(t[1]))
            if t[0] == 'playground':
                pass
            else:
                if isinstance(t[1], LTopLevel):
                    ret = t[1].processAndroidBack()
                if not ret:
                    self.popWork(t[0])
                    ret = True
            if ret:
                break
        return ret

# =============================================================================


class LApp(App):

    # Handling of android return key
    def key_input(self, window, key, scancode, codepoint, modifier):
        if key == 27:
            # Back key of Android.
            lapp = App.get_running_app()
            app = lapp.app
            if app is None:
                return False  # delegate

            # redirect to mainwindow to close popups, tree nodes
            # and html pages.
            if (self.mainWindow.processAndroidBack()):
                return True  # consumed

            # redirect to game to undo last step
            app.menubar.mUndo()
            return True     # consumed
        else:
            return False    # delegate

    def __init__(self):
        super(LApp, self).__init__()

        # Config.set('input', 'multitouchscreen1', 'tuio,0.0.0.0:3333')

        self.mainWindow = LMainWindow()
        logging.info('top = %s' % str(self.mainWindow))
        Cache.register('LAppCache', limit=10)
        Cache.append('LAppCache', 'mainWindow', self.mainWindow, timeout=0)
        Cache.append('LAppCache', 'mainApp', self, timeout=0)
        self.startCode = 0

    # Es gibt hier offensichtlich nur einen Bilschirm mit Höhe und Breite.
    # Alles andere stellt das Betriebssystem zur Verfügung. Wir wissen auch
    # nicht, wie das Gerät gerade orientiert ist, ist nicht unsere Sache.
    # Alles was wir tun können ist Höhe und Breite zu verfolgen, sobald wir
    # dazu informiert werden. (Android informiert leider nicht immer, wenn
    # es nötig wäre).
    # Update:
    # Nachdem im Manifest nun steht 'configChange=...|screenSize' bekommen
    # wir auch nach dem on_resume ein Signal.

    def delayedRebuild(self, dt):
        logging.info("LApp: delayedRebuild")
        self.mainWindow.rebuildContainer()

    def makeDelayedRebuild(self):
        def delayedRebuild(dt):
            # Clock.schedule_once(self.delayedRebuild, 0.01)
            Clock.schedule_once(self.delayedRebuild, 0.5)
        return delayedRebuild

    def doSize(self, obj, val):
        mval = self.mainWindow.size
        if (val[0] != mval[0] and val[1] != mval[1]):
            logging.info("LApp: size changed %s - %s (%s)" % (obj, val, mval))
            Clock.schedule_once(self.makeDelayedRebuild(), 0.01)
        pass

    def on_start(self):
        logging.info('mw = %s,  w = %s' % (self.mainWindow, Window))

        Window.bind(on_keyboard=self.key_input)
        Window.bind(size=self.doSize)

        if self.startCode > 0:
            logging.info("LApp: on_start fails")
            return

        logging.info("LApp: on_start")
        self.mainloop = self.app.mainproc()  # Einrichten
        self.mainloop.send(None)                # Spielprozess starten
        logging.info("LApp: on_start processed")
        # Android: Request missing android permissions.
        requestStoragePerm()

    def on_stop(self):
        # Achtung wird u.U. 2 mal aufgerufen !!!
        logging.info("LApp: on_stop")
        if self.startCode > 0:
            return
        # lapp: erweiterte klasse dieser (mit pysolfc app members).
        lapp = App.get_running_app()
        lapp.app.menubar.mHoldAndQuit()

    def on_pause(self):
        logging.info("LApp: on_pause")
        # return True: wenn wir wirklich in pause gehen. Dann wird auch
        # resume aufgerufen falls die app wieder aktiviert wird.
        # return False: app wird gestoppt (on_stop wird aufgerufen)
        if self.startCode > 0:
            return False

        pauseSupport = True
        # True ist die bessere Variante.

        lapp = App.get_running_app()
        app = lapp.app
        if app is None:
            return

        logging.info("LApp: on_pause - pause on")
        # set pause
        if not app.game.pause:
            app.game.doPause()

        logging.info("LApp: on_pause - savegame")
        # save game
        try:
            app.game.gstats.holded = 1
            app.game._saveGame(app.fn.holdgame)
            app.opt.game_holded = app.game.id
            app.opt.last_gameid = app.game.id
        except Exception:
            traceback.print_exc()
            pass
        # save options
        try:
            app.saveOptions()
        except Exception:
            traceback.print_exc()
            pass
        # save statistics
        try:
            app.saveStatistics()
        except Exception:
            traceback.print_exc()
            pass
        logging.info("LApp: on_pause - gamesaved")

        logging.info("LApp: on_pause, Window.size=%s" % str(Window.size))

        return pauseSupport

    def on_resume(self):
        logging.info("LApp: on_resume")

        lapp = App.get_running_app()
        app = lapp.app
        if app is None:
            return

        so = get_screen_ori()
        go = so  # flake8: F841 nonsense!
        so = go
        logging.info("LApp: on_resume, Window.size=%s" % str(Window.size))
        # ANM:
        # kivy.core.window.Window hat hier u.U. eine falsche dimension
        # und unterscheidet sich vom display (-> in get_screen_ori).
        # Eine korrektur der Parameter von Window kann hier wie skizziert
        # durchgeführt werden und führt auch zu den korrekten 'on_size'
        # Notifikationen. Allerdings wird später (nach diesem Aufruf)
        # eine weitere Notifikation erhalten, welche das Fenster u.U.
        # wieder falsch aufstellt. (woher kommt die und warum ist sie
        # oft falsch ?)

        if app.game.pause:
            Clock.schedule_once(self.makeEndPauseCmd(app), 3.0)

    def makeEndPauseCmd(self, app):
        def endPauseCmd(dt):
            if app.game.pause:
                logging.info("LApp: on_resume - pause off")
                app.game.doPause()
        return endPauseCmd
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
# Copyright (C) 2017 LB
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#

import math
import os
import re

from kivy.event import EventDispatcher
from kivy.properties import BooleanProperty
from kivy.properties import NumericProperty
from kivy.properties import StringProperty

from pysollib.gamedb import GI
from pysollib.kivy.LApp import LMenu
from pysollib.kivy.LApp import LMenuItem
from pysollib.kivy.LApp import LScrollView
from pysollib.kivy.LApp import LTopLevel
from pysollib.kivy.LApp import LTreeNode
from pysollib.kivy.LApp import LTreeRoot
from pysollib.kivy.findcarddialog import destroy_find_card_dialog
from pysollib.kivy.selectcardset import SelectCardsetDialogWithPreview
from pysollib.kivy.selectgame import SelectGameDialog
from pysollib.kivy.solverdialog import connect_game_solver_dialog
from pysollib.kivy.tkconst import CURSOR_WATCH, EVENT_HANDLED, EVENT_PROPAGATE
from pysollib.kivy.tkconst import TOOLBAR_BUTTONS
from pysollib.kivy.tkutil import after_idle
from pysollib.kivy.tkutil import bind
from pysollib.mfxutil import Struct
from pysollib.mygettext import _
from pysollib.pysoltk import MfxMessageDialog
from pysollib.pysoltk import connect_game_find_card_dialog
from pysollib.settings import SELECT_GAME_MENU
from pysollib.settings import TITLE


# ************************************************************************
# * tk emuls:
# ************************************************************************


class TkVarObj(EventDispatcher):
    def __init(self):
        self.value = None

    def set(self, v):
        if v is None:
            if type(self.value) is str:
                v = ''
        self.value = v

    def get(self):
        return self.value


class BooleanVar(TkVarObj):
    value = BooleanProperty(False)


class IntVar(TkVarObj):
    value = NumericProperty(0)


class StringVar(TkVarObj):
    value = StringProperty('')

# ************************************************************************
# * Menu Dialogs
# ************************************************************************


class LMenuDialog(object):

    dialogCache = {}

    def make_pop_command(self, parent, title):
        def pop_command(event):
            print('event = %s' % event)
            parent.popWork(title)
        return pop_command

    def __init__(self, menubar, parent, title, app, **kw):
        super(LMenuDialog, self).__init__()

        self.menubar = menubar
        self.parent = parent
        self.app = app
        self.title = title
        self.window = None
        self.running = False
        self.persist = False
        if 'persist' in kw:
            self.persist = kw['persist']

        # prüfen ob noch aktiv - toggle.

        if parent.workStack.peek(title) is not None:
            parent.popWork(title)
            return

        if self.persist and title in self.dialogCache:
            parent.pushWork(title, self.dialogCache[title])
            return

        pc = self.closeWindow = self.make_pop_command(parent, title)

        # neuen Dialog aufbauen.

        window = LTopLevel(parent, title, **kw)
        window.titleline.bind(on_press=pc)
        self.parent.pushWork(title, window)
        self.window = window
        self.running = True

        if self.persist:
            self.dialogCache[title] = window

        # Tree skelett.

        tv = self.tvroot = LTreeRoot(root_options=dict(text='EditTree'))
        tv.hide_root = True
        tv.size_hint = 1, None
        tv.bind(minimum_height=tv.setter('height'))

        # menupunkte aufbauen.

        self.buildTree(tv, None)

        # tree in einem Scrollwindow präsentieren.

        root = LScrollView(pos=(0, 0))
        root.add_widget(tv)
        self.window.content.add_widget(root)

    def buildTree(self, tree, node):
        print('buildTree base')
        # to implement in dervied class
        pass

# ************************************************************************


class MainMenuDialog(LMenuDialog):

    def __init__(self, menubar, parent, title, app, **kw):
        kw['size_hint'] = (0.2, 1)
        kw['persist'] = True
        super(MainMenuDialog, self).__init__(
            menubar, parent, title, app, **kw)

    def make_game_command(self, command):
        def game_command():
            command()
            self.closeWindow(0)
        return game_command

    def buildTree(self, tv, node):
        rg = tv.add_node(
            LTreeNode(
                text=_("File"),
                command=self.make_game_command(self.menubar.mFileMenuDialog)))
        rg = tv.add_node(
            LTreeNode(
                text=_("Games"),
                command=self.make_game_command(
                    self.menubar.mSelectGameDialog)))
        rg = tv.add_node(
            LTreeNode(
                text=_("Tools"),
                command=self.make_game_command(self.menubar.mEditMenuDialog)))
        rg = tv.add_node(
            LTreeNode(
                text=_("Statistics"),
                command=self.make_game_command(self.menubar.mGameMenuDialog)))
        rg = tv.add_node(
            LTreeNode(
                text=_("Assist"),
                command=self.make_game_command(
                    self.menubar.mAssistMenuDialog)))
        rg = tv.add_node(
            LTreeNode(
                text=_("Options"),
                command=self.make_game_command(
                    self.menubar.mOptionsMenuDialog)))
        rg = tv.add_node(
            LTreeNode(
                text=_("Help"),
                command=self.make_game_command(self.menubar.mHelpMenuDialog)))
        del rg

# ************************************************************************


class FileMenuDialog(LMenuDialog):

    def __init__(self, menubar, parent, title, app, **kw):
        kw['size_hint'] = (0.3, 1)
        super(FileMenuDialog, self).__init__(
            menubar, parent, title, app, **kw)

    def make_game_command(self, key, command):
        def game_command():
            command(key)
        return game_command

    def buildTree(self, tv, node):
        rg = tv.add_node(
            LTreeNode(text=_('Recent games')))
        # Recent Liste
        recids = self.app.opt.recent_gameid
        # recgames = []
        for rid in recids:
            gi = self.app.getGameInfo(rid)
            if gi:
                command = self.make_game_command(
                    rid, self.menubar._mSelectGame)
                tv.add_node(
                    LTreeNode(text=gi.name, command=command), rg)

        rg = tv.add_node(
            LTreeNode(text=_('Favorite games')))
        if rg:
            tv.add_node(LTreeNode(
                text=_('<Add>'), command=self.menubar.mAddFavor), rg)
            tv.add_node(LTreeNode(
                text=_('<Remove>'), command=self.menubar.mDelFavor), rg)

            # Recent Liste
            favids = self.app.opt.favorite_gameid
            # favgames = []
            for fid in favids:
                gi = self.app.getGameInfo(fid)
                if gi:
                    command = self.make_game_command(
                        fid, self.menubar._mSelectGame)
                    tv.add_node(
                        LTreeNode(text=gi.name, command=command), rg)

        tv.add_node(LTreeNode(
            text=_('Load'), command=self.menubar.mOpen))
        tv.add_node(LTreeNode(
            text=_('Save'), command=self.menubar.mSaveAs))

        tv.add_node(LTreeNode(
            text=_('Quit'), command=self.menubar.mHoldAndQuit))

# ************************************************************************


class EditMenuDialog(LMenuDialog):  # Tools

    def __init__(self, menubar, parent, title, app, **kw):
        kw['size_hint'] = (0.2, 1)
        kw['persist'] = True
        super(EditMenuDialog, self).__init__(
            menubar, parent, title, app, **kw)

    def make_auto_command(self, variable, command):
        def auto_command():
            variable.set(not variable.get())
            command()
        return auto_command

    def addCheckNode(self, tv, rg, title, auto_var, auto_com):
        command = self.make_auto_command(auto_var, auto_com)
        rg1 = tv.add_node(
            LTreeNode(text=title, command=command, variable=auto_var), rg)
        return rg1

    def buildTree(self, tv, node):
        tv.add_node(LTreeNode(
            text=_('New game'), command=self.menubar.mNewGame))
        tv.add_node(LTreeNode(
            text=_('Restart game'), command=self.menubar.mRestart))

        tv.add_node(LTreeNode(
            text=_('Undo'), command=self.menubar.mUndo))
        tv.add_node(LTreeNode(
            text=_('Redo'), command=self.menubar.mRedo))
        tv.add_node(LTreeNode(
            text=_('Redo all'), command=self.menubar.mRedoAll))

        tv.add_node(LTreeNode(
            text=_('Auto drop'), command=self.menubar.mDrop))
        tv.add_node(LTreeNode(
            text=_('Shuffle tiles'), command=self.menubar.mShuffle))
        tv.add_node(LTreeNode(
            text=_('Deal cards'), command=self.menubar.mDeal))

        self.addCheckNode(tv, None,
                          _('Pause'),
                          self.menubar.tkopt.pause,
                          self.menubar.mPause)

        tv.add_node(LTreeNode(
            text=_('Load game'), command=self.menubar.mOpen))
        tv.add_node(LTreeNode(
            text=_('Save game'), command=self.menubar.mSaveAs))

        tv.add_node(LTreeNode(
            text=_('Help'), command=self.menubar.mHelpRules))

        # -------------------------------------------
        # TBD ?
        '''
        menu.add_separator()
        submenu = MfxMenu(menu, label=n_("&Set bookmark"))
        for i in range(9):
            label = _("Bookmark %d") % (i + 1)
            submenu.add_command(
                label=label, command=lambda i=i: self.mSetBookmark(i))
        submenu = MfxMenu(menu, label=n_("Go&to bookmark"))
        for i in range(9):
            label = _("Bookmark %d") % (i + 1)
            acc = m + "%d" % (i + 1)
            submenu.add_command(
                label=label,
                command=lambda i=i: self.mGotoBookmark(i),
                accelerator=acc)
        menu.add_command(
            label=n_("&Clear bookmarks"), command=self.mClearBookmarks)
        menu.add_separator()
        '''
        # und solitär wizard (-> custom games).
        '''
        tv.add_node(LTreeNode(
            text='Solitaire &Wizard', command=self.menubar.mWizard))
        tv.add_node(LTreeNode(
                text='Edit current game', command=self.menubar.mWizardEdit))
        '''

# ************************************************************************


class GameMenuDialog(LMenuDialog):

    def __init__(self, menubar, parent, title, app, **kw):
        kw['size_hint'] = (0.2, 1)
        kw['persist'] = True
        super(GameMenuDialog, self).__init__(
            menubar, parent, title, app, **kw)

    def make_command(self, key, command):
        def stats_command():
            kw = {}
            kw['mode'] = key
            command(**kw)
        return stats_command

    def buildTree(self, tv, node):
        tv.add_node(LTreeNode(
            text=_('Current game...'),
            command=self.make_command(101, self.menubar.mPlayerStats)), None)

        # tv.add_node(LTreeNode(
        #   text='All games ...',
        #   command=self.make_command(102, self.menubar.mPlayerStats)), None)

    # -------------------------------------------
    # TBD ? - just to remember original tk code.
    '''
        menu.add_command(
            label=n_("S&tatus..."),
            command=lambda x: self.mPlayerStats(mode=100), accelerator=m+"Y")
        menu.add_checkbutton(
            label=n_("&Comments..."), variable=self.tkopt.comment,
            command=self.mEditGameComment)
    '''
    '''
        menu.add_separator()
        submenu = MfxMenu(menu, label=n_("&Statistics"))
        submenu.add_command(
            label=n_("Current game..."),
            command=lambda x: self.mPlayerStats(mode=101))
        submenu.add_command(
            label=n_("All games..."),
            command=lambda x: self.mPlayerStats(mode=102))
        submenu.add_separator()
        submenu.add_command(
            label=n_("Session log..."),
            command=lambda x: self.mPlayerStats(mode=104))
        submenu.add_command(
            label=n_("Full log..."),
            command=lambda x: self.mPlayerStats(mode=103))
        submenu.add_separator()
        submenu.add_command(
            label=TOP_TITLE+"...",
            command=lambda x: self.mPlayerStats(mode=105),
            accelerator=m+"T")
        submenu.add_command(
            label=n_("Progression..."),
            command=lambda x: self.mPlayerStats(mode=107))
        submenu = MfxMenu(menu, label=n_("D&emo statistics"))
        submenu.add_command(
            label=n_("Current game..."),
            command=lambda x: self.mPlayerStats(mode=1101))
        submenu.add_command(
            label=n_("All games..."),
            command=lambda x: self.mPlayerStats(mode=1102))
    '''

# ************************************************************************


class AssistMenuDialog(LMenuDialog):

    def __init__(self, menubar, parent, title, app, **kw):
        kw['size_hint'] = (0.2, 1)
        kw['persist'] = True
        super(AssistMenuDialog, self).__init__(
            menubar, parent, title, app, **kw)

    def buildTree(self, tv, node):
        tv.add_node(LTreeNode(
            text=_('Hint'), command=self.menubar.mHint))

        tv.add_node(LTreeNode(
            text=_('Highlight piles'), command=self.menubar.mHighlightPiles))

        # tv.add_node(LTreeNode(
        #   text='Find Card', command=self.menubar.mFindCard))

        tv.add_node(LTreeNode(
            text=_('Demo'), command=self.menubar.mDemo))

        # -------------------------------------------
        # TBD. How ?

        '''
        menu.add_command(
            label=n_("Demo (&all games)"), command=self.mMixedDemo)
        if USE_FREECELL_SOLVER:
            menu.add_command(label=n_("&Solver"), command=self.mSolver)
        else:
            menu.add_command(label=n_("&Solver"), state='disabled')
        menu.add_separator()
        menu.add_command(
            label=n_("&Piles description"),
            command=self.mStackDesk, accelerator="F2")
        '''

# ************************************************************************


class OptionsMenuDialog(LMenuDialog):

    def __init__(self, menubar, parent, title, app, **kw):
        kw['size_hint'] = (0.5, 1)
        kw['persist'] = True
        super(OptionsMenuDialog, self).__init__(
            menubar, parent, title, app, **kw)

    def make_auto_command(self, variable, command):
        def auto_command():
            variable.set(not variable.get())
            command()
        return auto_command

    def addCheckNode(self, tv, rg, title, auto_var, auto_com):
        command = self.make_auto_command(auto_var, auto_com)
        rg1 = tv.add_node(
            LTreeNode(text=title, command=command, variable=auto_var), rg)
        return rg1

    def make_val_command(self, variable, value, command):
        def val_command():
            variable.set(value)
            command()
        return val_command

    def make_vars_command(self, command, key):
        def vars_command():
            command(key)
        return vars_command

    def addRadioNode(self, tv, rg, title, auto_var, auto_val, auto_com):
        command = self.make_val_command(auto_var, auto_val, auto_com)
        rg1 = tv.add_node(
            LTreeNode(text=title,
                      command=command,
                      variable=auto_var, value=auto_val), rg)
        return rg1

    def buildTree(self, tv, node):

        # -------------------------------------------
        # Automatic play settings

        rg = tv.add_node(
            LTreeNode(text=_('Automatic play')))
        if rg:
            self.addCheckNode(tv, rg,
                              _('Auto face up'),
                              self.menubar.tkopt.autofaceup,
                              self.menubar.mOptAutoFaceUp)

            self.addCheckNode(tv, rg,
                              _('Auto drop'),
                              self.menubar.tkopt.autodrop,
                              self.menubar.mOptAutoDrop)

            self.addCheckNode(tv, rg,
                              _('Auto deal'),
                              self.menubar.tkopt.autodeal,
                              self.menubar.mOptAutoDeal)

            # submenu.add_separator()

            self.addCheckNode(tv, rg,
                              _('Quick play'),
                              self.menubar.tkopt.quickplay,
                              self.menubar.mOptQuickPlay)

        # -------------------------------------------
        # Player assistance

        rg = tv.add_node(
            LTreeNode(text=_('Assist level')))
        if rg:
            self.addCheckNode(tv, rg,
                              _('Enable undo'),
                              self.menubar.tkopt.undo,
                              self.menubar.mOptEnableUndo)

            self.addCheckNode(tv, rg,
                              _('Enable bookmarks'),
                              self.menubar.tkopt.bookmarks,
                              self.menubar.mOptEnableBookmarks)

            self.addCheckNode(tv, rg,
                              _('Enable hint'),
                              self.menubar.tkopt.hint,
                              self.menubar.mOptEnableHint)

            self.addCheckNode(tv, rg,
                              _('Enable shuffle'),
                              self.menubar.tkopt.shuffle,
                              self.menubar.mOptEnableShuffle)

            self.addCheckNode(tv, rg,
                              _('Enable highlight piles'),
                              self.menubar.tkopt.highlight_piles,
                              self.menubar.mOptEnableHighlightPiles)

            self.addCheckNode(tv, rg,
                              _('Enable highlight cards'),
                              self.menubar.tkopt.highlight_cards,
                              self.menubar.mOptEnableHighlightCards)

            self.addCheckNode(tv, rg,
                              _('Enable highlight same rank'),
                              self.menubar.tkopt.highlight_samerank,
                              self.menubar.mOptEnableHighlightSameRank)

            self.addCheckNode(tv, rg,
                              _('Highlight no matching'),
                              self.menubar.tkopt.highlight_not_matching,
                              self.menubar.mOptEnableHighlightNotMatching)

            # submenu.add_separator()

            self.addCheckNode(tv, rg,
                              _('Show removed tiles (in Mahjongg games)'),
                              self.menubar.tkopt.mahjongg_show_removed,
                              self.menubar.mOptMahjonggShowRemoved)

            self.addCheckNode(tv, rg,
                              _('Show hint arrow (in Shisen-Sho games)'),
                              self.menubar.tkopt.shisen_show_hint,
                              self.menubar.mOptShisenShowHint)

            # submenu.add_separator()

        # -------------------------------------------
        # Language options

        rg = tv.add_node(
            LTreeNode(text=_('Language')))
        if rg:
            self.addRadioNode(tv, rg,
                              _('Default'),
                              self.menubar.tkopt.language, '',
                              self.menubar.mOptLanguage)
            self.addRadioNode(tv, rg,
                              _('English'),
                              self.menubar.tkopt.language, 'en',
                              self.menubar.mOptLanguage)
            self.addRadioNode(tv, rg,
                              _('German'),
                              self.menubar.tkopt.language, 'de',
                              self.menubar.mOptLanguage)
            self.addRadioNode(tv, rg,
                              _('Italian'),
                              self.menubar.tkopt.language, 'it',
                              self.menubar.mOptLanguage)
            self.addRadioNode(tv, rg,
                              _('Polish'),
                              self.menubar.tkopt.language, 'pl',
                              self.menubar.mOptLanguage)
            self.addRadioNode(tv, rg,
                              _('Russian'),
                              self.menubar.tkopt.language, 'ru',
                              self.menubar.mOptLanguage)

        # -------------------------------------------
        # Sound options

        rg = tv.add_node(
            LTreeNode(text=_('Sound')))
        if rg:
            self.addCheckNode(tv, rg,
                              _('Enable'),
                              self.menubar.tkopt.sound,
                              self.menubar.mOptSoundDialog)

            rg1 = tv.add_node(
                LTreeNode(text=_('Volume')), rg)
            if rg1:
                self.addRadioNode(tv, rg1,
                                  _('100%'),
                                  self.menubar.tkopt.sound_sample_volume, 100,
                                  self.menubar.mOptSoundSampleVol)
                self.addRadioNode(tv, rg1,
                                  _('75%'),
                                  self.menubar.tkopt.sound_sample_volume, 75,
                                  self.menubar.mOptSoundSampleVol)
                self.addRadioNode(tv, rg1,
                                  _('50%'),
                                  self.menubar.tkopt.sound_sample_volume, 50,
                                  self.menubar.mOptSoundSampleVol)
                self.addRadioNode(tv, rg1,
                                  _('25%'),
                                  self.menubar.tkopt.sound_sample_volume, 25,
                                  self.menubar.mOptSoundSampleVol)

            rg1 = tv.add_node(
                LTreeNode(text=_('Samples')), rg)
            if rg1:
                key = 'areyousure'
                self.addCheckNode(
                    tv, rg1,
                    _('are you sure'),
                    self.menubar.tkopt.sound_sample_vars[key],
                    self.make_vars_command(self.menubar.mOptSoundSample, key))
                key = 'autodrop'
                self.addCheckNode(
                    tv, rg1,
                    _('auto drop'),
                    self.menubar.tkopt.sound_sample_vars[key],
                    self.make_vars_command(self.menubar.mOptSoundSample, key))
                key = 'autoflip'
                self.addCheckNode(
                    tv, rg1,
                    _('auto flip'),
                    self.menubar.tkopt.sound_sample_vars[key],
                    self.make_vars_command(self.menubar.mOptSoundSample, key))
                key = 'autopilotlost'
                self.addCheckNode(
                    tv, rg1,
                    _('auto pilot lost'),
                    self.menubar.tkopt.sound_sample_vars[key],
                    self.make_vars_command(self.menubar.mOptSoundSample, key))
                key = 'autopilotwon'
                self.addCheckNode(
                    tv, rg1,
                    _('auto pilot won'),
                    self.menubar.tkopt.sound_sample_vars[key],
                    self.make_vars_command(self.menubar.mOptSoundSample, key))
                key = 'deal'
                self.addCheckNode(
                    tv, rg1,
                    _('deal'),
                    self.menubar.tkopt.sound_sample_vars[key],
                    self.make_vars_command(self.menubar.mOptSoundSample, key))
                key = 'dealwaste'
                self.addCheckNode(
                    tv, rg1,
                    _('deal waste'),
                    self.menubar.tkopt.sound_sample_vars[key],
                    self.make_vars_command(self.menubar.mOptSoundSample, key))
                key = 'droppair'
                self.addCheckNode(
                    tv, rg1,
                    _('drop pair'),
                    self.menubar.tkopt.sound_sample_vars[key],
                    self.make_vars_command(self.menubar.mOptSoundSample, key))
                key = 'drop'
                self.addCheckNode(
                    tv, rg1,
                    _('drop'),
                    self.menubar.tkopt.sound_sample_vars[key],
                    self.make_vars_command(self.menubar.mOptSoundSample, key))
                key = 'flip'
                self.addCheckNode(
                    tv, rg1,
                    _('flip'),
                    self.menubar.tkopt.sound_sample_vars[key],
                    self.make_vars_command(self.menubar.mOptSoundSample, key))
                key = 'move'
                self.addCheckNode(
                    tv, rg1,
                    _('move'),
                    self.menubar.tkopt.sound_sample_vars[key],
                    self.make_vars_command(self.menubar.mOptSoundSample, key))
                key = 'nomove'
                self.addCheckNode(
                    tv, rg1,
                    _('no move'),
                    self.menubar.tkopt.sound_sample_vars[key],
                    self.make_vars_command(self.menubar.mOptSoundSample, key))
                key = 'redo'
                self.addCheckNode(
                    tv, rg1,
                    _('redo'),
                    self.menubar.tkopt.sound_sample_vars[key],
                    self.make_vars_command(self.menubar.mOptSoundSample, key))
                key = 'startdrag'
                self.addCheckNode(
                    tv, rg1,
                    _('start drag'),
                    self.menubar.tkopt.sound_sample_vars[key],
                    self.make_vars_command(self.menubar.mOptSoundSample, key))
                key = 'turnwaste'
                self.addCheckNode(
                    tv, rg1,
                    _('turn waste'),
                    self.menubar.tkopt.sound_sample_vars[key],
                    self.make_vars_command(self.menubar.mOptSoundSample, key))
                key = 'undo'
                self.addCheckNode(
                    tv, rg1,
                    _('undo'),
                    self.menubar.tkopt.sound_sample_vars[key],
                    self.make_vars_command(self.menubar.mOptSoundSample, key))
                key = 'gamefinished'
                self.addCheckNode(
                    tv, rg1,
                    _('game finished'),
                    self.menubar.tkopt.sound_sample_vars[key],
                    self.make_vars_command(self.menubar.mOptSoundSample, key))
                key = 'gamelost'
                self.addCheckNode(
                    tv, rg1,
                    _('game lost'),
                    self.menubar.tkopt.sound_sample_vars[key],
                    self.make_vars_command(self.menubar.mOptSoundSample, key))
                key = 'gameperfect'
                self.addCheckNode(
                    tv, rg1,
                    _('game perfect'),
                    self.menubar.tkopt.sound_sample_vars[key],
                    self.make_vars_command(self.menubar.mOptSoundSample, key))
                key = 'gamewon'
                self.addCheckNode(
                    tv, rg1,
                    _('game won'),
                    self.menubar.tkopt.sound_sample_vars[key],
                    self.make_vars_command(self.menubar.mOptSoundSample, key))

        # -------------------------------------------
        # Cardsets and card backside options

        rg = tv.add_node(
            LTreeNode(text=_('Cardsets')))
        if rg:
            self.menubar.tkopt.cardset.set(self.app.cardset.index)

            csm = self.app.cardset_manager
            # cnt = csm.len()
            i = 0
            while 1:
                cs = csm.get(i)
                if cs is None:
                    break
                rg1 = self.addRadioNode(tv, rg,
                                        cs.name,
                                        self.menubar.tkopt.cardset, i,
                                        self.menubar.mOptCardset)
                if rg1:
                    cbs = cs.backnames
                    self.menubar.tkopt.cardbacks[i] = IntVar()
                    self.menubar.tkopt.cardbacks[i].set(cs.backindex)

                    bcnt = len(cbs)
                    bi = 0
                    while 1:
                        if bi == bcnt:
                            break
                        cb = cbs[bi]
                        self.addRadioNode(
                            tv, rg1,
                            cb,
                            self.menubar.tkopt.cardbacks[i], bi,
                            self.make_vars_command(
                                self.menubar.mOptSetCardback, i))
                        bi += 1

                i += 1

        # -------------------------------------------
        # Table background settings

        rg = tv.add_node(
            LTreeNode(text=_('Table')))
        if rg:
            rg1 = tv.add_node(
                LTreeNode(text=_('Solid colors')), rg)
            if rg1:
                key = 'table'
                self.addRadioNode(
                    tv, rg1,
                    _('Blue'),
                    self.menubar.tkopt.color_vars[key], '#0082df',
                    self.menubar.mOptTableColor)
                self.addRadioNode(
                    tv, rg1,
                    _('Green'),
                    self.menubar.tkopt.color_vars[key], '#008200',
                    self.menubar.mOptTableColor)
                self.addRadioNode(
                    tv, rg1,
                    _('Navy'),
                    self.menubar.tkopt.color_vars[key], '#000086',
                    self.menubar.mOptTableColor)
                self.addRadioNode(
                    tv, rg1,
                    _('Olive'),
                    self.menubar.tkopt.color_vars[key], '#868200',
                    self.menubar.mOptTableColor)
                self.addRadioNode(
                    tv, rg1,
                    _('Orange'),
                    self.menubar.tkopt.color_vars[key], '#f79600',
                    self.menubar.mOptTableColor)
                self.addRadioNode(
                    tv, rg1,
                    _('Teal'),
                    self.menubar.tkopt.color_vars[key], '#008286',
                    self.menubar.mOptTableColor)

            rg1 = tv.add_node(
                LTreeNode(text=_('Tiles and Images')), rg)

            if rg1:
                tm = self.app.tabletile_manager
                # cnt = tm.len()
                i = 1
                while True:
                    ti = tm.get(i)
                    if ti is None:
                        break
                    self.addRadioNode(tv, rg1,
                                      ti.name,
                                      self.menubar.tkopt.tabletile, i,
                                      self.menubar.mOptTileSet)
                    i += 1

        # -------------------------------------------
        # Card view options

        rg = tv.add_node(
            LTreeNode(text=_('Card view')))
        if rg:
            self.addCheckNode(tv, rg,
                              _('Card shadow'),
                              self.menubar.tkopt.shadow,
                              self.menubar.mOptShadow)

            self.addCheckNode(tv, rg,
                              _('Shade legal moves'),
                              self.menubar.tkopt.shade,
                              self.menubar.mOptShade)

            self.addCheckNode(tv, rg,
                              _('Negative cards bottom'),
                              self.menubar.tkopt.negative_bottom,
                              self.menubar.mOptNegativeBottom)

            self.addCheckNode(tv, rg,
                              _('Shrink face-down cards'),
                              self.menubar.tkopt.shrink_face_down,
                              self.menubar.mOptShrinkFaceDown)

            self.addCheckNode(tv, rg,
                              _('Shade filled stacks'),
                              self.menubar.tkopt.shade_filled_stacks,
                              self.menubar.mOptShadeFilledStacks)

        # -------------------------------------------
        # Animation settins

        rg = tv.add_node(
            LTreeNode(text=_('Animations')))
        if rg:
            self.addRadioNode(tv, rg,
                              _('None'),
                              self.menubar.tkopt.animations, 0,
                              self.menubar.mOptAnimations)

            self.addRadioNode(tv, rg,
                              _('Very fast'),
                              self.menubar.tkopt.animations, 1,
                              self.menubar.mOptAnimations)

            self.addRadioNode(tv, rg,
                              _('Fast'),
                              self.menubar.tkopt.animations, 2,
                              self.menubar.mOptAnimations)

            self.addRadioNode(tv, rg,
                              _('Medium'),
                              self.menubar.tkopt.animations, 3,
                              self.menubar.mOptAnimations)

            self.addRadioNode(tv, rg,
                              _('Slow'),
                              self.menubar.tkopt.animations, 4,
                              self.menubar.mOptAnimations)

            self.addRadioNode(tv, rg,
                              _('Very slow'),
                              self.menubar.tkopt.animations, 5,
                              self.menubar.mOptAnimations)

            # submenu.add_separator()

            self.addCheckNode(tv, rg,
                              _('Redeal animation'),
                              self.menubar.tkopt.redeal_animation,
                              self.menubar.mRedealAnimation)

            self.addCheckNode(tv, rg,
                              _('Winning animation'),
                              self.menubar.tkopt.win_animation,
                              self.menubar.mWinAnimation)

        # -------------------------------------------
        # Touch mode settings

        rg = tv.add_node(
            LTreeNode(text=_('Touch mode')))
        if rg:
            self.addRadioNode(tv, rg,
                              _('Drag-and-Drop'),
                              self.menubar.tkopt.mouse_type, 'drag-n-drop',
                              self.menubar.mOptMouseType)

            self.addRadioNode(tv, rg,
                              _('Point-and-Click'),
                              self.menubar.tkopt.mouse_type, 'point-n-click',
                              self.menubar.mOptMouseType)

            # sinnlos mit touch-device:
            # self.addRadioNode(tv, rg,
            #   'Sticky mouse',
            #   self.menubar.tkopt.mouse_type, u'sticky-mouse',
            #   self.menubar.mOptMouseType)

            # submenu.add_separator()

            # sinnlos mit touch-device:
            # self.addCheckNode(tv, rg,
            #   'Use mouse for undo/redo',
            #   self.menubar.tkopt.mouse_undo,
            #   self.menubar.mOptMouseUndo)

        # submenu.add_separator()

        # -------------------------------------------
        # TBD ?

        '''
        menu.add_command(label=n_("&Fonts..."), command=self.mOptFonts)
        menu.add_command(label=n_("&Colors..."), command=self.mOptColors)
        menu.add_command(label=n_("Time&outs..."), command=self.mOptTimeouts)
        menu.add_separator()
        '''

        # -------------------------------------------
        # Toolbar options

        rg = tv.add_node(
            LTreeNode(text=_('Toolbar')))
        if rg:
            self.addRadioNode(tv, rg,
                              _('Hide'),
                              self.menubar.tkopt.toolbar, 0,
                              self.menubar.mOptToolbar)

            # not supported: Top, Bottom
            # self.addRadioNode(tv, rg,
            #   'Top',
            #   self.menubar.tkopt.toolbar, 1,
            #   self.menubar.mOptToolbar)
            # self.addRadioNode(tv, rg,
            #   'Bottom',
            #   self.menubar.tkopt.toolbar, 2,
            #   self.menubar.mOptToolbar)

            self.addRadioNode(tv, rg,
                              _('Left'),
                              self.menubar.tkopt.toolbar, 3,
                              self.menubar.mOptToolbar)
            self.addRadioNode(tv, rg,
                              _('Right'),
                              self.menubar.tkopt.toolbar, 4,
                              self.menubar.mOptToolbar)

        # -------------------------------------------
        # Statusbar - not implemented

        '''
        submenu = MfxMenu(menu, label=n_("Stat&usbar"))
        submenu.add_checkbutton(
             label=n_("Show &statusbar"),
             variable=self.tkopt.statusbar,
             command=self.mOptStatusbar)
        submenu.add_checkbutton(
            label=n_("Show &number of cards"),
            variable=self.tkopt.num_cards,
            command=self.mOptNumCards)
        submenu.add_checkbutton(
            label=n_("Show &help bar"),
            variable=self.tkopt.helpbar,
            command=self.mOptHelpbar)
        '''

        # -------------------------------------------
        # general options

        # self.addCheckNode(tv, None,
        #   'Save games geometry',
        #   self.menubar.tkopt.save_games_geometry,
        #   self.menubar.mOptSaveGamesGeometry)

        # self.addCheckNode(tv, None,
        #   'Demo logo',
        #   self.menubar.tkopt.demo_logo,
        #   self.menubar.mOptDemoLogo)

        self.addCheckNode(tv, None,
                          _('Startup splash screen'),
                          self.menubar.tkopt.splashscreen,
                          self.menubar.mOptSplashscreen)

        self.addCheckNode(tv, None,
                          _('Winning splash'),
                          self.menubar.tkopt.display_win_message,
                          self.menubar.mWinDialog)


# ************************************************************************


class HelpMenuDialog(LMenuDialog):
    def __init__(self, menubar, parent, title, app, **kw):
        kw['size_hint'] = (0.3, 1)
        kw['persist'] = True
        super(HelpMenuDialog, self).__init__(menubar, parent, title, app, **kw)

    def make_help_command(self, command):
        def help_command():
            command()
            self.closeWindow(0)
        return help_command

    def buildTree(self, tv, node):
        tv.add_node(
            LTreeNode(
                text=_('Contents'),
                command=self.make_help_command(self.menubar.mHelp)))
        tv.add_node(
            LTreeNode(
                text=_('How to play'),
                command=self.make_help_command(self.menubar.mHelpHowToPlay)))
        tv.add_node(
            LTreeNode(
                text=_('Rules for this game'),
                command=self.make_help_command(self.menubar.mHelpRules)))
        tv.add_node(
            LTreeNode(
                text=_('License terms'),
                command=self.make_help_command(self.menubar.mHelpLicense)))
        tv.add_node(
            LTreeNode(
                text=_('About %s...') % TITLE,
                command=self.make_help_command(self.menubar.mHelpAbout)))

        # tv.add_node(LTreeNode(
        #   text='AboutKivy ...',
        #   command=self.makeHtmlCommand(self.menubar, "kivy.html")))

    def makeHtmlCommand(self, bar, htmlfile):
        def htmlCommand():
            bar.mHelpHtml(htmlfile)

        return htmlCommand


# ************************************************************************
# *
# ************************************************************************


class EmulTkMenu(object):

    def __init__(self, master, **kw):

        self.name = kw["name"]
        self.n = 0
        self._w = None
        if (self.name):
            if master._w == '.':
                self._w = '.' + self.name
            else:
                self._w = master._w + '.' + self.name
        else:
            self.name = "<>"

    def labeltoname(self, label):
        name = re.sub(r"[^0-9a-zA-Z]", "", label).lower()
        label = _(label)
        underline = label.find('&')
        if underline >= 0:
            label = label.replace('&', '')
        return name, label, underline

    def add_cascade(self, cnf={}, **kw):
        self.add('cascade', cnf or kw)
        pass

    def add(self, itemType, cnf={}):
        label = cnf.get("label")
        if label:
            name = cnf.get('name')
            if name:
                name, label, underline = self.labeltoname(label)
                cnf["underline"] = cnf.get("underline", underline)
                cnf["label"] = label
                if name and self.addPath:
                    path = str(self._w) + "." + name
                    self.addPath(path, self, self.n, cnf.get("menu"))

    def cget(self, key):
        return key

# ************************************************************************


class MfxMenubar(EmulTkMenu):
    addPath = None

    def __init__(self, master, **kw):
        super(MfxMenubar, self).__init__(master, **kw)
        topmenu = self.name == 'menubar'

        self.menu = LMenu(not topmenu, text=self.name)
        if topmenu:
            master.setMenu(self.menu)

# ************************************************************************
# * - create menubar
# * - update menubar
# * - menu actions
# ************************************************************************


class PysolMenubarTk:
    def __init__(self, app, top, progress=None):
        self._createTkOpt()
        self._setOptions()
        # init columnbreak
#        self.__cb_max = int(self.top.winfo_screenheight()/23)
        self.__cb_max = 8
#         sh = self.top.winfo_screenheight()
#         self.__cb_max = 22
#         if sh >= 600: self.__cb_max = 27
#         if sh >= 768: self.__cb_max = 32
#         if sh >= 1024: self.__cb_max = 40
        self.progress = progress
        # create menus
        self.__menubar = None
        self.__menupath = {}
        self.__keybindings = {}
        self._createMenubar()
        self.top = top

        if self.progress:
            self.progress.update(step=1)

        # set the menubar
        # self.updateBackgroundImagesMenu()
        # self.top.config(menu=self.__menubar)

    def _createTkOpt(self):
        # structure to convert menu-options to Toolkit variables
        self.tkopt = Struct(
            gameid=IntVar(),
            gameid_popular=IntVar(),
            comment=BooleanVar(),
            autofaceup=BooleanVar(),
            autodrop=BooleanVar(),
            autodeal=BooleanVar(),
            quickplay=BooleanVar(),
            undo=BooleanVar(),
            bookmarks=BooleanVar(),
            hint=BooleanVar(),
            shuffle=BooleanVar(),
            highlight_piles=BooleanVar(),
            highlight_cards=BooleanVar(),
            highlight_samerank=BooleanVar(),
            highlight_not_matching=BooleanVar(),
            mahjongg_show_removed=BooleanVar(),
            shisen_show_hint=BooleanVar(),
            sound=BooleanVar(),
            sound_sample_volume=IntVar(),
            sound_music_volume=IntVar(),
            cardback=IntVar(),
            tabletile=IntVar(),
            animations=IntVar(),
            redeal_animation=BooleanVar(),
            win_animation=BooleanVar(),
            shadow=BooleanVar(),
            shade=BooleanVar(),
            shade_filled_stacks=BooleanVar(),
            shrink_face_down=BooleanVar(),
            toolbar=IntVar(),
            toolbar_style=StringVar(),
            toolbar_relief=StringVar(),
            toolbar_compound=StringVar(),
            toolbar_size=IntVar(),
            statusbar=BooleanVar(),
            num_cards=BooleanVar(),
            helpbar=BooleanVar(),
            save_games_geometry=BooleanVar(),
            splashscreen=BooleanVar(),
            demo_logo=BooleanVar(),
            mouse_type=StringVar(),
            mouse_undo=BooleanVar(),
            negative_bottom=BooleanVar(),
            display_win_message=BooleanVar(),
            pause=BooleanVar(),
            cardset=IntVar(),
            cardbacks={},
            toolbar_vars={},
            sound_sample_vars={},
            color_vars={},
            language=StringVar(),
        )
        for w in TOOLBAR_BUTTONS:
            self.tkopt.toolbar_vars[w] = BooleanVar()
        for k in self.app.opt.sound_samples:
            self.tkopt.sound_sample_vars[k] = BooleanVar()
        for k in self.app.opt.colors:
            self.tkopt.color_vars[k] = StringVar()

    def _setOptions(self):
        tkopt, opt = self.tkopt, self.app.opt
        # set state of the menu items
        tkopt.autofaceup.set(opt.autofaceup)
        tkopt.autodrop.set(opt.autodrop)
        tkopt.autodeal.set(opt.autodeal)
        tkopt.quickplay.set(opt.quickplay)
        tkopt.undo.set(opt.undo)
        tkopt.hint.set(opt.hint)
        tkopt.shuffle.set(opt.shuffle)
        tkopt.bookmarks.set(opt.bookmarks)
        tkopt.highlight_piles.set(opt.highlight_piles)
        tkopt.highlight_cards.set(opt.highlight_cards)
        tkopt.highlight_samerank.set(opt.highlight_samerank)
        tkopt.highlight_not_matching.set(opt.highlight_not_matching)
        tkopt.shrink_face_down.set(opt.shrink_face_down)
        tkopt.shade_filled_stacks.set(opt.shade_filled_stacks)
        tkopt.mahjongg_show_removed.set(opt.mahjongg_show_removed)
        tkopt.shisen_show_hint.set(opt.shisen_show_hint)
        tkopt.sound.set(opt.sound)
        tkopt.sound_sample_volume.set(opt.sound_sample_volume)
        tkopt.sound_music_volume.set(opt.sound_music_volume)
        tkopt.cardback.set(self.app.cardset.backindex)
        tkopt.tabletile.set(self.app.tabletile_index)
        tkopt.animations.set(opt.animations)
        tkopt.redeal_animation.set(opt.redeal_animation)
        tkopt.win_animation.set(opt.win_animation)
        tkopt.shadow.set(opt.shadow)
        tkopt.shade.set(opt.shade)
        tkopt.toolbar.set(opt.toolbar)
        tkopt.toolbar_style.set(opt.toolbar_style)
        tkopt.toolbar_relief.set(opt.toolbar_relief)
        tkopt.toolbar_compound.set(opt.toolbar_compound)
        tkopt.toolbar_size.set(opt.toolbar_size)
        tkopt.toolbar_relief.set(opt.toolbar_relief)
        tkopt.statusbar.set(opt.statusbar)
        tkopt.num_cards.set(opt.num_cards)
        tkopt.helpbar.set(opt.helpbar)
        tkopt.save_games_geometry.set(opt.save_games_geometry)
        tkopt.demo_logo.set(opt.demo_logo)
        tkopt.splashscreen.set(opt.splashscreen)
        tkopt.mouse_type.set(opt.mouse_type)
        tkopt.mouse_undo.set(opt.mouse_undo)
        tkopt.negative_bottom.set(opt.negative_bottom)
        tkopt.display_win_message.set(opt.display_win_message)
        tkopt.cardset.set(self.app.cardset_manager.getSelected())
        tkopt.language.set(opt.language)

        for w in TOOLBAR_BUTTONS:
            tkopt.toolbar_vars[w].set(opt.toolbar_vars.get(w, False))
        for k in self.app.opt.sound_samples:
            self.tkopt.sound_sample_vars[k].set(
                opt.sound_samples.get(k, False))
        for k in self.app.opt.colors:
            self.tkopt.color_vars[k].set(opt.colors.get(k, '#000000'))

    def connectGame(self, game):
        self.game = game
        if game is None:
            return
        assert self.app is game.app
        tkopt = self.tkopt
        # opt = self.app.opt
        tkopt.gameid.set(game.id)
        tkopt.gameid_popular.set(game.id)
        tkopt.comment.set(bool(game.gsaveinfo.comment))
        tkopt.pause.set(self.game.pause)
        if game.canFindCard():
            connect_game_find_card_dialog(game)
        else:
            destroy_find_card_dialog()
        connect_game_solver_dialog(game)

    # create a GTK-like path
    def _addPath(self, path, menu, index, submenu):
        # print ('MfxMenubar: _addPath %s, %s' % (path, menu))
        # y = self.yy
        if path not in self.__menupath:
            # print path, menu, index, submenu
            self.__menupath[path] = (menu, index, submenu)

    def _getEnabledState(self, enabled):
        print('_getEnabledState: %s' % enabled)
        if enabled:
            return "normal"
        return "disabled"

    def updateProgress(self):
        if self.progress:
            self.progress.update(step=1)

    #
    # create the menubar
    #

    def _createMenubar(self):
        MfxMenubar.addPath = self._addPath
        kw = {"name": "menubar"}
        self.__menubar = MfxMenubar(self.top, **kw)

        # init keybindings
        bind(self.top, "<KeyPress>", self._keyPressHandler)

        # LMainMenuDialog()
        LMenuItem(self.__menubar.menu,
                  text=_("Menu"), command=self.mMainMenuDialog)

        MfxMenubar.addPath = None

    #
    # key binding utility
    #

    def _bindKey(self, modifier, key, func):
        #         if 0 and not modifier and len(key) == 1:
        #             self.__keybindings[key.lower()] = func
        #             self.__keybindings[key.upper()] = func
        #             return
        if not modifier and len(key) == 1:
            # ignore Ctrl/Shift/Alt
            # but don't ignore NumLock (state == 16)
            def lfunc(e, func=func):
                return e.state in (0, 16) and func(e)
            func = lfunc
            # func = lambda e, func=func: e.state in (0, 16) and func(e)
        sequence = "<" + modifier + "KeyPress-" + key + ">"
        bind(self.top, sequence, func)
        if len(key) == 1 and key != key.upper():
            key = key.upper()
            sequence = "<" + modifier + "KeyPress-" + key + ">"
            bind(self.top, sequence, func)

    def _keyPressHandler(self, event):
        r = EVENT_PROPAGATE
        if event and self.game:
            # print event.__dict__
            if self.game.demo:
                # stop the demo by setting self.game.demo.keypress
                if event.char:    # ignore Ctrl/Shift/etc.
                    self.game.demo.keypress = event.char
                    r = EVENT_HANDLED
#             func = self.__keybindings.get(event.char)
#             if func and (event.state & ~2) == 0:
#                 func(event)
#                 r = EVENT_HANDLED
        return r

    #
    # Select Game menu creation
    #
    '''
    def _addSelectGameMenu(self, menu):
        games = map(self.app.gdb.get, self.app.gdb.getGamesIdSortedByName())
        m = "Ctrl-"
        if sys.platform == "darwin":
            m = "Cmd-"
        menu.add_command(label=n_("All &games..."), accelerator=m + "W",
                         command=self.mSelectGameDialog)

    def _addSelectGameSubMenu(self, games, menu, select_data,
                              command, variable):
        # print select_data
        need_sep = 0
        for label, select_func in select_data:
            if label is None:
                need_sep = 1
                continue
            g = filter(select_func, games)
            if not g:
                continue
            if need_sep:
                menu.add_separator()
                need_sep = 0
            submenu = MfxMenu(menu, label=label)
            self._addSelectGameSubSubMenu(g, submenu, command, variable)

    def _getNumGames(self, games, select_data):
        ngames = 0
        for label, select_func in select_data:
            ngames += len(filter(select_func, games))
        return ngames

    def _addSelectMahjonggGameSubMenu(self, games, menu, command, variable):
        def select_func(gi): return gi.si.game_type == GI.GT_MAHJONGG
        mahjongg_games = filter(select_func, games)
        if len(mahjongg_games) == 0:
            return
        #
        menu = MfxMenu(menu, label=n_("&Mahjongg games"))

        def add_menu(games, c0, c1, menu=menu,
                     variable=variable, command=command):
            if not games:
                return
            label = c0 + ' - ' + c1
            if c0 == c1:
                label = c0
            submenu = MfxMenu(menu, label=label, name=None)
            self._addSelectGameSubSubMenu(games, submenu, command,
                                          variable, short_name=True)

        games = {}
        for gi in mahjongg_games:
            c = gi.short_name.strip()[0]
            if c in games:
                games[c].append(gi)
            else:
                games[c] = [gi]
        games = games.items()
        games.sort()
        g0 = []
        c0 = c1 = games[0][0]
        for c, g1 in games:
            if len(g0) + len(g1) >= self.__cb_max:
                add_menu(g0, c0, c1)
                g0 = g1
                c0 = c1 = c
            else:
                g0 += g1
                c1 = c
        add_menu(g0, c0, c1)

    def _addSelectPopularGameSubMenu(self, games, menu, command, variable):
        def select_func(gi): return gi.si.game_flags & GI.GT_POPULAR
        if len(filter(select_func, games)) == 0:
            return
        data = (n_("&Popular games"), select_func)
        self._addSelectGameSubMenu(games, menu, (data, ),
                                   self.mSelectGamePopular,
                                   self.tkopt.gameid_popular)

    def _addSelectFrenchGameSubMenu(self, games, menu, command, variable):
        if self._getNumGames(games, GI.SELECT_GAME_BY_TYPE) == 0:
            return
        submenu = MfxMenu(menu, label=n_("&French games"))
        self._addSelectGameSubMenu(games, submenu, GI.SELECT_GAME_BY_TYPE,
                                   self.mSelectGame, self.tkopt.gameid)

    def _addSelectOrientalGameSubMenu(self, games, menu, command, variable):
        if self._getNumGames(games, GI.SELECT_ORIENTAL_GAME_BY_TYPE) == 0:
            return
        submenu = MfxMenu(menu, label=n_("&Oriental games"))
        self._addSelectGameSubMenu(games, submenu,
                                   GI.SELECT_ORIENTAL_GAME_BY_TYPE,
                                   self.mSelectGame, self.tkopt.gameid)

    def _addSelectSpecialGameSubMenu(self, games, menu, command, variable):
        if self._getNumGames(games, GI.SELECT_ORIENTAL_GAME_BY_TYPE) == 0:
            return
        submenu = MfxMenu(menu, label=n_("&Special games"))
        self._addSelectGameSubMenu(games, submenu,
                                   GI.SELECT_SPECIAL_GAME_BY_TYPE,
                                   self.mSelectGame, self.tkopt.gameid)

    def _addSelectCustomGameSubMenu(self, games, menu, command, variable):
        submenu = MfxMenu(menu, label=n_("&Custom games"))

        def select_func(gi): return gi.si.game_type == GI.GT_CUSTOM
        games = filter(select_func, games)
        self.updateGamesMenu(submenu, games)
    '''

    def _addSelectAllGameSubMenu(self, games, menu, command, variable):
        # LB
        # herausgenommen: zu aufwendig !
        return
        '''
        menu = MfxMenu(menu, label=n_("&All games by name"))
        n, d = 0, self.__cb_max
        i = 0
        while True:
            if self.progress:
                self.progress.update(step=1)
            columnbreak = i > 0 and (i % d) == 0
            i += 1
            if not games[n:n + d]:
                break
            m = min(n + d - 1, len(games) - 1)
            label = games[n].name[:3] + ' - ' + games[m].name[:3]

            submenu = MfxMenu(menu, label=label, name=None)
            self._addSelectGameSubSubMenu(games[n:n + d], submenu,
                                          command, variable)
            n += d
            # if columnbreak:
            #    menu.entryconfigure(i, columnbreak=columnbreak)
        '''

    # Eine 'closure' in Python? - voila!
    def make_gamesetter(self, n, variable, command):
        def gamesetter(x):
            variable.set(n)
            command()
        return gamesetter

    def _addSelectGameSubSubMenu(self, games, menu, command, variable,
                                 short_name=False):

        # cb = self.__cb_max
        for i in range(len(games)):
            gi = games[i]
            # columnbreak = i > 0 and (i % cb) == 0
            if short_name:
                label = gi.short_name
            else:
                label = gi.name

            # optimized by inlining

            # geht nicht mehr 'optimiert' mit kivy
            # die Funktionalität des tk.calls kann mit hilfe
            # einer 'closure' rekonstruiert werden (s.o).
            # LB

            gsetter = self.make_gamesetter(gi.id, variable, command)
            menu.add_command(label=label, command=gsetter)

            # menu.tk.call((menu._w, 'add', 'radiobutton') +
            #             menu._options({'command': command,
            #                            'variable': variable,
            #                            'columnbreak': columnbreak,
            #                            'value': gi.id,
            #                            'label': label}))

    def updateGamesMenu(self, menu, games):

        def cmp2(a, b):
            """python 3 replacement for python 2 cmp function"""
            return (a > b) - (a < b)

        menu.delete(0, 'last')

        if len(games) == 0:
            menu.add_radiobutton(label=_('<none>'), name=None,
                                 state='disabled')
        elif len(games) > self.__cb_max * 4:
            games.sort(lambda a, b: cmp2(a.name, b.name))
            self._addSelectAllGameSubMenu(games, menu,
                                          command=self.mSelectGame,
                                          variable=self.tkopt.gameid)
        else:
            self._addSelectGameSubSubMenu(games, menu,
                                          command=self.mSelectGame,
                                          variable=self.tkopt.gameid)

    def mMainMenuDialog(self, *event):
        MainMenuDialog(self, self.top, title=_("Main Menu"), app=self.app)
        return EVENT_HANDLED

    def mFileMenuDialog(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.game.setCursor(cursor=CURSOR_WATCH)
        after_idle(self.top, self.__restoreCursor)
        FileMenuDialog(self, self.top, title=_("File Menu"), app=self.app)
        return EVENT_HANDLED

    def mEditMenuDialog(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.game.setCursor(cursor=CURSOR_WATCH)
        after_idle(self.top, self.__restoreCursor)
        EditMenuDialog(self, self.top, title=_("Tools"), app=self.app)
        return EVENT_HANDLED

    def mGameMenuDialog(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.game.setCursor(cursor=CURSOR_WATCH)
        after_idle(self.top, self.__restoreCursor)
        GameMenuDialog(self, self.top, title=_("Statistics"), app=self.app)
        return EVENT_HANDLED

    def mAssistMenuDialog(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.game.setCursor(cursor=CURSOR_WATCH)
        after_idle(self.top, self.__restoreCursor)
        AssistMenuDialog(self, self.top, title=_("Assists"), app=self.app)
        return EVENT_HANDLED

    def mOptionsMenuDialog(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.game.setCursor(cursor=CURSOR_WATCH)
        after_idle(self.top, self.__restoreCursor)
        OptionsMenuDialog(self, self.top, title=_("Options"), app=self.app)
        return EVENT_HANDLED

    def mHelpMenuDialog(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.game.setCursor(cursor=CURSOR_WATCH)
        after_idle(self.top, self.__restoreCursor)
        HelpMenuDialog(self, self.top, title=_("Help"), app=self.app)
        return EVENT_HANDLED
    #
    # Select Game menu actions
    #

    def mSelectGame(self, *args):
        print('mSelectGame %s' % self)
        self._mSelectGame(self.tkopt.gameid.get())

    def mSelectGamePopular(self, *args):
        self._mSelectGame(self.tkopt.gameid_popular.get())

    def _mSelectGameDialog(self, d):
        if d.gameid != self.game.id:
            self.tkopt.gameid.set(d.gameid)
            self.tkopt.gameid_popular.set(d.gameid)
            self._cancelDrag()
            self.game.endGame()
            self.game.quitGame(d.gameid, random=d.random)
        return EVENT_HANDLED

    def __restoreCursor(self, *event):
        self.game.setCursor(cursor=self.app.top_cursor)

    def mSelectGameDialog(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.game.setCursor(cursor=CURSOR_WATCH)
        after_idle(self.top, self.__restoreCursor)
        d = SelectGameDialog(self.top, title=_("Select game"),
                             app=self.app, gameid=self.game.id)
        return self._mSelectGameDialog(d)

    #
    # menubar overrides
    #

    def updateFavoriteGamesMenu(self):
        return

        # TBD ?
        '''
        gameids = self.app.opt.favorite_gameid

        print('favorite_gameids = %s' % gameids)

        submenu = self.__menupath[".menubar.file.favoritegames"][2]
        games = []
        for id in gameids:
            gi = self.app.getGameInfo(id)
            if gi:
                games.append(gi)
        self.updateGamesMenu(submenu, games)

        # das folgende ist nur das enable/disable des add/remove buttons.
        # geht mit kivy nicht so.

#        state = self._getEnabledState
#        in_favor = self.app.game.id in gameids

# menu, index, submenu = self.__menupath[".menubar.file.addtofavorites"]
# menu.entryconfig(index, state=state(not in_favor))

# menu, index, submenu = self.__menupath[".menubar.file.removefromfavorites"]
# menu.entryconfig(index, state=state(in_favor))
        '''

    def updateRecentGamesMenu(self, gameids):
        return

        # TBD ?
        '''
        submenu = self.__menupath[".menubar.file.recentgames"][2]
        games = []
        for id in gameids:
            gi = self.app.getGameInfo(id)
            if gi:
                games.append(gi)
        self.updateGamesMenu(submenu, games)
        '''

    def updateBookmarkMenuState(self):
        # LB:
        print('updateBookmarkMenuState - fake')
        return

        state = self._getEnabledState
        mp1 = self.__menupath.get(".menubar.edit.setbookmark")
        mp2 = self.__menupath.get(".menubar.edit.gotobookmark")
        mp3 = self.__menupath.get(".menubar.edit.clearbookmarks")
        if mp1 is None or mp2 is None or mp3 is None:
            return
        x = self.app.opt.bookmarks and self.game.canSetBookmark()
        #
        menu, index, submenu = mp1
        for i in range(9):
            submenu.entryconfig(i, state=state(x))
        menu.entryconfig(index, state=state(x))
        #
        menu, index, submenu = mp2
        ms = 0
        for i in range(9):
            s = self.game.gsaveinfo.bookmarks.get(i) is not None
            submenu.entryconfig(i, state=state(s and x))
            ms = ms or s
        menu.entryconfig(index, state=state(ms and x))
        #
        menu, index, submenu = mp3
        menu.entryconfig(index, state=state(ms and x))

    def updateBackgroundImagesMenu(self):
        # LB:
        print('updateBackgroundImagesMenu - fake')
        return

        mp = self.__menupath.get(".menubar.options.cardbackground")
        # delete all entries
        submenu = mp[2]
        submenu.delete(0, "last")
        # insert new cardbacks
        mbacks = self.app.images.getCardbacks()
        cb = int(math.ceil(math.sqrt(len(mbacks))))
        for i in range(len(mbacks)):
            columnbreak = i > 0 and (i % cb) == 0
            submenu.add_radiobutton(
                    label=mbacks[i].name,
                    image=mbacks[i].menu_image,
                    variable=self.tkopt.cardback,
                    value=i,
                    command=self.mOptCardback,
                    columnbreak=columnbreak,
                    indicatoron=0,
                    hidemargin=0)
    #
    # menu updates
    #

    def setMenuState(self, state, path):
        # LB: not used
        return

    def setToolbarState(self, state, path):
        # LB: not used
        return

    def _setCommentMenu(self, v):
        self.tkopt.comment.set(v)

    def _setPauseMenu(self, v):
        self.tkopt.pause.set(v)

    #
    # menu actions
    #

    DEFAULTEXTENSION = ".pso"
    # TRANSLATORS: Usually, 'PySol files'
    FILETYPES = ((_("%s files") % TITLE, "*" + DEFAULTEXTENSION),
                 (_("All files"), "*"))

    def mAddFavor(self, *event):
        gameid = self.app.game.id
        if gameid not in self.app.opt.favorite_gameid:
            self.app.opt.favorite_gameid.append(gameid)
            self.updateFavoriteGamesMenu()

    def mDelFavor(self, *event):
        gameid = self.app.game.id
        if gameid in self.app.opt.favorite_gameid:
            self.app.opt.favorite_gameid.remove(gameid)
            self.updateFavoriteGamesMenu()

    def mOpen(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        # filename = self.game.filename
        filename = "lastgame.pso"
        if filename:
            idir, ifile = os.path.split(os.path.normpath(filename))
        else:
            idir, ifile = "", ""
        if not idir:
            idir = self.app.dn.savegames
#        d = tkFileDialog.Open()
#        filename = d.show(filetypes=self.FILETYPES,
#                          defaultextension=self.DEFAULTEXTENSION,
#                          initialdir=idir, initialfile=ifile)
        filename = idir + "/" + ifile

        print('filename = %s' % filename)
        if filename:
            filename = os.path.normpath(filename)
            # filename = os.path.normcase(filename)
            if os.path.isfile(filename):
                self.game.loadGame(filename)

    def mSaveAs(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        if not self.menustate.save_as:
            return
        # filename = self.game.filename
        filename = "lastgame.pso"
        if not filename:
            filename = self.app.getGameSaveName(self.game.id)
            if os.name == "posix":
                filename = filename + "-" + self.game.getGameNumber(format=0)
            elif os.path.supports_unicode_filenames:  # new in python 2.3
                filename = filename + "-" + self.game.getGameNumber(format=0)
            else:
                filename = filename + "-01"
            filename = filename + self.DEFAULTEXTENSION
        idir, ifile = os.path.split(os.path.normpath(filename))
        if not idir:
            idir = self.app.dn.savegames
        # print self.game.filename, ifile
        # d = tkFileDialog.SaveAs()
        # filename = d.show(filetypes=self.FILETYPES,
        #                  defaultextension=self.DEFAULTEXTENSION,
        #                  initialdir=idir, initialfile=ifile)
        filename = idir + "/" + ifile
        if filename:
            filename = os.path.normpath(filename)
            # filename = os.path.normcase(filename)
            self.game.saveGame(filename)
            self.updateMenus()

    def mPause(self, *args):
        if not self.game:
            return
        if not self.game.pause:
            if self._cancelDrag():
                return
        self.game.doPause()
        self.tkopt.pause.set(self.game.pause)

    def mOptLanguage(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.language = self.tkopt.language.get()
        MfxMessageDialog(
           self.app.top, title=_("Note"),
           text=_("""\
These settings will take effect
the next time you restart the %(app)s""") % {'app': TITLE})

    def mOptSoundDialog(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.sound = self.tkopt.sound.get()

    def mOptSoundSampleVol(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.sound_sample_volume = self.tkopt.sound_sample_volume.get()

    def mOptSoundMusicVol(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.sound_music_volume = self.tkopt.sound_music_volume.get()

    def mOptSoundSample(self, key, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.sound_samples[key] = \
            self.tkopt.sound_sample_vars[key].get()

    def mOptTableColor(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        nv = self.tkopt.color_vars['table'].get()
        ov = self.app.opt.colors['table']
        self.app.opt.colors['table'] = nv
        if ov != nv:
            self.app.top_bg = nv
            self.app.tabletile_index = 0
            self.app.setTile(0, force=True)
            self.tkopt.tabletile.set(0)

    def mOptTileSet(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        idx = self.tkopt.tabletile.get()
        if idx > 0 and idx != self.app.tabletile_index:
            self.app.setTile(idx)
            self.tkopt.color_vars['table'].set('#008285')

    def mOptAutoFaceUp(self, *args):
        if self._cancelDrag():
            return
        self.app.opt.autofaceup = self.tkopt.autofaceup.get()
        if self.app.opt.autofaceup:
            self.game.autoPlay()

    def mOptAutoDrop(self, *args):
        if self._cancelDrag():
            return
        self.app.opt.autodrop = self.tkopt.autodrop.get()
        if self.app.opt.autodrop:
            self.game.autoPlay()

    def mOptAutoDeal(self, *args):
        if self._cancelDrag():
            return
        self.app.opt.autodeal = self.tkopt.autodeal.get()
        if self.app.opt.autodeal:
            self.game.autoPlay()

    def mOptQuickPlay(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.quickplay = self.tkopt.quickplay.get()

    def mOptEnableUndo(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.undo = self.tkopt.undo.get()
        self.game.updateMenus()

    def mOptEnableBookmarks(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.bookmarks = self.tkopt.bookmarks.get()
        self.game.updateMenus()

    def mOptEnableHint(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.hint = self.tkopt.hint.get()
        self.game.updateMenus()

    def mOptEnableShuffle(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.shuffle = self.tkopt.shuffle.get()
        self.game.updateMenus()

    def mOptEnableHighlightPiles(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.highlight_piles = self.tkopt.highlight_piles.get()
        self.game.updateMenus()

    def mOptEnableHighlightCards(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.highlight_cards = self.tkopt.highlight_cards.get()
        self.game.updateMenus()

    def mOptEnableHighlightSameRank(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.highlight_samerank = self.tkopt.highlight_samerank.get()
        # self.game.updateMenus()

    def mOptEnableHighlightNotMatching(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.highlight_not_matching = \
            self.tkopt.highlight_not_matching.get()
        # self.game.updateMenus()

    def mOptAnimations(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.animations = self.tkopt.animations.get()

    def mRedealAnimation(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.redeal_animation = self.tkopt.redeal_animation.get()

    def mWinAnimation(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.win_animation = self.tkopt.win_animation.get()

    def mWinDialog(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.display_win_message = self.tkopt.display_win_message.get()

    def mOptShadow(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.shadow = self.tkopt.shadow.get()

    def mOptShade(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.shade = self.tkopt.shade.get()

    def mOptShrinkFaceDown(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.shrink_face_down = self.tkopt.shrink_face_down.get()
        self.game.endGame(bookmark=1)
        self.game.quitGame(bookmark=1)

    def mOptShadeFilledStacks(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.shade_filled_stacks = self.tkopt.shade_filled_stacks.get()
        self.game.endGame(bookmark=1)
        self.game.quitGame(bookmark=1)

    def mOptMahjonggShowRemoved(self, *args):
        if self._cancelDrag():
            return
        self.app.opt.mahjongg_show_removed = \
            self.tkopt.mahjongg_show_removed.get()
        # self.game.updateMenus()
        self.game.endGame(bookmark=1)
        self.game.quitGame(bookmark=1)

    def mOptShisenShowHint(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.shisen_show_hint = self.tkopt.shisen_show_hint.get()
        # self.game.updateMenus()

    def mOptCardset(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        idx = self.tkopt.cardset.get()
        cs = self.app.cardset_manager.get(idx)
        if cs is None or idx == self.app.cardset.index:
            return
        if idx >= 0:
            self.app.nextgame.cardset = cs
            self._cancelDrag()
            self.game.endGame(bookmark=1)
            self.game.quitGame(bookmark=1)

    def mSelectCardsetDialog(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        # strings, default = ("&OK", "&Load", "&Cancel"), 0
        strings, default = (None, _("&Load"), _("&Cancel"), ), 1
        # if os.name == "posix":
        strings, default = (None, _("&Load"), _(
            "&Cancel"), _("&Info..."), ), 1
        key = self.app.nextgame.cardset.index
        d = SelectCardsetDialogWithPreview(
                self.top, title=_("Select cardset"),
                app=self.app, manager=self.app.cardset_manager, key=key,
                strings=strings, default=default)

        cs = self.app.cardset_manager.get(d.key)
        if cs is None or d.key == self.app.cardset.index:
            return
        if d.status == 0 and d.button in (0, 1) and d.key >= 0:
            self.app.nextgame.cardset = cs
            if d.button == 1:
                self._cancelDrag()
                self.game.endGame(bookmark=1)
                self.game.quitGame(bookmark=1)

    def mOptSetCardback(self, key, *event):
        val = self.tkopt.cardbacks[key].get()
        cs = self.app.cardset_manager.get(key)
        cs.updateCardback(backindex=val)
        # ANM: wir können den Background nur für das aktuell
        # selektierte Cardset wirklich ändern. Nur dieses wird
        # wird in den Optionen gespeichert.
        if (cs == self.app.cardset):
            self.app.updateCardset(self.game.id)
            self.app.cardset.backindex = val
            image = self.app.images.getBack(update=True)
            for card in self.game.cards:
                card.updateCardBackground(image=image)
            self.app.canvas.update_idletasks()

    def _mOptCardback(self, index):
        if self._cancelDrag(break_pause=False):
            return
        cs = self.app.cardset
        old_index = cs.backindex
        cs.updateCardback(backindex=index)
        if cs.backindex == old_index:
            return
        self.app.updateCardset(self.game.id)
        image = self.app.images.getBack(update=True)
        for card in self.game.cards:
            card.updateCardBackground(image=image)
        self.app.canvas.update_idletasks()
        self.tkopt.cardback.set(cs.backindex)

    def mOptCardback(self, *event):
        self._mOptCardback(self.tkopt.cardback.get())

    def mOptChangeCardback(self, *event):
        self._mOptCardback(self.app.cardset.backindex + 1)

    def mOptToolbar(self, *event):
        # if self._cancelDrag(break_pause=False): return
        self.setToolbarSide(self.tkopt.toolbar.get())

    def mOptToolbarStyle(self, *event):
        # if self._cancelDrag(break_pause=False): return
        self.setToolbarStyle(self.tkopt.toolbar_style.get())

    def mOptToolbarCompound(self, *event):
        # if self._cancelDrag(break_pause=False): return
        self.setToolbarCompound(self.tkopt.toolbar_compound.get())

    def mOptToolbarSize(self, *event):
        # if self._cancelDrag(break_pause=False): return
        self.setToolbarSize(self.tkopt.toolbar_size.get())

    def mOptToolbarRelief(self, *event):
        # if self._cancelDrag(break_pause=False): return
        self.setToolbarRelief(self.tkopt.toolbar_relief.get())

    def mOptToolbarConfig(self, w):
        self.toolbarConfig(w, self.tkopt.toolbar_vars[w].get())

    def mOptStatusbar(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        if not self.app.statusbar:
            return
        side = self.tkopt.statusbar.get()
        self.app.opt.statusbar = side
        resize = not self.app.opt.save_games_geometry
        if self.app.statusbar.show(side, resize=resize):
            self.top.update_idletasks()

    def mOptNumCards(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.num_cards = self.tkopt.num_cards.get()

    def mOptHelpbar(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        if not self.app.helpbar:
            return
        show = self.tkopt.helpbar.get()
        self.app.opt.helpbar = show
        resize = not self.app.opt.save_games_geometry
        if self.app.helpbar.show(show, resize=resize):
            self.top.update_idletasks()

    def mOptSaveGamesGeometry(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.save_games_geometry = self.tkopt.save_games_geometry.get()

    def mOptDemoLogo(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.demo_logo = self.tkopt.demo_logo.get()

    def mOptSplashscreen(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.splashscreen = self.tkopt.splashscreen.get()

    def mOptMouseType(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.mouse_type = self.tkopt.mouse_type.get()

    def mOptMouseUndo(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.mouse_undo = self.tkopt.mouse_undo.get()

    def mOptNegativeBottom(self, *event):
        if self._cancelDrag():
            return
        self.app.opt.negative_bottom = self.tkopt.negative_bottom.get()
        self.app.updateCardset()
        self.game.endGame(bookmark=1)
        self.game.quitGame(bookmark=1)

    #
    # toolbar support
    #

    def setToolbarSide(self, side):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.toolbar = side
        self.tkopt.toolbar.set(side)                    # update radiobutton
        resize = not self.app.opt.save_games_geometry
        if self.app.toolbar.show(side, resize=resize):
            self.top.update_idletasks()

    def setToolbarSize(self, size):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.toolbar_size = size
        self.tkopt.toolbar_size.set(size)                # update radiobutton
        dir = self.app.getToolbarImagesDir()
        if self.app.toolbar.updateImages(dir, size):
            self.game.updateStatus(player=self.app.opt.player)
            self.top.update_idletasks()

    def setToolbarStyle(self, style):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.toolbar_style = style
        # update radiobutton
        self.tkopt.toolbar_style.set(style)
        dir = self.app.getToolbarImagesDir()
        size = self.app.opt.toolbar_size
        if self.app.toolbar.updateImages(dir, size):
            # self.game.updateStatus(player=self.app.opt.player)
            self.top.update_idletasks()

    def setToolbarCompound(self, compound):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.toolbar_compound = compound
        self.tkopt.toolbar_compound.set(
            compound)          # update radiobutton
        if self.app.toolbar.setCompound(compound):
            self.game.updateStatus(player=self.app.opt.player)
            self.top.update_idletasks()

    def setToolbarRelief(self, relief):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.toolbar_relief = relief
        self.tkopt.toolbar_relief.set(relief)           # update radiobutton
        self.app.toolbar.setRelief(relief)
        self.top.update_idletasks()

    def toolbarConfig(self, w, v):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.toolbar_vars[w] = v
        self.app.toolbar.config(w, v)
        self.top.update_idletasks()

    #
    # stacks descriptions
    #

    def mStackDesk(self, *event):
        if self.game.stackdesc_list:
            self.game.deleteStackDesc()
        else:
            if self._cancelDrag(break_pause=True):
                return
            self.game.showStackDesc()

    def wizardDialog(self, edit=False):
        from pysollib.wizardutil import write_game, reset_wizard
        from wizarddialog import WizardDialog

        if edit:
            reset_wizard(self.game)
        else:
            reset_wizard(None)
        d = WizardDialog(self.top, _('Solitaire Wizard'), self.app)
        if d.status == 0 and d.button == 0:
            try:
                if edit:
                    gameid = write_game(self.app, game=self.game)
                else:
                    gameid = write_game(self.app)
            except Exception:
                return
            if SELECT_GAME_MENU:
                menu = self.__menupath[".menubar.select.customgames"][2]

                def select_func(gi): return gi.si.game_type == GI.GT_CUSTOM
                games = map(self.app.gdb.get,
                            self.app.gdb.getGamesIdSortedByName())
                games = filter(select_func, games)
                self.updateGamesMenu(menu, games)

            self.tkopt.gameid.set(gameid)
            self._mSelectGame(gameid, force=True)

    def mWizard(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.wizardDialog()

    def mWizardEdit(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.wizardDialog(edit=True)


'''
'''
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#

# imports
# import os

# Toolkit imports
from pysollib.pysoltk import MfxScrolledCanvas


# ************************************************************************
# *
# ************************************************************************


class MfxTreeBaseNode:
    def __init__(self, tree, parent_node, text, key):
        self.tree = tree
        self.parent_node = parent_node
        self.text = text
        self.key = key
        # state
        self.selected = 0
        self.subnodes = None
        # canvas item ids
        self.symbol_id = None
        self.text_id = None
        self.textrect_id = None

    def registerKey(self):
        if self.key is not None:
            lk = self.tree.keys.get(self.key, [])
            lk.append(self)
            self.tree.keys[self.key] = lk

    def whoami(self):
        if self.parent_node is None:
            return (self.text, )
        else:
            return self.parent_node.whoami() + (self.text, )

    # drawing functions not used with kivy.
    '''
    def draw(self, x, y, lastx=None, lasty=None):
        canvas, style = self.tree.canvas, self.tree.style
        topleftx = x + style.distx
        toplefty = y - style.height / 2  # +++
        # draw the horizontal line
        if lastx is not None:
            canvas.create_line(x, y, topleftx, y,
                               stipple=style.linestyle, fill=style.linecolor)
        # draw myself - ugly, ugly...
        self.selected = 0
        self.symbol_id = -1
        self.drawSymbol(topleftx, toplefty)
        linestart = style.distx + style.width + 5
        self.text_id = -1
        self.drawText(x + linestart, y)
        return x, y, x, y + style.disty

    #
    #
    #

    def drawText(self, x, y):
        canvas, style = self.tree.canvas, self.tree.style
        if self.selected:
            fg, bg = style.text_selected_fg, style.text_selected_bg
        else:
            fg, bg = style.text_normal_fg, style.text_normal_bg
        #
        if self.tree.nodes.get(self.text_id) is self:
            canvas.itemconfig(self.text_id, fill=fg)
        else:
            # note: I don't use Label + canvas.create_window here
            #   because it doesn't propagate events to the canvas
            #   and has some other re-display annoyances
            # print 'style.font:', style.font
            self.text_id = canvas.create_text(x + 1, y, text=self.text,
                                              anchor="w", justify="left",
                                              font=style.font,
                                              fill=fg)
            self.tree.nodes[self.text_id] = self
        #
        if self.tree.nodes.get(self.textrect_id) is self:
            try:
                # _tkinter.TclError: unknown option "-fill" ???
                canvas.itemconfig(self.textrect_id, fill=bg)
            except Tkinter.TclError:
                pass
        elif self.selected:
            b = canvas.bbox(self.text_id)
            self.textrect_id = canvas.create_rectangle(
                b[0] - 1, b[1] - 1, b[2] + 1, b[3] + 1, fill=bg, outline="")
            canvas.tag_lower(self.textrect_id, self.text_id)
            self.tree.nodes[self.textrect_id] = self

    def updateText(self):
        if self.tree.nodes.get(self.text_id) is self:
            self.drawText(-1, -1)

    #
    #
    #

    def drawSymbol(self, x, y, **kw):
        canvas, style = self.tree.canvas, self.tree.style
        color = kw.get("color")
        if color is None:
            if self.selected:
                color = "darkgreen"
            else:
                color = "green"
        # note: rectangle outline is one pixel
        if self.tree.nodes.get(self.symbol_id) is self:
            canvas.itemconfig(self.symbol_id, fill=color)
        else:
            self.symbol_id = canvas.create_rectangle(
                x + 1, y + 1, x + style.width, y + style.height, fill=color)
            self.tree.nodes[self.symbol_id] = self

    def updateSymbol(self):
        if self.tree.nodes.get(self.symbol_id) is self:
            self.drawSymbol(-1, -1)
    '''

# ************************************************************************
# * Terminal and non-terminal nodes
# ************************************************************************


class MfxTreeLeaf(MfxTreeBaseNode):
    def drawText(self, x, y):
        if self.text_id < 0:
            self.registerKey()
        MfxTreeBaseNode.drawText(self, x, y)


class MfxTreeNode(MfxTreeBaseNode):
    def __init__(self, tree, parent_node, text, key, expanded=0):
        MfxTreeBaseNode.__init__(self, tree, parent_node, text, key)
        self.expanded = expanded

    def drawChildren(self, x, y, lastx, lasty):
        # get subnodes
        self.subnodes = self.tree.getContents(self)
        # draw subnodes
        lx, ly = lastx, lasty
        nx, ny = x, y
        for node in self.subnodes:
            # update tree
            node.tree = self.tree
            # draw node
            lx, ly, nx, ny = node.draw(nx, ny, lx, ly)
        # draw the vertical line
        if self.subnodes:
            style = self.tree.style
            dy = (style.disty - style.width) / 2
            y = y - style.disty / 2 - dy
            self.tree.canvas.create_line(x, y, nx, ly,
                                         stipple=style.linestyle,
                                         fill=style.linecolor)
        return ny

    def draw(self, x, y, ilastx=None, ilasty=None):
        # draw myself
        lx, ly, nx, ny = MfxTreeBaseNode.draw(self, x, y, ilastx, ilasty)
        if self.expanded:
            style = self.tree.style
            childx = nx + style.distx + style.width / 2
            childy = ny
            clastx = nx + style.distx + style.width / 2
            clasty = ly + style.height / 2
            ny = self.drawChildren(childx, childy, clastx, clasty)
        return lx, ly, x, ny

    #
    #
    #

    def drawSymbol(self, x, y, **kw):
        color = kw.get("color")
        if color is None:
            if self.expanded:
                color = "red"
            else:
                color = "pink"
        MfxTreeBaseNode.drawSymbol(self, x, y, color=color)


# ************************************************************************
# *
# ************************************************************************

class MfxTreeInCanvas(MfxScrolledCanvas):
    pass
    '''
    class Style:
        def __init__(self):
            self.distx = 16
            self.disty = 18
            self.width = 16         # width of symbol
            self.height = 16        # height of symbol
            self.originx = 0
            self.originy = 0
            self.text_normal_fg = "black"
            self.text_normal_bg = "white"
            self.text_selected_fg = "white"
            self.text_selected_bg = "#00008b"       # "darkblue"
            self.font = None
            self.linestyle = "gray50"
            self.linecolor = "black"

    def __init__(self, parent, rootnodes, **kw):
        # LB bg = kw["bg"] = kw.get("bg") or parent.cget("bg")
        kw['bd'] = 0
        MfxScrolledCanvas.__init__(self, parent, **kw)
        #
        self.rootnodes = rootnodes
        self.updateNodesWithTree(self.rootnodes, self)
        self.selection_key = None
        self.nodes = {}
        self.keys = {}
        #
        self.style = self.Style()
        # self.style.text_normal_fg = self.canvas.cget("insertbackground")
        self.style.text_normal_fg = self.canvas.option_get(
            'foreground', '') or self.canvas.cget("insertbackground")
        self.style.text_normal_bg = bg
        #
        bind(self.canvas, "<ButtonPress-1>", self.singleClick)
        bind(self.canvas, "<Double-Button-1>", self.doubleClick)
        # bind(self.canvas, "<ButtonRelease-1>", xxx)
        self.pack(fill='both', expand=True)

    def destroy(self):
        for node in self.keys.get(self.selection_key, []):
            node.selected = 0
        MfxScrolledCanvas.destroy(self)

    def findNode(self, event=None):
        id = self.canvas.find_withtag('current')
        if id:
            return self.nodes.get(id[0])
        return None

    #
    # draw nodes
    #

    def draw(self):
        nx, ny = self.style.originx, self.style.originy
        # Account for initial offsets, see topleft[xy] in BaseNode.draw().
        # We do this so that our bounding box always starts at (0, 0)
        # and the yscrollincrement works nicely.
        nx = nx - self.style.distx
        ny = ny + self.style.height / 2
        for node in self.rootnodes:
            # update tree
            node.tree = self
            # draw
            try:
                lx, ly, nx, ny = node.draw(nx, ny, None, None)
            except Tkinter.TclError:
                # FIXME: Tk bug ???
                raise
        # set scroll region
        bbox = self.canvas.bbox("all")
        # self.canvas.config(scrollregion=bbox)
        self.canvas.config(scrollregion=(0, 0, bbox[2], bbox[3]))
        self.canvas.config(yscrollincrement=self.style.disty)

    def clear(self):
        self.nodes = {}
        self.keys = {}
        self.canvas.delete("all")

    def redraw(self):
        oldcur = self.canvas["cursor"]
        self.canvas["cursor"] = "watch"
        self.canvas.update_idletasks()
        self.clear()
        self.draw()
        self.updateSelection(self.selection_key)
        self.canvas["cursor"] = oldcur

    #
    #
    #

    def getContents(self, node):
        # Overload this, supposed to return a list of subnodes of node.
        pass

    def singleClick(self, event=None):
        # Overload this if you want to know when a node is clicked on.
        pass

    def doubleClick(self, event=None):
        # Overload this if you want to know when a node is d-clicked on.
        self.singleClick(event)

    #
    #
    #

    def updateSelection(self, key):
        l1 = self.keys.get(self.selection_key, [])
        l2 = self.keys.get(key, [])
        for node in l1:
            if node.selected and node not in l2:
                node.selected = 0
                node.updateSymbol()
                node.updateText()
        for node in l2:
            if not node.selected:
                node.selected = 1
                node.updateSymbol()
                node.updateText()
        self.selection_key = key

    def updateNodesWithTree(self, nodes, tree):
        for node in nodes:
            node.tree = tree
            if node.subnodes:
                self.updateNodesWithTree(node.subnodes, tree)
    '''

# ************************************************************************
# *
# ************************************************************************


'''
class DirectoryBrowser(MfxTreeInCanvas):
    def __init__(self, parent, dirs):
        nodes = []
        if isinstance(dirs, str):
            dirs = (dirs, )
        for dir in dirs:
            self.addNode(nodes, None, dir, dir)
        # note: best results if height is a multiple of style.disty
        MfxTreeInCanvas.__init__(self, parent, nodes, height=25 * 18)
        self.draw()

    def addNode(self, list, node, filename, text):
        try:
            if os.path.isdir(filename):
                list.append(MfxTreeNode(self, node, text, key=filename))
            else:
                list.append(MfxTreeLeaf(self, node, text, key=filename))
        except EnvironmentError:
            pass

    def getContents(self, node):
        # use cached values
        if node.subnodes is not None:
            return node.subnodes
        #
        dir = node.key
        print "Getting %s" % dir
        try:
            filenames = os.listdir(dir)
            filenames.sort()
        except EnvironmentError:
            return ()
        contents = []
        for filename in filenames:
            self.addNode(contents, node, os.path.join(
                dir, filename), filename)
        # print "gotten"
        return contents

    def singleClick(self, event=None):
        node = self.findNode(event)
        if not node:
            return
        print "Clicked node %s %s" % (node.text, node.key)
        if isinstance(node, MfxTreeLeaf):
            self.updateSelection(key=node.key)
        elif isinstance(node, MfxTreeNode):
            node.expanded = not node.expanded
            self.redraw()
        return "break"
'''

if __name__ == "__main__":
    '''
    tk = Tkinter.Tk()
    if os.name == "nt":
        app = DirectoryBrowser(tk, ("c:\\", "c:\\windows"))
    else:
        app = DirectoryBrowser(tk, ("/", "/home"))
    tk.mainloop()
    '''
    pass
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#

# imports
# import os
# import traceback

# PySol imports

# Toolkit imports
# from tkutil import after, after_cancel
# from tkutil import bind, unbind_destroy, makeImage
# from tkcanvas import MfxCanvas, MfxCanvasGroup
# from tkcanvas import MfxCanvasImage, MfxCanvasRectangle

# from pysollib.settings import TITLE

# ************************************************************************
# *
# ************************************************************************

LARGE_EMBLEMS_SIZE = (38, 34)
SMALL_EMBLEMS_SIZE = (31, 21)


find_card_dialog = None


def create_find_card_dialog(parent, game, dir):
    pass
    '''
    global find_card_dialog
    try:
        find_card_dialog.wm_deiconify()
        find_card_dialog.tkraise()
    except:
        # traceback.print_exc()
        find_card_dialog = FindCardDialog(parent, game, dir)
    '''


def connect_game_find_card_dialog(game):
    pass
    '''
    try:
        find_card_dialog.connectGame(game)
    except:
        pass
    '''


def destroy_find_card_dialog():
    pass
    '''
    global find_card_dialog
    try:
        find_card_dialog.destroy()
    except:
        # traceback.print_exc()
        pass
    find_card_dialog = None
    '''


'''
'''
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#

# Toolkit imports
from pysollib.pysoltk import MfxDialog

# ************************************************************************
# *
# ************************************************************************
# not supported.


class FontsDialog(MfxDialog):
    def __init__(self, parent, title, app, **kw):
        pass
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#

from pysollib.acard import AbstractCard
from pysollib.kivy.LApp import LImage
from pysollib.kivy.LApp import LImageItem
from pysollib.kivy.tkcanvas import MfxCanvasGroup, MfxCanvasImage


class _HideableCard(AbstractCard):
    def hide(self, stack):
        if stack is self.hide_stack:
            return
        self.item.config(state="hidden")
        self.hide_stack = stack
        # print "hide:", self.id, self.item.coords()

    def unhide(self):
        if self.hide_stack is None:
            return 0
        # print "unhide:", self.id, self.item.coords()
        self.item.config(state="normal")
        self.hide_stack = None
        return 1

    # moveBy aus Basisklasse überschreiben.
    def moveBy(self, dx, dy):
        # wir verwenden direkt den float Wert.
        if dx or dy:
            self.x = self.x + dx
            self.y = self.y + dy
            self.item.move(dx, dy)


# ************************************************************************
# * New implemetation since 2.10
# *
# * We use a single CanvasImage and call CanvasImage.config() to
# * turn the card.
# * This makes turning cards a little bit slower, but dragging cards
# * around is noticeable faster as the total number of images is
# * reduced by half.
# ************************************************************************
# * Kivy Implementation
# * Wir verwenden ein BoxLayout und installieren je nach Status das
# * face oder das back Image.
# ************************************************************************


class _OneImageCard(_HideableCard):
    def __init__(self, id, deck, suit, rank, game, x=0, y=0):
        _HideableCard.__init__(self, id, deck, suit, rank, game, x=x, y=y)

        fimage = game.getCardFaceImage(deck, suit, rank)
        bimage = game.getCardBackImage(deck, suit, rank)

        self._face_image = LImage(texture=fimage.texture)
        self._back_image = LImage(texture=bimage.texture)
        # self._face_image = Image(source=fimage.source)
        # self._back_image = Image(source=bimage.source)
        self._shade_image = game.getCardShadeImage()

        aimage = LImageItem(
            pos=(x, -y), size=self._face_image.size, game=game, card=self)
        aimage.add_widget(self._back_image)
        self._active_image = aimage

        self.item = MfxCanvasImage(
            game.canvas, self.x, self.y, image=aimage, anchor="nw")
        self.shade_item = None

        # print ('card: face = %s xy=%s/%s' % (self._face_image.source, x, y))
        # print ('card: back = %s xy=%s/%s' % (self._back_image.source, x, y))
        # y = self.yy

    def _setImage(self, image):
        self._active_image.clear_widgets()
        self._active_image.add_widget(image)

    def showFace(self, unhide=1):
        # print ('card: showFace = %s' % self._face_image.source)
        if not self.face_up:
            self._setImage(image=self._face_image)
            self.tkraise(unhide)
            self.face_up = 1

    def showBack(self, unhide=1):
        # print ('card: showBack = %s' % self._back_image.source)
        if self.face_up:
            self._setImage(image=self._back_image)
            self.tkraise(unhide)
            self.face_up = 0

    def updateCardBackground(self, image):
        print('card: updateCardBackground = %s' % image.source)
        self._back_image = LImage(texture=image.texture)
        if not self.face_up:
            self._setImage(image=self._back_image)

    def setSelected(self, s, group=None):
        print('card: setselected(%s, %s)' % (s, group))
        # wird nicht bedient.
        pass

    def animatedMove(self, dx, dy, duration=0.2):
        self.item.animatedMove(dx, dy, duration)

# ************************************************************************
# * New idea since 3.00
# *
# * Hide a card by configuring the canvas image to None.
# ************************************************************************


class _OneImageCardWithHideByConfig(_OneImageCard):
    def hide(self, stack):
        if stack is self.hide_stack:
            return
        self._setImage(image=None)
        self.hide_stack = stack

    def unhide(self):
        if self.hide_stack is None:
            return 0
        if self.face_up:
            self._setImage(image=self._face_image)
        else:
            self._setImage(image=self._back_image)
        self.hide_stack = None
        return 1

    #
    # much like in _OneImageCard
    #

    def showFace(self, unhide=1):
        if not self.face_up:
            if unhide:
                self._setImage(image=self._face_image)
            self.item.tkraise()
            self.face_up = 1

    def showBack(self, unhide=1):
        if self.face_up:
            if unhide:
                self._setImage(image=self._back_image)
            self.item.tkraise()
            self.face_up = 0

    def updateCardBackground(self, image):
        self._back_image = image
        if not self.face_up and not self.hide_stack:
            self._setImage(image=image)


# ************************************************************************
# * Old implemetation prior to 2.10
# *
# * The card consists of two CanvasImages. To show the card face up,
# * the face item is placed in front of the back. To show it face
# * down, this is reversed.
# ************************************************************************


class _TwoImageCard(_HideableCard):
    # Private instance variables:
    #   __face, __back -- the canvas items making up the card
    def __init__(self, id, deck, suit, rank, game, x=0, y=0):
        _HideableCard.__init__(self, id, deck, suit, rank, game, x=x, y=y)
        self.item = MfxCanvasGroup(game.canvas)
        self.__face = MfxCanvasImage(
            game.canvas, self.x, self.y,
            image=game.getCardFaceImage(deck, suit, rank), anchor="nw")
        self.__back = MfxCanvasImage(
            game.canvas, self.x, self.y,
            image=game.getCardBackImage(deck, suit, rank), anchor="nw")
        self.__face.addtag(self.item)
        self.__back.addtag(self.item)

    def showFace(self, unhide=1):
        if not self.face_up:
            self.__face.tkraise()
            self.tkraise(unhide)
            self.face_up = 1

    def showBack(self, unhide=1):
        if self.face_up:
            self.__back.tkraise()
            self.tkraise(unhide)
            self.face_up = 0

    def updateCardBackground(self, image):
        self.__back.config(image=image)


# ************************************************************************
# * New idea since 2.90
# *
# * The card consists of two CanvasImages. Instead of raising
# * one image above the other we move the inactive image out
# * of the visible canvas.
# ************************************************************************


class _TwoImageCardWithHideItem(_HideableCard):
    # Private instance variables:
    #   __face, __back -- the canvas items making up the card
    def __init__(self, id, deck, suit, rank, game, x=0, y=0):
        _HideableCard.__init__(self, id, deck, suit, rank, game, x=x, y=y)
        self.item = MfxCanvasGroup(game.canvas)
        self.__face = MfxCanvasImage(
            game.canvas, self.x, self.y + 11000,
            image=game.getCardFaceImage(deck, suit, rank), anchor="nw")
        self.__back = MfxCanvasImage(
            game.canvas, self.x, self.y,
            image=game.getCardBackImage(deck, suit, rank), anchor="nw")
        self.__face.addtag(self.item)
        self.__back.addtag(self.item)

    def showFace(self, unhide=1):
        if not self.face_up:
            self.__back.move(0, 10000)
            # self.__face.tkraise()
            self.__face.move(0, -11000)
            self.tkraise(unhide)
            self.face_up = 1

    def showBack(self, unhide=1):
        if self.face_up:
            self.__face.move(0, 11000)
            # self.__back.tkraise()
            self.__back.move(0, -10000)
            self.tkraise(unhide)
            self.face_up = 0

    def updateCardBackground(self, image):
        self.__back.config(image=image)


# choose the implementation
# Card = _TwoImageCardWithHideItem
# Card = _TwoImageCard
# Card = _OneImageCardWithHideByConfig
Card = _OneImageCard


'''end of file'''
import logging
try:
    import jnius
except ImportError:
    jnius = None

# link address of related support library:
# https://maven.google.com/com/android/support/support-v4/24.1.1/support-v4-24.1.1.aar

# inspired by stackoverflow.com/questions/47510030/
# as functools (reduce,partial,map) do not seem to work in python3 on android,
# implemented in a classic functional way.
# LB190927.
# wait loop removed. (Implement it in external code if needed.)
# LB191011.


class AndroidPerms(object):
    def __init__(self):
        if jnius is None:
            return
        self.PythonActivity = jnius.autoclass(
            'org.kivy.android.PythonActivity')
        self.Compat = jnius.autoclass(
            'android.support.v4.content.ContextCompat')
        self.currentActivity = jnius.cast(
            'android.app.Activity', self.PythonActivity.mActivity)

    def getPerm(self, permission):
        if jnius is None:
            return True
        p = self.Compat.checkSelfPermission(self.currentActivity, permission)
        return p == 0

    # check actual permissions
    def getPerms(self, permissions):
        if jnius is None:
            return True
        haveperms = True
        for perm in permissions:
            haveperms = haveperms and self.getPerm(perm)
        return haveperms

    # invoke the permissions dialog
    def requestPerms(self, permissions):
        if jnius is None:
            return True
        logging.info("androidperms: invoke permission dialog")
        self.currentActivity.requestPermissions(permissions, 0)
        return


def getStoragePerm():
    ap = AndroidPerms()
    return ap.getPerms(
        ["android.permission.WRITE_EXTERNAL_STORAGE"])


def requestStoragePerm():
    ap = AndroidPerms()
    # ap.requestPerms(
    #    ["android.permission.READ_EXTERNAL_STORAGE","android.permission.WRITE_EXTERNAL_STORAGE"])
    ap.requestPerms(
        ["android.permission.WRITE_EXTERNAL_STORAGE"])
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#

from kivy.uix.popup import Popup

# ************************************************************************
# * a simple progress bar
# ************************************************************************
# not really supportable with kivy. dummy def.


class PysolProgressBar(Popup):
    def __init__(self, app, parent, title=None, images=None, color="blue",
                 width=300, height=25, show_text=1, norm=1):
        self.percent = 100
        return

    def update(self, **kw):
        return

    def destroy(self):
        return

    def reset(self, percent=0):
        return
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
# Copyright (C) 2017 LB
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#
# Note:
# Many classes or some methods of classes are dead code resulting from the tk
# implementation. If executed it would throw exceptions.
#
# Kivy Implementation used: MfxScrolledCanvas, MfxDialog (partly)

from __future__ import division

import logging

from kivy.clock import Clock
from kivy.uix.anchorlayout import AnchorLayout
from kivy.uix.boxlayout import BoxLayout
from kivy.uix.label import Label

from pysollib.kivy.LApp import LBoxLayout
from pysollib.kivy.LApp import LImage
from pysollib.kivy.LApp import LScrollView
from pysollib.kivy.LApp import LTopLevel
from pysollib.kivy.tkcanvas import MfxCanvas
from pysollib.kivy.tkutil import bind, unbind_destroy
from pysollib.kivy.tkutil import makeToplevel
from pysollib.mfxutil import KwStruct, kwdefault
from pysollib.mygettext import _
from pysollib.settings import WIN_SYSTEM

# ************************************************************************
# * abstract base class for the dialogs in this module
# ************************************************************************


class MfxDialog:  # ex. _ToplevelDialog
    img = {}
    button_img = {}

    def __init__(self, parent, title="", resizable=False, default=-1):
        self.parent = parent
        self.status = 0
        self.button = default
        self.timer = None
        self.buttons = []
        self.accel_keys = {}
        self.top = makeToplevel(parent, title=title)

    def wmDeleteWindow(self, *event):
        self.status = 1
        raise SystemExit
        # return EVENT_HANDLED

    def mCancel(self, *event):
        self.status = 1
        raise SystemExit

    def mTimeout(self, *event):
        self.status = 2
        raise SystemExit

    def mDone(self, button):
        self.button = button
        raise SystemExit

    def altKeyEvent(self, event):
        key = event.char
        # key = unicode(key, 'utf-8')
        key = key.lower()
        button = self.accel_keys.get(key)
        if button is not None:
            self.mDone(button)

    def initKw(self, kw):
        kw = KwStruct(kw,
                      timeout=0, resizable=False,
                      text="", justify="center",
                      strings=(_("&OK"), ),
                      default=0,
                      width=0,
                      padx=20, pady=20,
                      bitmap=None, bitmap_side="left",
                      bitmap_padx=10, bitmap_pady=20,
                      image=None, image_side="left",
                      image_padx=10, image_pady=20,
                      )
        # default to separator if more than one button
        sep = len(kw.strings) > 1
        kwdefault(kw.__dict__, separator=sep)
        return kw

    def createFrames(self, kw):
        a = LBoxLayout(orientation="vertical")
        b = LBoxLayout(orientation="vertical")
        return a, b


# ************************************************************************
# Needed Labels.

class MfxSimpleEntry:
    pass


class MfxToolTip:
    pass

# ************************************************************************
# * replacement for the tk_dialog script
# ************************************************************************
# Kivy implementation helpers.


class FLabel(Label):
    def __init__(self, **kw):
        super(FLabel, self).__init__(**kw)

        self.bind(size=self.onUpdate)
        self.bind(pos=self.onUpdate)
        self.bind(text=self.onUpdate)

    def onUpdate(self, instance, size):
        self.size_hint_y = None
        self.text_size = self.width, None
        self.texture_update()
        self.height = self.texture_size[1]


class FText(LScrollView):
    def __init__(self, **kw):
        super(FText, self).__init__(**kw)

        self.label = FLabel(**kw)
        self.add_widget(self.label)


class MfxMessageDialog(MfxDialog):
    def __init__(self, parent, title, **kw):
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)

        if (kw.image):
            image = LImage(texture=kw.image.texture, size_hint=(1, 1))
            self.top.add_widget(image)

        label = FText(text=kw.text, halign='center')
        self.top.add_widget(label)

        # LB
        # nicht automatisch ein neues spiel laden.
        if (title == _("Game won")):
            self.status = 1
            # self.button = 0
        if (title == _("Game finished")):
            self.status = 1
            # self.button =

# ************************************************************************
# *
# ************************************************************************


class MfxExceptionDialog(MfxMessageDialog):
    def __init__(self, parent, ex, title=_("Error"), **kw):
        kw = KwStruct(kw, bitmap="error")
        text = kw.get("text", "")
        if not text.endswith("\n"):
            text = text + "\n"
        text = text + "\n"
        if isinstance(ex, EnvironmentError) and ex.filename is not None:
            t = "[Errno %s] %s:\n%s" % (
                ex.errno, ex.strerror, repr(ex.filename))
        else:
            t = str(ex)
        kw.text = text + t
        MfxMessageDialog.__init__(self, parent, title, **kw.getKw())


# ************************************************************************
# *
# ************************************************************************

class PysolAboutDialog(object):

    # Die einzige Instanz.
    AboutDialog = None

    def onClick(self, event):
        print('LTopLevel: onClick')
        PysolAboutDialog.AboutDialog.parent.popWork('AboutDialog')
        PysolAboutDialog.AboutDialog.running = False

    def __init__(self, app, parent, title, **kw):
        logging.info('PysolAboutDialog:')
        super(PysolAboutDialog, self).__init__()

        self._url = kw['url']
        logging.info('PysolAboutDialog: txt=%s' % title)

        text = kw['text']
        text = text + '\n' + self._url
        logging.info('PysolAboutDialog: txt=%s' % text)

        text = text + '\n\n' + 'Adaptation to Kivy/Android\n' + \
            ' Copyright (C) (2016-19) LB'

        self.parent = parent
        self.app = app
        self.window = None
        self.running = False
        self.status = 1  # -> von help.py so benötigt
        self.button = 0  # -> von help.py so benötigt

        # bestehenden Dialog rezyklieren.

        logging.info('PysolAboutDialog: 1')
        onlyone = PysolAboutDialog.AboutDialog
        if (onlyone and onlyone.running):
            return
        if (onlyone):
            onlyone.parent.pushWork('AboutDialog', onlyone.window)
            onlyone.running = True
            return

        # neuen Dialog aufbauen.

        window = LTopLevel(parent, title, size_hint=(1.0, 1.0))
        window.titleline.bind(on_press=self.onClick)
        self.parent.pushWork('AboutDialog', window)
        self.window = window
        self.running = True
        PysolAboutDialog.AboutDialog = self

        if kw['image']:
            image = LImage(texture=kw['image'].texture)
            image.size_hint = (1, 0.8)
            al = AnchorLayout()
            al.add_widget(image)
            al.size_hint = (1, 0.3)
            window.content.add_widget(al)

        label = FText(text=text, halign='center', size_hint=(1, 1))
        window.content.add_widget(label)


# ************************************************************************
# * a simple tooltip
# ************************************************************************
# ToolTip - not used in Kivy - would not run without adaptations.


'''
class MfxTooltip:
    last_leave_time = 0

    def __init__(self, widget):
        # private vars
        self.widget = widget
        self.text = None
        self.timer = None
        self.cancel_timer = None
        self.tooltip = None
        self.label = None
        self.bindings = []
        self.bindings.append(self.widget.bind("<Enter>", self._enter))
        self.bindings.append(self.widget.bind("<Leave>", self._leave))
        self.bindings.append(self.widget.bind("<ButtonPress>", self._leave))
        # user overrideable settings
        self.timeout = 800                    # milliseconds
        self.cancel_timeout = 5000
        self.leave_timeout = 400
        self.relief = 'solid'
        self.justify = 'left'
        self.fg = "#000000"
        self.bg = "#ffffe0"
        self.xoffset = 0
        self.yoffset = 4

    def setText(self, text):
        self.text = text

    def _unbind(self):
        if self.bindings and self.widget:
            self.widget.unbind("<Enter>", self.bindings[0])
            self.widget.unbind("<Leave>", self.bindings[1])
            self.widget.unbind("<ButtonPress>", self.bindings[2])
            self.bindings = []

    def destroy(self):
        self._unbind()
        self._leave()

    def _enter(self, *event):
        after_cancel(self.timer)
        after_cancel(self.cancel_timer)
        self.cancel_timer = None
        timediff = time.time() - MfxTooltip.last_leave_time
        if timediff < self.leave_timeout / 1000.:
            self._showTip()
        else:
            self.timer = after(self.widget, self.timeout, self._showTip)

    def _leave(self, *event):
        after_cancel(self.timer)
        after_cancel(self.cancel_timer)
        self.timer = self.cancel_timer = None
        if self.tooltip:
            self.label.destroy()
            destruct(self.label)
            self.label = None
            self.tooltip.destroy()
            destruct(self.tooltip)
            self.tooltip = None
            MfxTooltip.last_leave_time = time.time()

    def _showTip(self):
        self.timer = None
        if self.tooltip or not self.text:
            return
#         if isinstance(self.widget, (Tkinter.Button, Tkinter.Checkbutton)):
#             if self.widget["state"] == 'disabled':
#                 return
        # x = self.widget.winfo_rootx()
        x = self.widget.winfo_pointerx()
        y = self.widget.winfo_rooty() + self.widget.winfo_height()
        x += self.xoffset
        y += self.yoffset
        self.tooltip = Tkinter.Toplevel()
        self.tooltip.wm_iconify()
        self.tooltip.wm_overrideredirect(1)
        self.tooltip.wm_protocol("WM_DELETE_WINDOW", self.destroy)
        self.label = Tkinter.Label(self.tooltip, text=self.text,
                                   relief=self.relief, justify=self.justify,
                                   fg=self.fg, bg=self.bg, bd=1, takefocus=0)
        self.label.pack(ipadx=1, ipady=1)
        self.tooltip.wm_geometry("%+d%+d" % (x, y))
        self.tooltip.wm_deiconify()
        self.cancel_timer = after(
            self.widget, self.cancel_timeout, self._leave)
        # self.tooltip.tkraise()
'''

# ************************************************************************
# * A canvas widget with scrollbars and some useful bindings.
# ************************************************************************
# Kivy implementation of MfxScrolledCanvas.


class LScrollFrame(BoxLayout):
    def __init__(self, **kw):
        super(LScrollFrame, self).__init__(orientation="vertical", **kw)


class MfxScrolledCanvas(object):
    def __init__(self, parent, hbar=True, vbar=True, propagate=False, **kw):
        kwdefault(kw, highlightthickness=0, bd=1, relief='sunken')
        self.parent = parent

        # workarea = parent.getWork()
        print('MfxScrolledCanvas: parent=%s' % (parent))

        super(MfxScrolledCanvas, self).__init__()
        self.createFrame(kw)
        self.canvas = None
        # do_scroll_x = None
        # do_scroll_y = None
        # self.hbar = None
        # self.vbar = None
        self.hbar_show = False
        self.vbar_show = False
        self.createCanvas(kw)
        # self.frame.grid_rowconfigure(0, weight=1)
        # self.frame.grid_columnconfigure(0, weight=1)
        # self.frame.grid_propagate(propagate)
        if hbar:
            self.createHbar()
            self.bindHbar()
        if vbar:
            self.createVbar()
            self.bindVbar()
        # self.canvas.focus_set()

    def destroy(self):
        logging.info('MfxRoot: destroy')
        self.unbind_all()
        self.canvas.destroy()
        self.frame.destroy()

    def pack(self, **kw):
        pass
        # self.frame.pack(**kw)

    def grid(self, **kw):
        pass
        # self.frame.grid(**kw)

    #
    #
    #

    def setTile(self, app, i, force=False):
        logging.info('MfxRoot: setTitle app=%s' % app)

        tile = app.tabletile_manager.get(i)

        print('setTile: (tile) %s, index=%s' % (tile, i))

        if tile is None or tile.error:
            return False

        # print i, tile
        if i == 0:
            assert tile.color
            assert tile.filename is None
        else:
            assert tile.color is None
            assert tile.filename
            assert tile.basename
        if not force:
            if (i == app.tabletile_index and
                    tile.color == app.opt.colors['table']):
                return False
        #
        print('setTile2: %s' % (tile.filename))

        if not self.canvas.setTile(
                tile.filename, tile.stretch, tile.save_aspect):
            tile.error = True
            return False

        print(
            'MfxScrolledCanvas: tile.color, app.top_bg %s, %s'
            % (tile.color, app.top_bg))
        if i == 0:
            if force:
                tile.color = app.opt.colors['table']
            self.canvas.config(bg=tile.color)
        else:
            if type(app.top_bg) is str:
                self.canvas.config(bg=app.top_bg)

        self.canvas.setTextColor(app.opt.colors['text'])
        return True
    #
    #
    #

    def deleteAllItems(self):
        logging.info('MfxRoot: deleteAllItems')
        # self.parent.getWork()
        # self.parent.popWork()
        # self.frame.clear_widgets()
        self.canvas.clear_widgets()

    def update_idletasks(self):
        logging.info('MfxRoot: update_idletasks')
        Clock.schedule_once(lambda x: self.canvas.canvas.ask_update)

    def unbind_all(self):
        unbind_destroy(self.hbar)
        unbind_destroy(self.vbar)
        unbind_destroy(self.canvas)
        unbind_destroy(self.frame)

    def createFrame(self, kw):
        logging.info('MfxRoot: createFrame')
        # width = kw.get("width")
        # height = kw.get("height")
        print('createFrame: kw=%s' % kw)
        # self.frame = Tkinter.Frame(self.parent, width=width, height=height)

        self.frame = LScrollFrame(size_hint=(1, 1))

        print("createFrame: self.parent %s" % str(self.frame))

    def createCanvas(self, kw):
        logging.info('MfxRoot: createCanvas')
        # bd = kw['bd']
        kw['bd'] = 0
        # relief = kw['relief']
        del kw['relief']
        # frame = Tkinter.Frame(self.frame, bd=bd, relief=relief)
        # frame.grid(row=0, column=0, sticky="news")
        '''
        self.canvas = MfxCanvas(self.frame, **kw)
        self.frame.add_widget(self.canvas)
        self.parent.pushWork(self.frame)
        '''
        self.canvas = MfxCanvas(self.parent, **kw)
        self.frame = self.canvas
        self.parent.pushWork('playground', self.frame)
        ''
        # self.canvas.pack(expand=True, fill='both')

    def createHbar(self):
        pass
        '''
        self.hbar = Tkinter.Scrollbar(self.frame, takefocus=0,
                                      orient="horizontal")
        self.canvas["xscrollcommand"] = self._setHbar
        self.hbar["command"] = self.canvas.xview
        self.hbar.grid(row=1, column=0, sticky="we")
        self.hbar.grid_remove()
        '''

    def createVbar(self):
        pass
        '''
        self.vbar = Tkinter.Scrollbar(self.frame, takefocus=0)
        self.canvas["yscrollcommand"] = self._setVbar
        self.vbar["command"] = self.canvas.yview
        self.vbar.grid(row=0, column=1, sticky="ns")
        self.vbar.grid_remove()
        '''

    def bindHbar(self, w=None):
        if w is None:
            w = self.canvas
        bind(w, "<KeyPress-Left>", self.unit_left)
        bind(w, "<KeyPress-Right>", self.unit_right)

    def bindVbar(self, w=None):
        if w is None:
            w = self.canvas
        bind(w, "<KeyPress-Prior>", self.page_up)
        bind(w, "<KeyPress-Next>", self.page_down)
        bind(w, "<KeyPress-Up>", self.unit_up)
        bind(w, "<KeyPress-Down>", self.unit_down)
        bind(w, "<KeyPress-Begin>", self.scroll_top)
        bind(w, "<KeyPress-Home>", self.scroll_top)
        bind(w, "<KeyPress-End>", self.scroll_bottom)
        # mousewheel support
        if WIN_SYSTEM == 'x11':
            bind(w, '<4>', self.mouse_wheel_up)
            bind(w, '<5>', self.mouse_wheel_down)
        # don't work on Linux
        # bind(w, '<MouseWheel>', self.mouse_wheel)

    def mouse_wheel(self, *args):
        pass

    def _setHbar(self, first, last):
        if self.canvas.busy:
            return
        sb = self.hbar
        if float(first) <= 0 and float(last) >= 1:
            sb.grid_remove()
            self.hbar_show = False
        else:
            if self.canvas.winfo_ismapped():
                sb.grid()
                self.hbar_show = True
        sb.set(first, last)

    def _setVbar(self, first, last):
        if self.canvas.busy:
            return
        sb = self.vbar
        if float(first) <= 0 and float(last) >= 1:
            sb.grid_remove()
            self.vbar_show = False
        else:
            if self.canvas.winfo_ismapped():
                sb.grid()
                self.vbar_show = True
        sb.set(first, last)

    def _xview(self, *args):
        if self.hbar_show:
            self.canvas.xview(*args)
        return 'break'

    def _yview(self, *args):
        if self.vbar_show:
            self.canvas.yview(*args)
        return 'break'

    def page_up(self, *event):
        return self._yview('scroll', -1, 'page')

    def page_down(self, *event):
        return self._yview('scroll', 1, 'page')

    def unit_up(self, *event):
        return self._yview('scroll', -1, 'unit')

    def unit_down(self, *event):
        return self._yview('scroll', 1, 'unit')

    def mouse_wheel_up(self, *event):
        return self._yview('scroll', -5, 'unit')

    def mouse_wheel_down(self, *event):
        return self._yview('scroll', 5, 'unit')

    def page_left(self, *event):
        return self._xview('scroll', -1, 'page')

    def page_right(self, *event):
        return self._xview('scroll', 1, 'page')

    def unit_left(self, *event):
        return self._xview('scroll', -1, 'unit')

    def unit_right(self, *event):
        return self._xview('scroll', 1, 'unit')

    def scroll_top(self, *event):
        return self._yview('moveto', 0)

    def scroll_bottom(self, *event):
        return self._yview('moveto', 1)


# ************************************************************************
# *
# ************************************************************************
# not used witch kivy. would not nun as it refers TkInter.
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#


# PySol imports
# from pysollib.mfxutil import KwStruct
# from pysollib.gamedb import GI

# Toolkit imports
from pysollib.pysoltk import MfxDialog

__all__ = ['GameInfoDialog']

# ************************************************************************
# *
# ************************************************************************


class GameInfoDialog(MfxDialog):
    def __init__(self, parent, title, app, **kw):
        pass


'''
'''
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#

# Toolkit imports
from pysollib.pysoltk import MfxDialog

# ************************************************************************
# *
# ************************************************************************


class EditTextDialog(MfxDialog):

    def __init__(self, parent, title, text, **kw):
        # not used with kivy.
        pass

    def initKw(self, kw):
        pass

    def destroy(self):
        pass

    def wmDeleteWindow(self, *event):   # ignore
        pass

    def mCancel(self, *event):          # ignore <Escape>
        pass


'''end of file'''
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#

import logging

from kivy.cache import Cache

TclError = 0


def MfxRoot(**kw):
    mainWindow = Cache.get('LAppCache', 'mainWindow')
    logging.info('tkwrap: top = %s' % str(mainWindow))
    return mainWindow
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#

from pysollib.mfxutil import kwdefault
from pysollib.mygettext import _
from pysollib.pysoltk import MfxDialog

# ************************************************************************
# * Dialog
# ************************************************************************
# not used with kivy. dummy def.


class SelectCardsetDialogWithPreview(MfxDialog):
    _cardset_store = None

    def __init__(self, parent, title, app, manager, key=None, **kw):
        if key is None:
            key = 1
        self.status = -1
        self.key = key
        self.app = app
        self.manager = manager
        return

    def getSelected(self):
        return None

    def showSelected(self, w):
        pass

    def updatePreview(self, key):
        pass

    def initKw(self, kw):
        kwdefault(kw,
                  strings=(_("&Load"), _("&Cancel"), _("&Info..."), ),
                  default=1,
                  resizable=1,
                  padx=10, pady=10,
                  width=600, height=400,
                  )
        return MfxDialog.initKw(self, kw)

    def createInfo(self):
        pass

    def done(self, button):
        pass
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ************************************************************************
# * constants
# ************************************************************************

EVENT_HANDLED = "break"
EVENT_PROPAGATE = None

CURSOR_DRAG = "hand1"
CURSOR_WATCH = "watch"
CURSOR_DOWN_ARROW = 'sb_down_arrow'

ANCHOR_CENTER = 'center'
ANCHOR_N = 'n'
ANCHOR_NW = 'nw'
ANCHOR_NE = 'ne'
ANCHOR_S = 's'
ANCHOR_SW = 'sw'
ANCHOR_SE = 'se'
ANCHOR_W = 'w'
ANCHOR_E = 'e'
'''
COMPOUNDS = (
    # (Tkinter.BOTTOM,  'bottom'),
    # (Tkinter.CENTER,  'center'),
    # (Tkinter.RIGHT,    'right'),
    (Tkinter.NONE,   n_('Icons only')),
    (Tkinter.TOP,    n_('Text below icons')),
    (Tkinter.LEFT,   n_('Text beside icons')),
    ('text',         n_('Text only')),
    )
'''
TOOLBAR_BUTTONS = (
    "new",
    "restart",
    "open",
    "save",
    "undo",
    "redo",
    "autodrop",
    "shuffle",
    "pause",
    "statistics",
    "rules",
    "quit",
    "player",
)
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#

# kivy implementation:
# most of the code will not be used, but some important function have been
# emulated.

from __future__ import division

import logging
import os
from array import array

from kivy.clock import Clock
from kivy.core.image import Image as CoreImage
from kivy.core.text import Label as CoreLabel
from kivy.graphics.texture import Texture

from pysollib.kivy.LApp import LImage
from pysollib.kivy.LApp import LTopLevel0

# ************************************************************************
# * window manager util
# ************************************************************************


def wm_withdraw(window):
    window.wm_withdraw()


def wm_map(window, maximized=0):
    return


# ************************************************************************
# * window util
# ************************************************************************


def setTransient(window, parent, relx=None, rely=None, expose=1):
    # Make an existing toplevel window transient for a parent.
    #
    # The window must exist but should not yet have been placed; in
    # other words, this should be called after creating all the
    # subwidget but before letting the user interact.

    # not used in kivy (highly tk specific).
    return


def makeToplevel(parent, title=None):
    print('tkutil: makeTopLevel')

    # Create a Toplevel window.
    #
    window = LTopLevel0(parent, title)
    # window = LTopLevelPopup(parent, title)
    return window.content


def make_help_toplevel(app, title=None):
    # Create an independent Toplevel window.

    window = app.top

    # from pysollib.winsystems import init_root_window
    # window = Tkinter.Tk(className=TITLE)
    # init_root_window(window, app)
    return window


# ************************************************************************
# * bind wrapper - Tkinter doesn't properly delete all bindings
# ************************************************************************

__mfx_bindings = {}
__mfx_wm_protocols = ("WM_DELETE_WINDOW", "WM_TAKE_FOCUS", "WM_SAVE_YOURSELF")


def bind(widget, sequence, func, add=None):

    # logging.info('tkutil: bind  %s %s %s %s '
    #              % (widget, sequence, func, add))

    # logging.info('tkutil: bind canvas = ' % str(widget.canvas))

    if hasattr(widget, 'bindings'):
        # logging.info('tkutil: bind  %s %s %s %s '
        #              % (sequence, widget, func, add))
        widget.bindings[sequence] = func
    else:
        # logging.info('tkutil: bind failed %s %s' % (sequence, widget))
        pass

    if (sequence == '<KeyPress-Left>'):
        return
    if (sequence == '<KeyPress-Right>'):
        return
    if (sequence == '<KeyPress-Prior>'):
        return
    if (sequence == '<KeyPress-Next>'):
        return
    if (sequence == '<KeyPress-Up>'):
        return
    if (sequence == '<KeyPress-Down>'):
        return
    if (sequence == '<KeyPress-Begin>'):
        return
    if (sequence == '<KeyPress-Home>'):
        return
    if (sequence == '<KeyPress-End>'):
        return
    if (sequence == '<KeyPress-Down>'):
        return

    if (sequence == '<4>'):
        return
    if (sequence == '<5>'):
        return

    if (sequence == '<1>'):
        return
    if (sequence == '<Motion>'):
        return
    if (sequence == '<ButtonRelease-1>'):
        return
    if (sequence == '<Control-1>'):
        return
    if (sequence == '<Shift-1>'):
        return
    if (sequence == '<Double-1>'):
        return
    if (sequence == '<3>'):
        return
    if (sequence == '<2>'):
        return
    if (sequence == '<Control-3>'):
        return
    if (sequence == '<Enter>'):
        return
    if (sequence == '<Leave>'):
        return
    if (sequence == '<Unmap>'):
        return
    if (sequence == '<Configure>'):
        return
    pass


def unbind_destroy(widget):
    # logging.info('tkutil: unbind  %s' % (widget))
    widget.bindings = []
    pass


# ************************************************************************
# * timer wrapper - Tkinter doesn't properly delete all commands
# ************************************************************************


def after(widget, ms, func, *args):
    print('tkutil: after(%s, %s, %s, %s)' % (widget, ms, func, args))
    if (ms == 'idle'):
        print('demo use')
        Clock.schedule_once(lambda dt: func(), 1.0)
    elif (isinstance(ms, int)):
        # print('ms: play timer (accounting)')
        # Clock.schedule_once(lambda dt: func(), float(ms)/1000.0)
        # makes not sense, drains battery!
        pass


def after_idle(widget, func, *args):
    print('tkutil: after_idle()')
    return after(widget, "idle", func, *args)


def after_cancel(t):
    print('tkutil: after_cancel()')
    pass


# ************************************************************************
# * image handling
# ************************************************************************


def makeImage(file=None, data=None, dither=None, alpha=None):
    kw = {}
    if data is None:
        assert file is not None
        kw["source"] = file
        # print('makeImage: source = %s' % file)
        # if (file=='/home/lb/PRG/Python/Kivy/pysolfc/data/images/redeal.gif'):
        #    y = self.yy
    else:
        assert data is not None
        kw["texture"] = data
        # ob das geht ?? - kommt das vor ?
        # yy = self.yy
    '''
    if 'source' in kw:
        logging.info ("makeImage: " + kw["source"])
    if 'texture' in kw:
        logging.info ("makeImage: " + str(kw["texture"]))
    '''

    return LImage(**kw)


loadImage = makeImage


def copyImage(image, x, y, width, height):

    # return Image(source=image.source)
    # return Image(texture=image.texture)
    return image


def fillTexture(texture, fill, outline=None, owidth=1):

    # logging.info("fillImage: t=%s, f=%s o=%s, w=%s" %
    #              (texture, fill, outline, owidth))
    # O.K. Kivy

    if not fill and not outline:
        return

    width = texture.width
    height = texture.height

    ox = round(owidth)
    ow = int(ox)  # muss int sein!
    if width <= 2 * ow or height <= 2 * ow:
        fill = fill or outline
        outline = None

    if not fill:
        fi0 = 0
        fi1 = 0
        fi2 = 0
        fi3 = 0
    else:
        # wir erwarten Werte als '#xxxxxx' (color Werte in Tk notation)
        # (optional mit transparenz)
        if (fill[0] == '#'):
            fill = fill[1:]
        fi0 = int(fill[0:2], 16)
        fi1 = int(fill[2:4], 16)
        fi2 = int(fill[4:6], 16)
        fi3 = 255
        if len(fill) >= 8:
            fi3 = int(fill[6:8], 16)

    if not outline:
        f = (fi0, fi1, fi2, fi3) * width
        f = (f, ) * height
        assert len(f) == height
        f = sum(f, ())
        assert len(f) == height * width * 4
        arr = array('B', f)
        texture.blit_buffer(arr, colorfmt='rgba', bufferfmt='ubyte')
    else:
        if (outline[0] == '#'):
            outline = outline[1:]
        ou0 = int(outline[0:2], 16)
        ou1 = int(outline[2:4], 16)
        ou2 = int(outline[4:6], 16)
        ou3 = 255
        if len(outline) >= 8:
            ou3 = int(outline[6:8], 16)

        l1 = (
            ou0,
            ou1,
            ou2,
            ou3,
        ) * width
        l2 = (ou0, ou1, ou2, ou3, ) * ow + (fi0, fi1, fi2, fi3, ) * \
            (width - 2 * ow) + (ou0, ou1, ou2, ou3, ) * ow
        f = (l1, ) * ow + (l2, ) * (height - 2 * ow) + (l1, ) * ow
        assert len(f) == height
        f = sum(f, ())
        assert len(f) == height * width * 4
        arr = array('B', f)
        texture.blit_buffer(arr, colorfmt='rgba', bufferfmt='ubyte')


def createImage(width, height, fill, outline=None, outwidth=1):

    logging.info("createImage: w=%s, h=%s, f=%s, o=%s, ow=%s" %
                 (width, height, fill, outline, outwidth))

    # test stellungen:
    # if (fill==None):
    #   fill = '#00cc00'
    # if (outline==None):
    #   outline = '#ff00ff'

    # if (fill is None and (outline is None or outline == '')):
    #     outline = '#fff000'
    #     outwidth = 1

    texture = Texture.create(size=(width, height), colorfmt='rgba')
    fillTexture(texture, fill, outline, outwidth)
    image = LImage(texture=texture)
    # logging.info("createImage: LImage create %s" % image)
    return image


def shadowImage(image, color='#3896f8', factor=0.3):

    logging.info("shadowImage: ")
    # TBD.
    return None
    # Kivy nicht benötigt. aber - was tut das ?
    # wurde aufgerufen, als der erste König auf die Foundation
    # gezogen wurde. (möglicherweise eine Gewonnen! - Markierung).


def markImage(image):
    logging.info("markImage: ")
    return None


def _createImageMask(texture, color):

    col = 0
    if (color == 'black'):
        col = 0
    if (color == 'white'):
        col = 255

    g = texture.pixels
    arr = array('B', g)

    for mx in range(int(len(arr) / 4)):
        m = 4 * mx
        if arr[m + 3] < 128:
            arr[m + 3] = 0
            arr[m] = arr[m + 1] = arr[m + 2] = 0
        else:
            arr[m + 3] = 32
            arr[m] = arr[m + 1] = arr[m + 2] = col

    mask = Texture.create(size=texture.size, colorfmt='rgba')
    mask.blit_buffer(arr, colorfmt='rgba', bufferfmt='ubyte')
    return mask


def _scaleTextureToSize(texture, size):

    width = size[0]
    height = size[1]

    g = texture.pixels
    ag = array('B', g)
    gw, gh = texture.size

    # print('size:',width,height)
    # print('texture size:',gw,gh)

    bb = array('B', [0 for x in range(width * height * 4)])
    # print ('bb length: ',len(bb))
    # print ('gg length: ',gw*gh*4)

    scalex = width / gw
    scaley = height / gh

    # scale, x und y offset bestimmen.

    scale = scaley
    if (scalex < scaley):
        scale = scalex

    offx = (width - gw * scale) / 2
    offy = (height - gh * scale) / 2

    # print ('scale: ',scalex,'/',scaley,' -> ',scale)
    # print ('offs: ',offx,'/',offy)

    for bi in range(height):
        bline = bi * width
        if (bi >= offy) and (bi < (height - offy)):
            # transfer
            ai = gh - int((bi - offy) / scale) - 1
            aline = ai * gw
            for bk in range(width):
                bpos = (bline + bk) * 4
                if (bk >= offx) and (bk < (width - offx)):
                    # transfer
                    ak = int((bk - offx) / scale)
                    apos = (aline + ak) * 4
                    bb[bpos] = ag[apos]
                    bb[bpos + 1] = ag[apos + 1]
                    bb[bpos + 2] = ag[apos + 2]
                    bb[bpos + 3] = ag[apos + 3]
                else:
                    # transparent
                    bb[bpos + 3] = 0
        else:
            # transparent
            for bk in range(width):
                bb[(bline + bk) * 4 + 3] = 0

    stext = Texture.create(size=(width, height), colorfmt='rgba')
    stext.blit_buffer(bb, colorfmt='rgba', bufferfmt='ubyte')
    return stext


def _pasteTextureTo(texture, totexture):

    g = texture.pixels
    ag = array('B', g)
    gw, gh = texture.size

    t = totexture.pixels
    at = array('B', t)
    tw, th = totexture.size

    if (tw != gw) or (th != gh):
        return

    for i in range(int(len(ag) / 4)):
        i4 = i * 4
        if ag[i4 + 3] > 128:
            at[i4] = ag[i4]
            at[i4 + 1] = ag[i4 + 1]
            at[i4 + 2] = ag[i4 + 2]
            at[i4 + 3] = ag[i4 + 3]

    stext = Texture.create(size=(tw, th), colorfmt='rgba')
    stext.blit_buffer(at, colorfmt='rgba', bufferfmt='ubyte')
    return stext


def createBottom(image, color='white', backfile=None):

    backfilebase = None
    if backfile is not None:
        backfilebase = os.path.basename(backfile)

    logging.info("createBottom: %s | %s" % (color, backfilebase))
    # print('createBottom:',image)

    # th = 1                              # thickness
    # size = (w - th * 2, h - th * 2)
    # original: zeichnet noch eine outline um die karte - können wir nicht.

    tmp0 = _createImageMask(image.texture, color)
    if backfile:
        tmp1 = CoreImage(backfile)
        txtre = _scaleTextureToSize(tmp1.texture, image.texture.size)
        tmp = _pasteTextureTo(txtre, tmp0)
    else:
        tmp = tmp0

    img = LImage(texture=tmp)
    img.size[0] = image.getWidth()
    img.size[1] = image.getHeight()
    return img
    '''
    im = image._pil_image
    th = 1                              # thickness
    sh = Image.new('RGBA', im.size, color)
    out = Image.composite(sh, im, im)
    w, h = im.size
    size = (w - th * 2, h - th * 2)
    tmp = Image.new('RGBA', size, color)
    tmp.putalpha(60)
    mask = out.resize(size, Image.ANTIALIAS)
    out.paste(tmp, (th, th), mask)
    if backfile:
        back = Image.open(backfile).convert('RGBA')
        w0, h0 = back.size
        w1, h1 = im.size
        a = min(float(w1) / w0, float(h1) / h0)
        a = a * 0.9
        w0, h0 = int(w0 * a), int(h0 * a)
        back = back.resize((w0, h0), Image.ANTIALIAS)
        x, y = (w1 - w0) / 2, (h1 - h0) / 2
        out.paste(back, (x, y), back)
    return PIL_Image(image=out)
    '''


# ************************************************************************
# * font utils
# ************************************************************************


def get_text_width(text, font, root=None):

    logging.info("get_text_width: %s  %s" % (text, font))

    label = CoreLabel()
    label.text = text
    label.refresh()
    return label.content_width
    # return Font(root=root, font=font).measure(text)
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
# Copyright (C) 2017 LB
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#

from __future__ import division

import logging

from kivy.clock import Clock
from kivy.graphics import Color
from kivy.graphics import Rectangle
from kivy.uix.anchorlayout import AnchorLayout
from kivy.uix.widget import Widget

from pysollib.kivy.LApp import LAnimationManager
from pysollib.kivy.LApp import LColorToKivy
from pysollib.kivy.LApp import LImage
from pysollib.kivy.LApp import LImage as Image
from pysollib.kivy.LApp import LImageItem
from pysollib.kivy.LApp import LLine
from pysollib.kivy.LApp import LRectangle
from pysollib.kivy.LApp import LText

# ************************************************************************
# * canvas items helpers
# ************************************************************************


def addAnchorOffset(pos, anchor, size):
    # print ('MfxCanvas: anchor=%s' % (anchor))
    x = pos[0]
    y = pos[1]
    xa = 0
    ya = 0
    if anchor == "n":
        ya = -1
    elif anchor == "w":
        xa = -1
    elif anchor == "s":
        ya = 1
    elif anchor == "e":
        xa = 1
    elif anchor == "ne":
        ya = -1
        xa = 1
    elif anchor == "nw":
        ya = -1
        xa = -1
    elif anchor == "se":
        ya = 1
        xa = 1
    elif anchor == "sw":
        ya = 1
        xa = -1

    if xa == 0:
        x = x - size[0] / 2.0
    elif xa == 1:
        x = x - size[0]
    if ya == 0:
        y = y - size[1] / 2.0
    elif ya == 1:
        y = y - size[1]
    return (x, y)


def subAnchorOffset(pos, anchor, size):
    # print ('MfxCanvas: anchor=%s' % (anchor))
    x = pos[0]
    y = pos[1]
    xa = 0
    ya = 0
    if anchor == "n":
        ya = -1
    elif anchor == "w":
        xa = -1
    elif anchor == "s":
        ya = 1
    elif anchor == "e":
        xa = 1
    elif anchor == "ne":
        ya = -1
        xa = 1
    elif anchor == "nw":
        ya = -1
        xa = -1
    elif anchor == "se":
        ya = 1
        xa = 1
    elif anchor == "sw":
        ya = 1
        xa = -1

    if xa == 0:
        x = x + size[0] / 2.0
    elif xa == 1:
        x = x + size[0]
    if ya == 0:
        y = y + size[1] / 2.0
    elif ya == 1:
        y = y + size[1]
    return (x, y)

# ************************************************************************
# * canvas items
# ************************************************************************


class MfxCanvasGroup():
    def __init__(self, canvas, tag=None):
        # logging.info('MfxCanvasGroup: __init__() %s - %s' %
        #  (str(canvas), str(tag)))
        self.canvas = canvas
        self.bindings = {}
        self.stack = None

    def tkraise(self):
        pass

    def addtag(self, tag, option="withtag"):
        # logging.info('MfxCanvasGroup: addtag(%s, %s)' % (tag, option))
        # self.canvas.addtag(tag, option, self.id)
        pass

    def delete(self):
        # logging.info('MfxCanvasGroup: delete()')
        # del self.canvas.items[self.id]
        pass

    def gettags(self):
        # logging.info('MfxCanvasGroup: gettags()')
        # return self.canvas.tk.splitlist(self._do("gettags"))
        return None


class MfxCanvasImage(object):
    def __init__(self, canvas, *args, **kwargs):

        # print ('MfxCanvasImage: %s | %s | %s' % (canvas, args, kwargs))

        group = None
        if 'group' in kwargs:
            group = kwargs['group']
            del kwargs['group']
        self._image = None
        if 'image' in kwargs:
            self._image = kwargs['image']
        self._anchor = None
        if 'anchor' in kwargs:
            self._anchor = kwargs['anchor']

        super(MfxCanvasImage, self).__init__()
        self.canvas = canvas
        self.animation = None

        ed = kwargs['image']
        size = ed.size

        if type(ed) is LImageItem:
            aimage = ed
        else:
            if (ed.source is None):
                image = LImage(texture=ed.texture)
                image.size = [ed.getWidth(), ed.getHeight()]
                aimage = LImageItem(size=image.size, group=group)
                aimage.add_widget(image)
                size = image.size
            else:
                image = LImage(texture=ed.texture)
                # image = LImage(source=ed.source)
                image.size = [ed.getWidth(), ed.getHeight()]
                aimage = LImageItem(size=ed.size, group=group)
                aimage.add_widget(image)
                size = image.size

        xy = addAnchorOffset(args, self._anchor, size)

        aimage.coreSize = (aimage.size[0], aimage.size[1])
        aimage.corePos = (xy[0], xy[1])

        aimage.pos, aimage.size = canvas.CoreToKivy(xy, aimage.size)
        self.canvas.add_widget(aimage)
        self.image = aimage
        self.widget = aimage

        if group:
            self.addtag(group)

    def __del__(self):
        print('MfxCanvasImage: __del__(%s)' % self.image)
        self.canvas.clear_widgets([self.image])

    def config(self, **kw):
        pass

    def tkraise(self, aboveThis=None):
        # print('MfxCanvasImage: tkraise')
        abitm = None
        if aboveThis:
            abitm = aboveThis.widget
        if not self.animation:
            self.canvas.tag_raise(self.image, abitm)
        pass

    def addtag(self, tag):
        # print('MfxCanvasImage: addtag %s' % tag)
        self.group = tag
        if (self.image):
            self.image.group = tag
        pass

    def dtag(self, tag):
        # print('MfxCanvasImage: remtag %s' % tag)
        self.group = None
        if (self.image):
            self.image.group = None
        pass

    def delete(self):
        # print('MfxCanvasImage: delete()')
        self.canvas.clear_widgets([self.image])

    def move(self, dx, dy):
        # print ('MfxCanvasImage: move %s, %s' % (dx, dy))
        image = self.image
        dsize = image.coreSize
        dpos = (image.corePos[0] + dx, image.corePos[1] + dy)
        image.corePos = dpos
        if not self.animation:
            image.pos, image.size = self.canvas.CoreToKivy(dpos, dsize)

    def makeAnimStart(self):
        def animStart(anim, widget):
            # print('MfxCanvasImage: animStart')
            image = self.image
            self.canvas.tag_raise(image, None)
            pass
        return animStart

    def makeAnimEnd(self, dpos, dsize):
        def animEnd(anim, widget):
            # print('MfxCanvasImage: animEnd %s' % self)
            self.animation = False
            image = self.image
            image.pos, image.size = self.canvas.CoreToKivy(dpos, dsize)
            pass
        return animEnd

    def animatedMove(self, dx, dy, duration=0.2):
        # print ('MfxCanvasImage: animatedMove %s, %s' % (dx, dy))

        image = self.image
        dsize = image.coreSize
        dpos = (image.corePos[0] + dx, image.corePos[1] + dy)
        pos, size = self.canvas.CoreToKivy(dpos, dsize)
        transition1 = 'out_expo'
        # transition2 = 'out_cubic'
        # transition3 = 'out_quad'
        # transition4 = 'out_quint'
        # transition5 = 'out_sine'
        transition6 = 'in_out_quad'
        # transition7 = 'in_bounce'
        # transition8 = 'in_elastic'
        transition = transition6
        if self.canvas.wmain.app.game.demo:
            transition = transition1

        self.animation = True
        ssize = image.coreSize
        spos = (image.corePos[0], image.corePos[1])
        spos, ssize = self.canvas.CoreToKivy(spos, ssize)
        LAnimationManager.create(
            spos,
            image,
            x=pos[0], y=pos[1],
            duration=duration, transition=transition,
            bindS=self.makeAnimStart(),
            bindE=self.makeAnimEnd(dpos, dsize))

    # def moveTo(self, x, y):
    #    c = self.coords()
    #    self.move(x - int(c[0]), y - int(c[1]))

    def show(self):
        self.config(state='normal')

    def hide(self):
        self.config(state='hidden')


class MfxCanvasLine(object):
    def __init__(self, canvas, *args, **kwargs):
        print('MfxCanvasLine: %s %s' % (args, kwargs))

        self.canvas = canvas
        line = LLine(canvas, args, **kwargs)
        line.pos, line.size = canvas.CoreToKivy(line.corePos, line.coreSize)
        canvas.add_widget(line)
        self.canvas = canvas
        self.line = line
        self.widget = line

    def delete_deferred(self, seconds):
        print('MfxCanvasLine: delete_deferred(%s)' % seconds)
        Clock.schedule_once(lambda dt: self.delete(), seconds)

    def delete(self):
        print('MfxCanvasLine: delete()')
        self.canvas.clear_widgets([self.line])


class MfxCanvasRectangle(object):
    def __init__(self, canvas, *args, **kwargs):

        # logging.info('MfxCanvasRectangle: %s %s' % (args, kwargs))

        rect = LRectangle(canvas, args, **kwargs)
        rect.pos, rect.size = canvas.CoreToKivy(rect.corePos, rect.coreSize)
        canvas.add_widget(rect)
        self.canvas = canvas
        self.rect = rect
        self.widget = rect

    def delete(self):
        # print('MfxCanvasRectangle: delete()')
        self.canvas.clear_widgets([self.rect])

    def __del__(self):
        # print('MfxCanvasRectangle: __del__()')
        self.delete()

    def delete_deferred_step(self, seconds):
        # print ('MfxCanvasRectangle: delete_deferred_step(%s)' % seconds)
        Clock.schedule_once(lambda dt: self.delete(), seconds)

    def delete_deferred(self, seconds):
        # self.canvas.canvas.ask_update()
        # print ('MfxCanvasRectangle: delete_deferred(%s)' % seconds)
        Clock.schedule_once(
            lambda dt: self.delete_deferred_step(seconds), 0.05)

    def addtag(self, tag):
        logging.info('MfxCanvasRectangle: addtag(%s) - fake' % tag)
        pass

    def tkraise(self, aboveThis=None):
        # logging.info('MfxCanvasRectangle: tkraise(%s) - fake' % item)
        abitm = None
        if aboveThis:
            abitm = aboveThis.widget
        self.canvas.tag_raise(self.rect, abitm)
        pass


class MfxCanvasText(object):
    def __init__(self, canvas, x, y, preview=-1, **kwargs):

        print(
            'MfxCanvasText: %s | %s, %s, %s | %s'
            % (canvas, x, y, preview, kwargs))

        if preview < 0:
            preview = canvas.preview
        if preview > 1:
            return
        if "fill" not in kwargs:
            kwargs["fill"] = canvas._text_color
        if 'group' in kwargs:
            del kwargs['group']

        super(MfxCanvasText, self).__init__()

        label = LText(canvas, x, y, **kwargs)
        label.pos, label.size = canvas.CoreToKivy(
            label.corePos, label.coreSize)
        canvas.add_widget(label)
        self.canvas = canvas
        self.label = label
        self.widget = label

    def config(self, **kw):
        print('MfxCanvasText: config %s' % kw)
        if ('text' in kw):
            self.label.text = kw['text']

    def tkraise(self, aboveThis=None):
        abitm = None
        if aboveThis:
            abitm = aboveThis.widget
        self.canvas.tag_raise(self.label, abitm)
        pass

    def bbox(self):
        # Dimensionen als 2x2 array zurückgeben.
        # (aufruf z.B. bei games/special/poker.py und bei Memory!)
        label = self.label
        canvas = self.canvas
        pos = label.pos
        size = label.size
        pos, size = canvas.KivyToCore(pos, size)
        ret = [[pos[0], pos[1]], [pos[0] + size[0], pos[1] + size[1]]]
        return ret

    def addtag(self, tag):
        pass

# ************************************************************************
# * canvas
# ************************************************************************


class MfxCanvas(Widget):

    def __init__(self, wmain, *args, **kw):
        # super(MfxCanvas, self).__init__(**kw)
        super(MfxCanvas, self).__init__()

        # self.tags = {}   # bei basisklasse widget (ev. nur vorläufig)

        self.wmain = wmain
        print('MfxCanvas: wmain = %s' % self.wmain)

        # Tkinter.Canvas.__init__(self, *args, **kw)
        self.preview = 0
        self.busy = False
        self._text_color = '#000000'
        self._bg_color = '#00ffff'
        self._stretch_bg_image = 0
        self._save_aspect_bg_image = 0
        #
        self.xmargin, self.ymargin = 0.0, 0.0
        self.topImage = None

        # Skalierung
        # self.lastsize = (self.size[0], self.size[1])
        # self.lastpos = (self.pos[0], self.pos[1])

        self.scale = 1.2
        self.r_width = None
        self.r_height = None

        self.bindings = {}
        self.bind(pos=self.pos_update_widget)
        self.bind(size=self.size_update_widget)

    def KivyToCoreP(self, pos, size, scale):
        cpos = pos
        cpos = (cpos[0] - self.pos[0], self.pos[1] +
                self.size[1] - cpos[1] - size[1])
        cpos = (1.0 * cpos[0] / scale, 1.0 * cpos[1] / scale)
        csize = (1.0 * size[0] / scale, 1.0 * size[1] / scale)
        return cpos, csize

    def CoreToKivyP(self, cpos, csize, scale):
        size = (1.0 * csize[0] * scale, 1.0 * csize[1] * scale)
        pos = (1.0 * cpos[0] * scale, 1.0 * cpos[1] * scale)
        pos = (self.pos[0] + pos[0], self.pos[1] +
               self.size[1] - pos[1] - size[1])
        return pos, size

    def KivyToCore(self, pos, size=(0.0, 0.0)):
        return self.KivyToCoreP(pos, size, self.scale)

    def CoreToKivy(self, cpos, csize=(0.0, 0.0)):
        return self.CoreToKivyP(cpos, csize, self.scale)

    def move(self, itm, dx, dy):
        # print ('MfxCanvas: move %s %s %s' % (itm, dx, dy))
        scale = self.scale
        dx = scale * dx
        dy = scale * dy
        itm.pos = (itm.pos[0] + dx, itm.pos[1] - dy)

    def scalefactor(self):
        if self.r_width is None:
            return self.scale
        if self.r_height is None:
            return self.scale

        # TBD (idee).
        # Hier ev. einen 2ten Modus zulassen, welche das Spielfeld
        # knapp auf die vorhandenen Karten/Anzeigeelemente bemisst.
        # Zur Optimierung der Sichtbarkeit auf kleinen Geräten.
        # Könnte z.B. über Doppelklick umgeschaltet werden. (Die
        # Skalierung müsste dann allerding nach jedem Zug dem ev.
        # veränderten Feld angepasst werden.)

        wid = self.size[0]
        hei = self.size[1]
        scfx = wid / self.r_width
        scfy = hei / self.r_height

        scf = scfx
        if (scfx < scfy):
            # print('scale factor by x = %s' % (scfx))
            scf = scfx
        else:
            # print('scale factor by y = %s' % (scfy))
            scf = scfy

        return scf

    def pos_update_widget(self, posorobj, size):
        # print('MfxCanvas: pos_update_widget size=(%s, %s)' %
        #       (self.size[0], self.size[1]))
        self.update_widget(posorobj, size)

    def size_update_widget(self, posorobj, size):
        # print('MfxCanvas: size_update_widget size=(%s, %s)' %
        #       (self.size[0], self.size[1]))
        self.update_widget(posorobj, size)

    def update_widget(self, posorobj, size):

        # print('MfxCanvas: update_widget size=(%s, %s)' %
        #       (self.size[0], self.size[1]))

        # Update Skalierungsparameter

        oldscale = self.scale
        newscale = self.scalefactor()
        print('MfxCanvas: scale factor old= %s, new=%s' %
              (oldscale, newscale))
        self.scale = newscale

        # Anpassung Skalierung.

        for c in self.children:
            if not hasattr(c, 'corePos'):
                continue
            if not hasattr(c, 'coreSize'):
                continue

            bpos = c.corePos
            bsiz = c.coreSize
            if bpos and bsiz:
                npos, nsiz = self.CoreToKivy(bpos, bsiz)
                c.pos = npos
                c.size = nsiz

        # Hintergrund update.

        self.canvas.before.clear()
        texture = None
        if self._bg_img:
            texture = self._bg_img.texture

            # Color only: Nur eine Hintergrundfarbe wird installiert.
        if texture is None:
            kc = LColorToKivy(self._bg_color)
            self.canvas.before.add(
                Color(kc[0], kc[1], kc[2], kc[3]))
            self.canvas.before.add(
                Rectangle(pos=self.pos, size=self.size))
            return

        # Image: Das Bild wird im Fenster expandiert.
        if self._stretch_bg_image:
            if self._save_aspect_bg_image == 0:
                self.canvas.before.add(
                    Rectangle(texture=texture, pos=self.pos, size=self.size))
            else:
                # TBD: gesucht: aspect erhaltende skalierung
                self.canvas.before.add(
                    Rectangle(texture=texture, pos=self.pos, size=self.size))
            return

            # Tiles: Die Kacheln werden im Fenster ausgelegt und minim
        # skaliert, damit sie genau passen.
        else:
            print('tiles !')
            stsize = (texture.size[0] * self.scale,
                      texture.size[1] * self.scale)
            stepsy = int(self.size[1] / stsize[1]) + 1
            stepsx = int(self.size[0] / stsize[0]) + 1

            scaley = 1.0 * self.size[1] / (stepsy * stsize[1])
            sy = scaley * stsize[1]
            scalex = 1.0 * self.size[0] / (stepsx * stsize[0])
            sx = scalex * stsize[0]
            tsize = (sx, sy)

            # print ('self.size = %s, %s' % (self.size[0], self.size[1]))
            # print ('sx, sy = %s, %s' % (stepsx, stepsy))
            for y in range(0, stepsy):
                py = y * sy
                for x in range(0, stepsx):
                    px = x * sx
                    tpos = (self.pos[0] + px, self.pos[1] + py)
                    self.canvas.before.add(
                        Rectangle(texture=texture, pos=tpos, size=tsize))

    def setBackgroundImage(self, event=None):

        print('setBackgroundImage', self._bg_img)

        if not self._bg_img:  # solid color
            return
        return 1

    # Funktionen, welche vom Core aufgerufen werden.

    def winfo_width(self):
        # return self.r_width
        cpos, csize = self.KivyToCoreP(self.pos, self.size, self.scale)
        print('MfxCanvas: winfo_width %s' % (csize[0]))
        return csize[0]

    def winfo_height(self):
        # return self.r_height
        cpos, csize = self.KivyToCoreP(self.pos, self.size, self.scale)
        print('MfxCanvas: winfo_height %s' % (csize[1]))
        return csize[1]

    def cget(self, f):
        print('MfxCanvas: cget %s -> %s, %s' % (f, self.pos, self.size))
        cpos, csize = self.KivyToCoreP(self.pos, self.size, self.scale)
        if f == 'width':
            print('MfxCanvas: cget %s -> x=%s' % (f, cpos[0]))
            return cpos[0]
        if f == 'height':
            print('MfxCanvas: cget %s -> y=%s' % (f, cpos[1]))
            return cpos[1]
        # if f=='bg':
        #    return background-color
        print('MfxCanvas: cget unsupported token')
        return 1

    def xview(self):
        print('MfxCanvas: xview')
        return [1, 1]
        pass

    def yview(self):
        print('MfxCanvas: yview')
        return [1, 1]
        pass

    #
    # top-image support
    #

    def tag_raise(self, itm, abitm=None):
        # print('MfxCanvas: tag_raise, itm=%s, aboveThis=%s' % (itm, abitm))
        if (itm is not None):
            if (abitm is None):
                # print('MfxCanvas: tag_raise: to top')
                self.clear_widgets([itm])
                self.add_widget(itm)
            else:
                print('MfxCanvas: tag_raise: to specified position')
                ws = []
                for c in reversed(self.children):   # reversed!
                    if c != itm and c != abitm:
                        ws.append(c)
                    if c == itm:
                        ws.append(abitm)
                        ws.append(itm)    # (~shadow image!)
                self.clear_widgets()
                for w in ws:
                    self.add_widget(w)

    def tag_lower(self, id, belowThis=None):
        print('MfxCanvas: tag_lower(%s, %s)' % (id, belowThis))
        # y = self.yy  # kommt das vor ?
        pass

    #
    #
    #
    def setInitialSize(self, width, height):
        print('MfxCanvas: setInitialSize request %s/%s' % (width, height))
        print(
            'MfxCanvas: setInitialSize actual  %s/%s'
            % (self.size[0], self.size[1]))
        self.r_width = width
        self.r_height = height

        # ev. update anstossen
        self.update_widget(self.pos, self.size)

        # self.size[0] = width
        # self.size[1] = height
        return

    # delete all CanvasItems, but keep the background and top tiles
    def deleteAllItems(self):
        print('MfxCanvas: deleteAllItems')
        self.clear_widgets()
        pass

    def findCard(self, stack, event):
        print('MfxCanvas: findCard(%s, %s)' % (stack, event))
        if (event.cardid > -1):
            return event.cardid

        print('MfxCanvas: findCard no cardid')
        return -1

    def setTextColor(self, color):
        print('MfxCanvas: setTextColor1 %s' % color)
        if color is None:
            c = self.cget("bg")
            if not isinstance(c, str) or c[0] != "#" or len(c) != 7:
                return
            v = []
            for i in (1, 3, 5):
                v.append(int(c[i:i + 2], 16))
            luminance = (0.212671 * v[0] + 0.715160 *
                         v[1] + 0.072169 * v[2]) / 255
            # print c, ":", v, "luminance", luminance
            color = ("#000000", "#ffffff")[luminance < 0.3]

        print('MfxCanvas: setTextColor2 %s' % color)
        if self._text_color != color:
            self._text_color = color

            # falls wir das wollen in kivy:
            # -> text_color als property deklarieren, und a.a.O binden.
            # for item in self._text_items:
            #    item.config(fill=self._text_color)

    def setTile(self, image, stretch=0, save_aspect=0):

        print('setTile: %s, %s' % (image, stretch))
        if image:
            try:
                # print ('setTile: image.open %s, %s' % (image, Image))
                bs = False
                if stretch > 0:
                    bs = True
                self._bg_img = Image(source=image, allow_stretch=bs)

                self._stretch_bg_image = stretch
                self._save_aspect_bg_image = save_aspect
                self.setBackgroundImage()
                self.update_widget(self.pos, self.size)
            except Exception:
                return 0
        else:
            # print ('setTile: no image!')
            self._bg_img = None
            self.update_widget(self.pos, self.size)
        return 1

    def setTopImage(self, image, cw=0, ch=0):
        print('MfxCanvas: setTopImage %s' % image)

        if self.topImage:
            self.clear_widgets([self.topImage])
            self.topImage = None

        if image:
            tex = LImage(texture=image.texture)
            tex.size_hint = (0.4, 0.4)
            lay = AnchorLayout(anchor_y='bottom')
            lay.size = self.size
            lay.add_widget(tex)

            self.topImage = lay
            self.add_widget(self.topImage)

        return 1
    #
    # Pause support
    #

    def hideAllItems(self):
        print('MfxCanvas: hideAllItems')
        # TBD
        # Wir lassen das. Das TopImage deckt alles ab. Spielen ist
        # nicht möglich.
        pass

    def showAllItems(self):
        print('MfxCanvas: showAllItems')
        # TBD
        pass

    # Erweiterungen fuer Tk Canvas (prüfen was noch nötig!!).

    def itemconfig(self, tagOrId, cnf=None, **kw):
        """Configure resources of an item TAGORID.

        The values for resources are specified as keyword
        arguments. To get an overview about
        the allowed keyword arguments call the method without arguments.
        """
        print(
            'MfxCanvas: itemconfigure tagOrId=%s, cnf=%s, kw=%s'
            % (tagOrId, cnf, kw))

        if 'image' in cnf:
            # tagOrId ist ein Image oder ein CardImage
            # self.clear_widgets([cnf['image']])
            # self.add_widget(cnf['image'])
            # y = self.yy
            pass
        if 'text' in cnf:
            # tagOrId ist das Label.
            tagOrId.text = cnf['text']
            pass

    def config(self, cnf={}, **kw):
        print('MfxCanvas: config %s %s' % (cnf, kw))
        if ('cursor' in kw):
            pass
        if ('width' in kw):
            self.size[0] = kw['width']
        if ('height' in kw):
            self.size[1] = kw['height']
        if ('bg' in kw):
            self._bg_color = kw['bg']
            self.update_widget(self.pos, self.size)

    def dtag(self, tag, b=None):
        # print ('Canvas: dtag %s %s' % (tag, b))
        # if (tag in self.tags):
        #  if (self.tags[tag]==b):
        #    del self.tags[tag]
        pass

    def addtag(self, tag, b, c):
        # print ('Canvas: addtag %s %s %s' % (tag, b, c))
        # self.tags[c] = tag
        # self.tags.append(tag)
        pass

    def delete(self, tag):
        # print ('MfxCanvas: delete tag=%s' % tag)
        # y = self.yy
        pass

    def update_idletasks(self):
        print('MfxCanvas: update_idletasks')
        self.wmain.update_idletasks()
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#

from kivy.clock import Clock

from pysollib.gamedb import GI
from pysollib.kivy.LApp import LScrollView
from pysollib.kivy.LApp import LTopLevel
from pysollib.kivy.LApp import LTreeNode
from pysollib.kivy.LApp import LTreeRoot
from pysollib.kivy.selecttree import SelectDialogTreeData
from pysollib.kivy.selecttree import SelectDialogTreeLeaf, SelectDialogTreeNode
from pysollib.mygettext import _

from six.moves import UserList


# ************************************************************************
# * Nodes
# ************************************************************************


class SelectGameLeaf(SelectDialogTreeLeaf):
    def getContents(self):
        return None


class SelectGameNode(SelectDialogTreeNode):
    def _getContents(self):
        contents = []
        if isinstance(self.select_func, UserList):
            # key/value pairs
            for id, name in self.select_func:
                if id and name:
                    node = SelectGameLeaf(self.tree, self, name, key=id)
                    contents.append(node)
        else:
            for gi in self.tree.all_games_gi:
                if gi and self.select_func is None:
                    # All games
                    # name = '%s (%s)' % (gi.name, CSI.TYPE_NAME[gi.category])
                    name = gi.name
                    node = SelectGameLeaf(self.tree, self, name, key=gi.id)
                    contents.append(node)
                elif gi and self.select_func(gi):
                    name = gi.name
                    node = SelectGameLeaf(self.tree, self, name, key=gi.id)
                    contents.append(node)
        return contents or self.tree.no_games


# ************************************************************************
# * Tree database
# ************************************************************************

class SelectGameData(SelectDialogTreeData):
    def __init__(self, app):
        SelectDialogTreeData.__init__(self)

        # originale.
        self.all_games_gi = list(
            map(app.gdb.get, app.gdb.getGamesIdSortedByName()))
        self.no_games = [SelectGameLeaf(None, None, _("(no games)"), None), ]
        #
        s_by_type = s_oriental = s_special = None
        s_original = s_contrib = s_mahjongg = None
        g = []
        for data in (GI.SELECT_GAME_BY_TYPE,
                     GI.SELECT_ORIENTAL_GAME_BY_TYPE,
                     GI.SELECT_SPECIAL_GAME_BY_TYPE,
                     GI.SELECT_ORIGINAL_GAME_BY_TYPE,
                     GI.SELECT_CONTRIB_GAME_BY_TYPE,
                     ):
            gg = []
            for name, select_func in data:
                if name is None or not filter(select_func, self.all_games_gi):
                    continue
                gg.append(SelectGameNode(None, _(name), select_func))
            g.append(gg)

        def select_mahjongg_game(gi): return gi.si.game_type == GI.GT_MAHJONGG
        gg = None
        if filter(select_mahjongg_game, self.all_games_gi):
            gg = SelectGameNode(None, _("Mahjongg Games"),
                                select_mahjongg_game)
        g.append(gg)
        if g[0]:
            s_by_type = SelectGameNode(None, _("French games"),
                                       tuple(g[0]), expanded=1)
        if g[1]:
            s_oriental = SelectGameNode(None, _("Oriental Games"),
                                        tuple(g[1]))
        if g[2]:
            s_special = SelectGameNode(None, _("Special Games"),
                                       tuple(g[2]))
        if g[3]:
            s_original = SelectGameNode(None, _("Original Games"),
                                        tuple(g[3]))
#         if g[4]:
#           s_contrib = SelectGameNode(None, "Contributed Games", tuple(g[4]))
        if g[5]:
            s_mahjongg = g[5]
        #
        # all games sorted (in pieces).
        s_all_games, gg = None, []
        agames = self.all_games_gi
        n, d = 0, 17
        i = 0
        while True:
            # columnbreak = i > 0 and (i % d) == 0
            i += 1
            if not agames[n:n + d]:
                break
            m = min(n + d - 1, len(agames) - 1)
            label = agames[n].name[:4] + ' - ' + agames[m].name[:4]
            # print('label = %s' % label)

            ggg = []
            for ag in agames[n:n + d]:
                # print('game, id = %s, %s' % (ag.name, ag.id))
                ggg.append((ag.id, ag.name + ' (' + str(ag.id) + ')'))

            gg.append(SelectGameNode(None, label, UserList(ggg)))
            n += d
        if 1 and gg:
            s_all_games = SelectGameNode(None, _("All Games"), tuple(gg))
        #
        s_by_compatibility, gg = None, []
        for name, games in GI.GAMES_BY_COMPATIBILITY:
            def select_func(gi, games=games):
                return gi.id in games
            if name is None or not list(filter(
                    select_func, self.all_games_gi)):
                continue
            gg.append(SelectGameNode(None, name, select_func))
        if 1 and gg:
            s_by_compatibility = SelectGameNode(None, _("by Compatibility"),
                                                tuple(gg))
            pass
        #
        s_by_pysol_version, gg = None, []
        for name, games in GI.GAMES_BY_PYSOL_VERSION:
            def select_func(gi, games=games):
                return gi.id in games
            if name is None or not list(filter(
                    select_func, self.all_games_gi)):
                continue
            name = _("New games in v. %(version)s") % {'version': name}
            gg.append(SelectGameNode(None, name, select_func))
        if 1 and gg:
            s_by_pysol_version = SelectGameNode(None, _("by PySol version"),
                                                tuple(gg))
        #
        s_by_inventors, gg = None, []
        for name, games in GI.GAMES_BY_INVENTORS:
            def select_func(gi, games=games):
                return gi.id in games
            if name is None or not list(filter(
                    select_func, self.all_games_gi)):
                continue
            gg.append(SelectGameNode(None, name, select_func))
        if 1 and gg:
            s_by_inventors = SelectGameNode(None, _("by Inventors"),
                                            tuple(gg))
        #
        ul_alternate_names = UserList(
            list(app.gdb.getGamesTuplesSortedByAlternateName()))
        #
        self.rootnodes = [_f for _f in (
            # SelectGameNode(None, _("All Games"), None),
            SelectGameNode(None, _("Popular Games"),
                           lambda gi: gi.si.game_flags & GI.GT_POPULAR),
            s_mahjongg,
            s_oriental,
            s_special,
            # SelectGameNode(None, _("Custom Games"),
            #               lambda gi: gi.si.game_type == GI.GT_CUSTOM),
            SelectGameNode(None, _("Alternate Names"), ul_alternate_names),
            s_by_type,
            s_all_games,
            SelectGameNode(None, _('by Skill Level'), (
                SelectGameNode(None, _('Luck only'),
                           lambda gi: gi.skill_level == GI.SL_LUCK),
                SelectGameNode(None, _('Mostly luck'),
                           lambda gi: gi.skill_level == GI.SL_MOSTLY_LUCK),
                SelectGameNode(None, _('Balanced'),
                           lambda gi: gi.skill_level == GI.SL_BALANCED),
                SelectGameNode(None, _('Mostly skill'),
                           lambda gi: gi.skill_level == GI.SL_MOSTLY_SKILL),
                SelectGameNode(None, _('Skill only'),
                           lambda gi: gi.skill_level == GI.SL_SKILL),
            )),
            SelectGameNode(None, _("by Game Feature"), (
                SelectGameNode(None, _("by Number of Cards"), (
                    SelectGameNode(None, _("32 cards"),
                                   lambda gi: gi.si.ncards == 32),
                    SelectGameNode(None, _("48 cards"),
                                   lambda gi: gi.si.ncards == 48),
                    SelectGameNode(None, _("52 cards"),
                                   lambda gi: gi.si.ncards == 52),
                    SelectGameNode(None, _("64 cards"),
                                   lambda gi: gi.si.ncards == 64),
                    SelectGameNode(None, _("78 cards"),
                                   lambda gi: gi.si.ncards == 78),
                    SelectGameNode(None, _("104 cards"),
                                   lambda gi: gi.si.ncards == 104),
                    SelectGameNode(None, _("144 cards"),
                                   lambda gi: gi.si.ncards == 144),
                    SelectGameNode(None, _("Other number"),
                                   lambda gi: gi.si.ncards not in
                                   (32, 48, 52, 64, 78, 104, 144)),
                )),
                SelectGameNode(None, _("by Number of Decks"), (
                    SelectGameNode(None, _("1 deck games"),
                                   lambda gi: gi.si.decks == 1),
                    SelectGameNode(None, _("2 deck games"),
                                   lambda gi: gi.si.decks == 2),
                    SelectGameNode(None, _("3 deck games"),
                                   lambda gi: gi.si.decks == 3),
                    SelectGameNode(None, _("4 deck games"),
                                   lambda gi: gi.si.decks == 4),
                )),
                SelectGameNode(None, _("by Number of Redeals"), (
                    SelectGameNode(None, _("No redeal"),
                               lambda gi: gi.si.redeals == 0),
                    SelectGameNode(None, _("1 redeal"),
                               lambda gi: gi.si.redeals == 1),
                    SelectGameNode(None, _("2 redeals"),
                               lambda gi: gi.si.redeals == 2),
                    SelectGameNode(None, _("3 redeals"),
                               lambda gi: gi.si.redeals == 3),
                    SelectGameNode(None, _("Unlimited redeals"),
                               lambda gi: gi.si.redeals == -1),
                    SelectGameNode(None, "Variable redeals",
                               lambda gi: gi.si.redeals == -2),
                    SelectGameNode(None, _("Other number of redeals"),
                               lambda gi: gi.si.redeals not in
                               (-1, 0, 1, 2, 3)),
                )),
                s_by_compatibility,
            )),
            s_by_pysol_version,
            s_by_inventors,
            SelectGameNode(None, _("Other Categories"), (
                SelectGameNode(None, _("Games for Children (very easy)"),
                               lambda gi: gi.si.game_flags & GI.GT_CHILDREN),
                SelectGameNode(None, _("Games with Scoring"),
                               lambda gi: gi.si.game_flags & GI.GT_SCORE),
                SelectGameNode(None, _("Games with Separate Decks"),
                           lambda gi: gi.si.game_flags & GI.GT_SEPARATE_DECKS),
                SelectGameNode(None, _("Open Games (all cards visible)"),
                               lambda gi: gi.si.game_flags & GI.GT_OPEN),
                SelectGameNode(None, _("Relaxed Variants"),
                               lambda gi: gi.si.game_flags & GI.GT_RELAXED),
            )),
            s_original,
            s_contrib,
        ) if _f]


# ************************************************************************
# * Canvas that shows the tree
# ************************************************************************
'''
class SelectGameTreeWithPreview(SelectDialogTreeCanvas):
    data = None


class SelectGameTree(SelectGameTreeWithPreview):
    def singleClick(self, event=None):
        self.doubleClick(event)
'''
# ************************************************************************
# * Kivy support
# ************************************************************************


class LGameRoot(LTreeRoot):
    def __init__(self, gametree, gameview, **kw):
        super(LGameRoot, self).__init__(**kw)
        self.gametree = gametree
        self.gameview = gameview
        self.kw = kw


class LGameNode(LTreeNode):
    def __init__(self, gamenode, gameview, **kw):

        self.lastpos = None
        self.gamenode = gamenode
        self.gameview = gameview
        super(LGameNode, self).__init__(**kw)

        self.coreFont = self.font_size
        # self.scaleFont(self.gameview.size[1])
        # self.gameview.bind(size=self.scaleFontCB)

        self.command = None
        if 'command' in kw:
            self.command = kw['command']
        self.bind(on_release=self.on_released)

    # font skalierung.

    def scaleFont(self, value):
        self.font_size = int(self.coreFont * value / 550.0)

    def scaleFontCB(self, instance, value):
        self.scaleFont(value[1])

    # benutzer interaktion.

    def on_released(self, v):
        if self.gamenode.key:
            if self.command:
                # print('game number = %s' % self.gamenode.key)
                Clock.schedule_once(self.commandCB, 0.1)
        else:
            # verzögert aufrufen, wegen user feedback.
            Clock.schedule_once(self.toggleCB, 0.1)
    '''
    def on_touch_move(self, touch):
        if self.collide_point(*touch.pos):
            if self.lastpos==None:
                self.lastpos = touch.pos
                print('touch.pos %s' % str(touch.pos))
                return

            print ('touch move on %s - %s' % (self.text, touch.profile))
            print('touch.pos(2) %s' % str(touch.pos))
            # tbd: nur wenn horizontal move !
            if (touch.pos[0]+2) < self.lastpos[0]:
                Clock.schedule_once(self.collapseParentCB, 0.1)
        pass
    '''

    def commandCB(self, d):
        self.command(self.gamenode.key)

    def toggleCB(self, d):
        self.parent.toggle_node(self)

    '''
    def collapseParentCB(self, d):
        if self.parent:
            if self.parent_node.is_open:
                self.parent.toggle_node(self.parent_node)
            self.lastpos = None
    '''
# ************************************************************************
# * Dialog
# ************************************************************************


class SelectGameDialog(object):

    # Dialog, einmal erzeugt, wird rezykliert.
    SingleInstance = None

    def onClick(self, event):
        print('LTopLevel: onClick')
        SelectGameDialog.SingleInstance.parent.popWork('SelectGame')
        SelectGameDialog.SingleInstance.running = False

    def selectCmd(self, gameid):
        self.app.menubar._mSelectGame(gameid)

    def __init__(self, parent, title, app, gameid, **kw):
        super(SelectGameDialog, self).__init__()

        self.parent = parent
        self.app = app
        self.gameid = gameid
        self.random = None
        self.running = False
        self.window = None

        # bestehenden Dialog rezyklieren.

        si = SelectGameDialog.SingleInstance
        # if (si and si.running): return
        if (si and si.running):
            si.parent.popWork('SelectGame')
            si.running = False
            return
        if (si):
            si.parent.pushWork('SelectGame', si.window)
            si.running = True
            return

        # neuen Dialog aufbauen.

        window = LTopLevel(parent, title)
        window.titleline.bind(on_press=self.onClick)
        self.parent.pushWork('SelectGame', window)
        self.window = window
        self.running = True
        SelectGameDialog.SingleInstance = self

        # Asynchron laden.

        def loaderCB(treeview, node):

            # Beispielcode aus doku:
            #
            # for name in ('Item 1', 'Item 2'):
            #   yield TreeViewLabel(text=name, parent=node)
            #
            # LGameNode ist ein Button. Es stellt sich heraus, dass
            # wir (ev. darum) parent=node NICHT setzen dürfen, da das
            # sonst zum versuchten doppelten einfügen des gleichen
            # widget im tree führt.

            if node:
                if not hasattr(node, "gamenode"):
                    # (das löst ein problem mit dem root knoten),
                    return

            v = treeview.gameview
            if node:
                n = node.gamenode
                n.tree = treeview.gametree

                nodes = n.getContents()
                if type(nodes) is list:
                    # Blaetter
                    for l in nodes:
                        # print ('**game=%s' % l.text)
                        yield LGameNode(
                            l, v, text=l.text,
                            is_leaf=True,
                            command=self.selectCmd)

                if type(nodes) is tuple:
                    # Knoten
                    for nn in nodes:
                        # print ('**node=%s' % nn.text)
                        newnode = LGameNode(
                            nn, v, text=nn.text, is_leaf=False)
                        yield newnode

                    print('all nodes done')
            else:
                # Knoten
                nodes = treeview.gametree.rootnodes[:]
                for n in nodes:
                    newnode = LGameNode(n, v, text=n.text, is_leaf=False)
                    # print ('**node=%s' % newnode)
                    yield newnode

        # treeview aufsetzen.

        tree = SelectGameData(app)
        tv = self.tvroot = LGameRoot(
            tree,
            self.app.canvas,
            root_options=dict(text='Tree One'))
        tv.size_hint = 1, None
        tv.hide_root = True
        tv.load_func = loaderCB
        tv.bind(minimum_height=tv.setter('height'))

        # tree in einem Scrollwindow präsentieren.

        root = LScrollView(pos=(0, 0))
        root.add_widget(tv)
        window.content.add_widget(root)

# ************************************************************************
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##
from pysollib.mygettext import _
from pysollib.settings import TITLE
from pysollib.ui.tktile.tkconst import EVENT_HANDLED

from six.moves import tkinter


class BaseSolverDialog:
    def _ToggleShowProgressButton(self, *args):
        self.app.opt.solver_show_progress = self.progress_var.get()

    def _getMaxIters(self):
        try:
            i = self.max_iters_var.get()
        except Exception:
            i = 100000
        return i

    def _OnAssignToMaxIters(self, *args):
        self.app.opt.solver_max_iterations = self._getMaxIters()

    def _OnAssignToPreset(self, *args):
        self.app.opt.solver_preset = self.preset_var.get()

    def __init__(self, parent, app, **kw):
        self.parent = parent
        self.app = app
        title = _('%(app)s - FreeCell Solver') % {'app': TITLE}
        kw = self.initKw(kw)
        self._calc_MfxDialog().__init__(
            self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.createBitmaps(top_frame, kw)
        self.games = {}                 # key: gamename; value: gameid

        #
        frame = self._calcToolkit().Frame(top_frame)
        frame.pack(expand=True, fill='both', padx=4, pady=4)
        frame.columnconfigure(1, weight=1)

        #
        row = 0
        self._calcToolkit().Label(
            frame, text=_('Game:'), anchor='w').grid(
            row=row, column=0, sticky='ew', padx=2, pady=2)
        games = app.getGamesForSolver()
        gamenames = ['']
        for id in games:
            name = app.getGameTitleName(id)
            gamenames.append(name)
            self.games[name] = id
        gamenames.sort()
        self.gamenames = gamenames
        self.games_var = self._createGamesVar(frame, row)

        #
        row += 1
        self._calcToolkit().Label(
            frame, text=_('Preset:'), anchor='w').grid(
            row=row, column=0, sticky='ew', padx=2, pady=2)
        presets = app.opt.solver_presets
        self.presets = presets
        self.preset_var = self._createPresetVar(frame, row)
        self.preset_var.set(self.app.opt.solver_preset)

        #
        row += 1
        self.max_iters_var = tkinter.IntVar()
        self.max_iters_var.set(self.app.opt.solver_max_iterations)
        self._calcToolkit().Label(
            frame, text=_('Max iterations:'), anchor='w').grid(
            row=row, column=0, sticky='ew', padx=2, pady=2)
        spin = tkinter.Spinbox(frame, bg='white', from_=1000, to=10e6,
                               increment=1000, textvariable=self.max_iters_var)
        self.max_iters_var.trace('w', self._OnAssignToMaxIters)
        spin.grid(row=row, column=1, sticky='w', padx=2, pady=2)

        #
        row += 1
        self.progress_var = tkinter.BooleanVar()
        self.progress_var.set(self.app.opt.solver_show_progress)
        w = self._createShowProgressButton(frame)
        w.grid(row=row, column=0, columnspan=2, sticky='ew', padx=2, pady=2)
        w.config(command=self._ToggleShowProgressButton)

        #
        label_frame = self._calcToolkit().LabelFrame(
            top_frame, text=_('Progress'))
        label_frame.pack(expand=True, fill='both', padx=6, pady=2)
        # label_frame.columnconfigure(0, weight=1)
        label_frame.columnconfigure(1, weight=1)

        #
        frow = 0
        self._calcToolkit().Label(
            label_frame, text=_('Iteration:'), anchor='w').grid(
            row=frow, column=0, sticky='ew', padx=4, pady=2)
        lb = self._calcToolkit().Label(label_frame, anchor='w')
        lb.grid(row=frow, column=1, sticky='ew', padx=4, pady=2)
        self.iter_label = lb
        frow += 1
        self._calcToolkit().Label(
            label_frame, text=_('Depth:'), anchor='w').grid(
            row=frow, column=0, sticky='ew', padx=4, pady=2)
        lb = self._calcToolkit().Label(label_frame, anchor='w')
        lb.grid(row=frow, column=1, sticky='ew', padx=4, pady=2)
        self.depth_label = lb
        frow += 1
        self._calcToolkit().Label(
            label_frame, text=_('Stored-States:'), anchor='w').grid(
            row=frow, column=0, sticky='ew', padx=4, pady=2)
        lb = self._calcToolkit().Label(label_frame, anchor='w')
        lb.grid(row=frow, column=1, sticky='ew', padx=4, pady=2)
        self.states_label = lb

        #
        lb = self._calcToolkit().Label(top_frame, anchor='w')
        lb.pack(expand=True, fill='x', padx=6, pady=4)
        self.result_label = lb

        #
        focus = self.createButtons(bottom_frame, kw)
        self.start_button = self.buttons[0]
        self.play_button = self.buttons[1]
        self._reset()
        self.connectGame(self.app.game)
        self.mainloop(focus, kw.timeout, transient=False)

    def mDone(self, button):
        if button == 0:
            self.startSolving()
        elif button == 1:
            self.startPlay()
        elif button == 2:
            self.app.menubar.mNewGame()
        elif button == 3:
            global solver_dialog
            solver_dialog = None
            self.destroy()
        return EVENT_HANDLED

    def mCancel(self, *event):
        return self.mDone(3)

    def wmDeleteWindow(self, *event):
        return self.mDone(3)

    def gameSelected(self, *event):
        name = self.games_var.get()
        if not name:
            return
        id = self.games[name]
        self.app.menubar._mSelectGame(id)

    def _reset(self):
        self.play_button.config(state='disabled')
        self.setText(iter='', depth='', states='')
        self.result_label['text'] = ''
        self.top.update_idletasks()

    def reset(self):
        self.play_button.config(state='disabled')

    def startSolving(self):
        from pysollib.mygettext import ungettext

        self._reset()
        game = self.app.game
        solver = game.Solver_Class(game, self)  # create solver instance
        game.solver = solver
        preset = self.preset_var.get()
        max_iters = self._getMaxIters()
        progress = self.app.opt.solver_show_progress
        iters_step = self.app.opt.solver_iterations_output_step
        solver.config(preset=preset, max_iters=max_iters, progress=progress,
                      iters_step=iters_step)
        try:
            solver.computeHints()
        except RuntimeError:
            self.result_label['text'] = _('Solver not found in the PATH')
            return
        hints_len = len(solver.hints)-1
        if hints_len > 0:
            if solver.solver_state == 'intractable':
                t = ungettext('This game can be hinted in %d move.',
                              'This game can be hinted in %d moves.',
                              hints_len)
            else:
                t = ungettext('This game is solvable in %d move.',
                              'This game is solvable in %d moves.',
                              hints_len)
            t = t % hints_len
            self.result_label['text'] = t
            self.play_button.config(state='normal')
        else:
            self.result_label['text'] = \
                (_('I could not solve this game.')
                 if solver.solver_state == 'unsolved'
                 else _('Iterations count exceeded (Intractable)'))
            self.play_button.config(state='disabled')

    def startPlay(self):
        self.play_button.config(state='disabled')
        self.start_button.focus()
        if self.app.game.pause:
            self.app.menubar.mPause()
        self.app.top.tkraise()
        self.app.top.update_idletasks()
        self.app.top.update()
        self.app.top.after(200)
        self.app.game.startDemo(level=3)

    def setText(self, **kw):
        if 'iter' in kw:
            self.iter_label['text'] = kw['iter']
        if 'depth' in kw:
            self.depth_label['text'] = kw['depth']
        if 'states' in kw:
            self.states_label['text'] = kw['states']
        self.top.update_idletasks()


solver_dialog = None


def connect_game_solver_dialog(game):
    try:
        solver_dialog.connectGame(game)
    except Exception:
        pass


def destroy_solver_dialog():
    global solver_dialog
    try:
        solver_dialog.destroy()
    except Exception:
        # traceback.print_exc()
        pass
    solver_dialog = None


def reset_solver_dialog():
    if solver_dialog:
        try:
            solver_dialog.reset()
        except Exception:
            # traceback.print_exc()
            pass
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

# ************************************************************************
# * Nodes
# ************************************************************************

# imports
from six.moves import tkinter_font


class BaseSelectDialogTreeLeaf:
    def drawSymbol(self, x, y, **kw):
        if self.tree.nodes.get(self.symbol_id) is not self:
            self.symbol_id = self.tree.canvas.create_image(
                x, y,
                image=self.tree.data.img[2+(self.key is None)], anchor="nw")
            self.tree.nodes[self.symbol_id] = self


class BaseSelectDialogTreeNode:
    def __init__(self, tree, text, select_func, expanded=0, parent_node=None):
        self._calc_MfxTreeNode().__init__(
            self, tree, parent_node, text, key=None, expanded=expanded)
        # callable or a tuple/list of MfxTreeNodes
        self.select_func = select_func

    def drawSymbol(self, x, y, **kw):
        if self.tree.nodes.get(self.symbol_id) is not self:
            self.symbol_id = self.tree.canvas.create_image(
                x, y,
                image=self.tree.data.img[self.expanded], anchor="nw")
            self.tree.nodes[self.symbol_id] = self

    def getContents(self):
        # cached values
        if self.subnodes is not None:
            return self.subnodes
        # print self.whoami()
        if isinstance(self.select_func, (tuple, list)):
            return self.select_func
        return self._getContents()

    def _getContents(self):
        # subclass
        return []


# ************************************************************************
# * Tree database
# ************************************************************************

class SelectDialogTreeData:
    img = []  # loaded in Application.loadImages3

    def __init__(self):
        self.tree_xview = (0.0, 1.0)
        self.tree_yview = (0.0, 1.0)


# ************************************************************************
# * Canvas that shows the tree (left side)
# ************************************************************************

class BaseSelectDialogTreeCanvas:
    def __init__(self, dialog, parent, key, default,
                 font=None, width=-1, height=-1, hbar=2, vbar=3):
        self.dialog = dialog
        self.default = default
        self.n_selections = 0
        self.n_expansions = 0
        #
        disty = 16
        if width < 0:
            width = 400
        if height < 0:
            height = 20 * disty
            if parent and parent.winfo_screenheight() >= 600:
                height = 25 * disty
            if parent and parent.winfo_screenheight() >= 800:
                height = 30 * disty
        self.lines = height // disty
        self._calc_MfxTreeInCanvas().__init__(
                self, parent, self.data.rootnodes,
                width=width, height=height,
                hbar=hbar, vbar=vbar)
        self.style.distx = 20
        self.style.disty = disty
        self.style.width = 16     # width of symbol
        self.style.height = 14    # height of symbol
        if font:
            self.style.font = font
            f = tkinter_font.Font(parent, font)
            h = f.metrics()["linespace"]
            self.style.disty = max(self.style.width, h)

        self.draw()
        self.updateSelection(key)
        if self.hbar:
            # print self.data.tree_yview
            # print self.canvas.xview()
            self.canvas.xview_moveto(self.data.tree_xview[0])
        if self.vbar:
            # print self.data.tree_yview
            # print self.canvas.yview()
            self.canvas.yview_moveto(self.data.tree_yview[0])

    def destroy(self):
        if self.n_expansions > 0:   # must save updated xyview
            self.data.tree_xview = self.canvas.xview()
            self.data.tree_yview = self.canvas.yview()
        self._calc_MfxTreeInCanvas().destroy(self)

    def getContents(self, node):
        return node.getContents()

    def singleClick(self, event=None):
        node = self.findNode()
        if isinstance(node, self._calc_MfxTreeLeaf()):
            if not node.selected and node.key is not None:
                oldcur = self.canvas["cursor"]
                self.canvas["cursor"] = "watch"
                self.canvas.update_idletasks()
                self.n_selections = self.n_selections + 1
                self.updateSelection(node.key)
                self.dialog.updatePreview(self.selection_key)
                self.canvas["cursor"] = oldcur
        elif isinstance(node, self._calc_MfxTreeNode()):
            self.n_expansions = self.n_expansions + 1
            node.expanded = not node.expanded
            self.redraw()
        return "break"

    def doubleClick(self, event=None):
        node = self.findNode()
        if isinstance(node, self._calc_MfxTreeLeaf()):
            if node.key is not None:
                self.n_selections = self.n_selections + 1
                self.updateSelection(node.key)
                self.dialog.mDone(self.default)
        elif isinstance(node, self._calc_MfxTreeNode()):
            self.n_expansions = self.n_expansions + 1
            node.expanded = not node.expanded
            self.redraw()
        return "break"
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

from pysollib.mfxutil import KwStruct
from pysollib.mygettext import _

from six.moves import tkinter
from six.moves.tkinter_colorchooser import askcolor


class BaseColorsDialog:
    def _calcFrame(self):
        return self._calcToolkit().Frame

    def _calcLabel(self):
        return self._calcToolkit().Label

    def _calcButton(self):
        return self._calcToolkit().Button

    def __init__(self, parent, title, app, **kw):
        kw = self.initKw(kw)
        self._calc_MfxDialog().__init__(
            self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.createBitmaps(top_frame, kw)

        frame = self._calcFrame()(top_frame)
        frame.pack(expand=True, fill='both', padx=5, pady=10)
        frame.columnconfigure(0, weight=1)

        self.text_var = tkinter.StringVar()
        self.text_var.set(app.opt.colors['text'])
        self.piles_var = tkinter.StringVar()
        self.piles_var.set(app.opt.colors['piles'])
        self.cards_1_var = tkinter.StringVar()
        self.cards_1_var.set(app.opt.colors['cards_1'])
        self.cards_2_var = tkinter.StringVar()
        self.cards_2_var.set(app.opt.colors['cards_2'])
        self.samerank_1_var = tkinter.StringVar()
        self.samerank_1_var.set(app.opt.colors['samerank_1'])
        self.samerank_2_var = tkinter.StringVar()
        self.samerank_2_var.set(app.opt.colors['samerank_2'])
        self.hintarrow_var = tkinter.StringVar()
        self.hintarrow_var.set(app.opt.colors['hintarrow'])
        self.not_matching_var = tkinter.StringVar()
        self.not_matching_var.set(app.opt.colors['not_matching'])
        #
        row = 0
        for title, var in (
            (_('Text foreground:'),        self.text_var),
            (_('Highlight piles:'),        self.piles_var),
            (_('Highlight cards 1:'),      self.cards_1_var),
            (_('Highlight cards 2:'),      self.cards_2_var),
            (_('Highlight same rank 1:'),  self.samerank_1_var),
            (_('Highlight same rank 2:'),  self.samerank_2_var),
            (_('Hint arrow:'),             self.hintarrow_var),
            (_('Highlight not matching:'), self.not_matching_var),
                ):
            self._calcLabel()(
                frame, text=title, anchor='w',).grid(
                row=row, column=0, sticky='we')
            label = tkinter.Label(frame, width=10, height=2,
                                  bg=var.get(), textvariable=var)
            label.grid(row=row, column=1, padx=5)
            b = self._calcButton()(
                frame, text=_('Change...'), width=10,
                command=lambda label=label: self.selectColor(label))
            b.grid(row=row, column=2)
            row += 1
        #
        focus = self.createButtons(bottom_frame, kw)
        self.mainloop(focus, kw.timeout)
        #
        self.text_color = self.text_var.get()
        self.piles_color = self.piles_var.get()
        self.cards_1_color = self.cards_1_var.get()
        self.cards_2_color = self.cards_2_var.get()
        self.samerank_1_color = self.samerank_1_var.get()
        self.samerank_2_color = self.samerank_2_var.get()
        self.hintarrow_color = self.hintarrow_var.get()
        self.not_matching_color = self.not_matching_var.get()

    def selectColor(self, label):
        try:
            c = askcolor(parent=self.top, initialcolor=label.cget('bg'),
                         title=_("Select color"))
        except Exception:
            pass
        else:
            if c and c[1]:
                label.configure(bg=c[1])
                # label.configure(text=c[1]) # don't work
                label.setvar(label.cget('textvariable'), c[1])

    def initKw(self, kw):
        kw = KwStruct(kw,
                      strings=(_("&OK"), _("&Cancel")),
                      default=0,
                      )
        return self._calc_MfxDialog().initKw(self, kw)
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

import formatter
import os
import sys

import pysollib.htmllib2 as htmllib
from pysollib.mfxutil import openURL
from pysollib.mygettext import _
from pysollib.settings import TITLE
from pysollib.ui.tktile.tkutil import bind, unbind_destroy

from six.moves import tkinter

REMOTE_PROTOCOLS = ("ftp:", "gopher:", "http:", "mailto:", "news:", "telnet:")

# ************************************************************************
# *
# ************************************************************************


class tkHTMLWriter(formatter.NullWriter):
    def __init__(self, text, viewer, app):
        formatter.NullWriter.__init__(self)

        self.text = text
        self.viewer = viewer

        if app:
            font = app.getFont("sans")
            fixed = app.getFont("fixed")
        else:
            font = ('helvetica', 12)
            fixed = ('courier', 12)
        size = font[1]
        sign = 1
        if size < 0:
            sign = -1
        self.fontmap = {
            "h1": (font[0], size + 12*sign, "bold"),
            "h2": (font[0], size + 8*sign, "bold"),
            "h3": (font[0], size + 6*sign, "bold"),
            "h4": (font[0], size + 4*sign, "bold"),
            "h5": (font[0], size + 2*sign, "bold"),
            "h6": (font[0], size + 1*sign, "bold"),
            "bold": (font[0], size, "bold"),
            "italic": (font[0], size, "italic"),
            "pre": fixed,
        }

        self.text.config(cursor=self.viewer.defcursor, font=font)
        for f in self.fontmap.keys():
            self.text.tag_config(f, font=self.fontmap[f])

        self.anchor = None
        self.anchor_mark = None
        self.font = None
        self.font_mark = None
        self.indent = ""

    def createCallback(self, href):
        class Functor:
            def __init__(self, viewer, arg):
                self.viewer = viewer
                self.arg = arg

            def __call__(self, *args):
                self.viewer.updateHistoryXYView()
                return self.viewer.display(self.arg)
        return Functor(self.viewer, href)

    def write(self, data):
        self.text.insert("insert", str(data))

    def anchor_bgn(self, href, name, type):
        if href:
            # self.text.update_idletasks()   # update display during parsing
            self.anchor = (href, name, type)
            self.anchor_mark = self.text.index("insert")

    def anchor_end(self):
        if self.anchor:
            url = self.anchor[0]
            tag = "href_" + url
            self.text.tag_add(tag, self.anchor_mark, "insert")
            self.text.tag_bind(tag, "<1>", self.createCallback(url))
            self.text.tag_bind(
                tag, "<Enter>", lambda e: self.anchor_enter(url))
            self.text.tag_bind(tag, "<Leave>", self.anchor_leave)
            fg = 'blue'
            u = self.viewer.normurl(url, with_protocol=False)
            if u in self.viewer.visited_urls:
                fg = '#660099'
            self.text.tag_config(tag, foreground=fg, underline=1)
            self.anchor = None

    def anchor_enter(self, url):
        url = self.viewer.normurl(url)
        self.viewer.statusbar.updateText(url=url)
        self.text.config(cursor=self.viewer.handcursor)

    def anchor_leave(self, *args):
        self.viewer.statusbar.updateText(url='')
        self.text.config(cursor=self.viewer.defcursor)

    def new_font(self, font):
        # end the current font
        if self.font:
            # print "end_font(%s)" % `self.font`
            self.text.tag_add(self.font, self.font_mark, "insert")
            self.font = None
        # start the new font
        if font:
            # print "start_font(%s)" % `font`
            self.font_mark = self.text.index("insert")
            if font[0] in self.fontmap:
                self.font = font[0]
            elif font[3]:
                self.font = "pre"
            elif font[2]:
                self.font = "bold"
            elif font[1]:
                self.font = "italic"
            else:
                self.font = None

    def new_margin(self, margin, level):
        self.indent = "    " * level

    def send_label_data(self, data):
        # self.write(self.indent + data + " ")
        self.write(self.indent)
        if data == '*':  # <li>
            img = self.viewer.symbols_img.get('disk')
            if img:
                self.text.image_create(index='insert', image=img,
                                       padx=0, pady=0)
            else:
                self.write('*')
        else:
            self.write(data)
        self.write(' ')

    def send_paragraph(self, blankline):
        self.write("\n" * blankline)

    def send_line_break(self):
        self.write("\n")

    def send_hor_rule(self, *args):
        width = int(int(self.text["width"]) * 0.9)
        self.write("_" * width)
        self.write("\n")

    def send_literal_data(self, data):
        self.write(data)

    def send_flowing_data(self, data):
        self.write(data)


# ************************************************************************
# *
# ************************************************************************

class tkHTMLParser(htmllib.HTMLParser):
    def anchor_bgn(self, href, name, type):
        self.formatter.flush_softspace()
        htmllib.HTMLParser.anchor_bgn(self, href, name, type)
        self.formatter.writer.anchor_bgn(href, name, type)

    def anchor_end(self):
        if self.anchor:
            self.anchor = None
        self.formatter.writer.anchor_end()

    def do_dt(self, attrs):
        self.formatter.end_paragraph(1)
        self.ddpop()

    def handle_image(self, src, alt, ismap, align, width, height):
        self.formatter.writer.viewer.showImage(
            src, alt, ismap, align, width, height)


class Base_HTMLViewer:
    def initBindings(self):
        w = self.parent
        bind(w, "WM_DELETE_WINDOW", self.destroy)
        bind(w, "<Escape>", self.destroy)
        bind(w, "<KeyPress-Prior>", self.page_up)
        bind(w, "<KeyPress-Next>", self.page_down)
        bind(w, "<KeyPress-Up>", self.unit_up)
        bind(w, "<KeyPress-Down>", self.unit_down)
        bind(w, "<KeyPress-Begin>", self.scroll_top)
        bind(w, "<KeyPress-Home>", self.scroll_top)
        bind(w, "<KeyPress-End>", self.scroll_bottom)
        bind(w, "<KeyPress-BackSpace>", self.goBack)

    def destroy(self, *event):
        unbind_destroy(self.parent)
        try:
            self.parent.wm_withdraw()
        except Exception:
            pass
        try:
            self.parent.destroy()
        except Exception:
            pass
        self.parent = None

    def _yview(self, *args):
        self.text.yview(*args)
        return 'break'

    def page_up(self, *event):
        return self._yview('scroll', -1, 'page')

    def page_down(self, *event):
        return self._yview('scroll', 1, 'page')

    def unit_up(self, *event):
        return self._yview('scroll', -1, 'unit')

    def unit_down(self, *event):
        return self._yview('scroll', 1, 'unit')

    def scroll_top(self, *event):
        return self._yview('moveto', 0)

    def scroll_bottom(self, *event):
        return self._yview('moveto', 1)

    # locate a file relative to the current self.url
    def basejoin(self, url, baseurl=None, relpath=1):
        if baseurl is None:
            baseurl = self.url
        if 0:
            import urllib.request
            import urllib.parse
            import urllib.error
            url = urllib.request.pathname2url(url)
            if relpath and self.url:
                url = urllib.basejoin(baseurl, url)
        else:
            url = os.path.normpath(url)
            if relpath and baseurl and not os.path.isabs(url):
                h1, t1 = os.path.split(url)
                h2, t2 = os.path.split(baseurl)
                if h1 != h2:
                    url = os.path.join(h2, h1, t1)
                url = os.path.normpath(url)
        return url

    def normurl(self, url, with_protocol=True):
        for p in REMOTE_PROTOCOLS:
            if url.startswith(p):
                break
        else:
            url = self.basejoin(url)
            if with_protocol:
                if os.name == 'nt':
                    url = url.replace('\\', '/')
                url = 'file://'+url
        return url

    def openfile(self, url):
        if url[-1:] == "/" or os.path.isdir(url):
            url = os.path.join(url, "index.html")
        url = os.path.normpath(url)

        def my_open(url):
            if sys.version_info > (3,):
                import codecs
                return codecs.open(url, encoding='utf-8')
            else:
                return open(url, "rb")
        return my_open(url), url

    def display(self, url, add=1, relpath=1, xview=0, yview=0):
        # for some reason we have to stop the PySol demo
        # (is this a multithread problem with tkinter ?)
        if self.app and self.app.game:
            self.app.game.stopDemo()
            # self.app.game._cancelDrag()
            # pass

        # ftp: and http: would work if we use urllib, but this widget is
        # far too limited to display anything but our documentation...
        for p in REMOTE_PROTOCOLS:
            if url.startswith(p):
                if not openURL(url):
                    self.errorDialog(_('''%(app)s HTML limitation:
The %(protocol)s protocol is not supported yet.

Please use your standard web browser
to open the following URL:
%(url)s
''') % {'app': TITLE, 'protocol': p, 'url': url})
                return

        # locate the file relative to the current url
        url = self.basejoin(url, relpath=relpath)

        # read the file
        try:
            file = None
            if 0:
                import urllib.request
                import urllib.parse
                import urllib.error
                file = urllib.request.urlopen(url)
            else:
                file, url = self.openfile(url)
            data = file.read()
            file.close()
            file = None
        except Exception as ex:
            if file:
                file.close()
            self.errorDialog(_("Unable to service request:\n") + url +
                             "\n\n" + str(ex))
            return
        except Exception:
            if file:
                file.close()
            self.errorDialog(_("Unable to service request:\n") + url)
            return

        self.url = url
        if self.home is None:
            self.home = self.url
        if add:
            self.addHistory(self.url, xview=xview, yview=yview)

        # print self.history.index, self.history.list
        if self.history.index > 1:
            self.backButton.config(state="normal")
        else:
            self.backButton.config(state="disabled")
        if self.history.index < len(self.history.list):
            self.forwardButton.config(state="normal")
        else:
            self.forwardButton.config(state="disabled")

        old_c1, old_c2 = self.defcursor, self.handcursor
        self.defcursor = self.handcursor = "watch"
        self.text.config(cursor=self.defcursor)
        self.text.update_idletasks()
        # self.frame.config(cursor=self.defcursor)
        # self.frame.update_idletasks()
        self.text.config(state="normal")
        self.text.delete("1.0", "end")
        # self.images = {}
        writer = tkHTMLWriter(self.text, self, self.app)
        fmt = formatter.AbstractFormatter(writer)
        parser = tkHTMLParser(fmt)
        parser.feed(data)
        parser.close()
        self.text.config(state="disabled")
        if 0.0 <= xview <= 1.0:
            self.text.xview_moveto(xview)
        if 0.0 <= yview <= 1.0:
            self.text.yview_moveto(yview)
        self.parent.wm_title(parser.title)
        self.parent.wm_iconname(parser.title)
        self.defcursor, self.handcursor = old_c1, old_c2
        self.text.config(cursor=self.defcursor)
        # self.frame.config(cursor=self.defcursor)

    def addHistory(self, url, xview=0, yview=0):
        if url not in self.visited_urls:
            self.visited_urls.append(url)
        if self.history.index > 0:
            u, xv, yv = self.history.list[self.history.index-1]
            if u == url:
                self.updateHistoryXYView()
                return
        del self.history.list[self.history.index:]
        self.history.list.append((url, xview, yview))
        self.history.index = self.history.index + 1

    def updateHistoryXYView(self):
        if self.history.index > 0:
            url, xview, yview = self.history.list[self.history.index-1]
            xview = self.text.xview()[0]
            yview = self.text.yview()[0]
            self.history.list[self.history.index-1] = (url, xview, yview)

    def goBack(self, *event):
        if self.history.index > 1:
            self.updateHistoryXYView()
            self.history.index = self.history.index - 1
            url, xview, yview = self.history.list[self.history.index-1]
            self.display(url, add=0, relpath=0, xview=xview, yview=yview)

    def goForward(self, *event):
        if self.history.index < len(self.history.list):
            self.updateHistoryXYView()
            url, xview, yview = self.history.list[self.history.index]
            self.history.index = self.history.index + 1
            self.display(url, add=0, relpath=0, xview=xview, yview=yview)

    def goHome(self, *event):
        if self.home and self.home != self.url:
            self.updateHistoryXYView()
            self.display(self.home, relpath=0)

    def errorDialog(self, msg):
        self._calc_MfxMessageDialog()(
            self.parent, title="%(app)s HTML Problem" % {'app': TITLE},
            text=msg,
            # bitmap="warning", # FIXME: this interp don't have images
            strings=(_("&OK"),), default=0)

    def getImage(self, fn):
        if fn in self.images:
            return self.images[fn]
        try:
            img = tkinter.PhotoImage(master=self.parent, file=fn)
        except Exception:
            img = None
        self.images[fn] = img
        return img

    def showImage(self, src, alt, ismap, align, width, height):
        url = self.basejoin(src)
        img = self.getImage(url)
        if img:
            self.text.image_create(index="insert", image=img, padx=0, pady=0)
import math
import os
import re
import sys

from pysollib.gamedb import GI
from pysollib.hint import PySolHintLayoutImportError
from pysollib.mfxutil import Image, USE_PIL
from pysollib.mfxutil import Struct, kwdefault
from pysollib.mygettext import _, n_
from pysollib.settings import SELECT_GAME_MENU
from pysollib.settings import TITLE, WIN_SYSTEM
from pysollib.settings import USE_FREECELL_SOLVER
from pysollib.ui.tktile.tkconst import COMPOUNDS, CURSOR_WATCH, EVENT_HANDLED
from pysollib.ui.tktile.tkconst import EVENT_PROPAGATE
from pysollib.ui.tktile.tkconst import TOOLBAR_BUTTONS
from pysollib.ui.tktile.tkutil import after_idle, bind

from six.moves import tkinter
from six.moves import tkinter_tkfiledialog


def createToolbarMenu(menubar, menu):
    tearoff = menu.cget('tearoff')
#     data_dir = os.path.join(menubar.app.dataloader.dir, 'images', 'toolbar')
#     submenu = MfxMenu(menu, label=n_('Style'), tearoff=tearoff)
#     for f in os.listdir(data_dir):
#         d = os.path.join(data_dir, f)
#         if os.path.isdir(d) and os.path.exists(os.path.join(d, 'small')):
#             name = f.replace('_', ' ').capitalize()
#             submenu.add_radiobutton(
#               label=name,
#               variable=menubar.tkopt.toolbar_style,
#               value=f, command=menubar.mOptToolbarStyle)
    submenu = MfxMenu(menu, label=n_('Compound'), tearoff=tearoff)
    for comp, label in COMPOUNDS:
        submenu.add_radiobutton(
            label=label, variable=menubar.tkopt.toolbar_compound,
            value=comp, command=menubar.mOptToolbarCompound)
    menu.add_separator()
    menu.add_radiobutton(label=n_("Hide"),
                         variable=menubar.tkopt.toolbar, value=0,
                         command=menubar.mOptToolbar)
    menu.add_radiobutton(label=n_("Top"),
                         variable=menubar.tkopt.toolbar, value=1,
                         command=menubar.mOptToolbar)
    menu.add_radiobutton(label=n_("Bottom"),
                         variable=menubar.tkopt.toolbar, value=2,
                         command=menubar.mOptToolbar)
    menu.add_radiobutton(label=n_("Left"),
                         variable=menubar.tkopt.toolbar, value=3,
                         command=menubar.mOptToolbar)
    menu.add_radiobutton(label=n_("Right"),
                         variable=menubar.tkopt.toolbar, value=4,
                         command=menubar.mOptToolbar)
    #  menu.add_separator()
    #  menu.add_radiobutton(label=n_("Small icons"),
    #                       variable=menubar.tkopt.toolbar_size, value=0,
    #                       command=menubar.mOptToolbarSize)
    #  menu.add_radiobutton(label=n_("Large icons"),
    #                       variable=menubar.tkopt.toolbar_size, value=1,
    #                       command=menubar.mOptToolbarSize)
    menu.add_separator()
    submenu = MfxMenu(menu, label=n_('Visible buttons'), tearoff=tearoff)
    for w in TOOLBAR_BUTTONS:
        submenu.add_checkbutton(
            label=_(w.capitalize()),
            variable=menubar.tkopt.toolbar_vars[w],
            command=lambda m=menubar, w=w: m.mOptToolbarConfig(w))


# ************************************************************************
# *
# ************************************************************************

class MfxMenubar(tkinter.Menu):
    addPath = None

    def __init__(self, master, **kw):
        self.name = kw["name"]
        tearoff = 0
        self.n = kw["tearoff"] = int(kw.get("tearoff", tearoff))
        tkinter.Menu.__init__(self, master, **kw)

    def labeltoname(self, label):
        # print label, type(label)
        name = re.sub(r"[^0-9a-zA-Z]", "", label).lower()
        label = _(label)
        underline = label.find('&')
        if underline >= 0:
            label = label.replace('&', '')
        return name, label, underline

    def add(self, itemType, cnf={}):
        label = cnf.get("label")
        if label:
            name = cnf.get('name')
            if name:
                del cnf['name']  # TclError: unknown option "-name"
            else:
                name, label, underline = self.labeltoname(label)
                cnf["underline"] = cnf.get("underline", underline)
            cnf["label"] = label
            if name and self.addPath:
                path = str(self._w) + "." + name
                self.addPath(path, self, self.n, cnf.get("menu"))
        tkinter.Menu.add(self, itemType, cnf)
        self.n = self.n + 1


class MfxMenu(MfxMenubar):
    def __init__(self, master, label, underline=None, **kw):
        if 'name' in kw:
            name, label_underline = kw['name'], -1
        else:
            name, label, label_underline = self.labeltoname(label)
        kwdefault(kw, name=name)
        MfxMenubar.__init__(self, master, **kw)
        if underline is None:
            underline = label_underline
        if master:
            master.add_cascade(
                menu=self, name=name, label=label, underline=underline)


class PysolMenubarTkCommon:
    def __init__(self, app, top, progress=None):
        self._createTkOpt()
        self._setOptions()
        # init columnbreak
        self.cb_max = int(self.top.winfo_screenheight()//23)
        #  sh = self.top.winfo_screenheight()
        #  self.cb_max = 22
        #  if sh >= 600: self.cb_max = 27
        #  if sh >= 768: self.cb_max = 32
        #  if sh >= 1024: self.cb_max = 40
        self.progress = progress
        # create menus
        self.menubar = None
        self.menupath = {}
        self.keybindings = {}
        self._createMenubar()
        self.top = top

        if self.progress:
            self.progress.update(step=1)

        # set the menubar
        self.updateBackgroundImagesMenu()
        self.top.config(menu=self.menubar)

    def _createTkOpt(self):
        # structure to convert menu-options to Toolkit variables
        self.tkopt = Struct(
            gameid=tkinter.IntVar(),
            gameid_popular=tkinter.IntVar(),
            comment=tkinter.BooleanVar(),
            autofaceup=tkinter.BooleanVar(),
            autodrop=tkinter.BooleanVar(),
            autodeal=tkinter.BooleanVar(),
            quickplay=tkinter.BooleanVar(),
            undo=tkinter.BooleanVar(),
            bookmarks=tkinter.BooleanVar(),
            hint=tkinter.BooleanVar(),
            shuffle=tkinter.BooleanVar(),
            highlight_piles=tkinter.BooleanVar(),
            highlight_cards=tkinter.BooleanVar(),
            highlight_samerank=tkinter.BooleanVar(),
            highlight_not_matching=tkinter.BooleanVar(),
            mahjongg_show_removed=tkinter.BooleanVar(),
            shisen_show_hint=tkinter.BooleanVar(),
            sound=tkinter.BooleanVar(),
            auto_scale=tkinter.BooleanVar(),
            cardback=tkinter.IntVar(),
            tabletile=tkinter.IntVar(),
            animations=tkinter.IntVar(),
            redeal_animation=tkinter.BooleanVar(),
            win_animation=tkinter.BooleanVar(),
            shadow=tkinter.BooleanVar(),
            shade=tkinter.BooleanVar(),
            shade_filled_stacks=tkinter.BooleanVar(),
            shrink_face_down=tkinter.BooleanVar(),
            toolbar=tkinter.IntVar(),
            toolbar_style=tkinter.StringVar(),
            toolbar_relief=tkinter.StringVar(),
            toolbar_compound=tkinter.StringVar(),
            toolbar_size=tkinter.IntVar(),
            statusbar=tkinter.BooleanVar(),
            num_cards=tkinter.BooleanVar(),
            helpbar=tkinter.BooleanVar(),
            save_games_geometry=tkinter.BooleanVar(),
            splashscreen=tkinter.BooleanVar(),
            demo_logo=tkinter.BooleanVar(),
            mouse_type=tkinter.StringVar(),
            mouse_undo=tkinter.BooleanVar(),
            negative_bottom=tkinter.BooleanVar(),
            pause=tkinter.BooleanVar(),
            theme=tkinter.StringVar(),
            toolbar_vars={},
        )
        for w in TOOLBAR_BUTTONS:
            self.tkopt.toolbar_vars[w] = tkinter.BooleanVar()

    def _setOptions(self):
        tkopt, opt = self.tkopt, self.app.opt
        # set state of the menu items
        tkopt.autofaceup.set(opt.autofaceup)
        tkopt.autodrop.set(opt.autodrop)
        tkopt.autodeal.set(opt.autodeal)
        tkopt.quickplay.set(opt.quickplay)
        tkopt.undo.set(opt.undo)
        tkopt.hint.set(opt.hint)
        tkopt.shuffle.set(opt.shuffle)
        tkopt.bookmarks.set(opt.bookmarks)
        tkopt.highlight_piles.set(opt.highlight_piles)
        tkopt.highlight_cards.set(opt.highlight_cards)
        tkopt.highlight_samerank.set(opt.highlight_samerank)
        tkopt.highlight_not_matching.set(opt.highlight_not_matching)
        tkopt.shrink_face_down.set(opt.shrink_face_down)
        tkopt.shade_filled_stacks.set(opt.shade_filled_stacks)
        tkopt.mahjongg_show_removed.set(opt.mahjongg_show_removed)
        tkopt.shisen_show_hint.set(opt.shisen_show_hint)
        tkopt.sound.set(opt.sound)
        tkopt.auto_scale.set(opt.auto_scale)
        tkopt.cardback.set(self.app.cardset.backindex)
        tkopt.tabletile.set(self.app.tabletile_index)
        tkopt.animations.set(opt.animations)
        tkopt.redeal_animation.set(opt.redeal_animation)
        tkopt.win_animation.set(opt.win_animation)
        tkopt.shadow.set(opt.shadow)
        tkopt.shade.set(opt.shade)
        tkopt.toolbar.set(opt.toolbar)
        tkopt.toolbar_style.set(opt.toolbar_style)
        tkopt.toolbar_relief.set(opt.toolbar_relief)
        tkopt.toolbar_compound.set(opt.toolbar_compound)
        tkopt.toolbar_size.set(opt.toolbar_size)
        tkopt.toolbar_relief.set(opt.toolbar_relief)
        tkopt.statusbar.set(opt.statusbar)
        tkopt.num_cards.set(opt.num_cards)
        tkopt.helpbar.set(opt.helpbar)
        tkopt.save_games_geometry.set(opt.save_games_geometry)
        tkopt.demo_logo.set(opt.demo_logo)
        tkopt.splashscreen.set(opt.splashscreen)
        tkopt.mouse_type.set(opt.mouse_type)
        tkopt.mouse_undo.set(opt.mouse_undo)
        tkopt.negative_bottom.set(opt.negative_bottom)
        for w in TOOLBAR_BUTTONS:
            tkopt.toolbar_vars[w].set(opt.toolbar_vars.get(w, False))

    def connectGame(self, game):
        self.game = game
        if game is None:
            return
        assert self.app is game.app
        tkopt = self.tkopt
        tkopt.gameid.set(game.id)
        tkopt.gameid_popular.set(game.id)
        tkopt.comment.set(bool(game.gsaveinfo.comment))
        tkopt.pause.set(self.game.pause)
        if game.canFindCard():
            self._connect_game_find_card_dialog(game)
        else:
            self._destroy_find_card_dialog()
        self._connect_game_solver_dialog(game)

    # create a GTK-like path
    def _addPath(self, path, menu, index, submenu):
        if path not in self.menupath:
            # print path, menu, index, submenu
            self.menupath[path] = (menu, index, submenu)

    def _getEnabledState(self, enabled):
        if enabled:
            return "normal"
        return "disabled"

    def updateProgress(self):
        if self.progress:
            self.progress.update(step=1)

    def _createMenubar(self):
        MfxMenubar.addPath = self._addPath
        kw = {"name": "menubar"}
        self.menubar = MfxMenubar(self.top, **kw)

        # init keybindings
        bind(self.top, "<KeyPress>", self._keyPressHandler)

        m = "Ctrl-"
        if sys.platform == "darwin":
            m = "Cmd-"

        if WIN_SYSTEM == "aqua":
            applemenu = MfxMenu(self.menubar, "apple")
            applemenu.add_command(
                label=_("&About %s") % TITLE, command=self.mHelpAbout)

        menu = MfxMenu(self.menubar, n_("&File"))
        menu.add_command(
            label=n_("&New game"), command=self.mNewGame, accelerator="N")
        submenu = MfxMenu(menu, label=n_("R&ecent games"))
        # menu.add_command(label=n_("Select &random game"),
        #   command=self.mSelectRandomGame, accelerator=m+"R")
        submenu = MfxMenu(menu, label=n_("Select &random game"))
        submenu.add_command(
            label=n_("&All games"), command=lambda:
            self.mSelectRandomGame('all'), accelerator=m+"R")
        submenu.add_command(
            label=n_("Games played and &won"),
            command=lambda: self.mSelectRandomGame('won'))
        submenu.add_command(
            label=n_("Games played and &not won"),
            command=lambda: self.mSelectRandomGame('not won'))
        submenu.add_command(
            label=n_("Games not &played"),
            command=lambda: self.mSelectRandomGame('not played'))
        menu.add_command(
            label=n_("Select game by nu&mber..."),
            command=self.mSelectGameById, accelerator=m+"M")
        menu.add_separator()
        submenu = MfxMenu(menu, label=n_("Fa&vorite games"))
        menu.add_command(label=n_("A&dd to favorites"), command=self.mAddFavor)
        menu.add_command(
            label=n_("Remove &from favorites"),
            command=self.mDelFavor)
        menu.add_separator()
        menu.add_command(
            label=n_("&Open..."),
            command=self.mOpen, accelerator=m+"O")
        menu.add_command(
            label=n_("&Save"),
            command=self.mSave, accelerator=m+"S")
        menu.add_command(label=n_("Save &as..."), command=self.mSaveAs)
        menu.add_command(
            label=n_("E&xport current layout..."),
            command=self.mExportCurrentLayout)
        menu.add_command(
            label=n_("&Import starting layout..."),
            command=self.mImportStartingLayout)
        menu.add_separator()
        menu.add_command(
            label=n_("&Hold and quit"),
            command=self.mHoldAndQuit, accelerator=m+"X")
        if WIN_SYSTEM != "aqua":
            menu.add_command(
                label=n_("&Quit"),
                command=self.mQuit, accelerator=m+"Q")

        if self.progress:
            self.progress.update(step=1)

        menu = MfxMenu(self.menubar, label=n_("&Select"))
        self._addSelectGameMenu(menu)

        if self.progress:
            self.progress.update(step=1)

        menu = MfxMenu(self.menubar, label=n_("&Edit"))
        menu.add_command(
            label=n_("&Undo"),
            command=self.mUndo, accelerator="Z")
        menu.add_command(
            label=n_("&Redo"),
            command=self.mRedo, accelerator="R")
        menu.add_command(label=n_("Redo &all"), command=self.mRedoAll)

        menu.add_separator()
        submenu = MfxMenu(menu, label=n_("&Set bookmark"))
        for i in range(9):
            label = _("Bookmark %d") % (i + 1)
            submenu.add_command(
                label=label,
                command=lambda i=i: self.mSetBookmark(i))
        submenu = MfxMenu(menu, label=n_("Go&to bookmark"))
        for i in range(9):
            label = _("Bookmark %d") % (i + 1)
            acc = m + "%d" % (i + 1)
            submenu.add_command(
                label=label,
                command=lambda i=i: self.mGotoBookmark(i), accelerator=acc)
        menu.add_command(
            label=n_("&Clear bookmarks"),
            command=self.mClearBookmarks)
        menu.add_separator()

        menu.add_command(
            label=n_("Restart"),
            command=self.mRestart, accelerator=m+"G")

        menu.add_separator()
        menu.add_command(label=n_("Solitaire &Wizard"), command=self.mWizard)
        menu.add_command(
            label=n_("&Edit current game"),
            command=self.mWizardEdit)

        menu = MfxMenu(self.menubar, label=n_("&Game"))
        menu.add_command(
            label=n_("&Deal cards"),
            command=self.mDeal, accelerator="D")
        menu.add_command(
            label=n_("&Auto drop"),
            command=self.mDrop, accelerator="A")
        menu.add_command(
            label=n_("Shu&ffle tiles"),
            command=self.mShuffle, accelerator="F")
        menu.add_checkbutton(
            label=n_("&Pause"), variable=self.tkopt.pause,
            command=self.mPause, accelerator="P")
        # menu.add_command(
        #    label=n_("&Pause"), command=self.mPause, accelerator="P")
        menu.add_separator()
        menu.add_command(
            label=n_("S&tatus..."),
            command=lambda: self.mPlayerStats(mode=100), accelerator=m+"Y")
        menu.add_checkbutton(
            label=n_("&Comments..."), variable=self.tkopt.comment,
            command=self.mEditGameComment)
        menu.add_separator()
        menu.add_command(
            label=n_("&Statistics..."),
            command=self.mPlayerStats, accelerator=m+"T")
        menu.add_command(
            label=n_("Log..."),
            command=lambda: self.mPlayerStats(mode=103))
        menu.add_separator()
        menu.add_command(
            label=n_("D&emo statistics"),
            command=lambda: self.mPlayerStats(mode=1101))

        menu = MfxMenu(self.menubar, label=n_("&Assist"))
        menu.add_command(
            label=n_("&Hint"),
            command=self.mHint, accelerator="H")
        menu.add_command(
            label=n_("Highlight p&iles"),
            command=self.mHighlightPiles, accelerator="I")
        menu.add_command(
            label=n_("&Find card"),
            command=self.mFindCard, accelerator="F3")
        menu.add_separator()
        menu.add_command(
            label=n_("&Demo"),
            command=self.mDemo, accelerator=m+"D")
        menu.add_command(
            label=n_("Demo (&all games)"),
            command=self.mMixedDemo)
        if USE_FREECELL_SOLVER:
            menu.add_command(label=n_("&Solver"), command=self.mSolver)
        else:
            menu.add_command(label=n_("&Solver"), state='disabled')
        menu.add_separator()
        menu.add_command(
            label=n_("&Piles description"),
            command=self.mStackDesk, accelerator="F2")

        if self.progress:
            self.progress.update(step=1)

        menu = MfxMenu(self.menubar, label=n_("&Options"))
        menu.add_command(
            label=n_("&Player options..."),
            command=self.mOptPlayerOptions)
        submenu = MfxMenu(menu, label=n_("&Automatic play"))
        submenu.add_checkbutton(
            label=n_("Auto &face up"), variable=self.tkopt.autofaceup,
            command=self.mOptAutoFaceUp)
        submenu.add_checkbutton(
            label=n_("A&uto drop"), variable=self.tkopt.autodrop,
            command=self.mOptAutoDrop)
        submenu.add_checkbutton(
            label=n_("Auto &deal"), variable=self.tkopt.autodeal,
            command=self.mOptAutoDeal)
        submenu.add_separator()
        submenu.add_checkbutton(
            label=n_("&Quick play"), variable=self.tkopt.quickplay,
            command=self.mOptQuickPlay)
        submenu = MfxMenu(menu, label=n_("Assist &level"))
        submenu.add_checkbutton(
            label=n_("Enable &undo"), variable=self.tkopt.undo,
            command=self.mOptEnableUndo)
        submenu.add_checkbutton(
            label=n_("Enable &bookmarks"), variable=self.tkopt.bookmarks,
            command=self.mOptEnableBookmarks)
        submenu.add_checkbutton(
            label=n_("Enable &hint"), variable=self.tkopt.hint,
            command=self.mOptEnableHint)
        submenu.add_checkbutton(
            label=n_("Enable shu&ffle"), variable=self.tkopt.shuffle,
            command=self.mOptEnableShuffle)
        submenu.add_checkbutton(
            label=n_("Enable highlight p&iles"),
            variable=self.tkopt.highlight_piles,
            command=self.mOptEnableHighlightPiles)
        submenu.add_checkbutton(
            label=n_("Enable highlight &cards"),
            variable=self.tkopt.highlight_cards,
            command=self.mOptEnableHighlightCards)
        submenu.add_checkbutton(
            label=n_("Enable highlight same &rank"),
            variable=self.tkopt.highlight_samerank,
            command=self.mOptEnableHighlightSameRank)
        submenu.add_checkbutton(
            label=n_("Highlight &no matching"),
            variable=self.tkopt.highlight_not_matching,
            command=self.mOptEnableHighlightNotMatching)
        submenu.add_separator()
        submenu.add_checkbutton(
            label=n_("&Show removed tiles (in Mahjongg games)"),
            variable=self.tkopt.mahjongg_show_removed,
            command=self.mOptMahjonggShowRemoved)
        submenu.add_checkbutton(
            label=n_("Show hint &arrow (in Shisen-Sho games)"),
            variable=self.tkopt.shisen_show_hint,
            command=self.mOptShisenShowHint)
        menu.add_separator()
        label = n_("&Sound...")
        if not self.app.audio.CAN_PLAY_SOUND:
            menu.add_checkbutton(
                label=label, variable=self.tkopt.sound,
                command=self.mOptSoundDialog, state='disabled')
        else:
            menu.add_checkbutton(
                label=label, variable=self.tkopt.sound,
                command=self.mOptSoundDialog)
        # cardsets
        if USE_PIL:
            submenu = MfxMenu(menu, label=n_("Card si&ze"))
            submenu.add_command(
                label=n_("&Increase the card size"),
                command=self.mIncreaseCardset, accelerator=m+"+")
            submenu.add_command(
                label=n_("&Decrease the card size"),
                command=self.mDecreaseCardset, accelerator=m+"-")
            submenu.add_checkbutton(
                label=n_("&Auto scaling"), variable=self.tkopt.auto_scale,
                command=self.mOptAutoScale, accelerator=m+'0')
        # manager = self.app.cardset_manager
        # n = manager.len()
        menu.add_command(
            label=n_("Cards&et..."),
            command=self.mSelectCardsetDialog, accelerator=m+"E")
        menu.add_command(
            label=n_("Table t&ile..."),
            command=self.mSelectTileDialog)
        # this submenu will get set by updateBackgroundImagesMenu()
        submenu = MfxMenu(menu, label=n_("Card &background"))
        submenu = MfxMenu(menu, label=n_("Card &view"))
        submenu.add_checkbutton(
            label=n_("Card shado&w"), variable=self.tkopt.shadow,
            command=self.mOptShadow)
        submenu.add_checkbutton(
            label=n_("Shade &legal moves"), variable=self.tkopt.shade,
            command=self.mOptShade)
        submenu.add_checkbutton(
            label=n_("&Negative cards bottom"),
            variable=self.tkopt.negative_bottom,
            command=self.mOptNegativeBottom)
        submenu.add_checkbutton(
            label=n_("Shrink face-down cards"),
            variable=self.tkopt.shrink_face_down,
            command=self.mOptShrinkFaceDown)
        submenu.add_checkbutton(
            label=n_("Shade &filled stacks"),
            variable=self.tkopt.shade_filled_stacks,
            command=self.mOptShadeFilledStacks)
        submenu = MfxMenu(menu, label=n_("A&nimations"))
        submenu.add_radiobutton(
            label=n_("&None"), variable=self.tkopt.animations, value=0,
            command=self.mOptAnimations)
        submenu.add_radiobutton(
            label=n_("&Very fast"), variable=self.tkopt.animations, value=1,
            command=self.mOptAnimations)
        submenu.add_radiobutton(
            label=n_("&Fast"), variable=self.tkopt.animations, value=2,
            command=self.mOptAnimations)
        submenu.add_radiobutton(
            label=n_("&Medium"), variable=self.tkopt.animations, value=3,
            command=self.mOptAnimations)
        submenu.add_radiobutton(
            label=n_("&Slow"), variable=self.tkopt.animations, value=4,
            command=self.mOptAnimations)
        submenu.add_radiobutton(
            label=n_("V&ery slow"), variable=self.tkopt.animations, value=5,
            command=self.mOptAnimations)
        submenu.add_separator()
        submenu.add_checkbutton(
            label=n_("&Redeal animation"),
            variable=self.tkopt.redeal_animation,
            command=self.mRedealAnimation)
        if Image:
            submenu.add_checkbutton(
                label=n_("&Winning animation"),
                variable=self.tkopt.win_animation,
                command=self.mWinAnimation)
        submenu = MfxMenu(menu, label=n_("&Mouse"))
        submenu.add_radiobutton(
            label=n_("&Drag-and-Drop"), variable=self.tkopt.mouse_type,
            value='drag-n-drop',
            command=self.mOptMouseType)
        submenu.add_radiobutton(
            label=n_("&Point-and-Click"), variable=self.tkopt.mouse_type,
            value='point-n-click',
            command=self.mOptMouseType)
        submenu.add_radiobutton(
            label=n_("&Sticky mouse"), variable=self.tkopt.mouse_type,
            value='sticky-mouse',
            command=self.mOptMouseType)
        submenu.add_separator()
        submenu.add_checkbutton(
            label=n_("Use mouse for undo/redo"),
            variable=self.tkopt.mouse_undo,
            command=self.mOptMouseUndo)
        menu.add_separator()
        menu.add_command(label=n_("&Fonts..."), command=self.mOptFonts)
        menu.add_command(label=n_("&Colors..."), command=self.mOptColors)
        menu.add_command(label=n_("Time&outs..."), command=self.mOptTimeouts)
        menu.add_separator()
        self.createThemesMenu(menu)
        submenu = MfxMenu(menu, label=n_("&Toolbar"))
        createToolbarMenu(self, submenu)
        submenu = MfxMenu(menu, label=n_("Stat&usbar"))
        submenu.add_checkbutton(
            label=n_("Show &statusbar"), variable=self.tkopt.statusbar,
            command=self.mOptStatusbar)
        submenu.add_checkbutton(
            label=n_("Show &number of cards"), variable=self.tkopt.num_cards,
            command=self.mOptNumCards)
        submenu.add_checkbutton(
            label=n_("Show &help bar"), variable=self.tkopt.helpbar,
            command=self.mOptHelpbar)
        # if not USE_PIL:
        menu.add_checkbutton(
            label=n_("Save games &geometry"),
            variable=self.tkopt.save_games_geometry,
            command=self.mOptSaveGamesGeometry)
        menu.add_checkbutton(
            label=n_("&Demo logo"), variable=self.tkopt.demo_logo,
            command=self.mOptDemoLogo)
        menu.add_checkbutton(
            label=n_("Startup splash sc&reen"),
            variable=self.tkopt.splashscreen,
            command=self.mOptSplashscreen)
        #  menu.add_separator()
        #  menu.add_command(label="Save options", command=self.mOptSave)

        if self.progress:
            self.progress.update(step=1)

        menu = MfxMenu(self.menubar, label=n_("&Help"))
        menu.add_command(
            label=n_("&Contents"),
            command=self.mHelp, accelerator=m+"F1")
        menu.add_command(
            label=n_("&How to play"),
            command=self.mHelpHowToPlay)
        menu.add_command(
            label=n_("&Rules for this game"),
            command=self.mHelpRules, accelerator="F1")
        menu.add_command(
            label=n_("&License terms"),
            command=self.mHelpLicense)
        # menu.add_command(label=n_("What's &new ?"), command=self.mHelpNews)
        if WIN_SYSTEM != "aqua":
            menu.add_separator()
            menu.add_command(
                label=_("&About %s...") % TITLE,
                command=self.mHelpAbout)

        MfxMenubar.addPath = None

        # FIXME: all key bindings should be *added* to keyPressHandler
        ctrl = "Control-"
        if sys.platform == "darwin":
            ctrl = "Command-"
        self._bindKey("",   "n", self.mNewGame)
        self._bindKey(ctrl, "w", self.mSelectGameDialog)
        self._bindKey(ctrl, "v", self.mSelectGameDialogWithPreview)
        self._bindKey(ctrl, "r", lambda e: self.mSelectRandomGame())
        self._bindKey(ctrl, "m", self.mSelectGameById)
        self._bindKey(ctrl, "n", self.mNewGameWithNextId)
        self._bindKey(ctrl, "o", self.mOpen)
        self._bindKey(ctrl, "s", self.mSave)
        self._bindKey(ctrl, "x", self.mHoldAndQuit)
        self._bindKey(ctrl, "q", self.mQuit)
        self._bindKey(ctrl, "z", self.mUndo)
        self._bindKey("",   "z", self.mUndo)
        self._bindKey("",   "BackSpace", self.mUndo)    # undocumented
        self._bindKey("",   "KP_Enter", self.mUndo)     # undocumented
        self._bindKey("",   "r", self.mRedo)
        self._bindKey(ctrl, "g", self.mRestart)
        self._bindKey("",   "space", self.mDeal)        # undocumented
        self._bindKey(ctrl, "y", lambda e: self.mPlayerStats(mode=100))
        self._bindKey(ctrl, "t", lambda e: self.mPlayerStats(mode=105))
        self._bindKey("",   "h", self.mHint)
        self._bindKey(ctrl, "h", self.mHint1)           # undocumented
        # self._bindKey("",   "Shift_L", self.mHighlightPiles)
        # self._bindKey("",   "Shift_R", self.mHighlightPiles)
        self._bindKey("",   "i", self.mHighlightPiles)
        self._bindKey("",   "F3", self.mFindCard)
        self._bindKey(ctrl, "d", self.mDemo)
        self._bindKey(ctrl, "e", self.mSelectCardsetDialog)
        if USE_PIL:
            self._bindKey(ctrl, "plus", self.mIncreaseCardset)
            self._bindKey(ctrl, "equal", self.mIncreaseCardset)
            self._bindKey(ctrl, "minus", self.mDecreaseCardset)
            self._bindKey(ctrl, "0", self.mOptAutoScale)
        self._bindKey(ctrl, "b", self.mOptChangeCardback)  # undocumented
        self._bindKey(ctrl, "i", self.mOptChangeTableTile)  # undocumented
        self._bindKey(ctrl, "p", self.mOptPlayerOptions)   # undocumented
        self._bindKey(ctrl, "F1", self.mHelp)
        self._bindKey("",   "F1", self.mHelpRules)
        self._bindKey("",   "Print", self.mScreenshot)
        self._bindKey(ctrl, "u", self.mPlayNextMusic)   # undocumented
        self._bindKey("",   "p", self.mPause)
        self._bindKey("",   "Pause", self.mPause)       # undocumented
        self._bindKey("",   "Escape", self.mIconify)    # undocumented
        # ASD and LKJ
        self._bindKey("",   "a", self.mDrop)
        self._bindKey(ctrl, "a", self.mDrop1)
        self._bindKey("",   "s", self.mUndo)
        self._bindKey("",   "d", self.mDeal)
        self._bindKey("",   "l", self.mDrop)
        self._bindKey(ctrl, "l", self.mDrop1)
        self._bindKey("",   "k", self.mUndo)
        self._bindKey("",   "j", self.mDeal)

        self._bindKey("",   "F2", self.mStackDesk)
        #
        # undocumented, devel
        self._bindKey("", "slash", lambda e: self.mPlayerStats(mode=106))
        #
        self._bindKey("",   "f", self.mShuffle)

        for i in range(9):
            self._bindKey(
                ctrl, str(i+1),
                lambda e, i=i: self.mGotoBookmark(i, confirm=0))

        # undocumented, devel
        self._bindKey(ctrl, "End", self.mPlayNextMusic)
        self._bindKey(ctrl, "Prior", self.mSelectPrevGameByName)
        self._bindKey(ctrl, "Next", self.mSelectNextGameByName)
        self._bindKey(ctrl, "Up", self.mSelectPrevGameById)
        self._bindKey(ctrl, "Down", self.mSelectNextGameById)

    #
    # key binding utility
    #

    def _bindKey(self, modifier, key, func):
        #  if 0 and not modifier and len(key) == 1:
        #      self.keybindings[key.lower()] = func
        #      self.keybindings[key.upper()] = func
        #      return
        if not modifier and len(key) == 1:
            # ignore Ctrl/Shift/Alt
            # but don't ignore NumLock (state == 16)
            def func(e, f2=func):
                return e.state in (0, 16) and f2(e)
        sequence = "<" + modifier + "KeyPress-" + key + ">"
        bind(self.top, sequence, func)
        if len(key) == 1 and key != key.upper():
            key = key.upper()
            sequence = "<" + modifier + "KeyPress-" + key + ">"
            bind(self.top, sequence, func)

    def _keyPressHandler(self, event):
        r = EVENT_PROPAGATE
        if event and self.game:
            # print event.__dict__
            if self.game.demo:
                # stop the demo by setting self.game.demo.keypress
                if event.char:    # ignore Ctrl/Shift/etc.
                    self.game.demo.keypress = event.char
                    r = EVENT_HANDLED
                # func = self.keybindings.get(event.char)
                # if func and (event.state & ~2) == 0:
                #    func(event)
                #    r = EVENT_HANDLED
        return r

    #
    # Select Game menu creation
    #

    def _addSelectGameMenu(self, menu):
        # games = map(self.app.gdb.get,
        #   self.app.gdb.getGamesIdSortedByShortName())
        games = list(map(
            self.app.gdb.get, self.app.gdb.getGamesIdSortedByName()))
        # games = tuple(games)
        # menu = MfxMenu(menu, label="Select &game")
        m = "Ctrl-"
        if sys.platform == "darwin":
            m = "Cmd-"
        menu.add_command(label=n_("All &games..."), accelerator=m+"W",
                         command=self.mSelectGameDialog)
        menu.add_command(label=n_("Playable pre&view..."), accelerator=m+"V",
                         command=self.mSelectGameDialogWithPreview)
        if not SELECT_GAME_MENU:
            return
        menu.add_separator()
        self._addSelectPopularGameSubMenu(games, menu, self.mSelectGame,
                                          self.tkopt.gameid)
        self._addSelectFrenchGameSubMenu(games, menu, self.mSelectGame,
                                         self.tkopt.gameid)
        if self.progress:
            self.progress.update(step=1)
        self._addSelectMahjonggGameSubMenu(games, menu, self.mSelectGame,
                                           self.tkopt.gameid)
        self._addSelectOrientalGameSubMenu(games, menu, self.mSelectGame,
                                           self.tkopt.gameid)
        self._addSelectSpecialGameSubMenu(games, menu, self.mSelectGame,
                                          self.tkopt.gameid)
        self._addSelectCustomGameSubMenu(games, menu, self.mSelectGame,
                                         self.tkopt.gameid)
        menu.add_separator()
        if self.progress:
            self.progress.update(step=1)
        self._addSelectAllGameSubMenu(games, menu, self.mSelectGame,
                                      self.tkopt.gameid)

    def _addSelectGameSubMenu(self, games, menu, select_data,
                              command, variable):
        # print select_data
        need_sep = 0
        for label, select_func in select_data:
            if label is None:
                need_sep = 1
                continue
            g = list(filter(select_func, games))
            if not g:
                continue
            if need_sep:
                menu.add_separator()
                need_sep = 0
            submenu = MfxMenu(menu, label=label)
            self._addSelectGameSubSubMenu(g, submenu, command, variable)

    def _getNumGames(self, games, select_data):
        ngames = 0
        for label, select_func in select_data:
            ngames += len(list(filter(select_func, games)))
        return ngames

    def _addSelectMahjonggGameSubMenu(self, games, menu, command, variable):
        def select_func(gi):
            return gi.si.game_type == GI.GT_MAHJONGG
        mahjongg_games = list(filter(select_func, games))
        if len(mahjongg_games) == 0:
            return
        #
        menu = MfxMenu(menu, label=n_("&Mahjongg games"))

        def add_menu(games, c0, c1, menu=menu,
                     variable=variable, command=command):
            if not games:
                return
            label = c0 + ' - ' + c1
            if c0 == c1:
                label = c0
            submenu = MfxMenu(menu, label=label, name=None)
            self._addSelectGameSubSubMenu(games, submenu, command,
                                          variable, short_name=True)

        games = {}
        for gi in mahjongg_games:
            c = gi.short_name.strip()[0]
            if c in games:
                games[c].append(gi)
            else:
                games[c] = [gi]
        games = list(games.items())
        games.sort()
        g0 = []
        c0 = c1 = games[0][0]
        for c, g1 in games:
            if len(g0)+len(g1) >= self.cb_max:
                add_menu(g0, c0, c1)
                g0 = g1
                c0 = c1 = c
            else:
                g0 += g1
                c1 = c
        add_menu(g0, c0, c1)

    def _addSelectPopularGameSubMenu(self, games, menu, command, variable):
        def select_func(gi):
            return gi.si.game_flags & GI.GT_POPULAR
        if len(list(filter(select_func, games))) == 0:
            return
        data = (n_("&Popular games"), select_func)
        self._addSelectGameSubMenu(games, menu, (data, ),
                                   self.mSelectGamePopular,
                                   self.tkopt.gameid_popular)

    def _addSelectFrenchGameSubMenu(self, games, menu, command, variable):
        if self._getNumGames(games, GI.SELECT_GAME_BY_TYPE) == 0:
            return
        submenu = MfxMenu(menu, label=n_("&French games"))
        self._addSelectGameSubMenu(games, submenu, GI.SELECT_GAME_BY_TYPE,
                                   self.mSelectGame, self.tkopt.gameid)

    def _addSelectOrientalGameSubMenu(self, games, menu, command, variable):
        if self._getNumGames(games, GI.SELECT_ORIENTAL_GAME_BY_TYPE) == 0:
            return
        submenu = MfxMenu(menu, label=n_("&Oriental games"))
        self._addSelectGameSubMenu(games, submenu,
                                   GI.SELECT_ORIENTAL_GAME_BY_TYPE,
                                   self.mSelectGame, self.tkopt.gameid)

    def _addSelectSpecialGameSubMenu(self, games, menu, command, variable):
        if self._getNumGames(games, GI.SELECT_ORIENTAL_GAME_BY_TYPE) == 0:
            return
        submenu = MfxMenu(menu, label=n_("&Special games"))
        self._addSelectGameSubMenu(games, submenu,
                                   GI.SELECT_SPECIAL_GAME_BY_TYPE,
                                   self.mSelectGame, self.tkopt.gameid)

    def _addSelectCustomGameSubMenu(self, games, menu, command, variable):
        submenu = MfxMenu(menu, label=n_("&Custom games"))

        def select_func(gi):
            return gi.si.game_type == GI.GT_CUSTOM
        games = list(filter(select_func, games))
        self.updateGamesMenu(submenu, games)

    def _addSelectAllGameSubMenu(self, games, menu, command, variable):
        menu = MfxMenu(menu, label=n_("&All games by name"))
        n, d = 0, self.cb_max
        i = 0
        while True:
            if self.progress:
                self.progress.update(step=1)
            columnbreak = i > 0 and (i % d) == 0
            i += 1
            if not games[n:n+d]:
                break
            m = min(n+d-1, len(games)-1)
            label = games[n].name[:3] + ' - ' + games[m].name[:3]
            submenu = MfxMenu(menu, label=label, name=None)
            self._addSelectGameSubSubMenu(games[n:n+d], submenu,
                                          command, variable)
            n += d
            if columnbreak:
                menu.entryconfigure(i, columnbreak=columnbreak)

    def _addSelectGameSubSubMenu(self, games, menu, command, variable,
                                 short_name=False):
        # cb = (25, self.cb_max) [ len(g) > 4 * 25 ]
        # cb = min(cb, self.cb_max)
        cb = self.cb_max
        for i in range(len(games)):
            gi = games[i]
            columnbreak = i > 0 and (i % cb) == 0
            if short_name:
                label = gi.short_name
            else:
                label = gi.name
            # optimized by inlining
            menu.tk.call((menu._w, 'add', 'radiobutton') +
                         menu._options({'command': command,
                                        'variable': variable,
                                        'columnbreak': columnbreak,
                                        'value': gi.id,
                                        'label': label}))

    def updateGamesMenu(self, menu, games):
        menu.delete(0, 'last')
        if len(games) == 0:
            menu.add_radiobutton(label=_('<none>'), name=None,
                                 state='disabled')
        elif len(games) > self.cb_max*4:
            games.sort(key=lambda x: x.name)
            self._addSelectAllGameSubMenu(games, menu,
                                          command=self.mSelectGame,
                                          variable=self.tkopt.gameid)
        else:
            self._addSelectGameSubSubMenu(games, menu,
                                          command=self.mSelectGame,
                                          variable=self.tkopt.gameid)

    #
    # Select Game menu actions
    #

    def mSelectGame(self, *args):
        self._mSelectGame(self.tkopt.gameid.get())

    def mSelectGamePopular(self, *args):
        self._mSelectGame(self.tkopt.gameid_popular.get())

    def _mSelectGameDialog(self, d):
        if d.status == 0 and d.button == 0 and d.gameid != self.game.id:
            self.tkopt.gameid.set(d.gameid)
            self.tkopt.gameid_popular.set(d.gameid)
            if 0:
                self._mSelectGame(d.gameid, random=d.random)
            else:
                # don't ask areYouSure()
                self._cancelDrag()
                self.game.endGame()
                self.game.quitGame(d.gameid, random=d.random)
        return EVENT_HANDLED

    def __restoreCursor(self, *event):
        self.game.setCursor(cursor=self.app.top_cursor)

    def mSelectGameDialog(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.game.setCursor(cursor=CURSOR_WATCH)
        after_idle(self.top, self.__restoreCursor)
        d = self._calcSelectGameDialog()(
            self.top, title=_("Select game"),
            app=self.app, gameid=self.game.id)
        return self._mSelectGameDialog(d)

    def mSelectGameDialogWithPreview(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.game.setCursor(cursor=CURSOR_WATCH)
        bookmark = None
        if 0:
            # use a bookmark for our preview game
            if self.game.setBookmark(-2, confirm=0):
                bookmark = self.game.gsaveinfo.bookmarks[-2][0]
                del self.game.gsaveinfo.bookmarks[-2]
        after_idle(self.top, self.__restoreCursor)
        d = self._calcSelectGameDialogWithPreview()(
            self.top, title=_("Select game"),
            app=self.app, gameid=self.game.id,
            bookmark=bookmark)
        return self._mSelectGameDialog(d)

    #
    # menubar overrides
    #

    def updateFavoriteGamesMenu(self):
        gameids = self.app.opt.favorite_gameid
        submenu = self.menupath[".menubar.file.favoritegames"][2]
        games = []
        for id in gameids:
            gi = self.app.getGameInfo(id)
            if gi:
                games.append(gi)
        self.updateGamesMenu(submenu, games)
        state = self._getEnabledState
        in_favor = self.app.game.id in gameids
        menu, index, submenu = self.menupath[".menubar.file.addtofavorites"]
        menu.entryconfig(index, state=state(not in_favor))
        menu, index, submenu = \
            self.menupath[".menubar.file.removefromfavorites"]
        menu.entryconfig(index, state=state(in_favor))

    def updateRecentGamesMenu(self, gameids):
        submenu = self.menupath[".menubar.file.recentgames"][2]
        games = []
        for id in gameids:
            gi = self.app.getGameInfo(id)
            if gi:
                games.append(gi)
        self.updateGamesMenu(submenu, games)

    def updateBookmarkMenuState(self):
        state = self._getEnabledState
        mp1 = self.menupath.get(".menubar.edit.setbookmark")
        mp2 = self.menupath.get(".menubar.edit.gotobookmark")
        mp3 = self.menupath.get(".menubar.edit.clearbookmarks")
        if mp1 is None or mp2 is None or mp3 is None:
            return
        x = self.app.opt.bookmarks and self.game.canSetBookmark()
        #
        menu, index, submenu = mp1
        for i in range(9):
            submenu.entryconfig(i, state=state(x))
        menu.entryconfig(index, state=state(x))
        #
        menu, index, submenu = mp2
        ms = 0
        for i in range(9):
            s = self.game.gsaveinfo.bookmarks.get(i) is not None
            submenu.entryconfig(i, state=state(s and x))
            ms = ms or s
        menu.entryconfig(index, state=state(ms and x))
        #
        menu, index, submenu = mp3
        menu.entryconfig(index, state=state(ms and x))

    def updateBackgroundImagesMenu(self):
        mp = self.menupath.get(".menubar.options.cardbackground")
        # delete all entries
        submenu = mp[2]
        submenu.delete(0, "last")
        # insert new cardbacks
        mbacks = self.app.images.getCardbacks()
        cb = int(math.ceil(math.sqrt(len(mbacks))))
        for i in range(len(mbacks)):
            columnbreak = i > 0 and (i % cb) == 0
            submenu.add_radiobutton(
                label=mbacks[i].name, image=mbacks[i].menu_image,
                variable=self.tkopt.cardback, value=i,
                command=self.mOptCardback, columnbreak=columnbreak,
                indicatoron=0, hidemargin=0)

    #
    # menu updates
    #

    def setMenuState(self, state, path):
        # print state, path
        path = ".menubar." + path
        mp = self.menupath.get(path)
        menu, index, submenu = mp
        s = self._getEnabledState(state)
        menu.entryconfig(index, state=s)

    def setToolbarState(self, state, path):
        # print state, path
        s = self._getEnabledState(state)
        w = getattr(self.app.toolbar, path + "_button")
        w["state"] = s

    def _setCommentMenu(self, v):
        self.tkopt.comment.set(v)

    def _setPauseMenu(self, v):
        self.tkopt.pause.set(v)

    #
    # menu actions
    #

    DEFAULTEXTENSION = ".pso"
    FILETYPES = ((_("%s files") % TITLE, "*" + DEFAULTEXTENSION),
                 (_("All files"), "*"))

    def mAddFavor(self, *event):
        gameid = self.app.game.id
        if gameid not in self.app.opt.favorite_gameid:
            self.app.opt.favorite_gameid.append(gameid)
            self.updateFavoriteGamesMenu()

    def mDelFavor(self, *event):
        gameid = self.app.game.id
        if gameid in self.app.opt.favorite_gameid:
            self.app.opt.favorite_gameid.remove(gameid)
            self.updateFavoriteGamesMenu()

    def mOpen(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        filename = self.game.filename
        if filename:
            idir, ifile = os.path.split(os.path.normpath(filename))
        else:
            idir, ifile = "", ""
        if not idir:
            idir = self.app.dn.savegames
        d = tkinter_tkfiledialog.Open()
        filename = d.show(filetypes=self.FILETYPES,
                          defaultextension=self.DEFAULTEXTENSION,
                          initialdir=idir, initialfile=ifile)
        if filename:
            filename = os.path.normpath(filename)
            # filename = os.path.normcase(filename)
            if os.path.isfile(filename):
                self.game.loadGame(filename)

    def mExportCurrentLayout(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        game = self.game
        if not self.menustate.save_as:
            return
        if not game.Solver_Class:
            d = self._calc_MfxMessageDialog()(
                self.top, title=_('Export game error'),
                text=_('''
Unsupported game for export.
'''),
                bitmap='error')
            return

        filename = game.filename
        if not filename:
            filename = self.app.getGameSaveName(self.game.id)
            if os.name == "posix" or os.path.supports_unicode_filenames:
                filename += "-" + self.game.getGameNumber(format=0)
            else:
                filename += "-01"
            filename += ".board"
        idir, ifile = os.path.split(os.path.normpath(filename))
        if not idir:
            idir = self.app.dn.savegames
        # print self.game.filename, ifile
        d = tkinter_tkfiledialog.SaveAs()
        filename = d.show(filetypes=self.FILETYPES,
                          defaultextension=self.DEFAULTEXTENSION,
                          initialdir=idir, initialfile=ifile)
        if filename:
            filename = os.path.normpath(filename)
            # filename = os.path.normcase(filename)
            with open(filename, 'w') as fh:
                game = self.game
                fh.write(game.Solver_Class(game, self).calcBoardString())
            self.updateMenus()

    def mImportStartingLayout(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        game = self.game
        if not game.Solver_Class:
            d = self._calc_MfxMessageDialog()(
                self.top, title=_('Import game error'),
                text=_('''
Unsupported game for import.
'''),
                bitmap='error')
            return

        filename = self.game.filename
        if filename:
            idir, ifile = os.path.split(os.path.normpath(filename))
        else:
            idir, ifile = "", ""
        if not idir:
            idir = self.app.dn.savegames
        d = tkinter_tkfiledialog.Open()
        key = 'PYSOL_DEBUG_IMPORT'
        if key not in os.environ:
            filename = d.show(filetypes=self.FILETYPES,
                              defaultextension=self.DEFAULTEXTENSION,
                              initialdir=idir, initialfile=ifile)
        else:
            filename = os.environ[key]
        if filename:
            filename = os.path.normpath(filename)
            # filename = os.path.normcase(filename)
            if os.path.isfile(filename):
                with open(filename, 'r+b') as fh:
                    game = self.game
                    try:
                        game.Solver_Class(game, self).importFile(
                            fh, game, self)
                    except PySolHintLayoutImportError as err:
                        self._calc_MfxMessageDialog()(
                            self.top,
                            title=_('Import game error'),
                            text=err.format(),
                            bitmap='error'
                        )
                        game.busy = False
                        game.endGame()
                        game.newGame()

    def mSaveAs(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        if not self.menustate.save_as:
            return
        filename = self.game.filename
        if not filename:
            filename = self.app.getGameSaveName(self.game.id)
            if os.name == "posix":
                filename = filename + "-" + self.game.getGameNumber(format=0)
            elif os.path.supports_unicode_filenames:  # new in python 2.3
                filename = filename + "-" + self.game.getGameNumber(format=0)
            else:
                filename = filename + "-01"
            filename = filename + self.DEFAULTEXTENSION
        idir, ifile = os.path.split(os.path.normpath(filename))
        if not idir:
            idir = self.app.dn.savegames
        # print self.game.filename, ifile
        d = tkinter_tkfiledialog.SaveAs()
        filename = d.show(filetypes=self.FILETYPES,
                          defaultextension=self.DEFAULTEXTENSION,
                          initialdir=idir, initialfile=ifile)
        if filename:
            filename = os.path.normpath(filename)
            # filename = os.path.normcase(filename)
            self.game.saveGame(filename)
            self.updateMenus()

    def mPause(self, *args):
        if not self.game:
            return
        if not self.game.pause:
            if self._cancelDrag():
                return
        self.game.doPause()
        self.tkopt.pause.set(self.game.pause)

    def mOptSoundDialog(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self._calcSoundOptionsDialog()(
            self.top, _("Sound settings"), self.app)
        self.tkopt.sound.set(self.app.opt.sound)

    def mOptAutoFaceUp(self, *args):
        if self._cancelDrag():
            return
        self.app.opt.autofaceup = self.tkopt.autofaceup.get()
        if self.app.opt.autofaceup:
            self.game.autoPlay()

    def mOptAutoDrop(self, *args):
        if self._cancelDrag():
            return
        self.app.opt.autodrop = self.tkopt.autodrop.get()
        if self.app.opt.autodrop:
            self.game.autoPlay()

    def mOptAutoDeal(self, *args):
        if self._cancelDrag():
            return
        self.app.opt.autodeal = self.tkopt.autodeal.get()
        if self.app.opt.autodeal:
            self.game.autoPlay()

    def mOptQuickPlay(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.quickplay = self.tkopt.quickplay.get()

    def mOptEnableUndo(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.undo = self.tkopt.undo.get()
        self.game.updateMenus()

    def mOptEnableBookmarks(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.bookmarks = self.tkopt.bookmarks.get()
        self.game.updateMenus()

    def mOptEnableHint(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.hint = self.tkopt.hint.get()
        self.game.updateMenus()

    def mOptEnableShuffle(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.shuffle = self.tkopt.shuffle.get()
        self.game.updateMenus()

    def mOptEnableHighlightPiles(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.highlight_piles = self.tkopt.highlight_piles.get()
        self.game.updateMenus()

    def mOptEnableHighlightCards(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.highlight_cards = self.tkopt.highlight_cards.get()
        self.game.updateMenus()

    def mOptEnableHighlightSameRank(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.highlight_samerank = self.tkopt.highlight_samerank.get()
        # self.game.updateMenus()

    def mOptEnableHighlightNotMatching(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.highlight_not_matching = \
            self.tkopt.highlight_not_matching.get()
        # self.game.updateMenus()

    def mOptAnimations(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.animations = self.tkopt.animations.get()

    def mRedealAnimation(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.redeal_animation = self.tkopt.redeal_animation.get()

    def mWinAnimation(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.win_animation = self.tkopt.win_animation.get()

    def mOptShadow(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.shadow = self.tkopt.shadow.get()

    def mOptShade(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.shade = self.tkopt.shade.get()

    def mOptShrinkFaceDown(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.shrink_face_down = self.tkopt.shrink_face_down.get()
        self.game.endGame(bookmark=1)
        self.game.quitGame(bookmark=1)

    def mOptShadeFilledStacks(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.shade_filled_stacks = self.tkopt.shade_filled_stacks.get()
        self.game.endGame(bookmark=1)
        self.game.quitGame(bookmark=1)

    def mOptMahjonggShowRemoved(self, *args):
        if self._cancelDrag():
            return
        self.app.opt.mahjongg_show_removed = \
            self.tkopt.mahjongg_show_removed.get()
        # self.game.updateMenus()
        self.game.endGame(bookmark=1)
        self.game.quitGame(bookmark=1)

    def mOptShisenShowHint(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.shisen_show_hint = self.tkopt.shisen_show_hint.get()
        # self.game.updateMenus()

    def _updateCardSize(self):
        geom = (self.app.canvas.winfo_width(),
                self.app.canvas.winfo_height())
        self.app.opt.game_geometry = geom
        self.app.game.resizeGame()
        if self.app.opt.auto_scale:
            w, h = self.app.opt.game_geometry
            self.app.canvas.setInitialSize(w, h, scrollregion=False)
        else:
            w = int(round(self.app.game.width * self.app.opt.scale_x))
            h = int(round(self.app.game.height * self.app.opt.scale_y))
            self.app.canvas.setInitialSize(w, h)
            self.app.top.wm_geometry("")    # cancel user-specified geometry
        # self.app.top.update_idletasks()

    def mIncreaseCardset(self, *event):
        if self._cancelDrag(break_pause=True):
            return
        if self.app.opt.scale_x < 4:
            self.app.opt.scale_x += 0.1
        else:
            return
        if self.app.opt.scale_y < 4:
            self.app.opt.scale_y += 0.1
        else:
            return
        self.app.opt.auto_scale = False
        self.tkopt.auto_scale.set(False)
        self._updateCardSize()

    def mDecreaseCardset(self, *event):
        if self._cancelDrag(break_pause=True):
            return
        if self.app.opt.scale_x > 0.5:
            self.app.opt.scale_x -= 0.1
        else:
            return
        if self.app.opt.scale_y > 0.5:
            self.app.opt.scale_y -= 0.1
        else:
            return
        self.app.opt.auto_scale = False
        self.tkopt.auto_scale.set(False)
        self._updateCardSize()

    def mOptAutoScale(self, *event):
        if self._cancelDrag(break_pause=True):
            return
        auto_scale = not self.app.opt.auto_scale
        self.app.opt.auto_scale = auto_scale
        self.tkopt.auto_scale.set(auto_scale)
        self._updateCardSize()

    def _mOptCardback(self, index):
        if self._cancelDrag(break_pause=False):
            return
        cs = self.app.cardset
        old_index = cs.backindex
        cs.updateCardback(backindex=index)
        if cs.backindex == old_index:
            return
        self.app.updateCardset(self.game.id)
        image = self.app.images.getBack(update=True)
        for card in self.game.cards:
            card.updateCardBackground(image=image)
        self.app.canvas.update_idletasks()
        self.tkopt.cardback.set(cs.backindex)

    def mOptCardback(self, *event):
        self._mOptCardback(self.tkopt.cardback.get())

    def mOptChangeCardback(self, *event):
        self._mOptCardback(self.app.cardset.backindex + 1)

    def mOptChangeTableTile(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        n = self.app.tabletile_manager.len()
        if n >= 2:
            i = (self.tkopt.tabletile.get() + 1) % n
            if self.app.setTile(i):
                self.tkopt.tabletile.set(i)

    def mSelectTileDialog(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        key = self.app.tabletile_index
        if key <= 0:
            key = self.app.opt.colors['table']  # .lower()
        d = self._calcSelectTileDialogWithPreview()(
            self.top, app=self.app,
            title=_("Select table background"),
            manager=self.app.tabletile_manager,
            key=key)
        if d.status == 0 and d.button == 0:
            if isinstance(d.key, str):
                tile = self.app.tabletile_manager.get(0)
                tile.color = d.key
                if self.app.setTile(0):
                    self.tkopt.tabletile.set(0)
            elif d.key > 0 and d.key != self.app.tabletile_index:
                if self.app.setTile(d.key):
                    self.tkopt.tabletile.set(d.key)

    def mOptToolbar(self, *event):
        # if self._cancelDrag(break_pause=False): return
        self.setToolbarSide(self.tkopt.toolbar.get())

    def mOptToolbarStyle(self, *event):
        # if self._cancelDrag(break_pause=False): return
        self.setToolbarStyle(self.tkopt.toolbar_style.get())

    def mOptToolbarCompound(self, *event):
        # if self._cancelDrag(break_pause=False): return
        self.setToolbarCompound(self.tkopt.toolbar_compound.get())

    def mOptToolbarSize(self, *event):
        # if self._cancelDrag(break_pause=False): return
        self.setToolbarSize(self.tkopt.toolbar_size.get())

    def mOptToolbarConfig(self, w):
        self.toolbarConfig(w, self.tkopt.toolbar_vars[w].get())

    def mOptStatusbar(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        if not self.app.statusbar:
            return
        side = self.tkopt.statusbar.get()
        self.app.opt.statusbar = side
        resize = not self.app.opt.save_games_geometry
        if self.app.statusbar.show(side, resize=resize):
            self.top.update_idletasks()

    def mOptNumCards(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.num_cards = self.tkopt.num_cards.get()

    def mOptHelpbar(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        if not self.app.helpbar:
            return
        show = self.tkopt.helpbar.get()
        self.app.opt.helpbar = show
        resize = not self.app.opt.save_games_geometry
        if self.app.helpbar.show(show, resize=resize):
            self.top.update_idletasks()

    def mOptSaveGamesGeometry(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.save_games_geometry = self.tkopt.save_games_geometry.get()

    def mOptDemoLogo(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.demo_logo = self.tkopt.demo_logo.get()

    def mOptSplashscreen(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.splashscreen = self.tkopt.splashscreen.get()

    def mOptMouseType(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.mouse_type = self.tkopt.mouse_type.get()

    def mOptMouseUndo(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.mouse_undo = self.tkopt.mouse_undo.get()

    def mOptNegativeBottom(self, *event):
        if self._cancelDrag():
            return
        self.app.opt.negative_bottom = self.tkopt.negative_bottom.get()
        self.app.updateCardset()
        self.game.endGame(bookmark=1)
        self.game.quitGame(bookmark=1)

    #
    # toolbar support
    #

    def setToolbarSide(self, side):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.toolbar = side
        self.tkopt.toolbar.set(side)                    # update radiobutton
        resize = not self.app.opt.save_games_geometry
        if self.app.toolbar.show(side, resize=resize):
            self.top.update_idletasks()

    def setToolbarSize(self, size):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.toolbar_size = size
        self.tkopt.toolbar_size.set(size)                # update radiobutton
        dir = self.app.getToolbarImagesDir()
        if self.app.toolbar.updateImages(dir, size):
            self.game.updateStatus(player=self.app.opt.player)
            self.top.update_idletasks()

    def setToolbarStyle(self, style):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.toolbar_style = style
        self.tkopt.toolbar_style.set(style)                # update radiobutton
        dir = self.app.getToolbarImagesDir()
        size = self.app.opt.toolbar_size
        if self.app.toolbar.updateImages(dir, size):
            # self.game.updateStatus(player=self.app.opt.player)
            self.top.update_idletasks()

    def setToolbarCompound(self, compound):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.toolbar_compound = compound
        self.tkopt.toolbar_compound.set(compound)          # update radiobutton
        if self.app.toolbar.setCompound(compound):
            self.game.updateStatus(player=self.app.opt.player)
            self.top.update_idletasks()

    def wizardDialog(self, edit=False):
        from pysollib.wizardutil import write_game, reset_wizard
        WizardDialog = self._calcWizardDialog()

        if edit:
            reset_wizard(self.game)
        else:
            reset_wizard(None)
        d = WizardDialog(self.top, _('Solitaire Wizard'), self.app)
        if d.status == 0 and d.button == 0:
            try:
                if edit:
                    gameid = write_game(self.app, game=self.game)
                else:
                    gameid = write_game(self.app)
            except Exception as err:
                # if False:
                #    traceback.print_exc()
                self._calc_MfxMessageDialog()(
                    self.top, title=_('Save game error'),
                    text=_('''
Error while saving game.

%s
''') % str(err),
                    bitmap='error')
                return

            if SELECT_GAME_MENU:
                menu = self.menupath[".menubar.select.customgames"][2]

                def select_func(gi):
                    return gi.si.game_type == GI.GT_CUSTOM
                games = list(map(self.app.gdb.get,
                                 self.app.gdb.getGamesIdSortedByName()))
                games = list(filter(select_func, games))
                self.updateGamesMenu(menu, games)

            self.tkopt.gameid.set(gameid)
            self._mSelectGame(gameid, force=True)

    def mWizard(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.wizardDialog()

    def mWizardEdit(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.wizardDialog(edit=True)

    def toolbarConfig(self, w, v):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.toolbar_vars[w] = v
        self.app.toolbar.config(w, v)
        self.top.update_idletasks()

    #
    # stacks descriptions
    #

    def mStackDesk(self, *event):
        if self.game.stackdesc_list:
            self.game.deleteStackDesc()
        else:
            if self._cancelDrag(break_pause=True):
                return
            self.game.showStackDesc()
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

import os

from pysollib.mygettext import _
from pysollib.settings import TITLE
from pysollib.ui.tktile.tkcanvas import MfxCanvas, MfxCanvasGroup
from pysollib.ui.tktile.tkcanvas import MfxCanvasImage, MfxCanvasRectangle
from pysollib.ui.tktile.tkutil import after, after_cancel
from pysollib.ui.tktile.tkutil import bind, makeImage, unbind_destroy

from six.moves import tkinter


LARGE_EMBLEMS_SIZE = (38, 34)
SMALL_EMBLEMS_SIZE = (31, 21)


class FindCardDialog(tkinter.Toplevel):
    CARD_IMAGES = {}  # key: (rank, suit)

    def __init__(self, parent, game, dir, size='large'):
        tkinter.Toplevel.__init__(self)
        title = TITLE + ' - ' + _('Find card')
        self.title(title)
        self.wm_resizable(False, False)
        #
        # self.images_dir = dir
        if size == 'large':
            self.images_dir = os.path.join(dir, 'large')
            self.label_width, self.label_height = LARGE_EMBLEMS_SIZE
        else:
            self.images_dir = os.path.join(dir, 'small')
            self.label_width, self.label_height = SMALL_EMBLEMS_SIZE
        self.canvas = MfxCanvas(self, bg='white')
        # self.canvas = MfxCanvas(self, bg='black')
        self.canvas.pack(expand=True, fill='both')
        #
        self.groups = []
        self.highlight_items = None
        self.busy = False
        self.connectGame(game)
        #
        bind(self, "WM_DELETE_WINDOW", self.destroy)
        bind(self, "<Escape>", self.destroy)
        #
        # self.normal_timeout = 400    # in milliseconds
        self.normal_timeout = int(
            1000*game.app.opt.timeouts['highlight_samerank'])
        self.hidden_timeout = 200
        self.timer = None

    def createCardLabel(self, suit, rank, x0, y0):
        dx, dy = self.label_width, self.label_height
        dir = self.images_dir
        canvas = self.canvas
        group = MfxCanvasGroup(canvas)
        #
        im = FindCardDialog.CARD_IMAGES.get((rank, suit))
        if im is None:
            r = '%02d' % (rank+1)
            s = 'cshd'[suit]
            fn = os.path.join(dir, r+s+'.gif')
            im = makeImage(file=fn)
            FindCardDialog.CARD_IMAGES[(rank, suit)] = im
        cim = MfxCanvasImage(canvas, x0, y0, image=im, anchor='nw')
        cim.addtag(group)
        cim.lower()
        #
        rect_width = 4
        x1, y1 = x0+dx, y0+dy
        rect = MfxCanvasRectangle(self.canvas, x0+1, y0+1, x1-1, y1-1,
                                  width=rect_width,
                                  fill=None,
                                  outline='red',
                                  state='hidden'
                                  )
        rect.addtag(group)
        #
        bind(group, '<Enter>',
             lambda e, suit=suit, rank=rank, rect=rect:
                 self.enterEvent(suit, rank, rect, group))
        bind(group, '<Leave>',
             lambda e, suit=suit, rank=rank, rect=rect:
                 self.leaveEvent(suit, rank, rect, group))
        self.groups.append(group)

    def connectGame(self, game):
        self.canvas.delete('all')
        self.game = game
        suits = game.gameinfo.suits
        ranks = game.gameinfo.ranks
        dx, dy = self.label_width, self.label_height
        uniq_suits = []
        i = 0
        for suit in suits:
            if suit in uniq_suits:
                continue
            uniq_suits.append(suit)
            j = 0
            for rank in ranks:
                x, y = dx*j+2, dy*i+2
                self.createCardLabel(suit=suit, rank=rank, x0=x, y0=y)
                j += 1
            i += 1
        w, h = dx*j+2, dy*i+2
        self.canvas.config(width=w, height=h)
        self.wm_iconname(TITLE + " - " + game.getTitleName())
        self.wm_geometry('')            # cancel user-specified geometry

    def enterEvent(self, suit, rank, rect, group):
        # print 'enterEvent', suit, rank, self.busy
        if self.busy:
            return
        if self.game.demo:
            return
        self.busy = True
        self.highlight_items = self.game.highlightCard(suit, rank)
        if not self.highlight_items:
            self.highlight_items = []
        if self.highlight_items:
            self.timer = after(self, self.normal_timeout, self.timeoutEvent)
        rect.config(state='normal')
        self.canvas.update_idletasks()
        self.busy = False

    def leaveEvent(self, suit, rank, rect, group):
        # print 'leaveEvent', suit, rank, self.busy
        if self.busy:
            return
        self.busy = True
        if self.highlight_items:
            for i in self.highlight_items:
                i.delete()
            self.highlight_items = []
        if self.timer:
            after_cancel(self.timer)
            self.timer = None
        rect.config(state='hidden')
        if self.game.canvas:
            self.game.canvas.update_idletasks()
        self.canvas.update_idletasks()
        self.busy = False

    def timeoutEvent(self, *event):
        if self.highlight_items:
            state = self.highlight_items[0].cget('state')
            if state in ('', 'normal'):
                state = 'hidden'
                self.timer = after(self, self.hidden_timeout,
                                   self.timeoutEvent)
            else:
                state = 'normal'
                self.timer = after(self, self.normal_timeout,
                                   self.timeoutEvent)
            for item in self.highlight_items:
                item.config(state=state)

    def destroy(self, *args):
        for l in self.groups:
            unbind_destroy(l)
        unbind_destroy(self)
        if self.timer:
            after_cancel(self.timer)
            self.timer = None
        self.wm_withdraw()
        if self.highlight_items:
            for i in self.highlight_items:
                i.delete()
        tkinter.Toplevel.destroy(self)


find_card_dialog = None


def create_find_card_dialog(parent, game, dir):
    global find_card_dialog
    try:
        find_card_dialog.wm_deiconify()
        find_card_dialog.tkraise()
    except Exception:
        # traceback.print_exc()
        find_card_dialog = FindCardDialog(parent, game, dir)


def connect_game_find_card_dialog(game):
    try:
        find_card_dialog.connectGame(game)
    except Exception:
        pass


def destroy_find_card_dialog():
    global find_card_dialog
    try:
        find_card_dialog.destroy()
    except Exception:
        # traceback.print_exc()
        pass
    find_card_dialog = None
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

from pysollib.acard import AbstractCard
from pysollib.ui.tktile.tkcanvas import MfxCanvasGroup, MfxCanvasImage


# ************************************************************************
# *
# ************************************************************************

class _HideableCard(AbstractCard):
    def hide(self, stack):
        if stack is self.hide_stack:
            return
        self.item.config(state="hidden")
        self.hide_stack = stack
        # print "hide:", self.id, self.item.coords()

    def unhide(self):
        if self.hide_stack is None:
            return 0
        # print "unhide:", self.id, self.item.coords()
        self.item.config(state="normal")
        self.hide_stack = None
        return 1


# ************************************************************************
# * New implementation since 2.10
# *
# * We use a single CanvasImage and call CanvasImage.config() to
# * turn the card.
# * This makes turning cards a little bit slower, but dragging cards
# * around is noticeable faster as the total number of images is
# * reduced by half.
# ************************************************************************

class _OneImageCard(_HideableCard):
    def __init__(self, id, deck, suit, rank, game, x=0, y=0):
        _HideableCard.__init__(self, id, deck, suit, rank, game, x=x, y=y)
        self._face_image = game.getCardFaceImage(deck, suit, rank)
        self._back_image = game.getCardBackImage(deck, suit, rank)
        self._shade_image = game.getCardShadeImage()
        self._active_image = self._back_image
        self.item = MfxCanvasImage(
            game.canvas, self.x, self.y, image=self._active_image, anchor="nw")
        self.shade_item = None
        # self._setImage = self.item.config

    def _setImage(self, image):
        if image is not self._active_image:
            self.item.config(image=image)
            self._active_image = image

    def showFace(self, unhide=1):
        if not self.face_up:
            self._setImage(image=self._face_image)
            self.tkraise(unhide)
            self.face_up = 1

    def showBack(self, unhide=1):
        if self.face_up:
            self._setImage(image=self._back_image)
            self.tkraise(unhide)
            self.face_up = 0

    def updateCardBackground(self, image):
        self._back_image = image
        if not self.face_up:
            self._setImage(image=image)

    #
    # optimized by inlining
    #

    def moveBy(self, dx, dy):
        dx, dy = int(dx), int(dy)
        self.x = self.x + dx
        self.y = self.y + dy
        item = self.item
        item.canvas.tk.call(item.canvas._w, "move", item.id, dx, dy)

    # for resize
    def update(self, id, deck, suit, rank, game):
        self._face_image = game.getCardFaceImage(deck, suit, rank)
        self._back_image = game.getCardBackImage(deck, suit, rank)
        self._shade_image = game.getCardShadeImage()
        if self.face_up:
            img = self._face_image
        else:
            img = self._back_image
        self.item.config(image=img)
        self._active_image = img


# ************************************************************************
# * New idea since 3.00
# *
# * Hide a card by configuring the canvas image to None.
# ************************************************************************

class _OneImageCardWithHideByConfig(_OneImageCard):
    def hide(self, stack):
        if stack is self.hide_stack:
            return
        self._setImage(image=None)
        self.hide_stack = stack

    def unhide(self):
        if self.hide_stack is None:
            return 0
        if self.face_up:
            self._setImage(image=self._face_image)
        else:
            self._setImage(image=self._back_image)
        self.hide_stack = None
        return 1

    #
    # much like in _OneImageCard
    #

    def showFace(self, unhide=1):
        if not self.face_up:
            if unhide:
                self._setImage(image=self._face_image)
            self.item.tkraise()
            self.face_up = 1

    def showBack(self, unhide=1):
        if self.face_up:
            if unhide:
                self._setImage(image=self._back_image)
            self.item.tkraise()
            self.face_up = 0

    def updateCardBackground(self, image):
        self._back_image = image
        if not self.face_up and not self.hide_stack:
            self._setImage(image=image)


# ************************************************************************
# * Old implementation prior to 2.10
# *
# * The card consists of two CanvasImages. To show the card face up,
# * the face item is placed in front of the back. To show it face
# * down, this is reversed.
# ************************************************************************

class _TwoImageCard(_HideableCard):
    # Private instance variables:
    #   __face, __back -- the canvas items making up the card
    def __init__(self, id, deck, suit, rank, game, x=0, y=0):
        _HideableCard.__init__(self, id, deck, suit, rank, game, x=x, y=y)
        self.item = MfxCanvasGroup(game.canvas)
        self.__face = MfxCanvasImage(
            game.canvas, self.x, self.y, image=game.getCardFaceImage(
                deck, suit, rank), anchor="nw")
        self.__back = MfxCanvasImage(
            game.canvas, self.x, self.y, image=game.getCardBackImage(
                deck, suit, rank), anchor="nw")
        self.__face.addtag(self.item)
        self.__back.addtag(self.item)

    def showFace(self, unhide=1):
        if not self.face_up:
            self.__face.tkraise()
            self.tkraise(unhide)
            self.face_up = 1

    def showBack(self, unhide=1):
        if self.face_up:
            self.__back.tkraise()
            self.tkraise(unhide)
            self.face_up = 0

    def updateCardBackground(self, image):
        self.__back.config(image=image)


# ************************************************************************
# * New idea since 2.90
# *
# * The card consists of two CanvasImages. Instead of raising
# * one image above the other we move the inactive image out
# * of the visible canvas.
# ************************************************************************

class _TwoImageCardWithHideItem(_HideableCard):
    # Private instance variables:
    #   __face, __back -- the canvas items making up the card
    def __init__(self, id, deck, suit, rank, game, x=0, y=0):
        _HideableCard.__init__(self, id, deck, suit, rank, game, x=x, y=y)
        self.item = MfxCanvasGroup(game.canvas)
        self.__face = MfxCanvasImage(
            game.canvas, self.x, self.y + 11000, image=game.getCardFaceImage(
                deck, suit, rank), anchor="nw")
        self.__back = MfxCanvasImage(
            game.canvas, self.x, self.y, image=game.getCardBackImage(
                deck, suit, rank), anchor="nw")
        self.__face.addtag(self.item)
        self.__back.addtag(self.item)

    def showFace(self, unhide=1):
        if not self.face_up:
            self.__back.move(0, 10000)
            # self.__face.tkraise()
            self.__face.move(0, -11000)
            self.tkraise(unhide)
            self.face_up = 1

    def showBack(self, unhide=1):
        if self.face_up:
            self.__face.move(0, 11000)
            # self.__back.tkraise()
            self.__back.move(0, -10000)
            self.tkraise(unhide)
            self.face_up = 0

    def updateCardBackground(self, image):
        self.__back.config(image=image)


# choose the implementation
Card = _TwoImageCardWithHideItem
Card = _TwoImageCard
Card = _OneImageCardWithHideByConfig
Card = _OneImageCard
# This module exports classes for the various canvas item types

# NOTE: This module was an experiment and is now obsolete.
# It's best to use the Tkinter.Canvas class directly.

from six.moves.tkinter import Canvas, _cnfmerge, _flatten  # noqa: F401


class CanvasItem:
    def __init__(self, canvas, itemType, *args, **kw):
        self.canvas = canvas
        self.id = canvas._create(itemType, args, kw)
        if not hasattr(canvas, 'items'):
            canvas.items = {}
        canvas.items[self.id] = self

    def __str__(self):
        return str(self.id)

    def __repr__(self):
        return '<%s, id=%d>' % (self.__class__.__name__, self.id)

    def delete(self):
        del self.canvas.items[self.id]
        self.canvas.delete(self.id)

    def __getitem__(self, key):
        v = self.canvas.tk.split(self.canvas.tk.call(
                self.canvas._w, 'itemconfigure',
                self.id, '-' + key))
        return v[4]
    cget = __getitem__

    def __setitem__(self, key, value):
        self.canvas.itemconfig(self.id, {key: value})

    def keys(self):
        if not hasattr(self, '_keys'):
            self._keys = map(lambda x, tk=self.canvas.tk:
                             tk.splitlist(x)[0][1:],
                             self.canvas.tk.splitlist(
                                     self.canvas._do(
                                             'itemconfigure',
                                             (self.id,))))
        return self._keys

    def has_key(self, key):
        return key in self.keys()

    def __contains__(self, key):
        return key in self.keys()

    def addtag(self, tag, option='withtag'):
        self.canvas.addtag(tag, option, self.id)

    def bbox(self):
        x1, y1, x2, y2 = self.canvas.bbox(self.id)
        return (x1, y1), (x2, y2)

    def bind(self, sequence=None, command=None, add=None):
        return self.canvas.tag_bind(self.id, sequence, command, add)

    def unbind(self, sequence, funcid=None):
        self.canvas.tag_unbind(self.id, sequence, funcid)

    def config(self, cnf={}, **kw):
        return self.canvas.itemconfig(self.id, _cnfmerge((cnf, kw)))

    def coords(self, pts=()):
        flat = ()
        for x, y in pts:
            flat += (x, y)
        return self.canvas.coords(self.id, *flat)

    def dchars(self, first, last=None):
        self.canvas.dchars(self.id, first, last)

    def dtag(self, ttd):
        self.canvas.dtag(self.id, ttd)

    def focus(self):
        self.canvas.focus(self.id)

    def gettags(self):
        return self.canvas.gettags(self.id)

    def icursor(self, index):
        self.canvas.icursor(self.id, index)

    def index(self, index):
        return self.canvas.index(self.id, index)

    def insert(self, beforethis, string):
        self.canvas.insert(self.id, beforethis, string)

    def lower(self, belowthis=None):
        self.canvas.tag_lower(self.id, belowthis)

    def move(self, xamount, yamount):
        self.canvas.move(self.id, xamount, yamount)

    def tkraise(self, abovethis=None):
        self.canvas.tag_raise(self.id, abovethis)
    raise_ = tkraise  # BW compat

    def scale(self, xorigin, yorigin, xscale, yscale):
        self.canvas.scale(self.id, xorigin, yorigin, xscale, yscale)

    def type(self):
        return self.canvas.type(self.id)


class Arc(CanvasItem):
    def __init__(self, canvas, *args, **kw):
        CanvasItem.__init__(self, canvas, 'arc', *args, **kw)


class Bitmap(CanvasItem):
    def __init__(self, canvas, *args, **kw):
        CanvasItem.__init__(self, canvas, 'bitmap', *args, **kw)


class ImageItem(CanvasItem):
    def __init__(self, canvas, *args, **kw):
        CanvasItem.__init__(self, canvas, 'image', *args, **kw)


class Line(CanvasItem):
    def __init__(self, canvas, *args, **kw):
        CanvasItem.__init__(self, canvas, 'line', *args, **kw)


class Oval(CanvasItem):
    def __init__(self, canvas, *args, **kw):
        CanvasItem.__init__(self, canvas, 'oval', *args, **kw)


class Polygon(CanvasItem):
    def __init__(self, canvas, *args, **kw):
        CanvasItem.__init__(self, canvas, 'polygon', *args, **kw)


class Rectangle(CanvasItem):
    def __init__(self, canvas, *args, **kw):
        CanvasItem.__init__(self, canvas, 'rectangle', *args, **kw)


# XXX "Text" is taken by the Text widget...
class CanvasText(CanvasItem):
    def __init__(self, canvas, *args, **kw):
        CanvasItem.__init__(self, canvas, 'text', *args, **kw)


class Window(CanvasItem):
    def __init__(self, canvas, *args, **kw):
        CanvasItem.__init__(self, canvas, 'window', *args, **kw)


class Group:
    def __init__(self, canvas, tag=None):
        if not tag:
            tag = 'Group%d' % id(self)
        self.tag = self.id = tag
        self.canvas = canvas
        self.canvas.dtag(self.tag)

    def str(self):
        return self.tag
    __str__ = str

    def _do(self, cmd, *args):
        return self.canvas._do(cmd, (self.tag,) + _flatten(args))

    def addtag_above(self, tagOrId):
        self._do('addtag', 'above', tagOrId)

    def addtag_all(self):
        self._do('addtag', 'all')

    def addtag_below(self, tagOrId):
        self._do('addtag', 'below', tagOrId)

    def addtag_closest(self, x, y, halo=None, start=None):
        self._do('addtag', 'closest', x, y, halo, start)

    def addtag_enclosed(self, x1, y1, x2, y2):
        self._do('addtag', 'enclosed', x1, y1, x2, y2)

    def addtag_overlapping(self, x1, y1, x2, y2):
        self._do('addtag', 'overlapping', x1, y1, x2, y2)

    def addtag_withtag(self, tagOrId):
        self._do('addtag', 'withtag', tagOrId)

    def bbox(self):
        return self.canvas._getints(self._do('bbox'))

    def bind(self, sequence=None, command=None, add=None):
        return self.canvas.tag_bind(self.id, sequence, command, add)

    def unbind(self, sequence, funcid=None):
        self.canvas.tag_unbind(self.id, sequence, funcid)

    def coords(self, *pts):
        return self._do('coords', pts)

    def dchars(self, first, last=None):
        self._do('dchars', first, last)

    def delete(self):
        self._do('delete')

    def dtag(self, tagToDelete=None):
        self._do('dtag', tagToDelete)

    def focus(self):
        self._do('focus')

    def gettags(self):
        return self.canvas.tk.splitlist(self._do('gettags', self.tag))

    def icursor(self, index):
        return self._do('icursor', index)

    def index(self, index):
        return self.canvas.tk.getint(self._do('index', index))

    def insert(self, beforeThis, string):
        self._do('insert', beforeThis, string)

    def config(self, cnf={}, **kw):
        return self.canvas.itemconfigure(self.tag, _cnfmerge((cnf, kw)))

    def lower(self, belowThis=None):
        self._do('lower', belowThis)

    def move(self, xAmount, yAmount):
        self._do('move', xAmount, yAmount)

    def tkraise(self, aboveThis=None):
        self._do('raise', aboveThis)
    lift = tkraise

    def scale(self, xOrigin, yOrigin, xScale, yScale):
        self._do('scale', xOrigin, yOrigin, xScale, yScale)

    def select_adjust(self, index):
        self.canvas._do('select', ('adjust', self.tag, index))

    def select_from(self, index):
        self.canvas._do('select', ('from', self.tag, index))

    def select_to(self, index):
        self.canvas._do('select', ('to', self.tag, index))

    def type(self):
        return self._do('type')
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

from pysollib.gamedb import GI
from pysollib.mfxutil import KwStruct
from pysollib.mygettext import _


class BaseGameInfoDialog:
    def __init__(self, parent, title, app, **kw):
        kw = self.initKw(kw)
        self._calc_MfxDialog().__init__(
            self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.createBitmaps(top_frame, kw)

        frame = self._calcToolkit().Frame(top_frame)
        frame.pack(expand=True, fill='both', padx=5, pady=10)
        frame.columnconfigure(0, weight=1)

        game = app.game
        gi = game.gameinfo

        #
        if gi.redeals == -2:
            redeals = 'VARIABLE'
        elif gi.redeals == -1:
            redeals = 'UNLIMITED'
        else:
            redeals = str(gi.redeals)
        cat = '<none>'
        type = '<none>'
        flags = []
        for attr in dir(GI):
            if attr.startswith('GC_'):
                c = getattr(GI, attr)
                if gi.category == c:
                    cat = attr
            elif attr.startswith('GT_'):
                t = getattr(GI, attr)
                if t < (1 << 12)-1:
                    if gi.si.game_type == t:
                        type = attr
                else:
                    if gi.si.game_flags & t:
                        flags.append(attr)
        #
        version = None
        for t in GI.GAMES_BY_PYSOL_VERSION:
            if gi.id in t[1]:
                version = t[0]
                break
        sl = {
            1: 'SL_LUCK',
            2: 'SL_MOSTLY_LUCK',
            3: 'SL_BALANCED',
            4: 'SL_MOSTLY_SKILL',
            5: 'SL_SKILL',
            }
        skill_level = sl.get(gi.skill_level)
        if game.Hint_Class is None:
            hint = None
        else:
            hint = game.Hint_Class.__name__
        row = 0
        for n, t in (('Name:', gi.name),
                     ('Short name:', gi.short_name),
                     ('ID:', gi.id),
                     ('Alt names:', '\n'.join(gi.altnames)),
                     ('PySol version:', version),
                     ('Decks:', gi.decks),
                     ('Cards:', gi.ncards),
                     ('Redeals:', redeals),
                     ('Category:', cat),
                     ('Type:', type),
                     ('Flags:', '\n'.join(flags)),
                     ('Skill level:', skill_level),
                     ('Rules filename:', gi.rules_filename),
                     ('Module:', game.__module__),
                     ('Class:', game.__class__.__name__),
                     ('Hint:', hint),
                     ):
            if t:
                self._calcToolkit().Label(
                    frame, text=n, anchor='w').grid(
                    row=row, column=0, sticky='nw')
                self._calcToolkit().Label(
                    frame, text=t, anchor='w', justify='left').grid(
                    row=row, column=1, sticky='nw')
                row += 1

        if game.s.talon:
            self.showStacks(frame, row, 'Talon:', game.s.talon)
            row += 1
        if game.s.waste:
            self.showStacks(frame, row, 'Waste:', game.s.waste)
            row += 1
        for t, s in (
            ('Foundations:', game.s.foundations,),
            ('Rows:',        game.s.rows,),
            ('Reserves:',    game.s.reserves,),
                ):
            if s:
                self.showStacks(frame, row, t, s)
                row += 1

        #
        focus = self.createButtons(bottom_frame, kw)
        self.mainloop(focus, kw.timeout)

    def showStacks(self, frame, row, title, stacks):
        self._calcToolkit().Label(
            frame, text=title, anchor='w').grid(
            row=row, column=0, sticky='nw')
        if isinstance(stacks, (list, tuple)):
            fs = {}
            for f in stacks:
                cn = f.__class__.__name__
                if cn in fs:
                    fs[cn] += 1
                else:
                    fs[cn] = 1
            t = '\n'.join(['%s (%d)' % (i[0], i[1]) for i in list(fs.items())])
        else:
            t = stacks.__class__.__name__
        self._calcToolkit().Label(
            frame, text=t, anchor='w', justify='left').grid(
            row=row, column=1, sticky='nw')

    def initKw(self, kw):
        kw = KwStruct(kw,
                      strings=(_("&OK"),),
                      default=0,
                      separator=True,
                      )
        return self._calc_MfxDialog().initKw(self, kw)

    # Requires implementing self._calcToolkit() self._calc_MfxDialog()
from pysollib.mfxutil import KwStruct
from pysollib.mygettext import _

from six.moves import tkinter


class BaseEditTextDialog:
    def __init__(self, parent, title, text, **kw):
        kw = self.initKw(kw)
        self._calc_MfxDialog().__init__(
            self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.createBitmaps(top_frame, kw)
        #
        self.text_w = tkinter.Text(top_frame, bd=1, relief="sunken",
                                   wrap="word", width=64, height=16)
        self.text_w.pack(side='left', fill="both", expand=True)
        # self.text_w.pack(side='top', padx=kw.padx, pady=kw.pady)
        vbar = self._calcToolkit().Scrollbar(top_frame)
        vbar.pack(side='right', fill='y')
        self.text_w["yscrollcommand"] = vbar.set
        vbar["command"] = self.text_w.yview
        #
        self.text = ""
        if text:
            self.text = text
            old_state = self.text_w["state"]
            self.text_w.config(state="normal")
            self.text_w.insert("insert", self.text)
            self.text_w.config(state=old_state)
        #
        focus = self.createButtons(bottom_frame, kw)
        focus = self.text_w
        self.mainloop(focus, kw.timeout)

    def initKw(self, kw):
        kw = KwStruct(kw,
                      strings=(_("&OK"), _("&Cancel")),
                      default=-1,
                      resizable=self._calc_Resizable(),
                      separator=False,
                      )
        return self._calc_MfxDialog().initKw(self, kw)

    def destroy(self):
        self.text = self.text_w.get("1.0", "end")
        self._calc_MfxDialog().destroy(self)

    def wmDeleteWindow(self, *event):   # ignore
        pass

    def mCancel(self, *event):          # ignore <Escape>
        pass
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

from pysollib.ui.tktile.tkconst import EVENT_PROPAGATE

from six.moves import tkinter
TclError = tkinter.TclError


# ************************************************************************
# * Wrapper class for Tk.
# * Required so that a Game will get properly destroyed.
# ************************************************************************

class MfxRoot(tkinter.Tk):
    def __init__(self, **kw):
        tkinter.Tk.__init__(self, **kw)
        self.app = None
        self.wm_protocol('WM_DELETE_WINDOW', self.wmDeleteWindow)
        # for interruptible sleep
        # self.sleep_var = tkinter.IntVar(self)
        # self.sleep_var.set(0)
        self.sleep_var = 0
        self.after_id = None
        # self.bind('<ButtonPress>', self._sleepEvent, add=True)

    def connectApp(self, app):
        self.app = app

    # sometimes an update() is needed under Windows, whereas
    # under Unix an update_idletasks() would be enough...
    def busyUpdate(self):
        game = None
        if self.app:
            game = self.app.game
        if not game:
            self.update()
        else:
            old_busy = game.busy
            game.busy = 1
            if game.canvas:
                game.canvas.update()
            self.update()
            game.busy = old_busy

    def mainquit(self):
        self.after_idle(self.quit)

    def screenshot(self, filename):
        # print 'MfxRoot.screenshot not yet implemented'
        pass

    def setCursor(self, cursor):
        if 0:
            # FIXME: this causes ugly resizes !
            tkinter.Tk.config(self, cursor=cursor)
        elif 0:
            # and this is even worse
            # print self.children
            for v in self.children.values():
                v.config(cursor=cursor)
        else:
            pass

    #
    # sleep
    #

    def sleep(self, seconds):
        # time.sleep(seconds)
        self.after(int(seconds*1000))
        return
        print('sleep', seconds)
        timeout = int(seconds*1000)
        self.sleep_var = 0
        while timeout > 0:
            self.update()
            self.update_idletasks()
            if self.sleep_var:
                break
            self.after(100)
            timeout -= 100
        print('finish sleep')
        return
        if self.after_id:
            self.after_cancel(self.after_id)
        self.after_id = self.after(int(seconds*1000), self._sleepEvent)
        self.sleep_var.set(1)
        self.update()
        self.wait_variable(self.sleep_var)
        if self.after_id:
            self.after_cancel(self.after_id)
            self.after_id = None
        print('finish sleep')

    def _sleepEvent(self, *args):
        return
        print('_sleepEvent', args)
        self.interruptSleep()
        return EVENT_PROPAGATE

    def interruptSleep(self):
        return
        print('interruptSleep')
        self.update()
        self.update_idletasks()
        self.sleep_var = 1
        # self.sleep_var.set(0)
        # self.after_idle(self.sleep_var.set, 0)

    #
    #
    #

    def update(self):
        tkinter.Tk.update(self)

    def wmDeleteWindow(self):
        if self.app and self.app.menubar:
            self.app.menubar.mQuit()
        else:
            # self.after_idle(self.quit)
            pass
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.mygettext import n_

from six.moves import tkinter

# ************************************************************************
# * constants
# ************************************************************************

EVENT_HANDLED = "break"
EVENT_PROPAGATE = None

CURSOR_DRAG = "hand1"
CURSOR_WATCH = "watch"
CURSOR_DOWN_ARROW = 'sb_down_arrow'

ANCHOR_CENTER = tkinter.CENTER
ANCHOR_N = tkinter.N
ANCHOR_NW = tkinter.NW
ANCHOR_NE = tkinter.NE
ANCHOR_S = tkinter.S
ANCHOR_SW = tkinter.SW
ANCHOR_SE = tkinter.SE
ANCHOR_W = tkinter.W
ANCHOR_E = tkinter.E

COMPOUNDS = (
    # (tkinter.BOTTOM,  'bottom'),
    # (tkinter.CENTER,  'center'),
    # (tkinter.RIGHT,    'right'),
    (tkinter.NONE,   n_('Icons only')),
    (tkinter.TOP,    n_('Text below icons')),
    (tkinter.LEFT,   n_('Text beside icons')),
    ('text',         n_('Text only')),
    )

TOOLBAR_BUTTONS = (
    "new",
    "restart",
    "open",
    "save",
    "undo",
    "redo",
    "autodrop",
    "shuffle",
    "pause",
    "statistics",
    "rules",
    "quit",
    "player",
    )
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

import re

from pysollib.mfxutil import Image, ImageOps, ImageTk
from pysollib.settings import TITLE, WIN_SYSTEM

from six.moves import tkinter
from six.moves import tkinter_font


# ************************************************************************
# * window manager util
# ************************************************************************

def wm_withdraw(window):
    window.wm_withdraw()


def wm_deiconify(window):
    window.wm_deiconify()


def wm_map(window, maximized=0):
    if window.wm_state() != "iconic":
        if maximized and WIN_SYSTEM == "win32":
            window.wm_state("zoomed")
        else:
            wm_deiconify(window)


__wm_get_geometry_re = re.compile(r"^(\d+)x(\d+)\+([\-]?\d+)\+([\-]?\d+)$")


def wm_get_geometry(window):
    g = window.wm_geometry()
    m = __wm_get_geometry_re.search(g)
    if not m:
        raise tkinter.TclError("invalid geometry "+str(g))
    lst = list(map(int, m.groups()))
    if window.wm_state() == "zoomed":
        # workaround as Tk returns the "unzoomed" origin
        lst[2] = lst[3] = 0
    return lst


# ************************************************************************
# * window util
# ************************************************************************

def setTransient(window, parent, relx=None, rely=None, expose=1):
    # Make an existing toplevel window transient for a parent.
    #
    # The window must exist but should not yet have been placed; in
    # other words, this should be called after creating all the
    # subwidget but before letting the user interact.

    # remain invisible while we figure out the geometry
    window.wm_withdraw()
    window.wm_group(parent)
    if parent and parent.wm_state() != "withdrawn":
        window.wm_transient(parent)
    # actualize geometry information
    window.update_idletasks()
    # show
    x, y = __getWidgetXY(window, parent, relx=relx, rely=rely)
    window.wm_geometry("+%d+%d" % (x, y))
    if expose:
        window.wm_deiconify()


def makeToplevel(parent, title=None):
    # Create a Toplevel window.
    #
    # This is a shortcut for a Toplevel() instantiation plus calls to
    # set the title and icon name of the window.
    window = tkinter.Toplevel(parent)  # , class_=TITLE)
    # window.wm_group(parent)
    # window.wm_command("")
    if WIN_SYSTEM == "x11":
        window.wm_command("/bin/true")
    # window.wm_protocol("WM_SAVE_YOURSELF", None)
    if title:
        window.wm_title(title)
        window.wm_iconname(title)
    return window


def make_help_toplevel(app, title=None):
    # Create an independent Toplevel window.
    from pysollib.winsystems import init_root_window
    window = tkinter.Toplevel(class_=TITLE)
    init_root_window(window, app)
    return window


def __getWidgetXY(widget, parent, relx=None, rely=None,
                  w_width=None, w_height=None):
    if w_width is None:
        w_width = widget.winfo_reqwidth()
    if w_height is None:
        w_height = widget.winfo_reqheight()
    s_width = widget.winfo_screenwidth()
    s_height = widget.winfo_screenheight()
    m_x = m_y = 0
    m_width, m_height = s_width, s_height
    if parent and parent.winfo_ismapped():
        # print parent.wm_geometry()
        # print parent.winfo_geometry(), parent.winfo_x(), parent.winfo_y(), \
        #   parent.winfo_rootx(), parent.winfo_rooty(), parent.winfo_vrootx(),\
        #   parent.winfo_vrooty()
        m_x = m_y = None
        if WIN_SYSTEM == "win32":
            try:
                m_width, m_height, m_x, m_y = wm_get_geometry(parent)
            except Exception:
                pass
        if m_x is None:
            m_x = parent.winfo_x()
            m_y = parent.winfo_y()
            m_width = parent.winfo_width()
            m_height = parent.winfo_height()
            if relx is None:
                relx = 0.5
            if rely is None:
                rely = 0.3
        else:
            if relx is None:
                relx = 0.5
            if rely is None:
                rely = 0.5
        m_x = max(m_x, 0)
        m_y = max(m_y, 0)
    else:
        if relx is None:
            relx = 0.5
        if rely is None:
            rely = 0.3
    x = m_x + int((m_width - w_width) * relx)
    y = m_y + int((m_height - w_height) * rely)
    # print x, y, w_width, w_height, m_x, m_y, m_width, m_height
    # make sure the widget is fully on screen
    if x < 0:
        x = 0
    elif x + w_width + 32 > s_width:
        x = max(0, (s_width - w_width) // 2)
    if y < 0:
        y = 0
    elif y + w_height + 32 > s_height:
        y = max(0, (s_height - w_height) // 2)
    return x, y


# ************************************************************************
# * bind wrapper - tkinter doesn't properly delete all bindings
# ************************************************************************

__mfx_bindings = {}
__mfx_wm_protocols = ("WM_DELETE_WINDOW", "WM_TAKE_FOCUS", "WM_SAVE_YOURSELF")


def bind(widget, sequence, func, add=None):
    # assert callable(func) # XXX: removed in py3k
    if sequence in __mfx_wm_protocols:
        funcid = widget._register(func)
        widget.tk.call("wm", "protocol", widget._w, sequence, funcid)
    elif add is None:
        funcid = widget.bind(sequence, func)
    else:
        # add = add and "+" or ""
        funcid = widget.bind(sequence, func, add)
    k = id(widget)
    if k in __mfx_bindings:
        __mfx_bindings[k].append((sequence, funcid))
    else:
        __mfx_bindings[k] = [(sequence, funcid)]


def unbind_destroy(widget):
    if widget is None:
        return
    k = id(widget)
    if k in __mfx_bindings:
        for sequence, funcid in __mfx_bindings[k]:
            # print widget, sequence, funcid
            try:
                if sequence in __mfx_wm_protocols:
                    widget.tk.call("wm", "protocol", widget._w, sequence, "")
                    # widget.deletecommand(funcid)
                else:
                    widget.unbind(sequence, funcid)
            except tkinter.TclError:
                pass
        del __mfx_bindings[k]
    # for k in __mfx_bindings.keys(): print __mfx_bindings[k]
    # print len(__mfx_bindings.keys())


# ************************************************************************
# * timer wrapper - tkinter doesn't properly delete all commands
# ************************************************************************

def after(widget, ms, func, *args):
    timer = widget.after(ms, func, *args)
    command = widget._tclCommands[-1]
    return (timer, command, widget)


def after_idle(widget, func, *args):
    return after(widget, "idle", func, *args)


def after_cancel(t):
    if t is not None:
        t[2].after_cancel(t[0])
        try:
            t[2].deletecommand(t[1])
        except tkinter.TclError:
            pass


# ************************************************************************
# * image handling
# ************************************************************************

if Image:
    class PIL_Image(ImageTk.PhotoImage):
        def __init__(self, file=None, image=None, pil_image_orig=None):
            if file:
                image = Image.open(file).convert('RGBA')
            ImageTk.PhotoImage.__init__(self, image)
            self._pil_image = image
            if pil_image_orig:
                self._pil_image_orig = pil_image_orig
            else:
                self._pil_image_orig = image

        def subsample(self, r):
            im = self._pil_image
            w, h = im.size
            w, h = int(float(w)/r), int(float(h)/r)
            im = im.resize((w, h))
            im = PIL_Image(image=im)
            return im

        def resize(self, xf, yf):
            w, h = self._pil_image_orig.size
            w0, h0 = int(w*xf), int(h*yf)
            im = self._pil_image_orig.resize((w0, h0), Image.ANTIALIAS)
            return PIL_Image(image=im, pil_image_orig=self._pil_image_orig)


def makeImage(file=None, data=None, dither=None, alpha=None):
    kw = {}
    if data is None:
        assert file is not None
        kw["file"] = file
    else:
        # assert data is not None
        kw["data"] = data
    if Image:
        # use PIL
        if file:
            im = PIL_Image(file)
            return im
        # fromstring(mode, size, data, decoder_name='raw', *args)
        else:
            return tkinter.PhotoImage(data=data)
    return tkinter.PhotoImage(**kw)


loadImage = makeImage


def copyImage(image, x, y, width, height):
    if Image:
        if isinstance(image, PIL_Image):
            return ImageTk.PhotoImage(
                image._pil_image.crop((x, y, x+width, y+height)))
    dest = tkinter.PhotoImage(width=width, height=height)
    assert dest.width() == width
    assert dest.height() == height
    dest.blank()
    image.tk.call(dest, "copy", image.name, "-from", x, y, x+width, y+height)
    assert dest.width() == width
    assert dest.height() == height
    return dest


def fillImage(image, fill, outline=None):
    if not fill and not outline:
        return
    width = image.width()
    height = image.height()
    ow = 1                              # outline width
    if width <= 2*ow or height <= 2*ow:
        fill = fill or outline
        outline = None
    if not outline:
        f = (fill,) * width
        f = (f,) * height
        assert len(f) == height
        image.put(f)
    elif not fill:
        l1 = ((outline,) * width,)
        for y in range(0, ow):
            image.put(l1, (0, y))
        for y in range(height-ow, height):
            image.put(l1, (0, y))
        p = ((outline,) * ow,)
        for y in range(ow, height-ow):
            image.put(p, (0, y))
            image.put(p, (width-ow, y))
    else:
        l1 = (outline,) * width
        l2 = (outline,) * ow + (fill,) * (width-2*ow) + (outline,) * ow
        f = (l1,) * ow + (l2,) * (height-2*ow) + (l1,) * ow
        assert len(f) == height
        image.put(f)


def createImage(width, height, fill, outline=None):
    image = tkinter.PhotoImage(width=width, height=height)
    assert image.width() == width
    assert image.height() == height
    image.blank()
    fillImage(image, fill, outline)
    return image


def shadowImage(image, color='#3896f8', factor=0.3):
    if not hasattr(image, '_pil_image'):
        return None
    im = image._pil_image
    # use an alpha image
    sh = Image.new('RGBA', im.size, color)
    sh.putalpha(100)
    out = Image.composite(sh, im, im)
    return PIL_Image(image=out)


def markImage(image):
    assert Image
    if 1:                               # shadow
        color, factor = '#6ae400', 0.3
        sh = Image.new('RGBA', image.size, color)
        tmp = Image.blend(image, sh, factor)
    else:                               # negate
        tmp = ImageOps.invert(image.convert('RGB'))
    out = Image.composite(tmp, image, image)
    return out


def _createBottomImage(image, color='white', backfile=None):
    th = 1                              # thickness
    sh = Image.new('RGBA', image.size, color)
    out = Image.composite(sh, image, image)
    w, h = image.size
    size = (w-th*2, h-th*2)
    tmp = Image.new('RGBA', size, color)
    tmp.putalpha(60)
    mask = out.resize(size, Image.ANTIALIAS)
    out.paste(tmp, (th, th), mask)
    if backfile:
        back = Image.open(backfile).convert('RGBA')
        w0, h0 = back.size
        w1, h1 = w, h
        a = min(float(w1)/w0, float(h1)/h0)
        a = a*0.9
        w0, h0 = int(w0*a), int(h0*a)
        back = back.resize((w0, h0), Image.ANTIALIAS)
        x, y = (w1 - w0) // 2, (h1 - h0) // 2
        out.paste(back, (x, y), back)
    return out


def createBottom(maskimage, color='white', backfile=None):
    if not hasattr(maskimage, '_pil_image'):
        return None
    maskimage = maskimage._pil_image
    out = _createBottomImage(maskimage, color, backfile)
    return PIL_Image(image=out)


def resizeBottom(image, maskimage, color='white', backfile=None):
    maskimage = maskimage._pil_image
    out = _createBottomImage(maskimage, color, backfile)
    image['image'] = out


# ************************************************************************
# * font utils
# ************************************************************************

def get_text_width(text, font, root=None):
    return tkinter_font.Font(root=root, font=font).measure(text)
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

from pysollib.mfxutil import Image, ImageTk
from pysollib.ui.tktile.Canvas2 import CanvasText, Group, Line, Rectangle
from pysollib.ui.tktile.Canvas2 import ImageItem as ImageItem2
from pysollib.ui.tktile.tkutil import loadImage, unbind_destroy

from six.moves import tkinter


# ************************************************************************
# * canvas items
# ************************************************************************

class MfxCanvasGroup(Group):
    def __init__(self, canvas, tag=None):
        Group.__init__(self, canvas=canvas, tag=tag)
        # register ourself so that we can unbind from the canvas
        assert self.id not in self.canvas.items
        self.canvas.items[self.id] = self

    def addtag(self, tag, option="withtag"):
        self.canvas.addtag(tag, option, self.id)

    def delete(self):
        del self.canvas.items[self.id]
        Group.delete(self)

    def gettags(self):
        return self.canvas.tk.splitlist(self._do("gettags"))


class MfxCanvasImage(ImageItem2):
    def __init__(self, canvas, x, y, **kwargs):
        self.init_coord = x, y
        group = None
        if 'group' in kwargs:
            group = kwargs['group']
            del kwargs['group']
        if 'image' in kwargs:
            self._image = kwargs['image']
        ImageItem2.__init__(self, canvas, x, y, **kwargs)
        if group:
            self.addtag(group)

    def moveTo(self, x, y):
        c = self.coords()
        self.move(x - int(c[0]), y - int(c[1]))

    def show(self):
        self.config(state='normal')

    def hide(self):
        self.config(state='hidden')


MfxCanvasLine = Line


class MfxCanvasRectangle(Rectangle):
    def __init__(self, canvas, *args, **kwargs):
        group = None
        if 'group' in kwargs:
            group = kwargs['group']
            del kwargs['group']
        Rectangle.__init__(self, canvas, *args, **kwargs)
        if group:
            self.addtag(group)


class MfxCanvasText(CanvasText):
    def __init__(self, canvas, x, y, preview=-1, **kwargs):
        self.init_coord = x, y
        self.x, self.y = x, y
        if preview < 0:
            preview = canvas.preview
        if preview > 1:
            return
        if "fill" not in kwargs:
            kwargs["fill"] = canvas._text_color
        group = None
        if 'group' in kwargs:
            group = kwargs['group']
            del kwargs['group']
        CanvasText.__init__(self, canvas, x, y, **kwargs)
        self.text_format = None
        canvas._text_items.append(self)
        if group:
            self.addtag(group)

    def moveTo(self, x, y):
        dx, dy = x - self.x, y - self.y
        self.x, self.y = x, y
        self.move(dx, dy)


# ************************************************************************
# * canvas
# ************************************************************************

class MfxCanvas(tkinter.Canvas):
    def __init__(self, *args, **kw):
        tkinter.Canvas.__init__(self, *args, **kw)
        self.preview = 0
        self.busy = False
        # this is also used by lib-tk/Canvas.py
        self.items = {}
        # private
        self.__tileimage = None
        self.__tiles = []           # id of canvas items
        self.__topimage = None
        self.__tops = []            # id of canvas items
        # friend MfxCanvasText
        self._text_color = "#000000"
        self._stretch_bg_image = 0
        self._save_aspect_bg_image = 0
        self._text_items = []
        #
        self.xmargin, self.ymargin = 10, 10
        # resize bg image
        self.bind('<Configure>', self.setBackgroundImage)

    def setBackgroundImage(self, event=None):
        # print 'setBackgroundImage', self._bg_img
        if not hasattr(self, '_bg_img'):
            return
        if not self._bg_img:  # solid color
            return
        stretch = self._stretch_bg_image
        save_aspect = self._save_aspect_bg_image
        if Image:
            if stretch:
                w, h = self._geometry()
                if save_aspect:
                    w0, h0 = self._bg_img.size
                    a = min(float(w0)/w, float(h0)/h)
                    w0, h0 = int(w0/a), int(h0/a)
                    im = self._bg_img.resize((w0, h0))
                else:
                    im = self._bg_img.resize((w, h))
                image = ImageTk.PhotoImage(im)
            else:
                image = ImageTk.PhotoImage(self._bg_img)
        else:  # not Image
            stretch = 0
            image = self._bg_img
        for id in self.__tiles:
            self.delete(id)
        self.__tiles = []
        # must keep a reference to the image, otherwise Python will
        # garbage collect it...
        self.__tileimage = image
        if stretch:
            #
            if self.preview:
                dx, dy = 0, 0
            else:
                dx, dy = -self.xmargin, -self.ymargin
            id = self._x_create("image", dx, dy, image=image, anchor="nw")
            self.tag_lower(id)          # also see tag_lower above
            self.__tiles.append(id)
        else:
            iw, ih = image.width(), image.height()
            sw, sh = self._geometry()
            for x in range(-self.xmargin, sw, iw):
                for y in range(-self.ymargin, sh, ih):
                    id = self._x_create(
                        "image", x, y, image=image, anchor="nw")
                    self.tag_lower(id)          # also see tag_lower above
                    self.__tiles.append(id)
        return 1

    def _geometry(self):
        w = max(self.winfo_width(), int(self.cget('width')))
        h = max(self.winfo_height(), int(self.cget('height')))
        scrollregion = self.cget('scrollregion')
        if not scrollregion:
            return w, h
        x, y, sw, sh = [int(i) for i in scrollregion.split()]
        sw -= x
        sh -= y
        w = max(w, sw)
        h = max(h, sh)
        return w, h

    #
    # top-image support
    #

    def _x_create(self, itemType, *args, **kw):
        return tkinter.Canvas._create(self, itemType, args, kw)

    def _create(self, itemType, args, kw):
        # print "_create:", itemType, args, kw
        id = tkinter.Canvas._create(self, itemType, args, kw)
        if self.__tops:
            self.tk.call(self._w, "lower", id, self.__tops[0])
        return id

    def tag_raise(self, id, aboveThis=None):
        # print "tag_raise:", id, aboveThis
        if aboveThis is None and self.__tops:
            self.tk.call(self._w, "lower", id, self.__tops[0])
        else:
            self.tk.call(self._w, "raise", id, aboveThis)

    def tag_lower(self, id, belowThis=None):
        # print "tag_lower:", id, belowThis
        if belowThis is None and self.__tiles:
            self.tk.call(self._w, "raise", id, self.__tiles[-1])
        else:
            self.tk.call(self._w, "lower", id, belowThis)

    def setInitialSize(self, width, height, margins=True, scrollregion=True):
        # print 'Canvas.setInitialSize:', width, height, scrollregion
        if self.preview:
            self.config(width=width, height=height,
                        scrollregion=(0, 0, width, height))
        else:
            # add margins
            dx, dy = self.xmargin, self.ymargin
            if margins:
                w, h = dx+width+dx, dy+height+dy
            else:
                w, h = width, height
            self.config(width=w, height=h)
            if scrollregion:
                self.config(scrollregion=(-dx, -dy, width+dx, height+dy))
            else:
                # no scrolls
                self.config(scrollregion=(-dx, -dy, dx, dy))

    # delete all CanvasItems, but keep the background and top tiles
    def deleteAllItems(self):
        self._text_items = []
        for id in list(self.items.keys()):
            assert id not in self.__tiles   # because the tile is created by id
            unbind_destroy(self.items[id])
            self.items[id].delete()
        assert self.items == {}

    def findCard(self, stack, event):
        if isinstance(stack.cards[0].item, Group):
            current = self.gettags("current")           # get tags
            for i in range(len(stack.cards)):
                if stack.cards[i].item.tag in current:
                    return i
        else:
            #  current = self.find("withtag", "current")   # get item ids
            #  for i in range(len(stack.cards)):
            #      if stack.cards[i].item.id in current:
            #          return i
            if self.preview:
                dx, dy = 0, 0
            else:
                dx, dy = -self.xmargin, -self.ymargin
            x = event.x+dx+self.xview()[0]*int(self.cget('width'))
            y = event.y+dy+self.yview()[0]*int(self.cget('height'))
            # x, y = event.x, event.y
            items = list(self.find_overlapping(x, y, x, y))
            items.reverse()
            for item in items:
                for i in range(len(stack.cards)):
                    if stack.cards[i].item.id == item:
                        return i
        return -1

    def setTextColor(self, color):
        if color is None:
            c = self.cget("bg")
            if not isinstance(c, str) or c[0] != "#" or len(c) != 7:
                return
            v = []
            for i in (1, 3, 5):
                v.append(int(c[i:i+2], 16))
            luminance = (0.212671 * v[0] + 0.715160 * v[1] + 0.072169 * v[2]) \
                / 255
            # print c, ":", v, "luminance", luminance
            color = ("#000000", "#ffffff")[luminance < 0.3]
        if self._text_color != color:
            self._text_color = color
            for item in self._text_items:
                item.config(fill=self._text_color)

    def setTile(self, image, stretch=0, save_aspect=0):
        # print 'setTile:', image, stretch
        if image:
            if Image:
                try:
                    self._bg_img = Image.open(image)
                except Exception:
                    return 0
            else:
                try:
                    self._bg_img = loadImage(file=image, dither=1)
                except Exception:
                    return 0
            self._stretch_bg_image = stretch
            self._save_aspect_bg_image = save_aspect
            self.setBackgroundImage()
        else:
            for id in self.__tiles:
                self.delete(id)
            self.__tiles = []
            self._bg_img = None
        return 1

    def setTopImage(self, image, cw=0, ch=0):
        try:
            if image and isinstance(image, str):
                image = loadImage(file=image)
        except tkinter.TclError:
            return 0
        if len(self.__tops) == 1 and image is self.__tops[0]:
            return 1
        for id in self.__tops:
            self.delete(id)
        self.__tops = []
        # must keep a reference to the image, otherwise Python will
        # garbage collect it...
        self.__topimage = image
        if image is None:
            return 1
        iw, ih = image.width(), image.height()
        if cw <= 0:
            # cw = max(int(self.cget("width")), self.winfo_width())
            cw = self.winfo_width()
        if ch <= 0:
            # ch = max(int(self.cget("height")),  self.winfo_height())
            ch = self.winfo_height()
        # print iw, ih, cw, ch
        x = (cw-iw)//2-self.xmargin+self.xview()[0]*int(self.cget('width'))
        y = (ch-ih)//2-self.ymargin+self.yview()[0]*int(self.cget('height'))
        id = self._x_create("image", x, y, image=image, anchor="nw")
        self.tk.call(self._w, "raise", id)
        self.__tops.append(id)
        return 1

    #
    # Pause support
    #

    def hideAllItems(self):
        for item in list(self.items.values()):
            item.config(state='hidden')

    def showAllItems(self):
        for item in list(self.items.values()):
            item.config(state='normal')

    #
    # restricted but fast _bind and _substitute
    #

    def _bind(self, what, sequence, func, add, needcleanup=1):
        funcid = self._register(func, self._substitute, needcleanup)
        cmd = ('%sif {"[%s %s]" == "break"} break\n' %
               (add and '+' or '', funcid, "%x %y"))
        self.tk.call(what + (sequence, cmd))
        return funcid

    def _substitute(self, *args):
        e = tkinter.Event()
        try:
            # Tk changed behavior in 8.4.2, returning "??" rather more often.
            e.x = int(args[0])
        except ValueError:
            e.x = args[0]
        try:
            e.y = int(args[1])
        except ValueError:
            e.y = args[1]
        return (e,)
# Written by Shlomi Fish, under the MIT Expat License.

import unittest

from pysol_tests.common_mocks1 import MockApp, MockCanvas, MockTalon

import pysollib.stack
from pysollib.hint import FreeCellSolver_Hint, PySolHintLayoutImportError


class MockGame:
    def __init__(self):
        self.app = MockApp()
        self.talon = MockTalon(self)

        self.allstacks = []
        self.stackmap = {}
        self.canvas = MockCanvas()
        self.foundations = [
            pysollib.stack.SS_FoundationStack(0, 0, self, s) for s in range(4)]
        self.rows = [pysollib.stack.AC_RowStack(0, 0, self) for s in range(8)]
        self.reserves = [
            pysollib.stack.AC_RowStack(0, 0, self) for s in range(4)]
        self.preview = 0


class Mock_S_Game:
    def __init__(self):
        self.s = MockGame()

    def flipMove(self, foo):
        pass

    def moveMove(self, cnt, frm, to, frames=0):
        c = frm.cards.pop()
        c.face_up = True
        to.addCard(c)
        pass


class MyTests(unittest.TestCase):
    def _calc_hint(self, fn):
        """docstring for _calc_hint"""
        s_game = Mock_S_Game()
        h = FreeCellSolver_Hint(s_game, None)
        fh = open(fn, 'r+b')
        h.importFileHelper(fh, s_game)
        return h

    def _successful_import(self, fn, want_s, blurb):
        self.assertEqual(self._calc_hint(fn).calcBoardString(), want_s, blurb)

    def test_import(self):
        return self._successful_import('tests/unit/data/with-10-for-rank.txt',
                                       '''FC: - - - -
4C 2C 9C 8C QS 4S 2H
5H QH 3C AC 3H 4H QD
QC 9S 6H 9H 3S KS 3D
5D 2S JC 5C JH 6D AS
2D KD TH TC TD 8D
7H JS KH TS KC 7C
AH 5S 6S AD 8H JD
7S 6C 7D 4D 8S 9D
''', 'import worked with "10"s as ranks')

    def test_import_2(self):
        return self._successful_import('tests/unit/data/624.board',
                                       '''FC: - - - -
KC 6H 4C QS 2D 4S AS
4H TH 2S JH 2H 9S AH
3S 6C 9H AD KH QD 7C
3C JS 5H KS TC 9C 8C
4D 9D 7S JC 5D TS
KD QC 5C QH 6S 3D
5S JD 8D 6D TD 8H
8S 7H 3H 2C AC 7D
''', 'import worked with Ts')

    def test_import_utf8_bom(self):
        return self._successful_import(
            'tests/unit/data/624-with-utf8-bom.board',
            '''FC: - - - -
KC 6H 4C QS 2D 4S AS
4H TH 2S JH 2H 9S AH
3S 6C 9H AD KH QD 7C
3C JS 5H KS TC 9C 8C
4D 9D 7S JC 5D TS
KD QC 5C QH 6S 3D
5S JD 8D 6D TD 8H
8S 7H 3H 2C AC 7D
''', 'import worked with utf-8 bom')

    def test_throw_error_on_duplicate_card(self):
        try:
            self._calc_hint('tests/unit/data/624-with-dup-card.board')
        except PySolHintLayoutImportError as err:
            self.assertEqual(err.msg, "Duplicate cards in input")
            self.assertEqual(err.cards, ["KC"])
            self.assertEqual(err.line_num, 1)
            self.assertEqual(err.format(), "Duplicate cards in input:\n\nKC")
            return
        self.fail("No exception thrown.")

    def test_throw_error_on_invalid_foundations_line(self):
        try:
            self._calc_hint(
                'tests/unit/data/624-invalid-foundations-line.board')
        except PySolHintLayoutImportError as err:
            self.assertEqual(err.msg, "Invalid Foundations line")
            self.assertEqual(err.cards, [])
            self.assertEqual(err.line_num, 1)
            return
        self.fail("No exception thrown.")

    def test_throw_error_on_missing_cards(self):
        try:
            self._calc_hint('tests/unit/data/624-missing-cards.board')
        except PySolHintLayoutImportError as err:
            self.assertEqual(err.msg, "Missing cards in input")
            self.assertEqual(err.cards, ["5H"])
            return
        self.fail("No exception thrown.")
# Written by Shlomi Fish, under the MIT Expat License.

import unittest

from pysollib.acard import AbstractCard
from pysollib.hint import Base_Solver_Hint


class MyTests(unittest.TestCase):
    def test_output(self):
        card = AbstractCard(1001, 0, 3, 7, 3001)
        h = Base_Solver_Hint(None, None, base_rank=0)

        got = h.card2str2(card)
        # TEST
        self.assertEqual(got, 'D-8', 'card2str2 works')
        # diag('got == ' + got)

        got = h.card2str1(card)
        # TEST
        self.assertEqual(got, '8D', 'card2str2 works')
        # diag('got == ' + got)
# Written by Shlomi Fish, under the MIT Expat License.

import unittest

from pysol_tests.common_mocks1 import MockApp, MockCanvas, MockItem, MockTalon

import pysollib.stack
from pysollib.acard import AbstractCard
from pysollib.games.spider import Scorpion_RowStack, Spider_RowStack


class MockGame:
    def __init__(self):
        self.app = MockApp()
        self.talon = MockTalon(self)

        self.allstacks = []
        self.stackmap = {}
        self.canvas = MockCanvas()
        self.foundations = [
            pysollib.stack.SS_FoundationStack(0, 0, self, s) for s in range(4)]
        self.rows = [pysollib.stack.Yukon_SS_RowStack(0, 0, self)
                     for s in range(8)]
        self.reserves = [
            pysollib.stack.Yukon_SS_RowStack(0, 0, self) for s in range(4)]
        self.preview = 0


class Mock_S_Game:
    def __init__(self):
        self.s = MockGame()

    def flipMove(self, foo):
        pass

    def moveMove(self, cnt, frm, to, frames=0):
        c = frm.cards.pop()
        c.face_up = True
        to.addCard(c)
        pass


class MyTests(unittest.TestCase):
    def _calc_Scorpion_stack(self):
        g = MockGame()
        stack = Scorpion_RowStack(0, 0, g)
        for s, r in [(2, 5), (3, 7), (2, 7), (2, 0), (2, 3), (2, 4), (1, 4)]:
            c = AbstractCard(1000+r*100+s*10, 0, s, r, g)
            c.face_up = True
            c.item = MockItem()
            stack.addCard(c)
        return stack

    def test_canMoveCards(self):
        stack = self._calc_Scorpion_stack()
        stack.canMoveCards(stack.cards[6:])
        self.assertTrue(stack)

    def test_canMoveCards_non_top(self):
        stack = self._calc_Scorpion_stack()
        self.assertTrue(stack.canMoveCards(stack.cards[4:]))
        self.assertTrue(stack)

    def _calc_Spider_stack(self):
        g = MockGame()
        stack = Spider_RowStack(0, 0, g)
        for s, r in [(2, 5), (3, 7), (2, 7), (2, 0), (2, 3), (2, 5), (1, 4)]:
            c = AbstractCard(1000+r*100+s*10, 0, s, r, g)
            c.face_up = True
            c.item = MockItem()
            stack.addCard(c)
        return stack

    def test_Spider_canMoveCards_non_top(self):
        stack = self._calc_Spider_stack()
        self.assertFalse(stack.canMoveCards(stack.cards[5:]))
        self.assertTrue(stack)
# Written by Shlomi Fish, under the MIT Expat License.

import unittest

from pysollib.game import GameDrag, GameStacks


class MyTests(unittest.TestCase):
    def test_shadows(self):
        d = GameDrag()
        d.shadows.append("test")
        self.assertTrue(len(d.shadows))

    def test_addattr(self):
        s = GameStacks()
        s.addattr(tableaux=[])
        s.tableaux.append("myval")
        self.assertEqual(s.tableaux, ["myval"])
# Written by Shlomi Fish, under the MIT Expat License.

import unittest

from pysollib.mfxutil import latin1_normalize


class MyTests(unittest.TestCase):
    def test_output(self):
        self.assertEqual(latin1_normalize('HELLO%%good'), 'hellogood')
#! /usr/bin/env python MockItem
# -*- coding: utf-8 -*-
# vim:fenc=utf-8
#
# Copyright © 2018 Shlomi Fish <shlomif@cpan.org>
#
# Distributed under terms of the MIT license.

import pysollib.stack
from pysollib.acard import AbstractCard

"""

"""


class MockItem:
    def __init__(self):
        pass

    def tkraise(self):
        return

    def addtag(self, nouse):
        return


class MockCanvas:
    def __init__(self):
        self.xmargin = self.ymargin = 50


class MockImages:
    def __init__(self):
        self.CARDW = self.CARDH = self.CARD_YOFFSET = 50


class MockOpt:
    def __init__(self):
        self.randomize_place = False


class MockApp:
    def __init__(self):
        self.images = MockImages()
        self.opt = MockOpt()


class MockTalon:
    def __init__(self, g):
        self.cards = [
            AbstractCard(1000+r*100+s*10, 0, s, r, g)
            for s in range(4) for r in range(13)]
        for c in self.cards:
            c.item = MockItem()


def _empty_override(*args):
    return True


pysollib.stack.MfxCanvasGroup = _empty_override
# Written by Shlomi Fish, under the MIT Expat License.

import unittest

from pysollib.acard import AbstractCard


class MyTests(unittest.TestCase):
    def test_cards(self):
        card1 = AbstractCard(1001, 0, 1, 2, 3001)
        # TEST
        self.assertEqual(card1.color, 0, 'card1.color is sane.')

        # TEST
        self.assertEqual(card1.rank, 2, 'card1.rank')

        card2 = AbstractCard(1001, 0, 3, 7, 3001)
        # TEST
        self.assertEqual(card2.color, 1, 'card2.color is sane.')

        # TEST
        self.assertEqual(card2.rank, 7, 'card2.rank')
# make_pysol_freecell_board.py - Program to generate the boards of
# PySol for input into Freecell Solver.
#
# Usage: make_pysol_freecell_board.py [board number] | fc-solve
#
# Or on non-UNIXes:
#
# python make_pysol_freecell_board.py [board number] | fc-solve
#
# This program is platform independent and will generate the same results
# on all architectures and operating systems.
#
# Based on the code by Markus Franz Xaver Johannes Oberhumer.
# Modified by Shlomi Fish, 2000
#
# Since much of the code here is ripped from the actual PySol code, this
# program is distributed under the GNU General Public License.
#
#
#
# vim:ts=4:et:nowrap
#
# ---------------------------------------------------------------------------##
#
# PySol -- a Python Solitaire game
#
# Copyright (C) 2000 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 1999 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 1998 Markus Franz Xaver Johannes Oberhumer
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; see the file COPYING.
# If not, write to the Free Software Foundation, Inc.,
# 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#
# Markus F.X.J. Oberhumer
# <markus.oberhumer@jk.uni-linz.ac.at>
# http://wildsau.idv.uni-linz.ac.at/mfx/pysol.html
#
# ---------------------------------------------------------------------------##


# imports
import unittest

from pysol_cards.cards import CardRenderer
from pysol_cards.deal_game import Game
from pysol_cards.random_base import RandomBase
from pysol_cards.random import random__int2str, random__str2int

# So the localpaths will be overrided.
from pysollib.pysolrandom import constructRandom

# PySol imports

# /***********************************************************************
# // Abstract PySol Random number generator.
# //
# // We use a seed of type long in the range [0, MAX_SEED].
# ************************************************************************/


ren = CardRenderer(True)


class MyTests(unittest.TestCase):
    def _cmp_board(self, got_s, expected_s, blurb):
        if not self.assertEqual(got_s, expected_s, blurb):
            return False
        return True

    def test_main(self):

        def test_24(blurb):
            game = Game("freecell", 24, RandomBase.DEALS_PYSOLFC)
            got_s = game.calc_layout_string(ren)
            self.assertEqual(got_s, '''4C 2C 9C 8C QS 4S 2H
5H QH 3C AC 3H 4H QD
QC 9S 6H 9H 3S KS 3D
5D 2S JC 5C JH 6D AS
2D KD TH TC TD 8D
7H JS KH TS KC 7C
AH 5S 6S AD 8H JD
7S 6C 7D 4D 8S 9D
''', blurb)

        # TEST
        test_24('Deal 24')

        game = Game("freecell", 123456, RandomBase.DEALS_MS)
        # TEST
        got_s = game.calc_layout_string(ren)
        self.assertEqual(got_s, '''QD TC AS KC AH KH 6H
6D TD 8D TH 7C 2H 9C
AC AD 5C 5H 8C 9H 9D
JS 8S 4D 4C 2S 7D 3C
7H 7S 9S 2C JC 5S
5D 3S 3D 3H KD JH
6C QS 4S 2D KS TS
JD QH 6S 4H QC 8H
''', 'Microsoft Deal 123456')

        game = Game("freecell", 123456, True)
        # TEST
        self._cmp_board(game.calc_layout_string(ren), '''3D 6C AS TS QC 8D 4D
2D TC 4H JD TD 2H 5C
2C 8S AH KD KH 5S 7C
9C 8C QH 3C 5D 9S QD
AC 9D 7H 6D KS JH
6H TH 8H QS 7D JC
4C 2S 3S 6S 5H 3H
KC JS 9H 4S 7S AD
''', 'PySolFC deal No. 123456')

        rand = constructRandom('ms3000000000')
        self.assertEqual(rand.getSeedAsStr(), 'ms3000000000')
        game = Game("freecell", 3000000000, RandomBase.DEALS_MS)
        # TEST
        self._cmp_board(game.calc_layout_string(ren), '''8D TS JS TD JH JD JC
4D QS TH AD 4S TC 3C
9H KH QH 4C 5C KD AS
9D 5D 8S 4H KS 6S 9S
6H 2S 7H 3D KC 2C
9C 7C QC 7S QD 7D
6C 3H 8H AC 6D 3S
8C AH 2H 5H 2D 5S
''', 'Microsoft Deal #3E9 - long seed.')

        rand = constructRandom('ms6000000000')
        game = Game("freecell", 6000000000, RandomBase.DEALS_MS)
        # TEST
        got_s = game.calc_layout_string(ren)
        self.assertEqual(got_s, '''2D 2C QS 8D KD 8C 4C
3D AH 2H 4H TS 6H QD
4D JS AD 6S JH JC JD
KH 3H KS AS TC 5D AC
TD 7C 9C 7H 3C 3S
QH 9H 9D 5S 7S 6C
5C 5H 2S KC 9S 4S
6D QC 8S TH 7D 8H
''', 'Microsoft Deal #6E9 - extra long seed.')

        inp = 'ms12345678'
        got = random__int2str(random__str2int(inp))

        # TEST
        self.assertEqual(got, inp, 'long2str ms roundtrip.')

        inp = '246007891097'
        got = random__int2str(random__str2int(inp))

        # TEST
        self.assertEqual(got, inp, 'long2str PySolFC roundtrip.')

        proto_inp = '246007891097'
        inp = random__str2int(proto_inp)
        got = random__str2int(random__int2str(inp))

        # TEST
        self.assertEqual(got, inp, 'str2long PySolFC roundtrip.')

        rand = constructRandom('ms100000')
        seed = rand.increaseSeed(rand.initial_seed)
        seed = rand.str(seed)
        # TEST
        self.assertEqual(seed, 'ms100001', 'increaseSeed for ms deals')
        rand = constructRandom(seed)
        game = Game("freecell", int(seed[2:]), RandomBase.DEALS_MS)
        # TEST
        self._cmp_board(game.calc_layout_string(ren), '''5S AH 4H TD 4S JD JS
3C 8C 4C AC JC AS QS
7C QH 2D QD 8S 9D AD
KS 7S 5H 3H TS 3S 5D
9S 7H KC TH 8D 6S
5C KD 9H 2H 2S 6D
9C JH 8H 3D 4D QC
KH 6H 6C TC 2C 7D
''', 'ms100001')

        seed = 24000024
        rand = constructRandom(str(seed))
        expected0 = rand.randint(0, 100)
        expected1 = rand.randint(0, 100)
        rand.reset()
        got0 = rand.randint(0, 100)
        got1 = rand.randint(0, 100)
        # TEST
        self.assertEqual(
            [got0, got1, ],
            [expected0, expected1, ],
            "same results after reset()",)
#!/usr/bin/env python3

import builtins
import os
import sys

from pysollib.gamedb import GAME_DB
from pysollib.gamedb import GI
from pysollib.mfxutil import latin1_normalize
from pysollib.mygettext import fix_gettext
# outdir = '../html'
pysollib_dir = '../'


builtins._ = lambda x: x
builtins.n_ = lambda x: x

import pysollib.games  # noqa: F402,I100,I202
import pysollib.games.mahjongg  # noqa: F402
import pysollib.games.special  # noqa: F401,F402
import pysollib.games.ultra  # noqa: F401,F402

try:
    os.mkdir('html')
except Exception:
    pass

try:
    os.mkdir('html/rules')
except Exception:
    pass


def merge_dicts(x, y):
    ret = x.copy()
    ret.update(y)
    return ret


pysollib_path = os.path.join(sys.path[0], pysollib_dir)
sys.path[0] = os.path.normpath(pysollib_path)
# print sys.path

fix_gettext()

files = [
    ('credits.html', 'PySol Credits'),
    ('ganjifa.html', 'PySol - General Ganjifa Card Rules'),
    ('general_rules.html', 'PySol - General Rules'),
    ('glossary.html', 'PySol - Glossary'),
    ('hanafuda.html', 'PySol - Rules for General Flower Card Rules'),
    ('hexadeck.html', 'PySol - General Hex A Deck Card Rules'),
    ('howtoplay.html', 'How to play PySol'),
    ('index.html', 'PySol - a Solitaire Game Collection'),
    ('install.html', 'PySol - Installation'),
    ('intro.html', 'PySol - Introduction'),
    ('license.html', 'PySol Software License'),
    ('news.html', 'PySol - a Solitaire Game Collection'),
    # ('rules_alternate.html', 'PySol - a Solitaire Game Collection'),
    # ('rules.html', 'PySol - a Solitaire Game Collection'),
    ]

rules_files = [
    # ('hanoipuzzle.html', ),
    ('mahjongg.html', 'PySol - Rules for Mahjongg'),
    ('matrix.html', 'PySol - Rules for Matrix'),
    ('pegged.html', 'PySol - Rules for Pegged'),
    ('shisensho.html', 'PySol - Rules for Shisen-Sho'),
    ('spider.html', 'PySol - Rules for Spider'),
    ('freecell.html', 'PySol - Rules for FreeCell'),
    ]
wikipedia_files = [
    ('houseinthewood.html', 'PySol - Rules for House in the Woods'),
    ('fourseasons.html', 'PySol - Rules for Four Seasons'),
    ]


def _fmt(fmt, params):
    return fmt % merge_dicts(params, {'logo_url': "images/pysollogo03.png",
                                      'logo_alt': "PySol FC Logo"})


main_header = '''<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
<head>
<title>%(title)s</title>
<meta name="license" content="GNU General Public License">
<meta http-equiv="content-type" content="text/html; charset=utf-8">
</head>
<body text="#000000" bgcolor="#F7F3FF" link="#0000FF" vlink="#660099"
alink="#FF0000">
<img src="%(logo_url)s" alt="%(logo_alt)s">
<br>
'''
main_footer = '''
<p>
<br>
%(back_to_index_link)s
</body>
</html>'''

rules_header = '''<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
<head>
<title>%(title)s</title>
<meta name="license" content="GNU General Public License">
<meta http-equiv="content-type" content="text/html; charset=utf-8">
</head>
<body text="#000000" bgcolor="#F7F3FF" link="#0000FF" vlink="#660099"
link="#FF0000">
<img src="../%(logo_url)s" alt="%(logo_alt)s">
<br>
'''
rules_footer = '''
<p>
%(footer)s
<br>
<a href="../glossary.html">Glossary</a>
<br>
<a href="../general_rules.html">General rules</a>

<p>
<a href="../index.html">Back to the index</a>
</body>
</html>'''

wikipedia_header = '''<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
<head>
<title>%(title)s</title>
<meta name="license" content="GNU General Public License">
<meta http-equiv="content-type" content="text/html; charset=utf-8">
</head>
<body text="#000000" bgcolor="#F7F3FF" link="#0000FF" vlink="#660099"
alink="#FF0000">
<img src="../%(logo_url)s" alt="%(logo_alt)s">
<br>
'''


def getGameRulesFilename(n):
    if n.startswith('Mahjongg'):
        return 'mahjongg.html'
    return latin1_normalize(n) + '.html'


def gen_main_html():
    for infile, title in files:
        outfile = open(os.path.join('html', infile), 'w')
        print(_fmt(main_header, {'title': title}), file=outfile)
        with open(infile, 'r') as file:
            print(file.read(), file=outfile)
        s = '<a href="index.html">Back to the index</a>'
        if infile == 'index.html':
            s = ''
        print(_fmt(main_footer, {'back_to_index_link': s}), file=outfile)
        outfile.close()


def gen_rules_html():
    # ls = glob(os.path.join('rules', '*.html'))
    rules_ls = os.listdir('rules')
    rules_ls.sort()
    wikipedia_ls = os.listdir('wikipedia')
    wikipedia_ls.sort()

    games = GAME_DB.getGamesIdSortedByName()
    rules_list = []
    files_list = []
    for fn, tt in rules_files:
        rules_list.append(('rules', fn, tt, ''))
        files_list.append(fn)
    for fn, tt in wikipedia_files:
        rules_list.append(('wikipedia', fn, tt, ''))
        files_list.append(fn)
    altnames = []

    # open file of list of all rules
    out_rules = open(os.path.join('html', 'rules.html'), 'w')
    print(_fmt(main_header, {'title': 'PySol - a Solitaire Game Collection'}),
          file=out_rules)
    with open('rules.html', 'r') as file:
        print(file.read(), file=out_rules)

    for id in games:
        # create list of rules

        gi = GAME_DB.get(id)

        rules_fn = gi.rules_filename
        if not rules_fn:
            rules_fn = getGameRulesFilename(gi.name)

        if rules_fn in files_list:
            continue

        if rules_fn in rules_ls:
            rules_dir = 'rules'
        elif rules_fn in wikipedia_ls:
            rules_dir = 'wikipedia'
        else:
            print('missing rules for %s (file: %s)'
                  % (gi.name, rules_fn))
            continue

        # print '>>>', rules_fn

        title = 'PySol - Rules for ' + gi.name
        s = ''
        if gi.si.game_type == GI.GT_HANAFUDA:
            s = '<a href="../hanafuda.html">General Flower Card rules</a>'
        elif gi.si.game_type == GI.GT_DASHAVATARA_GANJIFA:
            s = '<a href="../ganjifa.html">About Ganjifa</a>'
        elif gi.si.game_type == GI.GT_HEXADECK:
            s = '<a href="../hexadeck.html">General Hex A Deck rules</a>'
        elif gi.si.game_type == GI.GT_MUGHAL_GANJIFA:
            s = '<a href="../ganjifa.html">About Ganjifa</a>'
            # print '***', gi.name, '***'

        rules_list.append((rules_dir, rules_fn, title, s))
        files_list.append(rules_fn)
        # rules_list.append((rules_fn, gi.name))
        print('<li><a href="rules/%s">%s</a>'
              % (rules_fn, gi.name), file=out_rules)
        for n in gi.altnames:
            altnames.append((n, rules_fn))

    print('</ul>\n' + _fmt(main_footer,
          {'back_to_index_link':
           '<a href="index.html">Back to the index</a>'}),
          file=out_rules)

    out_rules.close()

    # create file of altnames
    out_rules_alt = open(os.path.join('html', 'rules_alternate.html'), 'w')
    print(_fmt(main_header, {'title': 'PySol - a Solitaire Game Collection'}),
          file=out_rules_alt)
    with open('rules_alternate.html', 'r') as file:
        print(file.read(), file=out_rules_alt)
    altnames.sort()
    for name, fn in altnames:
        print('<li> <a href="rules/%s">%s</a>'
              % (fn, name), file=out_rules_alt)
    print('</ul>\n' + _fmt(main_footer,
          {'back_to_index_link':
           '<a href="index.html">Back to the index</a>'}),
          file=out_rules_alt)
    out_rules_alt.close()

    # create rules
    for dir, filename, title, footer in rules_list:
        outfile = open(
            os.path.join('html', 'rules', filename), 'w', encoding='utf-8')
        if dir == 'rules':
            print(_fmt(rules_header, {'title': title}), file=outfile)
        else:  # d == 'wikipedia'
            print(_fmt(wikipedia_header, {'title': title}), file=outfile)
        with open(os.path.join(dir, filename), 'r', encoding='utf-8') as file:
            print(file.read(), file=outfile)
        print(_fmt(rules_footer, {'footer': footer}), file=outfile)
        outfile.close()


gen_main_html()
gen_rules_html()
#!/usr/bin/env python3
# ---------------------------------------------------------------------------
#
# PySol -- a Python Solitaire game
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; see the file COPYING.
# If not, write to the Free Software Foundation, Inc.,
# 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#
# ---------------------------------------------------------------------------

# Starter for kivy/android using buildozer: Needs an explizitly
# named main.py as startpoint.

import sys
if '--kivy' not in sys.argv:
    sys.argv.append('--kivy')

runmain = True
if runmain:
    from pysollib.init import init
init()

if runmain:
    from pysollib.main import main
sys.exit(main(sys.argv))
#!/usr/bin/env python3
# ---------------------------------------------------------------------------
#
# PySol -- a Python Solitaire game
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; see the file COPYING.
# If not, write to the Free Software Foundation, Inc.,
# 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#
# ---------------------------------------------------------------------------

# import pychecker.checker

# Starter for kivy/android using buildozer: Needs an explizitly
# named main.py as startpoint.

if True:
    import sys
    sys.path.insert(0, '..')
if True:
    from pysollib.settings import VERSION
    print(VERSION)
#!/usr/bin/env python3
# -*- mode: python; coding: koi8-r; -*-
#

import os
import sys
import time

# from pprint import pprint
import pysollib.games
import pysollib.games.mahjongg  # noqa: F401
import pysollib.games.special
import pysollib.games.ultra  # noqa: F401
from pysollib.gamedb import GAME_DB
from pysollib.gamedb import GI
from pysollib.mfxutil import latin1_normalize
from pysollib.mygettext import fix_gettext
from pysollib.resource import CSI

from six.moves import builtins
os.environ['LANG'] = 'C'
builtins.__dict__['_'] = lambda x: x
builtins.__dict__['n_'] = lambda x: x

pysollib_path = os.path.join(sys.path[0], '..')
sys.path[0] = os.path.normpath(pysollib_path)
rules_dir = os.path.normpath(os.path.join(pysollib_path, 'data/html/rules'))
# pprint(sys.path)
# print rules_dir
html_mode = None

fix_gettext()


def getGameRulesFilename(n):
    if n.startswith('Mahjongg'):
        return 'mahjongg.html'
    return latin1_normalize(n) + '.html'


GAME_BY_TYPE = {
    GI.GT_BAKERS_DOZEN: "Baker's Dozen",
    GI.GT_BELEAGUERED_CASTLE: "Beleaguered Castle",
    GI.GT_CANFIELD: "Canfield",
    GI.GT_FAN_TYPE: "Fan",
    GI.GT_FORTY_THIEVES: "Forty Thieves",
    GI.GT_FREECELL: "FreeCell",
    GI.GT_GOLF: "Golf",
    GI.GT_GYPSY: "Gypsy",
    GI.GT_KLONDIKE: "Klondike",
    GI.GT_MONTANA: "Montana",
    GI.GT_NAPOLEON: "Napoleon",
    GI.GT_NUMERICA: "Numerica",
    GI.GT_PAIRING_TYPE: "Pairing",
    GI.GT_RAGLAN: "Raglan",
    GI.GT_SIMPLE_TYPE: "Simple game",
    GI.GT_SPIDER: "Spider",
    GI.GT_TERRACE: "Terrace",
    GI.GT_YUKON: "Yukon",
    GI.GT_1DECK_TYPE: "One-Deck game",
    GI.GT_2DECK_TYPE: "Two-Deck game",
    GI.GT_3DECK_TYPE: "Three-Deck game",
    GI.GT_4DECK_TYPE: "Four-Deck game",

    GI.GT_MATRIX: "Matrix",
    GI.GT_MEMORY: "Memory",
    GI.GT_POKER_TYPE: "Poker",
    GI.GT_PUZZLE_TYPE: "Puzzle",
    GI.GT_TAROCK: "Tarock",
    GI.GT_HEXADECK: "Hex A Deck",
    GI.GT_HANAFUDA: "Hanafuda",
    GI.GT_DASHAVATARA_GANJIFA: "Dashavatara Ganjifa",
    GI.GT_MAHJONGG: "Mahjongg",
    GI.GT_MUGHAL_GANJIFA: "Mughal Ganjifa",
    GI.GT_SHISEN_SHO: "Shisen-Sho",

}


def by_category():
    games = GAME_DB.getGamesIdSortedById()
    games_by_cat = {}
    for id in games:
        gi = GAME_DB.get(id)
        gt = CSI.TYPE_NAME[gi.category]
        if gt in games_by_cat:
            games_by_cat[gt] += 1
        else:
            games_by_cat[gt] = 1
    games_by_cat_list = [(i, j) for i, j in games_by_cat.items()]
    games_by_cat_list.sort(key=lambda x: x[1])
    games_by_cat_list = games_by_cat_list[::-1]
#     print '<table border="2"><tr><th>Name</th><th>Number</th></tr>'
#     for i in games_by_cat_list:
#         print '<tr><td>%s</td><td>%s</td></tr>' % i
#     print '</table>'
    print('<ul>')
    for i in games_by_cat_list:
        print('<li>%s (%s games)</li>' % i)
    print('</ul>')
    return


def by_type():
    games = GAME_DB.getGamesIdSortedById()
    games_by_type = {}
    for id in games:
        gi = GAME_DB.get(id)
        if gi.si.game_type not in GAME_BY_TYPE:
            print(gi.si.game_type)
            continue
        gt = GAME_BY_TYPE[gi.si.game_type]
        if gt in games_by_type:
            games_by_type[gt] += 1
        else:
            games_by_type[gt] = 1
    games_by_type_list = list(games_by_type.items())
    games_by_type_list.sort(key=lambda x: x[0])
    #  print '<table border="2"><tr><th>Name</th><th>Number</th></tr>'
    #  for i in games_by_type_list:
    #      print '<tr><td>%s</td><td>%s</td></tr>' % i
    #  print '</table>'
    print('<ul>')
    for i in games_by_type_list:
        print('<li>%s (%s games)</li>' % i)
    print('</ul>')
    return


def all_games(sort_by='id'):
    # rules_dir = 'rules'
    print('''<table><thead>
<tr><th>ID</th><th>Name</th><th>Alternate names</th><th>Type</th></tr>
</thead>
<tbody>
''')

    if sort_by == 'id':
        get_games_func = GAME_DB.getGamesIdSortedById
    else:
        get_games_func = GAME_DB.getGamesIdSortedByName

    for id in get_games_func():
        gi = GAME_DB.get(id)
        if not gi.rules_filename:
            rules_fn = getGameRulesFilename(gi.name)
        else:
            rules_fn = gi.rules_filename
        gt = CSI.TYPE_NAME[gi.category]
        if gt == 'French':
            gt = 'French (%s)' % GAME_BY_TYPE[gi.si.game_type]
        name = gi.name
        altnames = '<br/>'.join(gi.altnames)
        fn = os.path.join(rules_dir, rules_fn)
        if 1 and os.path.exists(fn):
            print('''<tr>
<td>%s</td>
<td> <a href="%s" title="Rules for this game">%s</a> </td>
<td>%s</td>
<td>%s</td>
</tr>
''' % (id, fn, name, altnames, gt))
        else:
            print('''<tr>
<td>%s</td>
<td>%s</td>
<td>%s</td>
<td>%s</td>
</tr>
''' % (id, name, altnames, gt))
    print('</tbody></table>')


def create_html(sort_by):
    if html_mode != 'bare':
        print('''<!DOCTYPE html><html lang="en-US">
<head>
  <title>PySolFC - List of solitaire games</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
</head>
<body>
''')
    print('<strong>Total games: %d</strong>' %
          len(GAME_DB.getGamesIdSortedById()))
    print('<section>')
    print('<h2>Categories</h2>')
    by_category()
    print('</section>')
    print('<section>')
    print('<h2>Types</h2>')
    by_type()
    print('</section>')
    # print '<h2>All games</h2>'
    print('<section>')
    print('<h2>The games</h2>')
    all_games(sort_by)
    print('</section>')
    if html_mode != 'bare':
        print('</body></html>')


def get_text():
    # get_games_func = GAME_DB.getGamesIdSortedById
    get_games_func = GAME_DB.getGamesIdSortedByName

    games_list = {}  # for unique
    for id in get_games_func():
        gi = GAME_DB.get(id)
        games_list[gi.name] = ''
        if gi.name != gi.short_name:
            games_list[gi.short_name] = ''
        for n in gi.altnames:
            games_list[n] = ''
    games_list = list(games_list.keys())
    games_list.sort()
    print('''\
# SOME DESCRIPTIVE TITLE.
# Copyright (C) YEAR ORGANIZATION
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PySol 0.0.1\\n"
"POT-Creation-Date: %s\\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\\n"
"Language-Team: LANGUAGE <LL@li.org>\\n"
"MIME-Version: 1.0\\n"
"Content-Type: text/plain; charset=CHARSET\\n"
"Content-Transfer-Encoding: ENCODING\\n"
"Generated-By: %s 0.1\\n"

''' % (time.asctime(), sys.argv[0]))
    for g in games_list:
        print('msgid "%s"\nmsgstr ""\n' % g)


def old_plain_text():
    # get_games_func = GAME_DB.getGamesIdSortedById
    get_games_func = GAME_DB.getGamesIdSortedByName
    games_list = {}  # for unique
    for id in get_games_func():
        gi = GAME_DB.get(id)
        games_list[gi.name] = ''
        # if gi.name != gi.short_name:
        #    games_list[gi.short_name] = ''
        for n in gi.altnames:
            games_list[n] = ''
    games_list = games_list.keys()
    games_list.sort()
    for g in games_list:
        print(g)


def plain_text():
    get_games_func = GAME_DB.getGamesIdSortedByName
    for id in get_games_func():
        gi = GAME_DB.get(id)
        if gi.category == GI.GC_FRENCH:
            # print str(gi.gameclass)
            # gc = gi.gameclass
            # h = gc.Hint_Class is None and 'None' or gc.Hint_Class.__name__
            # print gi.name.encode('utf-8'), h
            print(gi.name)
            for n in gi.altnames:
                print(n)
            # name = gi.name.lower()
            # name = re.sub('\W', '', name)
            # print id, name #, gi.si.game_type,
            #       gi.si.game_type == GI.GC_FRENCH


if len(sys.argv) < 2 or sys.argv[1] == 'html':
    sort_by = 'id'
    if len(sys.argv) > 2:
        sort_by = sys.argv[2]
    if len(sys.argv) > 3:
        rules_dir = sys.argv[3]
    if len(sys.argv) > 4:
        html_mode = sys.argv[4]
    create_html(sort_by)
elif sys.argv[1] == 'gettext':
    get_text()
elif sys.argv[1] == 'text':
    plain_text()
else:
    sys.exit('invalid argument')
#!/usr/bin/env python
# Written by Shlomi Fish, under the MIT Expat License.

import os
import os.path
import re
from sys import platform

IS_MAC = (platform == "darwin")
TEST_TAGS = os.getenv('TEST_TAGS', '')


def _has_tag(tag):
    return re.search("\\b{}\\b".format(tag), TEST_TAGS)


PY_VERS = ([] if _has_tag('SKIP_PY2') else [2])+[3]
SKIP_GTK = _has_tag('SKIP_GTK')
module_names = []
for d, _, files in os.walk("pysollib"):
    for f in files:
        if re.search("\\.py$", f):
            module_names.append(
                (d + "/" + re.sub("\\.py$", "", f))
                .replace("/", ".").replace(os.sep, "."))

module_names.sort()
for module_name in module_names:
    if "kivy" in module_name:
        continue
    is_gtk = ("gtk" in module_name)
    for ver in PY_VERS:
        if ((not is_gtk) or (ver == 2 and (not IS_MAC) and (not SKIP_GTK))):
            def fmt(s):
                return s % {'module_name': module_name, 'ver': ver}
            open(os.path.join(".", "tests", "individually-importing", fmt("import_v%(ver)d_%(module_name)s.py")), 'w').write(fmt('''#!/usr/bin/env python%(ver)d
import sys
print('1..1')
sys.path.insert(0, ".")
import %(module_name)s
print('ok 1 - imported')
'''))

for ver in PY_VERS:
    for mod in [
            'pysol_tests.acard_unit',
            'pysol_tests.game_drag',
            'pysol_tests.hint',
            'pysol_tests.import_file1',
            'pysol_tests.latin1_conv_unit',
            'pysol_tests.ms_deals1',
            'pysol_tests.scorpion_canMove',
            ]:
        open(os.path.join(".", "tests", "unit-generated",
                          'test__%s__v%d.py' % (mod, ver)
                          ), 'w').write('''#!/usr/bin/env python%(ver)d
import unittest

from pycotap import TAPTestRunner

from %(mod)s import MyTests

suite = unittest.TestLoader().loadTestsFromTestCase(MyTests)
TAPTestRunner().run(suite)
''' % {'mod': mod, 'ver': ver})
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-

import os
import sys

alpha = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'


def decode_layout(layout):
    # decode tile positions
    assert layout[0] == "0"
    assert (len(layout) - 1) % 3 == 0
    tiles = []
    for i in range(1, len(layout), 3):
        n = alpha.find(layout[i])
        level, height = n / 7, n % 7 + 1
        tx = alpha.find(layout[i+1])
        ty = alpha.find(layout[i+2])
        assert n >= 0 and tx >= 0 and ty >= 0
        for tl in range(level, level + height):
            tiles.append((tl, tx, ty))
    tiles.sort()
    return tiles


def encode_layout(layout):
    # encode positions
    s = '0'
    # layout.sort()
    x_max = max([t[1] for t in layout])
    y_max = max([t[2] for t in layout])
    for x in range(x_max+1):
        for y in range(y_max+1):
            mylist = [t[0] for t in layout if t[1] == x and t[2] == y]
            if not mylist:
                continue
            i_0 = i_n = mylist[0]
            for i in mylist[1:]:
                if i == i_n+1:
                    i_n = i
                    continue
                s += alpha[i_0*7+(i_n-i_0)] + alpha[x] + alpha[y]
                i_0 = i_n = i
            s += alpha[i_0*7+(i_n-i_0)] + alpha[x] + alpha[y]

#     for tl, tx, ty in layout:
#         s += alpha[tl*7]+alpha[tx]+alpha[ty]
    return s


def parse_kyodai(filename):
    # Kyodai (http://www.kyodai.com/)

    fd = open(filename)
    fd.readline()
    fd.readline()

    s = fd.readline()
    i = 0
    y = 0
    z = 0
    layout = []
    while True:
        ss = s[i:i+34]
        if not ss:
            break
        x = 0
        for c in ss:
            if c == '1':
                layout.append((z, x, y))
            x += 1
        y += 1
        if y == 20:
            y = 0
            z += 1
        i += 34
    layout.sort()
    return normalize(layout)


def parse_ace(filename):
    # Ace of Penguins (http://www.delorie.com/store/ace/)
    mylist = open(filename).read().replace('\n', '').split(',')
    mylist.reverse()
    layout = []
    layer = 0
    while True:
        x = int(mylist.pop())
        if x == 127:
            break
        if x <= 0:
            x = -x
            y, z = int(mylist.pop()), int(mylist.pop())
            if layer < z:
                layer = z
        layout.append((z, x, y))
    layout.sort()
    return normalize(layout)


def parse_kmahjongg(filename):
    # KMahjongg
    fd = open(filename)
    fd.readline()
    lines = fd.readlines()
    level = 0
    n = 0
    layout = []
    for s in lines:
        i = 0
        while True:
            i = s.find('1', i)
            if i >= 0:
                layout.append((level, i, n))
                i += 1
            else:
                break
        n += 1
        if n == 16:
            n = 0
            level += 1
    layout.sort()
    return normalize(layout)


def parse_xmahjongg(filename):
    if open(filename).readline().startswith('Kyodai'):
        return parse_kyodai(filename)
    fd = open(filename)
    layout = []
    for s in fd:
        s = s.strip()
        if not s:
            continue
        if s.startswith('#'):
            continue
        row, col, lev = s.split()
        layout.append((int(lev), int(col), int(row)))
    layout.sort()
    return normalize(layout)


def normalize(mylist):
    minx = min([i[1] for i in mylist])
    if minx:
        mylist = [(i[0], i[1]-minx, i[2]) for i in mylist]
    miny = min([i[2] for i in mylist])
    if miny:
        mylist = [(i[0], i[1], i[2]-miny) for i in mylist]
    return mylist


if __name__ == '__main__':
    gameid = 5200

    usage = '''usage:
%s TYPE FILE ...
  where TYPE are:
    k | kyodai    - parse kyodai file
    x | xmahjongg - parse xmahjongg file
    m | kmahjongg - parse kmahjongg file
    a | ace       - parse ace of penguins file
''' % sys.argv[0]

    if len(sys.argv) < 3:
        sys.exit(usage)
    if sys.argv[1] in ['k', 'kyodai']:
        parse_func = parse_kyodai
    elif sys.argv[1] in ['x', 'xmahjongg']:
        parse_func = parse_xmahjongg
    elif sys.argv[1] in ['m', 'kmahjongg']:
        parse_func = parse_kmahjongg
    elif sys.argv[1] in ['a', 'ace']:
        parse_func = parse_ace
    else:
        sys.exit(usage)

    for filename in sys.argv[2:]:

        layout = parse_func(filename)
        layout = normalize(layout)

        # print filename, len(layout)

        s = encode_layout(layout)

        # check
        lt = decode_layout(s)
        if lt != layout:
            print('*** ERROR ***')
        else:
            # print s

            gamename = os.path.split(filename)[1].split('.')[0]
            # classname = gamename.replace(' ', '_')
            # classname = 'Mahjongg_' + re.sub('\W', '', classname)

            ncards = len(layout)

            if ncards != 144:
                print('''r(%d, "%s", ncards=%d, layout="%s")
''' % (gameid, gamename, ncards, s))

            else:
                print('''r(%d, "%s", layout="%s")
''' % (gameid, gamename, s))

            gameid += 1
#!/usr/bin/env python3

import os
import sys

import pysollib.settings

if sys.version_info > (3,):
    def execfile(fn):
        return exec(open(fn).read())

prog_name = 'PySol Fan Club edition'


dirs_list = []
files_list = []
for root, dirs, files in os.walk('dist'):
    if files:
        files_list.append(root)
    dirs_list.append(root)

prog_version = pysollib.settings.VERSION

out = open('setup.iss', 'w')

print('''
[Setup]
AppName=%(prog_name)s
AppVerName=%(prog_name)s v.%(prog_version)s
DefaultDirName={pf}\\%(prog_name)s
DefaultGroupName=%(prog_name)s
UninstallDisplayIcon={app}\\pysol.exe
Compression=lzma
SolidCompression=yes
SourceDir=dist
OutputDir=.
OutputBaseFilename=PySolFC_%(prog_version)s_setup
DisableWelcomePage=no
DisableDirPage=no
DisableProgramGroupPage=no

[Icons]
Name: "{group}\\%(prog_name)s"; Filename: "{app}\\pysol.exe"
Name: "{group}\\Uninstall %(prog_name)s"; Filename: "{uninstallexe}"
Name: "{userdesktop}\\%(prog_name)s"; Filename: "{app}\\pysol.exe"
''' % vars(), file=out)

print('[Dirs]', file=out)
for d in dirs_list[1:]:
    print('Name: "{app}%s"' % d.replace('dist', ''), file=out)

print(file=out)
print('[Files]', file=out)
print('Source: "*"; DestDir: "{app}"', file=out)
for d in files_list[1:]:
    d = d.replace('dist\\', '')
    print('Source: "%s\\*"; DestDir: "{app}\\%s"' % (d, d), file=out)

print('Source: "..\\vcredist_x86.exe"; DestDir: {tmp}; \
Flags: deleteafterinstall', file=out)
print('[Run]\n\
Filename: {tmp}\\vcredist_x86.exe; \
Parameters: "/passive /promptrestart /showfinalerror"; \
StatusMsg: "Installing MS Visual C++ 2010 SP1 Redistributable Package (x86)"; \
Check: not isVCInstalled', file=out)
print('''
[Code]
function isVCInstalled: Boolean;
var
  find: TFindRec;
begin
  if FindFirst(ExpandConstant('{sys}\\msvcr100.dll'), find) then begin
    Result := True;
    FindClose(find);
  end else begin
    Result := False;
  end;
 end;

function InitializeSetup(): Boolean;
var
  Version: TWindowsVersion;
begin
  GetWindowsVersionEx(Version);

  // Windows XP SP3 and higher
  if  ((Version.Major = 5) and ((Version.Minor = 1) and
       (Version.ServicePackMajor >= 3) or (Version.Minor > 1)) or
       (Version.Major > 5)) then
    Result := True
  else begin
    MsgBox(
      'This version of Windows is not supported. PySolFC %(prog_version)s \
requires Windows XP SP3 or higher.',
      mbCriticalError, MB_OK);
    Result := False;
  end;
end;
''' % vars(), file=out)

out.close()
#!/usr/bin/env python
# -*- mode: python; coding: koi8-r; -*-
#

import os
import sys
from glob import glob
from math import cos, pi, sin, sqrt

from six.moves import tkinter

try:
    from PIL import Image, ImageTk
except ImportError:
    Image = None

cardset_type = {
    '1': 'French',
    '2': 'Hanafuda',
    '3': 'Tarock',
    '4': 'Mahjongg',
    '5': 'Hexadeck',
    '6': 'Mughal Ganjifa',
    '7': 'Navagraha Ganjifa',
    '8': 'Dashavatara Ganjifa',
    '9': 'Trump only',
    }

all_imgs = False


class Cardset:
    def __init__(self, dir, name, type, ext, x, y):
        self.dir, self.name, self.type, self.ext, self.x, self.y = \
            dir, name, type, ext, x, y


def create_cs_list(ls):
    cardsets_list = {}
    for f in ls:
        dir = os.path.split(f)[0]
        lines = open(f).readlines()
        l0 = lines[0].split(';')
        try:
            ext = l0[2]
        except IndexError:
            # print f
            ext = '.gif'
        if len(l0) > 3:
            type = cardset_type[l0[3]]
        else:
            # type = 'Unknown'
            type = 'French'
        l1 = lines[1].split(';')
        name = l1[1].strip()
        l2 = lines[2].split()
        x, y = int(l2[0]), int(l2[1])
        cs = Cardset(dir, name, type, ext, x, y)
        cardsets_list[name] = cs
    return cardsets_list


tk_images = []
zoom = 0


def show_cardset(*args):
    global tk_images
    tk_images = []
    if list_box.curselection():
        cs_name = list_box.get(list_box.curselection())
        cs = cardsets_dict[cs_name]
        ls = glob(os.path.join(cs.dir, '[0-9][0-9][a-z]'+cs.ext))
        ls += glob(os.path.join(cs.dir, 'back*'+cs.ext))
        if all_imgs:
            ls += glob(os.path.join(cs.dir, 'bottom*'+cs.ext))
            ls += glob(os.path.join(cs.dir, 'l*'+cs.ext))
        # ls = glob(os.path.join(cs.dir, '*.gif'))
        # if not ls: return
        ls.sort()
        pf = None
        x, y = 10, 10
        width, height = 0, 0
        canvas.delete('all')
        for f in ls:
            if Image:
                filter = {
                    'NEAREST': Image.NEAREST,
                    'BILINEAR': Image.BILINEAR,
                    'BICUBIC': Image.BICUBIC,
                    'ANTIALIAS': Image.ANTIALIAS,
                    }[filter_var.get()]
                # filter = Image.BILINEAR
                # filter = Image.BICUBIC
                # filter = Image.ANTIALIAS
                # print f
                im = Image.open(f)
                if zoom != 0:
                    w, h = im.size
                    im = im.convert('RGBA')        # for save transparency
                    if rotate_var.get():
                        # rotate
                        # if filter == Image.ANTIALIAS:
                        #    filter = Image.BICUBIC
                        z = zoom*5
                        a = abs(pi/2/90*z)
                        neww = int(w*cos(a)+h*sin(a))
                        newh = int(h*cos(a)+w*sin(a))
                        # print w, h, neww, newh
                        d = int(sqrt(w*w+h*h))
                        dx, dy = (d-w)/2, (d-h)/2
                        newim = Image.new('RGBA', (d, d))
                        newim.paste(im, (dx, dy))
                        im = newim
                        im = im.rotate(z, resample=filter)
                        x0, y0 = (d-neww)/2, (d-newh)/2
                        x1, y1 = d-x0, d-y0
                        im = im.crop((x0, y0, x1, y1))
                        t = str(z)
                    else:
                        # zoom
                        z = 1.0 + zoom/10.0
                        z = max(0.2, z)
                        if 1:
                            tmp = Image.new('RGBA', (w+2, h+2))
                            tmp.paste(im, (1, 1), im)
                            im = tmp.resize((int(w*z), int(h*z)),
                                            resample=filter)
                        else:
                            im = im.resize((int(w*z), int(h*z)),
                                           resample=filter)
                        t = '%d %%' % int(z*100)

                    zoom_label.config(text=t)

                else:
                    zoom_label.config(text='')
                image = ImageTk.tkinter.PhotoImage(im)
            else:
                image = tkinter.PhotoImage(file=f)
            tk_images.append(image)
            ff = os.path.split(f)[1]
            if pf is None:
                pf = ff[:2]
                x, y = 10, 10
            elif ff[:2] != pf:
                pf = ff[:2]
                x = 10
                y += image.height()+10
            else:
                x += image.width()+10
            canvas.create_image(x, y, image=image, anchor=tkinter.NW)
            # canvas.create_rectangle(x, y, x+image.width(), y+image.height())
            width = max(width, x)
            height = max(height, y)
        width, height = width+image.width()+10, height+image.height()+10
        canvas.config(scrollregion=(0, 0, width, height))
        # print image.width(), image.height()
        label.config(text='''\
Name: %s
Type: %s
Directory: %s''' % (cs.name, cs.type, cs.dir))


def zoom_in(*args):
    global zoom
    zoom += 1
    show_cardset()


def zoom_out(*args):
    global zoom
    zoom -= 1
    show_cardset()


def zoom_cancel(*args):
    global zoom
    zoom = 0
    show_cardset()


def show_info(*args):
    if list_box.curselection():
        cs_name = list_box.get(list_box.curselection())
        cs = cardsets_dict[cs_name]
        fn = os.path.join(cs.dir, 'COPYRIGHT')
        top = tkinter.Toplevel()
        text = tkinter.Text(top)
        text.insert('insert', open(fn).read())
        text.pack(expand=tkinter.YES, fill=tkinter.BOTH)
        b_frame = tkinter.Frame(top)
        b_frame.pack(fill=tkinter.X)
        button = tkinter.Button(b_frame, text='Close', command=top.destroy)
        button.pack(side=tkinter.RIGHT)


def create_widgets():
    global list_box, canvas, label, zoom_label
    #
    root = tkinter.Tk()
    #
    list_box = tkinter.Listbox(root, exportselection=False)
    list_box.grid(row=0, column=0, rowspan=2, sticky=tkinter.NS)
    cardsets_list = list(cardsets_dict)
    cardsets_list.sort()
    for cs in cardsets_list:
        list_box.insert(tkinter.END, cs)
    list_box.bind('<<ListboxSelect>>', show_cardset)
    #
    sb = tkinter.Scrollbar(root)
    sb.grid(row=0, column=1, rowspan=2, sticky=tkinter.NS)
    list_box.config(yscrollcommand=sb.set)
    sb.config(command=list_box.yview)
    #
    canvas = tkinter.Canvas(root, bg='#5eab6b')
    canvas.grid(row=0, column=2, sticky=tkinter.NSEW)
    canvas.bind('<4>', lambda e: canvas.yview_scroll(-5, 'unit'))
    canvas.bind('<5>', lambda e: canvas.yview_scroll(5, 'unit'))
    #
    sb = tkinter.Scrollbar(root)
    sb.grid(row=0, column=3, sticky=tkinter.NS)
    canvas.config(yscrollcommand=sb.set)
    sb.config(command=canvas.yview)
    #
    if True:
        sb = tkinter.Scrollbar(root, orient=tkinter.HORIZONTAL)
        sb.grid(row=1, column=2, sticky=tkinter.EW)
        canvas.config(xscrollcommand=sb.set)
        sb.config(command=canvas.xview)
    #
    label = tkinter.Label(root)
    label.grid(row=2, column=0, columnspan=4)
    #
    b_frame = tkinter.Frame(root)
    b_frame.grid(row=3, column=0, columnspan=4, sticky=tkinter.EW)
    button = tkinter.Button(b_frame, text='Quit', command=root.quit, width=8)
    button.pack(side=tkinter.RIGHT)
    button = tkinter.Button(b_frame, text='Info', command=show_info, width=8)
    button.pack(side=tkinter.RIGHT)
    if Image:
        global rotate_var, filter_var
        rotate_var = tkinter.IntVar(root)
        filter_var = tkinter.StringVar(root)
        button = tkinter.Button(b_frame, text='  +  ', command=zoom_in)
        button.pack(side=tkinter.LEFT)
        button = tkinter.Button(b_frame, text='  -  ', command=zoom_out)
        button.pack(side=tkinter.LEFT)
        button = tkinter.Button(b_frame, text='  =  ', command=zoom_cancel)
        button.pack(side=tkinter.LEFT)
        button = tkinter.Checkbutton(
            b_frame, text='Rotate', indicatoron=0,
            selectcolor=b_frame['bg'], width=8,
            variable=rotate_var, command=show_cardset)
        button.pack(side=tkinter.LEFT, fill='y')
        om = tkinter.OptionMenu(
            b_frame, filter_var,
            'NEAREST', 'BILINEAR', 'BICUBIC', 'ANTIALIAS',
            command=show_cardset)
        filter_var.set('NEAREST')
        om.pack(side=tkinter.LEFT, fill='y')

        zoom_label = tkinter.Label(b_frame)
        zoom_label.pack(side=tkinter.LEFT)
    #
    root.columnconfigure(2, weight=1)
    root.rowconfigure(0, weight=1)

    root.title('Show Cardsets')

    return root


if __name__ == '__main__':
    if '-a' in sys.argv:
        sys.argv.remove('-a')
        all_imgs = True
    if len(sys.argv) > 1:
        data_dir = sys.argv[1]
    else:
        data_dir = os.path.normpath(
            os.path.join(sys.path[0], os.pardir, 'data'))
    ls = glob(os.path.join(data_dir, '*', 'config.txt'))
    cardsets_dict = create_cs_list(ls)
    root = create_widgets()
    root.mainloop()
#!/usr/bin/env python
# -*- mode: python; coding: koi8-r; -*-

import os

import gtk

imdir = 'images'
imtype = 'png'
background = '#efebe7'

# fill_color = 0xff000000                 # red
fill_color = int('ff000000', 16)

if not os.path.exists(imdir):
    os.mkdir(imdir)

gc = None


def draw_rect():
    global gc
    if gc is None:
        gc = drawing_area.window.new_gc()
        colormap = gtk.gdk.colormap_get_system()
        gc.set_colormap(colormap)
        color = gtk.gdk.color_parse('red')
        colormap.alloc_color(color)
        gc.set_rgb_fg_color(color)
    drawing_area.window.draw_rectangle(gc, True, 0, 0, 800, 800)


def save_image(fn, w, h, x=0, y=0):
    pixbuf = gtk.gdk.Pixbuf(gtk.gdk.COLORSPACE_RGB, True, 8, w, h)
    pixbuf.fill(fill_color)
    pb = pixbuf.get_from_drawable(drawing_area.window,
                                  drawing_area.get_colormap(),
                                  x, y, 0, 0, w, h)
    pb.save(os.path.join(imdir, fn+"."+imtype), imtype)
    drawing_area.window.clear()
    draw_rect()


done = False


def save_callback(*args):
    global done

    if done:
        return
    done = True
    print('create images')

    style = drawing_area.get_style()
    draw_rect()

    # separator
    w = 20
    style.paint_vline(drawing_area.window, gtk.STATE_NORMAL, None,
                      drawing_area, "frame", 0, w, 0)
    save_image('sep-v', 2, w)
    style.paint_hline(drawing_area.window, gtk.STATE_NORMAL, None,
                      drawing_area, "frame", 0, w, 0)
    save_image('sep-h', w, 2)

    # tree
    w, h = 32, 32
    w, h = 24, 24
    for fn, state, shadow in (
        ("tree-n", gtk.STATE_NORMAL,      gtk.SHADOW_OUT),
        ("tree-h", gtk.STATE_PRELIGHT,    gtk.SHADOW_OUT),
        ("tree-p", gtk.STATE_ACTIVE,      gtk.SHADOW_IN),
        ("tree-d", gtk.STATE_INSENSITIVE, gtk.SHADOW_IN),
            ):
        style.paint_box(drawing_area.window, state, shadow,
                        None, drawing_area, "stepper", 0, 0, w, h)
        save_image(fn, w, h)

    # sizegrip
    w, h = 16, 16
    fn = 'sizegrip'
    style.paint_resize_grip(drawing_area.window, gtk.STATE_NORMAL, None,
                            drawing_area, "statusbar",
                            gtk.gdk.WINDOW_EDGE_SOUTH_EAST, 0, 0, w, h)
    save_image(fn, w, h)

    # progress
    w, h = 37+3, 16+3
    progress_style = progress.get_style()
    fn = 'progress-h'
    progress_style.paint_box(drawing_area.window,
                             gtk.STATE_PRELIGHT, gtk.SHADOW_NONE,
                             None, progress, "bar", 0, 0, w, h)
    save_image(fn, w, h)

    # button
    w, h = 32, 32
    w, h = 28, 28
    for fn, state, shadow in (
        ("button-n", gtk.STATE_NORMAL,      gtk.SHADOW_OUT),
        ("button-a", gtk.STATE_PRELIGHT,    gtk.SHADOW_OUT),
        ("button-p", gtk.STATE_ACTIVE,      gtk.SHADOW_IN),
        ("button-d", gtk.STATE_INSENSITIVE, gtk.SHADOW_OUT),
            ):
        style.paint_box(drawing_area.window, state, shadow,
                        None, drawing_area, "buttondefault", 0, 0, w, h)
        save_image(fn, w, h)

    style.paint_box(drawing_area.window, gtk.STATE_PRELIGHT, gtk.SHADOW_IN,
                    None, togglebutton, "buttondefault", 0, 0, w, h)
    save_image("button-pa", w, h)

    # toolbar
    w, h = 16, 16
    w, h = 24, 24

    fn = "blank"
    pixbuf = gtk.gdk.Pixbuf(gtk.gdk.COLORSPACE_RGB, True, 8, w, h)
    pixbuf.fill(fill_color)
    pixbuf.save(os.path.join(imdir, fn+"."+imtype), imtype)

    for fn, state, shadow in (
        ("toolbutton-n", gtk.STATE_NORMAL,      gtk.SHADOW_OUT),
        ("toolbutton-a", gtk.STATE_PRELIGHT,    gtk.SHADOW_OUT),
        ("toolbutton-p", gtk.STATE_ACTIVE,      gtk.SHADOW_IN),
        ("toolbutton-d", gtk.STATE_INSENSITIVE, gtk.SHADOW_IN),
            ):
        style.paint_box(drawing_area.window, state, shadow,
                        None, drawing_area, "buttondefault", 0, 0, w, h)
        save_image(fn, w, h)

    style.paint_box(drawing_area.window, gtk.STATE_PRELIGHT, gtk.SHADOW_IN,
                    None, togglebutton, "buttondefault", 0, 0, w, h)
    save_image("toolbutton-pa", w, h)

    # slider
    msl = hscroll.style_get_property("min_slider_length")
    msl = 20
    sw = hscroll.style_get_property("slider_width")
    print('>>', msl, sw)
    for t, w, h, state, orient in (
        ('hn', msl, sw, gtk.STATE_NORMAL,      gtk.ORIENTATION_HORIZONTAL),
        ('ha', msl, sw, gtk.STATE_PRELIGHT,    gtk.ORIENTATION_HORIZONTAL),
        ('hp', msl, sw, gtk.STATE_NORMAL,      gtk.ORIENTATION_HORIZONTAL),
        ('hd', msl, sw, gtk.STATE_INSENSITIVE, gtk.ORIENTATION_HORIZONTAL),

        ('vn', sw, msl, gtk.STATE_NORMAL,      gtk.ORIENTATION_VERTICAL),
        ('va', sw, msl, gtk.STATE_PRELIGHT,    gtk.ORIENTATION_VERTICAL),
        ('vp', sw, msl, gtk.STATE_NORMAL,      gtk.ORIENTATION_VERTICAL),
        ('vd', sw, msl, gtk.STATE_INSENSITIVE, gtk.ORIENTATION_VERTICAL),
            ):
        fn = 'sbthumb-'+t
        if 0:
            style.paint_slider(drawing_area.window, state, gtk.SHADOW_OUT,
                               None, drawing_area, "slider",
                               0, 0, w, h, orient)
        else:
            if orient == gtk.ORIENTATION_VERTICAL:
                w, h = h, w
            style.paint_box(drawing_area.window, state, shadow,
                            None, drawing_area, "stepper", 0, 0, w, h)
        save_image(fn, w, h)

    msl = hscroll.style_get_property("min_slider_length")
    sw = hscroll.style_get_property("slider_width")
    # scale
    for t, w, h, state, orient in (
        ('hn', msl, sw, gtk.STATE_NORMAL,      gtk.ORIENTATION_HORIZONTAL),
        ('ha', msl, sw, gtk.STATE_PRELIGHT,    gtk.ORIENTATION_HORIZONTAL),
        ('hd', msl, sw, gtk.STATE_INSENSITIVE, gtk.ORIENTATION_HORIZONTAL),
        ('vn', sw, msl, gtk.STATE_NORMAL,      gtk.ORIENTATION_VERTICAL),
        ('va', sw, msl, gtk.STATE_PRELIGHT,    gtk.ORIENTATION_VERTICAL),
        ('vd', sw, msl, gtk.STATE_INSENSITIVE, gtk.ORIENTATION_VERTICAL),
            ):
        fn = 'scale-'+t
        if orient == gtk.ORIENTATION_HORIZONTAL:
            detail = "hscale"
        else:
            detail = "vscale"
        style.paint_slider(drawing_area.window, state, gtk.SHADOW_OUT,
                           None, drawing_area, detail, 0, 0, w+2, h+2, orient)
        save_image(fn, w, h, 1, 1)

    w, h = msl, sw
    fn = 'scaletrough-h'
    style.paint_box(drawing_area.window, gtk.STATE_ACTIVE, gtk.SHADOW_IN,
                    None, scale, "trough", 0, 0, w, h)
    save_image(fn, w, h)

    # arrow
    w = h = hscroll.style_get_property("stepper_size")
    # w = h = 15
    arrow_width = w / 2
    arrow_height = h / 2
    arrow_x = (w - arrow_width) / 2
    arrow_y = (h - arrow_height) / 2

    alloc = hscroll.get_allocation()
    x0 = alloc.x
    x1 = alloc.x+alloc.width-w
    alloc = vscroll.get_allocation()
    y0 = alloc.y
    y1 = alloc.y+alloc.height-h

    sn = gtk.STATE_NORMAL
    sp = gtk.STATE_PRELIGHT
    sa = gtk.STATE_ACTIVE
    si = gtk.STATE_INSENSITIVE

    for fn, x, y, state, shadow, arrow_type, widget in (
        ("arrowleft-n", x0, 0, sn, gtk.SHADOW_OUT, gtk.ARROW_LEFT, hscroll),
        ("arrowleft-a", x0, 0, sp, gtk.SHADOW_OUT, gtk.ARROW_LEFT, hscroll),
        ("arrowleft-p", x0, 0, sa, gtk.SHADOW_IN,  gtk.ARROW_LEFT, hscroll),
        ("arrowleft-d", x0, 0, si, gtk.SHADOW_OUT, gtk.ARROW_LEFT, hscroll),

        ("arrowright-n", x1, 0, sn, gtk.SHADOW_OUT, gtk.ARROW_RIGHT, hscroll),
        ("arrowright-a", x1, 0, sp, gtk.SHADOW_OUT, gtk.ARROW_RIGHT, hscroll),
        ("arrowright-p", x1, 0, sa, gtk.SHADOW_IN,  gtk.ARROW_RIGHT, hscroll),
        ("arrowright-d", x1, 0, si, gtk.SHADOW_OUT, gtk.ARROW_RIGHT, hscroll),

        ("arrowup-n", 0, y0, sn, gtk.SHADOW_OUT, gtk.ARROW_UP, vscroll),
        ("arrowup-a", 0, y0, sp, gtk.SHADOW_OUT, gtk.ARROW_UP, vscroll),
        ("arrowup-p", 0, y0, sa, gtk.SHADOW_IN,  gtk.ARROW_UP, vscroll),
        ("arrowup-d", 0, y0, si, gtk.SHADOW_OUT, gtk.ARROW_UP, vscroll),

        ("arrowdown-n", 0, y1, sn, gtk.SHADOW_OUT, gtk.ARROW_DOWN, vscroll),
        ("arrowdown-a", 0, y1, sp, gtk.SHADOW_OUT, gtk.ARROW_DOWN, vscroll),
        ("arrowdown-p", 0, y1, sa, gtk.SHADOW_IN,  gtk.ARROW_DOWN, vscroll),
        ("arrowdown-d", 0, y1, si, gtk.SHADOW_OUT, gtk.ARROW_DOWN, vscroll),
            ):
        if 0:
            detail = 'hscrollbar'
            if widget is vscroll:
                detail = 'vscrollbar'
        else:
            x, y = 0, 0
            detail = 'stepper'
            widget = drawing_area
        style.paint_box(drawing_area.window, state, shadow,
                        None, widget, detail, x, y, w, h)
        style.paint_arrow(drawing_area.window, state, shadow,
                          None, widget, detail, arrow_type, True,
                          x+arrow_x, y+arrow_y, arrow_width, arrow_height)
        save_image(fn, w, h, x, y)

    # combobox
    w, h = w, 24
    w, h = 16, 24
    alloc = hscroll.get_allocation()
    x1 = alloc.x+alloc.width-w
    arrow_width = w / 2
    arrow_height = h / 2
    arrow_x = (w - arrow_width) / 2
    arrow_y = (h - arrow_height) / 2
    detail = 'hscrollbar'
    widget = hscroll
    for fn, state, shadow, arrow_type in (
        ("comboarrow-n", gtk.STATE_NORMAL,     gtk.SHADOW_OUT, gtk.ARROW_DOWN),
        ("comboarrow-a", gtk.STATE_PRELIGHT,   gtk.SHADOW_OUT, gtk.ARROW_DOWN),
        ("comboarrow-p", gtk.STATE_ACTIVE,      gtk.SHADOW_IN, gtk.ARROW_DOWN),
        ("comboarrow-d", gtk.STATE_INSENSITIVE, gtk.SHADOW_IN, gtk.ARROW_DOWN),
            ):
        style.paint_box(drawing_area.window, state, shadow,
                        None, widget, detail, x1, 0, w, h)
        style.paint_arrow(drawing_area.window, state, shadow,
                          None, drawing_area, "stepper", arrow_type, True,
                          x1+arrow_x, arrow_y, arrow_width, arrow_height)
        save_image(fn, w, h, x1, 0)

    w = 24
    for fn, state, shadow in (
        ("combo-rn", gtk.STATE_NORMAL,      gtk.SHADOW_OUT),
        ("combo-ra", gtk.STATE_PRELIGHT,    gtk.SHADOW_OUT),
        ("combo-rp", gtk.STATE_ACTIVE,      gtk.SHADOW_IN),
        ("combo-rd", gtk.STATE_INSENSITIVE, gtk.SHADOW_OUT),
            ):
        style.paint_box(drawing_area.window, state, shadow,
                        None, drawing_area, "button", 0, 0, w+2, h)
        save_image(fn, w, h)

    style.paint_box(drawing_area.window, gtk.STATE_NORMAL, gtk.SHADOW_OUT,
                    None, drawing_area, "button", 0, 0, w+2, h)
    d = 3
    style.paint_focus(drawing_area.window, gtk.STATE_NORMAL,
                      None, drawing_area, "button", d, d, w-2*d, h-2*d)
    save_image('combo-rf', w, h)

    style.paint_shadow(drawing_area.window, gtk.STATE_NORMAL, gtk.SHADOW_IN,
                       None, drawing_area, "entry", 0, 0, w+2, h)
    save_image('combo-n', w, h)

    # checkbutton
    # define INDICATOR_SIZE     13
    # define INDICATOR_SPACING  2
    x, y = 2, 2
    w, h = 13, 13
    # w = h = checkbutton.style_get_property("indicator_size")
    for fn, state, shadow in (
        ("check-nc", gtk.STATE_NORMAL,      gtk.SHADOW_IN),
        ("check-nu", gtk.STATE_NORMAL,      gtk.SHADOW_OUT),
        ("check-ac", gtk.STATE_PRELIGHT,    gtk.SHADOW_IN),
        ("check-au", gtk.STATE_PRELIGHT,    gtk.SHADOW_OUT),
        ("check-pc", gtk.STATE_ACTIVE,      gtk.SHADOW_IN),
        ("check-pu", gtk.STATE_ACTIVE,      gtk.SHADOW_OUT),
        ("check-dc", gtk.STATE_INSENSITIVE, gtk.SHADOW_IN),
        ("check-du", gtk.STATE_INSENSITIVE, gtk.SHADOW_OUT),
            ):
        #   style.paint_flat_box(drawing_area.window,
        #                   gtk.STATE_PRELIGHT,
        #                   gtk.SHADOW_ETCHED_OUT,
        #                   gtk.gdk.Rectangle(0, 0,w, h), drawing_area,
        #                   "checkbutton", 0, 0, w, h)

        style.paint_check(drawing_area.window, state, shadow,
                          None, drawing_area, "checkbutton", x, y, w, h)
        save_image(fn, w+2*x, h+2*y)

    # radiobutton
    for fn, state, shadow in (
        ("radio-nc", gtk.STATE_NORMAL,      gtk.SHADOW_IN),
        ("radio-nu", gtk.STATE_NORMAL,      gtk.SHADOW_OUT),
        ("radio-ac", gtk.STATE_PRELIGHT,    gtk.SHADOW_IN),
        ("radio-au", gtk.STATE_PRELIGHT,    gtk.SHADOW_OUT),
        ("radio-pc", gtk.STATE_ACTIVE,      gtk.SHADOW_IN),
        ("radio-pu", gtk.STATE_ACTIVE,      gtk.SHADOW_OUT),
        ("radio-dc", gtk.STATE_INSENSITIVE, gtk.SHADOW_IN),
        ("radio-du", gtk.STATE_INSENSITIVE, gtk.SHADOW_OUT),
            ):
        #   style.paint_flat_box(drawing_area.window,
        #                   gtk.STATE_PRELIGHT,
        #                   gtk.SHADOW_ETCHED_OUT,
        #                   gtk.gdk.Rectangle(0, 0,w, h), drawing_area,
        #                   "checkbutton", 0, 0, w, h)
        style.paint_option(drawing_area.window, state, shadow,
                           None, drawing_area, "radiobutton", x, y, w, h)
        save_image(fn, w+2*x, h+2*y)

    # notebook
    w, h = 28, 22
    state = gtk.STATE_NORMAL
    shadow = gtk.SHADOW_OUT

    for fn, gap_h, state in (
        ("tab-n", 0, gtk.STATE_NORMAL),
        ("tab-a", 2, gtk.STATE_ACTIVE),
            ):
        #  style.paint_box_gap(drawing_area.window, state, shadow,
        #                      gtk.gdk.Rectangle(0, 0,w,gap_h), drawing_area,
        #                      "notebook", 0, 0, w,gap_h, gtk.POS_TOP, 0, w)
        y = gap_h
        hh = h - y
        style.paint_extension(drawing_area.window, state, gtk.SHADOW_OUT,
                              None, drawing_area, "tab",
                              0, y, w, hh, gtk.POS_BOTTOM)
        save_image(fn, w, h+2)

    print('done')

    gtk.main_quit()


def pack(w, row, col):
    table.attach(w,
                 col, col+1,              row, row+1,
                 gtk.EXPAND | gtk.FILL,   gtk.EXPAND | gtk.FILL,
                 0,                       0)


win = gtk.Window()
win.connect("destroy", gtk.main_quit)

table = gtk.Table()
win.add(table)

row, col = 0, 0

drawing_area = gtk.DrawingArea()
# drawing_area.set_size_request(100, 100)
pack(drawing_area, row, col)
row += 1

vscroll = gtk.VScrollbar()
pack(vscroll, 0, 1)

hscroll = gtk.HScrollbar()
pack(hscroll, row, col)
row += 1


notebook = gtk.Notebook()
label = gtk.Label("Label")
notebook.append_page(label)
label = gtk.Label("Label")
notebook.append_page(label)
pack(notebook, row, col)
row += 1

button = gtk.Button("Button")
pack(button, row, col)
row += 1

checkbutton = gtk.CheckButton("CheckButton")
pack(checkbutton, row, col)
row += 1

progress = gtk.ProgressBar()
pack(progress, row, col)
row += 1

scale = gtk.HScale()
pack(scale, row, col)
row += 1

entry = gtk.Entry()
pack(entry, row, col)
row += 1

togglebutton = gtk.ToggleButton()
pack(togglebutton, row, col)
togglebutton.set_active(True)
row += 1


drawing_area.connect("expose-event", save_callback)
# gobject.timeout_add(2000, save_callback)

win.show_all()
# drawing_area.modify_bg(gtk.STATE_NORMAL, gtk.gdk.color_parse('red'))

gtk.main()
