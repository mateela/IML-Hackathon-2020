
    def createGame(self, max_rounds=-1, num_deal=1, **layout):
        l, s = Layout(self), self.s
        kwdefault(layout, rows=8, waste=1, playcards=20)
        self.Layout_Method(l, **layout)
        self.setSize(l.size[0], l.size[1])

        # Create talon
        s.talon = self.Talon_Class(l.s.talon.x, l.s.talon.y, self,
                                   max_rounds=max_rounds, num_deal=num_deal)
        s.waste = WasteStack(l.s.waste.x, l.s.waste.y, self)

        # Create foundations
        for r in l.s.foundations[:4]:
            s.foundations.append(
                self.Foundation_Class(
                    r.x, r.y, self,
                    r.suit, mod=16, max_cards=16, max_move=1))
        r = l.s.foundations[4]
        s.foundations.append(
            HexATrump_Foundation(
                r.x, r.y, self, 4, mod=4,
                max_move=0, max_cards=4, base_rank=ANY_RANK))

        # Create rows
        for r in l.s.rows:
            s.rows.append(self.RowStack_Class(r.x, r.y, self,
                                              suit=ANY_SUIT, base_rank=15))

        # Define stack groups
        l.defaultAll()

    #
    # Game over rides
    #

    def startGame(self):
        assert len(self.s.talon.cards) == 68
        for i in range(len(self.s.rows)):
            self.s.talon.dealRow(rows=self.s.rows[i+1:], flip=0, frames=0)
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealCards()

    def _shuffleHook(self, cards):
        basecard = [None]
        for c in cards[:]:
            if c.suit == 4:
                if basecard[0] is None:
                    basecard[0] = c
                    cards.remove(c)
        cards = basecard + cards
        cards.reverse()
        return cards

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return (card1.color != card2.color and
                (card1.rank + 1 == card2.rank or card2.rank + 1 == card1.rank))


# ************************************************************************
# * Klondike Plus 16
# ************************************************************************

class KlondikePlus16(Game):
    Hint_Class = CautiousDefaultHint
    Layout_Method = staticmethod(Layout.klondikeLayout)
    Talon_Class = WasteTalonStack
    Foundation_Class = SS_FoundationStack
    RowStack_Class = HexAKlon_RowStack

    #
    # Game layout
    #

    def createGame(self, max_rounds=2, num_deal=1, **layout):
        l, s = Layout(self), self.s
        kwdefault(layout, rows=8, waste=1, playcards=20)
        self.Layout_Method(l, **layout)
        self.setSize(l.size[0], l.size[1])

        # Create talon
        s.talon = self.Talon_Class(l.s.talon.x, l.s.talon.y, self,
                                   max_rounds=max_rounds, num_deal=num_deal)
        s.waste = WasteStack(l.s.waste.x, l.s.waste.y, self)

        # Create foundations
        for r in l.s.foundations:
            s.foundations.append(
                self.Foundation_Class(
                    r.x, r.y, self,
                    r.suit, mod=16, max_cards=16, max_move=1))

        # Create rows
        for r in l.s.rows:
            s.rows.append(self.RowStack_Class(r.x, r.y, self,
                                              suit=ANY_SUIT, base_rank=15))

        # Define stack groups
        l.defaultAll()

    #
    # Game over rides
    #

    def startGame(self):
        assert len(self.s.talon.cards) == 68
        for i in range(len(self.s.rows)):
            self.s.talon.dealRow(rows=self.s.rows[i+1:], flip=0, frames=0)
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealCards()

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return (card1.color != card2.color and
                (card1.rank + 1 == card2.rank or card2.rank + 1 == card1.rank))


# ************************************************************************
# * The Familiar
# ************************************************************************

class TheFamiliar(Game):
    Hint_Class = CautiousDefaultHint
    Layout_Method = staticmethod(Layout.klondikeLayout)
    Talon_Class = WasteTalonStack
    Foundation_Class = SS_FoundationStack
    RowStack_Class = AC_RowStack

    #
    # Game layout
    #

    def createGame(self, max_rounds=2, num_deal=1, **layout):
        l, s = Layout(self), self.s
        kwdefault(layout, rows=8, waste=1, playcards=20)
        self.Layout_Method(l, **layout)
        self.setSize(l.size[0], l.size[1])

        # Create talon
        s.talon = self.Talon_Class(l.s.talon.x, l.s.talon.y, self,
                                   max_rounds=max_rounds, num_deal=num_deal)
        s.waste = WasteStack(l.s.waste.x, l.s.waste.y, self)

        # Create foundations
        for r in l.s.foundations:
            s.foundations.append(
                self.Foundation_Class(
                    r.x, r.y, self,
                    r.suit, mod=16, max_cards=16, max_move=1))

        # Create rows
        for r in l.s.rows:
            s.rows.append(self.RowStack_Class(r.x, r.y, self,
                                              suit=ANY_SUIT, base_rank=15))

        # Create reserve
        x, y = l.XM, self.height - l.YS
        s.reserves.append(Familiar_ReserveStack(x, y, self, max_cards=3))
        self.setRegion(
            s.reserves, (-999, y - l.YM, x + l.XS, 999999), priority=1)
        l.createText(s.reserves[0], "se")

        # Define stack groups
        l.defaultAll()

    #
    # Game over rides
    #

    def startGame(self):
        assert len(self.s.talon.cards) == 68
        for i in range(len(self.s.rows)):
            self.s.talon.dealRow(rows=self.s.rows[i+1:], flip=0, frames=0)
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealCards()

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return (card1.color != card2.color and
                (card1.rank + 1 == card2.rank or card2.rank + 1 == card1.rank))


# ************************************************************************
# * Two Familiars
# ************************************************************************

class TwoFamiliars(Game):
    Hint_Class = CautiousDefaultHint
    Layout_Method = staticmethod(Layout.klondikeLayout)
    Talon_Class = WasteTalonStack
    Foundation_Class = SS_FoundationStack
    RowStack_Class = AC_RowStack

    #
    # Game layout
    #

    def createGame(self, max_rounds=2, num_deal=1, **layout):
        l, s = Layout(self), self.s
        kwdefault(layout, rows=12, waste=1, playcards=20)
        self.Layout_Method(l, **layout)
        self.setSize(l.size[0], l.size[1])

        # Create talon
        s.talon = self.Talon_Class(l.s.talon.x, l.s.talon.y, self,
                                   max_rounds=max_rounds, num_deal=num_deal)
        s.waste = WasteStack(l.s.waste.x, l.s.waste.y, self)

        # Create foundations
        for r in l.s.foundations:
            s.foundations.append(
                self.Foundation_Class(
                    r.x, r.y, self,
                    r.suit, mod=16, max_cards=16, max_move=1))

        # Create rows
        for r in l.s.rows:
            s.rows.append(self.RowStack_Class(r.x, r.y, self,
                                              suit=ANY_SUIT, base_rank=15))

        # Create reserve
        x, y = l.XM, self.height - l.YS
        s.reserves.append(Familiar_ReserveStack(x, y, self, max_cards=3))
        self.setRegion(
            s.reserves, (-999, y - l.YM, x + l.XS, 999999), priority=1)
        l.createText(s.reserves[0], "se")

        # Define stack groups
        l.defaultAll()

    #
    # Game over rides
    #

    def startGame(self):
        assert len(self.s.talon.cards) == 68 * 2
        for i in range(len(self.s.rows)):
            self.s.talon.dealRow(rows=self.s.rows[i+1:], flip=0, frames=0)
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealCards()

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return (card1.color != card2.color and
                (card1.rank + 1 == card2.rank or card2.rank + 1 == card1.rank))


# ************************************************************************
# * Ten by Eight
# ************************************************************************

class TenByEight(Game):
    Hint_Class = CautiousDefaultHint
    Layout_Method = staticmethod(Layout.gypsyLayout)
    Talon_Class = WasteTalonStack
    Foundation_Class = SS_FoundationStack
    RowStack_Class = AC_RowStack

    #
    # Game layout
    #

    def createGame(self, max_rounds=-1, num_deal=1, **layout):
        l, s = Layout(self), self.s
        kwdefault(layout, rows=10, waste=1, playcards=30)
        self.Layout_Method(l, **layout)
        self.setSize(l.size[0], l.size[1])

        # Create talon
        s.talon = self.Talon_Class(l.s.talon.x, l.s.talon.y, self,
                                   max_rounds=max_rounds, num_deal=num_deal)
        s.waste = WasteStack(l.s.waste.x, l.s.waste.y, self)

        # Create foundations
        for r in l.s.foundations:
            s.foundations.append(
                self.Foundation_Class(
                    r.x, r.y, self,
                    r.suit, mod=16, max_cards=16, max_move=1))

        # Create rows
        for r in l.s.rows:
            s.rows.append(self.RowStack_Class(r.x, r.y, self,
                                              suit=ANY_SUIT,
                                              base_rank=ANY_RANK))

        # Define stack groups
        l.defaultAll()

    #
    # Game over rides
    #

    def startGame(self):
        assert len(self.s.talon.cards) == 68 * 2
        frames = 0
        for i in range(8):
            if i == 5:
                frames = -1
                self.startDealSample()
            self.s.talon.dealRow(frames=frames)
        self.s.talon.dealCards()

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return (card1.color != card2.color and
                (card1.rank + 1 == card2.rank or card2.rank + 1 == card1.rank))


# ************************************************************************
# * Drawbridge
# ************************************************************************

class Drawbridge(Game):
    Hint_Class = CautiousDefaultHint
    Layout_Method = staticmethod(Layout.harpLayout)
    Talon_Class = WasteTalonStack
    Foundation_Class = SS_FoundationStack
    RowStack_Class = AC_RowStack

    #
    # Game layout
    #

    def createGame(self, max_rounds=2, num_deal=1, **layout):
        l, s = Layout(self), self.s
        kwdefault(layout, rows=7, waste=1, playcards=20)
        self.Layout_Method(l, **layout)
        self.setSize(l.size[0], l.size[1])

        # Create talon
        s.talon = self.Talon_Class(l.s.talon.x, l.s.talon.y, self,
                                   max_rounds=max_rounds, num_deal=num_deal)
        s.waste = WasteStack(l.s.waste.x, l.s.waste.y, self)

        # Create foundations
        for r in l.s.foundations:
            s.foundations.append(
                self.Foundation_Class(
                    r.x, r.y, self,
                    r.suit, mod=16, max_cards=16, max_move=1))

        # Create rows
        for r in l.s.rows:
            s.rows.append(self.RowStack_Class(r.x, r.y, self,
                                              suit=ANY_SUIT,
                                              base_rank=ANY_RANK))

        # Define stack groups
        l.defaultAll()

    #
    # Game over rides
    #

    def startGame(self):
        assert len(self.s.talon.cards) == 68
        for i in range(len(self.s.rows) - 1):
            self.s.talon.dealRow(rows=self.s.rows[i+1:], flip=0, frames=0)
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealCards()

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return (card1.color != card2.color and
                (card1.rank + 1 == card2.rank or card2.rank + 1 == card1.rank))


# ************************************************************************
# * Double Drawbridge
# ************************************************************************

class DoubleDrawbridge(Game):
    Hint_Class = CautiousDefaultHint
    Layout_Method = staticmethod(Layout.harpLayout)
    Talon_Class = WasteTalonStack
    Foundation_Class = SS_FoundationStack
    RowStack_Class = AC_RowStack

    #
    # Game layout
    #

    def createGame(self, max_rounds=2, num_deal=1, **layout):
        l, s = Layout(self), self.s
        kwdefault(layout, rows=10, waste=1, playcards=20)
        self.Layout_Method(l, **layout)
        self.setSize(l.size[0], l.size[1])

        # Create talon
        s.talon = self.Talon_Class(l.s.talon.x, l.s.talon.y, self,
                                   max_rounds=max_rounds, num_deal=num_deal)
        s.waste = WasteStack(l.s.waste.x, l.s.waste.y, self)

        # Create foundations
        for r in l.s.foundations:
            s.foundations.append(
                self.Foundation_Class(
                    r.x, r.y, self,
                    r.suit, mod=16, max_cards=16, max_move=1))

        # Create rows
        for r in l.s.rows:
            s.rows.append(
                self.RowStack_Class(
                    r.x, r.y, self,
                    suit=ANY_SUIT, base_rank=ANY_RANK))

        # Define stack groups
        l.defaultAll()

    #
    # Game over rides
    #

    def startGame(self):
        assert len(self.s.talon.cards) == 68 * 2
        for i in range(len(self.s.rows) - 1):
            self.s.talon.dealRow(rows=self.s.rows[i+1:], flip=0, frames=0)
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealCards()

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return (card1.color != card2.color and
                (card1.rank + 1 == card2.rank or card2.rank + 1 == card1.rank))


# ************************************************************************
# * Hidden Passages
# ************************************************************************

class HiddenPassages(Game):
    Hint_Class = CautiousDefaultHint
    Layout_Method = staticmethod(Layout.klondikeLayout)
    Talon_Class = WasteTalonStack
    Foundation_Class = SS_FoundationStack
    RowStack_Class = AC_RowStack

    #
    # Game layout
    #

    def createGame(self, max_rounds=2, num_deal=1, **layout):
        l, s = Layout(self), self.s
        kwdefault(layout, rows=7, waste=1, playcards=20)
        self.Layout_Method(l, **layout)
        self.setSize(l.size[0], l.size[1])

        # Create talon
        s.talon = self.Talon_Class(l.s.talon.x, l.s.talon.y, self,
                                   max_rounds=max_rounds, num_deal=num_deal)
        s.waste = WasteStack(l.s.waste.x, l.s.waste.y, self)

        # Create foundations
        for r in l.s.foundations[:4]:
            s.foundations.append(
                self.Foundation_Class(
                    r.x, r.y, self,
                    r.suit, mod=16, max_cards=16, max_move=1))
        r = l.s.foundations[4]
        s.foundations.append(
            HexATrump_Foundation(
                r.x, r.y, self, 4, mod=4,
                max_move=0, max_cards=4, base_rank=ANY_RANK))

        # Create rows
        for r in l.s.rows:
            s.rows.append(self.RowStack_Class(r.x, r.y, self,
                                              suit=ANY_SUIT,
                                              base_rank=ANY_RANK))

        # Define stack groups
        l.defaultAll()

    #
    # Game over rides
    #
    def _shuffleHook(self, cards):
        topcards = [None] * 4
        for c in cards[:]:
            if c.rank == 0 and not c.suit == 4:
                topcards[c.suit] = c
                cards.remove(c)
        cards = topcards + cards
        cards.reverse()
        return cards

    def startGame(self):
        assert len(self.s.talon.cards) == 68
        self.s.talon.dealRow(rows=self.s.foundations[:4], frames=0)
        for i in range(2):
            self.s.talon.dealRow(flip=0, frames=0)
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealCards()

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return (card1.color != card2.color and
                (card1.rank + 1 == card2.rank or card2.rank + 1 == card1.rank))


# ************************************************************************
# * Cluitjar's Lair
# ************************************************************************

class CluitjarsLair(Game):
    Hint_Class = CautiousDefaultHint
    Layout_Method = staticmethod(Layout.klondikeLayout)
    Talon_Class = WasteTalonStack
    Foundation_Class = SS_FoundationStack
    RowStack_Class = HexADeck_ACRowStack

    #
    # Game layout
    #

    def createGame(self, max_rounds=1, num_deal=1, **layout):
        l, s = Layout(self), self.s
        kwdefault(layout, rows=7, waste=1, playcards=20)
        self.Layout_Method(l, **layout)
        self.setSize(l.size[0], l.size[1])

        # Create talon
        s.talon = self.Talon_Class(l.s.talon.x, l.s.talon.y, self,
                                   max_rounds=max_rounds, num_deal=num_deal)
        s.waste = WasteStack(l.s.waste.x, l.s.waste.y, self)

        # Create foundations
        for r in l.s.foundations[:4]:
            s.foundations.append(
                self.Foundation_Class(
                    r.x, r.y, self,
                    r.suit, mod=16, max_cards=16, max_move=1))
        r = l.s.foundations[4]
        s.foundations.append(
            HexATrump_Foundation(
                r.x, r.y, self, 4, mod=4,
                max_move=0, max_cards=4, base_rank=ANY_RANK))

        # Create rows
        for r in l.s.rows:
            s.rows.append(self.RowStack_Class(r.x, r.y, self,
                                              suit=ANY_SUIT,
                                              base_rank=ANY_RANK))

        # Define stack groups
        l.defaultAll()

    #
    # Game over rides
    #
    def startGame(self):
        assert len(self.s.talon.cards) == 68
        for i in range(2):
            self.s.talon.dealRow(flip=0, frames=0)
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealCards()

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return (card1.color != card2.color and
                (card1.rank + 1 == card2.rank or card2.rank + 1 == card1.rank))


# ************************************************************************
# * Merlin's Meander
# ************************************************************************

class MerlinsMeander(AbstractHexADeckGame):
    Hint_Class = Merlins_Hint
    MERLINS_CARDS = 20

    #
    # game layout
    #

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        # (piles up to 20 cards are playable - needed for Braid_BraidStack)
        h = max(4*l.YS + 30, l.YS+(self.MERLINS_CARDS-1)*l.YOFFSET)
        self.setSize(10*l.XS+l.XM, l.YM + h)

        # extra settings
        self.base_card = None

        # Create rows, reserves
        s.addattr(braid=None)      # register extra stack variable
        x, y = l.XM, l.YM
        for i in range(2):
            s.rows.append(Merlins_RowStack(x + l.XS * 0.5, y, self))
            s.rows.append(Merlins_RowStack(x + l.XS * 4.5, y, self))
            s.reserves.append(
                Familiar_ReserveStack(x + l.XS * 6.5, y, self, max_cards=3))
            y = y + l.YS * 3
        y = l.YM + l.YS
        for i in range(2):
            s.rows.append(Merlins_ReserveStack(x, y, self))
            s.rows.append(Merlins_ReserveStack(x + l.XS, y, self))
            s.rows.append(Merlins_ReserveStack(x, y + l.YS, self))
            s.rows.append(Merlins_ReserveStack(x + l.XS, y + l.YS, self))
            x = x + l.XS * 4

        # Create braid
        x, y = l.XM + l.XS * 2.2, l.YM
        s.braid = Merlins_BraidStack(x, y, self)

        # Create talon, waste
        x, y = l.XM + l.XS * 7, l.YM + l.YS * 1.5
        s.talon = WasteTalonStack(x, y, self, max_rounds=3)
        l.createText(s.talon, "s")
        s.talon.texts.rounds = MfxCanvasText(
            self.canvas,
            x + l.CW // 2, y - l.YM,
            anchor="s",
            font=self.app.getFont("canvas_default"))
        x -= l.XS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, "s")

        # Create foundations
        x, y = l.XM + l.XS * 8, l.YM
        for i in range(4):
            s.foundations.append(
                Merlins_Foundation(
                    x, y, self, i, mod=16,
                    max_cards=16, base_rank=ANY_RANK))
            s.foundations.append(
                Merlins_Foundation(
                    x + l.XS, y, self, i, mod=16,
                    max_cards=16, base_rank=ANY_RANK))
            y = y + l.YS
        self.texts.info = MfxCanvasText(
            self.canvas,
            x + l.CW + l.XM // 2, y,
            anchor="n",
            font=self.app.getFont("canvas_default"))

        # define stack-groups
        self.sg.talonstacks = [s.talon] + [s.waste]
        self.sg.openstacks = s.foundations + s.rows + s.reserves
        self.sg.dropstacks = [s.braid] + s.rows + [s.waste] + s.reserves

    #
    # game overrides
    #

    def startGame(self):
        assert len(self.s.talon.cards) == 68 * 2
        self.startDealSample()
        self.base_card = None
        self.updateText()
        for i in range(self.MERLINS_CARDS):
            self.s.talon.dealRow(rows=[self.s.braid])
        self.s.talon.dealRow()
        # deal base_card to foundations, update cap.base_rank
        self.base_card = self.s.talon.getCard()
        while self.base_card.suit == 4:
            self.s.talon.cards.remove(self.base_card)
            self.s.talon.cards.insert(0, self.base_card)
            self.base_card = self.s.talon.getCard()
        to_stack = self.s.foundations[2 * self.base_card.suit]
        self.flipMove(self.s.talon)
        self.moveMove(1, self.s.talon, to_stack)
        self.updateText()
        for s in self.s.foundations:
            s.cap.base_rank = self.base_card.rank
        # deal first card to WasteStack
        self.s.talon.dealCards()

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return (card1.suit == card2.suit and
                ((card1.rank + 1) % 16 == card2.rank or
                 (card2.rank + 1) % 16 == card1.rank))

    def getHighlightPilesStacks(self):
        return ()

    def _restoreGameHook(self, game):
        self.base_card = self.cards[game.loadinfo.base_card_id]
        for s in self.s.foundations:
            s.cap.base_rank = self.base_card.rank

    def _loadGameHook(self, p):
        self.loadinfo.addattr(base_card_id=None)    # register extra load var.
        self.loadinfo.base_card_id = p.load()

    def _saveGameHook(self, p):
        p.dump(self.base_card.id)

    #
    # game extras
    #

    def updateText(self):
        if self.preview > 1 or not self.texts.info:
            return
        if not self.base_card:
            t = ""
        else:
            t = self.RANKS[self.base_card.rank]
            dir = self.getFoundationDir() % 16
            if dir == 1:
                t = t + _(" Ascending")
            elif dir == 15:
                t = t + _(" Descending")
        self.texts.info.config(text=t)

    def isGameWon(self):
        for s in self.s.rows:
            if s.cards and s.cards[0].suit != 4:
                return 0
        if not len(self.s.talon.cards) and len(self.s.waste.cards) == 1:
            return self.s.waste.cards[0].suit == 4
        return len(self.s.talon.cards) + len(self.s.waste.cards) == 0


# ************************************************************************
# * Mage's Game
# ************************************************************************

class MagesGame(Game):
    Hint_Class = CautiousDefaultHint
    Layout_Method = staticmethod(Layout.gypsyLayout)
    Talon_Class = InitialDealTalonStack
    Foundation_Class = SS_FoundationStack
    RowStack_Class = AC_RowStack

    #
    # Game layout
    #

    def createGame(self, max_rounds=1, num_deal=1, **layout):
        l, s = Layout(self), self.s
        kwdefault(layout, rows=12, texts=0, playcards=20)
        self.Layout_Method(l, **layout)
        self.setSize(l.size[0], l.size[1])

        # Create talon
        s.talon = self.Talon_Class(l.s.talon.x, l.s.talon.y, self,
                                   max_rounds=max_rounds, num_deal=num_deal)

        # Create foundations
        for r in l.s.foundations:
            s.foundations.append(
                self.Foundation_Class(
                    r.x, r.y, self,
                    r.suit, mod=16, max_cards=16, max_move=1))

        # Create rows
        for r in l.s.rows:
            s.rows.append(self.RowStack_Class(r.x, r.y, self,
                                              suit=ANY_SUIT,
                                              base_rank=ANY_RANK))

        # Define stack groups
        l.defaultAll()

    #
    # Game over rides
    #

    def startGame(self):
        assert len(self.s.talon.cards) == 68
        self._startDealNumRows(4)
        self.s.talon.dealRow()
        self.s.talon.dealRow(rows=self.s.rows[2:10])
        self.s.talon.dealCards()

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return (card1.color != card2.color and
                (card1.rank + 1 == card2.rank or card2.rank + 1 == card1.rank))


# ************************************************************************
# *
# ************************************************************************

class Convolution(AbstractHexADeckGame):
    RowStack_Class = StackWrapper(HexADeck_RK_RowStack, base_rank=NO_RANK)

    #
    # game layout
    #

    def createGame(self, rows=9, reserves=8):
        # create layout
        l, s = Layout(self), self.s

        # set size
        maxrows = max(rows, reserves)
        self.setSize(l.XM + (maxrows + 2) * l.XS, l.YM + 6 * l.YS)

        #
        playcards = 4 * l.YS // l.YOFFSET
        xoffset, yoffset = [], []
        for i in range(playcards):
            xoffset.append(0)
            yoffset.append(l.YOFFSET)
        for i in range(68 * self.gameinfo.decks - playcards):
            xoffset.append(l.XOFFSET)
            yoffset.append(0)

        # create stacks
        x, y = l.XM + (maxrows - reserves) * l.XS // 2, l.YM
        for i in range(reserves):
            s.reserves.append(ReserveStack(x, y, self))
            x = x + l.XS
        x, y = l.XM + (maxrows - rows) * l.XS // 2, l.YM + l.YS
        self.setRegion(s.reserves, (-999, -999, 999999, y - l.YM // 2))
        for i in range(rows):
            stack = self.RowStack_Class(x, y, self, yoffset=yoffset)
            stack.CARD_XOFFSET = xoffset
            stack.CARD_YOFFSET = yoffset
            s.rows.append(stack)
            x = x + l.XS
        x, y = l.XM + maxrows * l.XS, l.YM
        for i in range(2):
            for suit in range(5):
                s.foundations.append(
                    SS_FoundationStack(x, y, self, suit=suit, max_cards=16))
                y = y + l.YS
            x, y = x + l.XS, l.YM
        self.setRegion(self.s.foundations, (x - l.XS * 2, -999, 999999,
                       self.height - (l.YS + l.YM)), priority=1)
        s.talon = InitialDealTalonStack(
            self.width - 3 * l.XS // 2, self.height - l.YS, self)

        # define stack-groups
        l.defaultStackGroups()

    #
    # game overrides
    #

    def startGame(self):
        self.startDealSample()
        i = 0
        while self.s.talon.cards:
            if self.s.talon.cards[-1].rank == 15:
                if self.s.rows[i].cards:
                    i = i + 1
            self.s.talon.dealRow(rows=[self.s.rows[i]], frames=4)

    # must look at cards
    def _getClosestStack(self, cx, cy, stacks, dragstack):
        closest, cdist = None, 999999999
        for stack in stacks:
            if stack.cards and stack is not dragstack:
                dist = (stack.cards[-1].x - cx)**2 + \
                    (stack.cards[-1].y - cy)**2
            else:
                dist = (stack.x - cx)**2 + (stack.y - cy)**2
            if dist < cdist:
                closest, cdist = stack, dist
        return closest

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        row = self.s.rows[0]
        sequence = row.isRankSequence
        return (sequence([card1, card2]) or sequence([card2, card1]))


# ************************************************************************
# *
# ************************************************************************

class Labyrinth(Convolution):
    RowStack_Class = StackWrapper(HexADeck_AC_RowStack, base_rank=NO_RANK)

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        row = self.s.rows[0]
        sequence = row.isAlternateColorSequence
        return (sequence([card1, card2]) or sequence([card2, card1]))


# ************************************************************************
# *
# ************************************************************************

class Snakestone(Convolution):
    RowStack_Class = StackWrapper(HexADeck_SS_RowStack, base_rank=NO_RANK)

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        row = self.s.rows[0]
        sequence = row.isSuitSequence
        return (sequence([card1, card2]) or sequence([card2, card1]))


# ************************************************************************
# *
# ************************************************************************

def r(id, gameclass, name, game_type, decks, redeals, skill_level):
    game_type = game_type | GI.GT_HEXADECK
    gi = GameInfo(id, gameclass, name, game_type, decks, redeals, skill_level,
                  suits=list(range(4)), ranks=list(range(16)),
                  trumps=list(range(4)))
    registerGame(gi)
    return gi


r(165, BitsNBytes, 'Bits n Bytes', GI.GT_HEXADECK, 1, 1, GI.SL_BALANCED)
r(166, HexAKlon, 'Hex A Klon', GI.GT_HEXADECK, 1, -1, GI.SL_BALANCED)
r(16666, KlondikePlus16, 'Klondike Plus 16', GI.GT_HEXADECK, 1, 1,
  GI.SL_BALANCED)
r(16667, HexAKlonByThrees, 'Hex A Klon by Threes', GI.GT_HEXADECK, 1, -1,
  GI.SL_BALANCED)
r(16668, KingOnlyHexAKlon, 'King Only Hex A Klon', GI.GT_HEXADECK, 1, -1,
  GI.SL_BALANCED)
r(16669, TheFamiliar, 'The Familiar', GI.GT_HEXADECK, 1, 1, GI.SL_BALANCED)
r(16670, TwoFamiliars, 'Two Familiars', GI.GT_HEXADECK, 2, 1, GI.SL_BALANCED)
r(16671, TenByEight, '10 x 8', GI.GT_HEXADECK, 2, -1, GI.SL_BALANCED)
r(16672, Drawbridge, 'Drawbridge', GI.GT_HEXADECK, 1, 1, GI.SL_BALANCED)
r(16673, DoubleDrawbridge, 'Double Drawbridge', GI.GT_HEXADECK, 2, 1,
  GI.SL_BALANCED)
r(16674, HiddenPassages, 'Hidden Passages', GI.GT_HEXADECK, 1, 1,
  GI.SL_MOSTLY_LUCK)
r(16675, CluitjarsLair, 'Cluitjar\'s Lair', GI.GT_HEXADECK, 1, 0,
  GI.SL_BALANCED)
r(16676, MerlinsMeander, 'Merlin\'s Meander', GI.GT_HEXADECK, 2, 2,
  GI.SL_BALANCED)
r(16677, MagesGame, 'Mage\'s Game', GI.GT_HEXADECK, 1, 0, GI.SL_BALANCED)
r(16678, Convolution, 'Convolution', GI.GT_HEXADECK, 2, 0, GI.SL_MOSTLY_SKILL)
r(16679, Labyrinth, 'Hex Labyrinth', GI.GT_HEXADECK, 2, 0, GI.SL_MOSTLY_SKILL)
r(16680, Snakestone, 'Snakestone', GI.GT_HEXADECK, 2, 0, GI.SL_MOSTLY_SKILL)

del r
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.games.ultra.hanafuda_common import \
        AbstractFlowerGame, \
        FlowerClock_RowStack, \
        Flower_OpenStack, \
        HanafudaRK_RowStack, \
        Hanafuda_SS_FoundationStack, \
        Hanafuda_SequenceStack, \
        JapaneseGarden_RowStack, \
        Queue_BraidStack, \
        Queue_Foundation, \
        Queue_Hint, \
        Queue_ReserveStack, \
        Queue_RowStack, \
        Samuri_RowStack
from pysollib.hint import AbstractHint, CautiousDefaultHint
from pysollib.layout import Layout
from pysollib.mfxutil import kwdefault
from pysollib.mygettext import _
from pysollib.pysoltk import MfxCanvasText
from pysollib.stack import \
        BasicRowStack, \
        DealRowTalonStack, \
        InitialDealTalonStack, \
        OpenStack, \
        ReserveStack, \
        StackWrapper, \
        WasteStack, \
        WasteTalonStack
from pysollib.util import ANY_RANK, ANY_SUIT, NO_RANK


# ************************************************************************
# * Paulownia
# ************************************************************************


class Paulownia(AbstractFlowerGame):
    Layout_Method = staticmethod(Layout.klondikeLayout)
    Talon_Class = WasteTalonStack
    Foundation_Class = Hanafuda_SS_FoundationStack
    RowStack_Class = Hanafuda_SequenceStack
    MaxRounds = -1
    BaseRank = 0
    NumDeal = 1

    #
    # Game layout
    #

    def createGame(self, **layout):
        l, s = Layout(self), self.s
        kwdefault(layout, rows=8, waste=1)
        self.Layout_Method(l, **layout)
        self.setSize(l.size[0], l.size[1])

        # Create talon
        s.talon = self.Talon_Class(l.s.talon.x, l.s.talon.y, self,
                                   max_rounds=self.MaxRounds,
                                   num_deal=self.NumDeal)
        s.waste = WasteStack(l.s.waste.x, l.s.waste.y, self)

        # Create foundations
        for r in l.s.foundations:
            s.foundations.append(self.Foundation_Class(r.x, r.y, self,
                                 suit=r.suit, base_rank=3))

        # Create row stacks
        for r in l.s.rows:
            s.rows.append(self.RowStack_Class(r.x, r.y, self,
                          base_rank=self.BaseRank, yoffset=l.YOFFSET))

        # Define stack groups
        l.defaultAll()

    #
    # Game over rides
    #

    def startGame(self):
        assert len(self.s.talon.cards) == 48 * self.gameinfo.decks
        for i in range(8):
            self.s.talon.dealRow(rows=self.s.rows[i + 1:], flip=0, frames=0)
        self.startDealSample()
        self.s.talon.dealRow()
        self.s.talon.dealCards()


class Pine(Paulownia):
    MaxRounds = 1
    NumDeal = 3


class Eularia(Paulownia):
    BaseRank = ANY_RANK


class Peony(Eularia):
    NumDeal = 3


class Iris(Peony):
    MaxRounds = 1


# ************************************************************************
# * Queue
# ************************************************************************

class LesserQueue(AbstractFlowerGame):
    Hint_Class = Queue_Hint
    BRAID_CARDS = 20
    BRAID_OFFSET = 1

    #
    # game layout
    #

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s

        # set window
        decks = self.gameinfo.decks
        yoffset = l.YOFFSET*self.BRAID_OFFSET
        h = l.YM+max(l.YS*5.5, l.YS+self.BRAID_CARDS*yoffset+2*l.TEXT_MARGIN)
        self.setSize(l.XM + l.XS * 10.5, h)

        # extra settings
        self.base_card = None

        # Create rows, reserves
        s.addattr(braid=None)
        x, x0 = l.XM + l.XS * 2, (decks - 1.5) % 2.5
        for j in range(decks // 2):
            y = l.YM
            for i in range(2):
                s.rows.append(Queue_RowStack(x + l.XS * (x0 + j), y, self))
                s.rows.append(Queue_RowStack(x + l.XS * (4 + x0 + j + .5), y,
                                             self))
                y = y + l.YS * (3 + (decks > 2))
        y = l.YM + l.YS
        for i in range(2):
            s.rows.append(Queue_ReserveStack(x, y, self))
            s.rows.append(Queue_ReserveStack(x + l.XS, y, self))
            s.rows.append(Queue_ReserveStack(x, y + l.YS, self))
            s.rows.append(Queue_ReserveStack(x + l.XS, y + l.YS, self))
            if decks - 2:
                s.rows.append(Queue_ReserveStack(x, y + l.YS * 2, self))
                s.rows.append(Queue_ReserveStack(x + l.XS, y + l.YS * 2, self))
            x = x + l.XS * 4.5

        # Create braid
        x, y = l.XM + l.XS * 4.25, l.YM
        s.braid = Queue_BraidStack(x, y, self, yoffset=self.BRAID_OFFSET)

        # Create talon, waste
        x, y = l.XM, h-l.YS
        s.talon = WasteTalonStack(x, y, self, max_rounds=3)
        l.createText(s.talon, "n")
        s.talon.texts.rounds = MfxCanvasText(
            self.canvas,
            self.width//2, h-2*l.TEXT_MARGIN,
            anchor="center",
            font=self.app.getFont("canvas_default"))
        x = x + l.XS
        s.waste = WasteStack(x, y, self)
        l.createText(s.waste, "n")

        # Create foundations
        x = l.XM
        for j in range(decks // 2):
            y = l.YM
            for i in range(4):
                s.foundations.append(Queue_Foundation(
                    x, y, self, -1, mod=12,
                    max_cards=12, base_suit=ANY_SUIT, base_rank=i, rank=i))
                s.foundations.append(
                    Queue_Foundation(
                        x + l.XS * (9.5 - j * 2),
                        y, self, -1, mod=12,
                        max_cards=12, base_suit=ANY_SUIT, base_rank=i, rank=i))
                y = y + l.YS
            x = x + l.XS
        self.texts.info = MfxCanvasText(
            self.canvas,
            self.width//2, h-l.TEXT_MARGIN,
            anchor="center",
            font=self.app.getFont("canvas_default"))

        # define stack-groups
        self.sg.talonstacks = [s.talon] + [s.waste]
        self.sg.openstacks = s.foundations + s.rows + s.reserves
        self.sg.dropstacks = [s.braid] + s.rows + [s.waste] + s.reserves

    #
    # game overrides
    #

    def startGame(self):
        assert len(self.s.talon.cards) == 48 * self.gameinfo.decks
        self.startDealSample()
        self.base_card = None
        self.updateText()
        for i in range(self.BRAID_CARDS):
            self.s.talon.dealRow(rows=[self.s.braid])
        self.s.talon.dealRow()
        # deal base_card to foundations, update cap.base_rank
        self.base_card = self.s.talon.getCard()
        to_stack = self.s.foundations[2 * self.base_card.rank]
        self.flipMove(self.s.talon)
        self.moveMove(1, self.s.talon, to_stack)
        self.updateText()
        for s in self.s.foundations:
            s.cap.base_suit = self.base_card.suit
        # deal first card to WasteStack
        self.s.talon.dealCards()

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return (card1.rank == card2.rank and
                ((card1.suit + 1) % 12 == card2.suit or
                 (card2.suit + 1) % 12 == card1.suit))

    def getHighlightPilesStacks(self):
        return ()

    def _restoreGameHook(self, game):
        self.base_card = self.cards[game.loadinfo.base_card_id]
        for s in self.s.foundations:
            s.cap.base_suit = self.base_card.suit

    def _loadGameHook(self, p):
        self.loadinfo.addattr(base_card_id=None)    # register extra load var.
        self.loadinfo.base_card_id = p.load()

    def _saveGameHook(self, p):
        p.dump(self.base_card.id)

    #
    # game extras
    #

    def updateText(self):
        if self.preview > 1 or not self.texts.info:
            return
        if not self.base_card:
            t = ""
        else:
            t = self.SUITS[self.base_card.suit]
            dir = self.getFoundationDir()
            if dir == 1:
                t = t + _(" Ascending")
            elif dir == 11:
                t = t + _(" Descending")
        self.texts.info.config(text=t)

    def getFoundationDir(self):
        for s in self.s.foundations:
            if len(s.cards) >= 2:
                return (s.cards[-1].suit - s.cards[-2].suit) % 12
        return 0


class GreaterQueue(LesserQueue):
    Hint_Class = Queue_Hint
    BRAID_CARDS = 40
    BRAID_OFFSET = .5


# ************************************************************************
# * Japanese Garden
# ************************************************************************

class JapaneseGarden(AbstractFlowerGame):
    Hint_Class = CautiousDefaultHint
    RowStack_Class = FlowerClock_RowStack
    WIDTH = 10
    HEIGHT = 6
    XROWS = 3
    YROWS = 2
    MAX_CARDS = 6
    MAX_MOVE = 1
    XRESERVES = 6
    YRESERVES = 2
    MAX_RESERVE = 0
    INITIAL_DEAL = 6
    DEAL_RESERVES = 1

    #
    # Game layout
    #

    def createGame(self):
        l, s = Layout(self), self.s

        # Set window size
        self.setSize(l.XM + l.XS * self.WIDTH, l.YM * 3 + l.YS * self.HEIGHT)

        # Create foundations
        x = self.width // 2 + l.XM // 2 - l.XS * 3
        y = l.YM
        for j in range(2):
            for i in range(6):
                s.foundations.append(
                    Hanafuda_SS_FoundationStack(
                        x, y, self, i + (j * 6),
                        max_cards=4, max_accept=1, base_rank=3))
                x = x + l.XS
            x = self.width // 2 + l.XM // 2 - l.XS * 3
            y = y + l.YS

        # Create flower beds
        x = l.XM
        y = l.YM * 2 + l.YS * 2
        for j in range(self.YROWS):
            for i in range(self.XROWS):
                row = self.RowStack_Class(
                    x, y, self, yoffset=0, max_accept=self.MAX_MOVE,
                    max_move=self.MAX_MOVE, max_cards=self.MAX_CARDS,
                    base_rank=0)
                row.CARD_XOFFSET = l.CW // 2
                s.rows.append(row)
                x = x + self.width // self.XROWS
            x = l.XM
            y = y + l.YS
        self.setRegion(s.rows, (l.XM, l.YS * 2, 999999, y))

        # Create pool
        x = self.width // 2 + l.XM // 2 - (l.XS * self.XRESERVES) // 2
        for j in range(self.YRESERVES):
            for i in range(self.XRESERVES):
                s.reserves.append(
                    ReserveStack(x, y, self, max_accept=self.MAX_RESERVE))
                x = x + l.XS
            x = self.width // 2 + l.XM // 2 - l.XS * (self.XRESERVES // 2)
            y = y + l.YS
        if s.reserves:
            self.setRegion(
                s.reserves, (l.XM, l.YS * (2 + self.YROWS), 999999, 999999))

        # Create talon
        s.talon = InitialDealTalonStack(l.XM, l.YM, self)

        # Define stack-groups
        l.defaultStackGroups()

    #
    # Game over rides
    #

    def startGame(self):
        assert len(self.s.talon.cards) == 48
        self.startDealSample()
        for i in range(self.INITIAL_DEAL):
            self.s.talon.dealRow()
        if self.DEAL_RESERVES:
            self.s.talon.dealRow(rows=self.s.reserves)
        self.s.talon.dealCards()


class JapaneseGardenII(JapaneseGarden):
    RowStack_Class = JapaneseGarden_RowStack


class JapaneseGardenIII(JapaneseGardenII):
    XROWS = 2
    YROWS = 4
    MAX_CARDS = 7
    XRESERVES = 0
    YRESERVES = 0
    DEAL_RESERVES = 0


class SixSages(JapaneseGarden):
    Hint_Class = CautiousDefaultHint
    XROWS = 2
    YROWS = 3
    MAX_CARDS = 9
    XRESERVES = 1
    YRESERVES = 1
    MAX_RESERVE = 1
    INITIAL_DEAL = 8
    DEAL_RESERVES = 0


class SixTengus(SixSages):
    RowStack_Class = HanafudaRK_RowStack
    HEIGHT = 5
    MAX_MOVE = 2
    XRESERVES = 0
    YRESERVES = 0


# ************************************************************************
# * Hanafuda Four Seasons
# ************************************************************************

class HanafudaFourSeasons(AbstractFlowerGame):

    #
    # Game layout
    #

    def createGame(self):
        l, s = Layout(self), self.s

        # Set window size
        self.setSize(l.XM + l.XS * 7, l.YM + l.YS * 5)

        # Create rows
        x, y, offset = l.XM, l.YM, self.app.images.CARD_YOFFSET
        for i in range(6):
            s.rows.append(Samuri_RowStack(x, y, self, offset, max_cards=8,
                                          max_accept=8, base_rank=0))
            x = x + l.XS + l.XM + (l.XM * (i == 2))
        x, y = l.XM, y + l.YS * 2.5
        for i in range(6):
            s.rows.append(Samuri_RowStack(x, y, self, offset, max_cards=8,
                                          max_accept=8, base_rank=0))
            x = x + l.XS + l.XM + (l.XM * (i == 2))
        self.setRegion(s.rows, (0, 0, 999999, 999999))

        # Create talon
        s.talon = InitialDealTalonStack(-l.XS, -l.YS, self)

        # Define stack-groups
        l.defaultAll()

    #
    # Game over rides
    #

    def startGame(self):
        assert len(self.s.talon.cards) == 48 * self.gameinfo.decks
        self.startDealSample()
        for i in range(4):
            self.s.talon.dealRow(flip=1)

    #
    # Game extras
    #

    def isGameWon(self):
        for r in self.s.rows:
            cards = r.cards
            if not len(cards) == 4:
                return 0
            if not (cards[0].suit == r.id and r.isHanafudaSequence(cards)):
                return 0
        return 1


# ************************************************************************
# * Wisteria
# ************************************************************************

class Wisteria(AbstractFlowerGame):
    RowStack_Class = StackWrapper(Hanafuda_SequenceStack, base_rank=NO_RANK)

    #
    # game layout
    #

    def createGame(self, rows=13):
        # create layout
        l, s = Layout(self), self.s

        # set size
        self.setSize(l.XM + rows * l.XS, l.YM + 6 * l.YS)

        # create stacks
        x, y = self.width // 2 - l.XS * 3, l.YM
        for i in range(2):
            for suit in range(6):
                s.foundations.append(
                    Hanafuda_SS_FoundationStack(
                        x, y, self, suit=suit + (6 * i)))
                x = x + l.XS
            x, y = self.width // 2 - l.XS * 3, y + l.YS
        self.setRegion(
            self.s.foundations, (-999, -999, 999999, l.YM + l.YS * 2),
            priority=1)
        x, y = l.XM, l.YM + l.YS * 2
        for i in range(rows):
            stack = self.RowStack_Class(x, y, self, yoffset=l.YOFFSET)
            s.rows.append(stack)
            x = x + l.XS
        s.talon = InitialDealTalonStack(l.XS, l.YS // 2, self)

        # define stack-groups
        l.defaultStackGroups()

    #
    # game overrides
    #

    def startGame(self):
        self.startDealSample()
        i = 0
        while self.s.talon.cards:
            if self.s.talon.cards[-1].rank == 0:
                if self.s.rows[i].cards:
                    i = i + 1
            self.s.talon.dealRow(rows=[self.s.rows[i]], frames=4)


# ************************************************************************
# * Flower Arrangement Hint
# ************************************************************************

class FlowerArrangement_Hint(AbstractHint):
    def computeHints(self):
        game = self.game

        # 2)See if we can move a card to the tableaux
        if not self.hints:
            for r in game.sg.dropstacks:
                pile = r.getPile()
                if not pile or len(pile) != 1:
                    continue
                if r in game.s.tableaux:
                    rr = self.ClonedStack(r, stackcards=r.cards[:-1])
                    if rr.acceptsCards(None, pile):
                        # do not move a card that is already in correct place
                        continue
                    base_score = 80000 + (4 - r.cap.base_suit)
                else:
                    base_score = 80000
                # find a stack that would accept this card
                for t in game.s.tableaux:
                    if t is not r and t.acceptsCards(r, pile):
                        score = base_score + 100 * (self.K - pile[0].rank)
                        self.addHint(score, 1, r, t)
                        break

        # 3)See if we can move a card from the tableaux
        #    to a row stack. This can only happen if there are
        #    no more cards to deal.
        if not self.hints:
            for r in game.s.tableaux:
                pile = r.getPile()
                if not pile or len(pile) != 1:
                    continue
                rr = self.ClonedStack(r, stackcards=r.cards[:-1])
                if rr.acceptsCards(None, pile):
                    # do not move a card that is already in correct place
                    continue
                # find a stack that would accept this card
                for t in game.s.rows:
                    if t is not r and t.acceptsCards(r, pile):
                        score = 70000 + 100 * (self.K - pile[0].rank)
                        self.addHint(score, 1, r, t)
                        break

        # 4)See if we can move a card within the row stacks
        if not self.hints:
            for r in game.s.rows:
                pile = r.getPile()
                if not pile or len(pile) != 1 or len(pile) == len(r.cards):
                    continue
                base_score = 60000
                # find a stack that would accept this card
                for t in game.s.rows:
                    if t is not r and t.acceptsCards(r, pile):
                        score = base_score + 100 * (self.K - pile[0].rank)
                        self.addHint(score, 1, r, t)
                        break

        # 5)See if we can deal cards
        if self.level >= 2:
            if game.canDealCards():
                self.addHint(self.SCORE_DEAL, 0, game.s.talon, None)


# ************************************************************************
# * Flower Arrangement Stacks
# ************************************************************************

class FlowerArrangement_TableauStack(Flower_OpenStack):
    def __init__(self, x, y, game, yoffset, **cap):
        kwdefault(cap, dir=-1, max_move=1, max_cards=4, max_accept=1,
                  base_rank=3)
        OpenStack.__init__(self, x, y, game, **cap)
        self.CARD_YOFFSET = yoffset

    def acceptsCards(self, from_stack, cards):
        if not self.basicAcceptsCards(from_stack, cards):
            return 0
        # check that the base card is correct
        suits = list(range(self.cap.mod, (self.cap.mod + 4)))
        if self.cards and (self.cards[0].rank == 3 and
                           self.cards[-1].suit in suits):
            return self.isHanafudaSequence([self.cards[-1], cards[0]])
        return not self.cards and cards[0].rank == 3 and cards[0].suit in suits

    def getBottomImage(self):
        return self.game.app.images.getSuitBottom()


class FlowerArrangement_RowStack(BasicRowStack):

    def acceptsCards(self, from_stack, cards):
        if not BasicRowStack.acceptsCards(self, from_stack, cards):
            return 0
        # check
        return not (self.cards or self.game.s.talon.cards)

    def getBottomImage(self):
        return self.game.app.images.getTalonBottom()


# ************************************************************************
# * Flower Arrangement
# ************************************************************************

class FlowerArrangement(Game):
    Hint_Class = FlowerArrangement_Hint

    #
    # game layout
    #

    def createGame(self):
        # create layout
        l, s = Layout(self), self.s
        TABLEAU_YOFFSET = min(9, max(3, l.YOFFSET // 3))

        # set window
        th = l.YS + 3 * TABLEAU_YOFFSET
        # (set piles so that at least 2/3 of a card is visible with 10 cards)
        h = (10-1)*l.YOFFSET + l.CH*2//3
        self.setSize(10*l.XS+l.XM, l.YM + 3*th + l.YM + h)

        # create stacks
        s.addattr(tableaux=[])     # register extra stack variable
        x = l.XM + 8 * l.XS + l.XS // 2
        y = l.YM
        for i in range(3):
            x = l.XM
            for j in range(8):
                s.tableaux.append(
                    FlowerArrangement_TableauStack(
                        x, y, self, TABLEAU_YOFFSET, mod=i * 4))
                x = x + l.XS
            y = y + th
        x, y = l.XM, y + l.YM
        for i in range(8):
            s.rows.append(FlowerArrangement_RowStack(x, y, self, max_accept=1))
            x = x + l.XS
        x = l.XM + 8 * l.XS + l.XS // 2
        y = self.height - l.YS
        s.talon = DealRowTalonStack(x, y, self)
        l.createText(s.talon, "se")

        # define stack-groups
        self.sg.openstacks = s.tableaux + s.rows
        self.sg.talonstacks = [s.talon]
        self.sg.dropstacks = s.tableaux + s.rows

    #
    # game overrides
    #

    def startGame(self):
        self.s.talon.dealRow(rows=self.s.tableaux, frames=0)
        self._startAndDealRow()

    def isGameWon(self):
        for stack in self.s.tableaux:
            if len(stack.cards) != 4:
                return 0
        return 1

    def fillStack(self, stack):
        if self.s.talon.cards:
            if stack in self.s.rows and len(stack.cards) == 0:
                self.s.talon.dealRow(rows=[stack])

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        return (card1.suit == card2.suit and
                (card1.rank + 3 == card2.rank or card2.rank + 3 == card1.rank))

    def getHighlightPilesStacks(self):
        return ()


# ************************************************************************
# * Register the games
# ************************************************************************

def r(id, gameclass, name, game_type, decks, redeals, skill_level):
    game_type = game_type | GI.GT_HANAFUDA
    gi = GameInfo(id, gameclass, name, game_type, decks, redeals, skill_level,
                  suits=list(range(12)), ranks=list(range(4)))
    registerGame(gi)
    return gi


r(12369, Paulownia, 'Paulownia', GI.GT_HANAFUDA, 1, -1, GI.SL_BALANCED)
r(12370, LesserQueue, 'Lesser Queue', GI.GT_HANAFUDA, 2, 2, GI.SL_BALANCED)
r(12371, GreaterQueue, 'Greater Queue', GI.GT_HANAFUDA, 4, 2, GI.SL_BALANCED)
r(12373, JapaneseGarden, 'Japanese Garden', GI.GT_HANAFUDA | GI.GT_OPEN, 1, 0,
  GI.SL_MOSTLY_SKILL)
r(12374, JapaneseGardenII, 'Japanese Garden II', GI.GT_HANAFUDA | GI.GT_OPEN,
  1, 0, GI.SL_MOSTLY_SKILL)
r(12375, SixSages, 'Six Sages', GI.GT_HANAFUDA | GI.GT_OPEN, 1, 0,
  GI.SL_MOSTLY_SKILL)
r(12376, SixTengus, 'Six Tengus', GI.GT_HANAFUDA | GI.GT_OPEN, 1, 0,
  GI.SL_MOSTLY_SKILL)
r(12377, JapaneseGardenIII, 'Japanese Garden III', GI.GT_HANAFUDA | GI.GT_OPEN,
  1, 0, GI.SL_MOSTLY_SKILL)
r(12378, HanafudaFourSeasons, 'Hanafuda Four Seasons',
  GI.GT_HANAFUDA | GI.GT_OPEN, 1, 0, GI.SL_MOSTLY_SKILL)
r(12380, Eularia, 'Eularia', GI.GT_HANAFUDA, 1, -1, GI.SL_BALANCED)
r(12381, Peony, 'Peony', GI.GT_HANAFUDA, 1, -1, GI.SL_BALANCED)
r(12382, Iris, 'Iris', GI.GT_HANAFUDA, 1, 0, GI.SL_BALANCED)
r(12383, Pine, 'Pine', GI.GT_HANAFUDA, 1, 0, GI.SL_BALANCED)
r(12384, Wisteria, 'Wisteria', GI.GT_HANAFUDA, 1, 0, GI.SL_MOSTLY_SKILL)
r(12385, FlowerArrangement, 'Flower Arrangement', GI.GT_HANAFUDA, 2, 0,
  GI.SL_BALANCED)

del r
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

import re
import time

from pysollib.game import Game
from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.hint import AbstractHint
from pysollib.layout import Layout
from pysollib.mfxutil import Image, Struct, kwdefault
from pysollib.mygettext import _
from pysollib.mygettext import ungettext
from pysollib.pysoltk import ANCHOR_NW, EVENT_HANDLED, bind
from pysollib.pysoltk import MfxCanvasImage, MfxCanvasText
from pysollib.pysoltk import MfxMessageDialog
from pysollib.settings import DEBUG, TOOLKIT
from pysollib.stack import \
        InitialDealTalonStack, \
        OpenStack
from pysollib.util import ANY_SUIT, NO_RANK

from six.moves import range


def factorial(x):
    if x <= 1:
        return 1
    a = 1
    for i in range(x):
        a *= (i+1)
    return a


# ************************************************************************
# *
# ************************************************************************

class Mahjongg_Hint(AbstractHint):
    # FIXME: no intelligence whatsoever is implemented here
    def computeHints(self):
        game = self.game
        # get free stacks
        stacks = []
        for r in game.s.rows:
            if r.cards and not r.basicIsBlocked():
                stacks.append(r)
        # find matching tiles
        i = 0
        for r in stacks:
            for t in stacks[i+1:]:
                if game.cardsMatch(r.cards[0], t.cards[0]):
                    # simple scoring...
                    # score = 10000 + r.id + t.id
                    rb = r.blockmap
                    tb = t.blockmap
                    score = \
                        10000 + \
                        1000 * (len(rb.below) + len(tb.below)) + \
                        len(rb.all_left) + len(rb.all_right) + \
                        len(tb.all_left) + len(tb.all_right)
                    self.addHint(score, 1, r, t)
            i += 1


# ************************************************************************
# *
# ************************************************************************

# class Mahjongg_Foundation(AbstractFoundationStack):
class Mahjongg_Foundation(OpenStack):

    def __init__(self, x, y, game, suit=ANY_SUIT, **cap):
        kwdefault(cap, max_move=0, max_accept=0, max_cards=game.NCARDS)
        OpenStack.__init__(self, x, y, game, **cap)

    def acceptsCards(self, from_stack, cards):
        # We do not accept any cards - pairs will get
        # delivered by _dropPairMove() below.
        return 0

    def basicIsBlocked(self):
        return 1

    # def initBindings(self):
    #    pass

    def _position(self, card):
        # AbstractFoundationStack._position(self, card)
        OpenStack._position(self, card)

        fnds = self.game.s.foundations

        cols = (3, 2, 1, 0)
        for i in cols:
            for j in range(9):
                n = i*9+j
                if fnds[n].cards:
                    fnds[n].group.tkraise()
        return

    def getHelp(self):
        return ''


# ************************************************************************
# *
# ************************************************************************

class Mahjongg_RowStack(OpenStack):
    def __init__(self, x, y, game, **cap):
        kwdefault(cap, max_move=1, max_accept=1, max_cards=2,
                  base_rank=NO_RANK)
        OpenStack.__init__(self, x, y, game, **cap)

    def basicIsBlocked(self):
        # any of above blocks
        for stack in self.blockmap.above:
            if stack.cards:
                return 1
        # any of left blocks - but we can try right as well
        for stack in self.blockmap.left:
            if stack.cards:
                break
        else:
            return 0
        # any of right blocks
        for stack in self.blockmap.right:
            if stack.cards:
                return 1
        return 0

    def acceptsCards(self, from_stack, cards):
        if not OpenStack.acceptsCards(self, from_stack, cards):
            return 0
        return self.game.cardsMatch(self.cards[0], cards[-1])

    def canFlipCard(self):
        return 0

    def canDropCards(self, stacks):
        return (None, 0)

    def moveMove(self, ncards, to_stack, frames=-1, shadow=-1):
        self._dropPairMove(ncards, to_stack, frames=-1, shadow=shadow)

    def _dropPairMove(self, n, other_stack, frames=-1, shadow=-1):
        # print 'drop:', self.id, other_stack.id
        assert n == 1 and self.acceptsCards(
            other_stack, [other_stack.cards[-1]])
        if not self.game.demo:
            self.game.playSample("droppair", priority=200)
        old_state = self.game.enterState(self.game.S_FILL)
        c = self.cards[0]
        if c.suit == 3:
            if c.rank >= 8:
                i = 35
            elif c.rank >= 4:
                i = 34
            else:
                i = 30+c.rank
        elif c.rank == 9:
            i = 27+c.suit
        else:
            i = c.suit*9+c.rank
        f = self.game.s.foundations[i]
        self.game.moveMove(n, self, f, frames=frames, shadow=shadow)
        self.game.moveMove(n, other_stack, f, frames=frames, shadow=shadow)
        self.game.leaveState(old_state)
        self.fillStack()
        other_stack.fillStack()

    #
    # Mahjongg special overrides
    #

    # Mahjongg special: we must preserve the relative stacking order
    # to keep our pseudo 3D look.
    def _position(self, card):
        OpenStack._position(self, card)
        #
        if TOOLKIT == 'tk':
            rows = [s for s in self.game.s.rows[:self.id] if s.cards]
            if rows:
                self.group.tkraise(rows[-1].group)
                return
            rows = [s for s in self.game.s.rows[self.id+1:] if s.cards]
            if rows:
                self.group.lower(rows[0].group)
                return
        elif TOOLKIT == 'kivy':
            rows = [s for s in self.game.s.rows[:self.id] if s.cards]
            if rows:
                # self.group.tkraise(rows[-1].group)
                return
            rows = [s for s in self.game.s.rows[self.id+1:] if s.cards]
            if rows:
                # self.group.lower(rows[0].group)
                return
        elif TOOLKIT == 'gtk':
            # FIXME (this is very slow)
            for s in self.game.s.rows[self.id+1:]:
                s.group.tkraise()

    # In Mahjongg games type there are a lot of stacks, so we optimize
    # and don't create bindings that are not used anyway.
    def initBindings(self):
        group = self.group
        # FIXME: dirty hack to access the Stack's private methods
        # bind(group, "<1>", self._Stack__clickEventHandler)
        # bind(group, "<3>", self._Stack__controlclickEventHandler)
        # bind(group, "<Control-1>", self._Stack__controlclickEventHandler)
        #
        bind(group, "<1>", self.__clickEventHandler)
        bind(group, "<3>", self.__controlclickEventHandler)
        bind(group, "<Control-1>", self.__controlclickEventHandler)
        # bind(group, "<Enter>", self._Stack__enterEventHandler)
        # bind(group, "<Leave>", self._Stack__leaveEventHandler)

    def __defaultClickEventHandler(self, event, handler):
        self.game.event_handled = True  # for Game.undoHandler
        if self.game.demo:
            self.game.stopDemo(event)
        if self.game.busy:
            return EVENT_HANDLED
        handler(event)
        return EVENT_HANDLED

    def __clickEventHandler(self, event):
        # print 'click:', self.id
        return self.__defaultClickEventHandler(event, self.clickHandler)

    def __controlclickEventHandler(self, event):
        return self.__defaultClickEventHandler(event, self.controlclickHandler)

    def clickHandler(self, event):
        game = self.game
        drag = game.drag
        # checks
        if not self.cards:
            return 1
        card = self.cards[-1]
        from_stack = drag.stack
        if from_stack is self:
            # remove selection
            self.game.playSample("nomove")
            self._stopDrag()
            return 1
        if self.basicIsBlocked():
            # remove selection
            # self.game.playSample("nomove")
            return 1
        # possible move
        if from_stack:
            if self.acceptsCards(from_stack, from_stack.cards):
                self._stopDrag()
                # this code actually moves the tiles
                from_stack.playMoveMove(1, self, frames=0, sound=True)
                if TOOLKIT == 'kivy':
                    if drag.shade_img:
                        # drag.shade_img.dtag(drag.shade_stack.group)
                        drag.shade_img.delete()
                        # game.canvas.delete(drag.shade_img)
                        drag.shade_img = None
                return 1
        drag.stack = self
        self.game.playSample("startdrag")
        # create the shade image (see stack.py, _updateShade)
        if drag.shade_img:
            # drag.shade_img.dtag(drag.shade_stack.group)
            drag.shade_img.delete()
            # game.canvas.delete(drag.shade_img)
            drag.shade_img = None
        img = game.app.images.getHighlightedCard(
            card.deck, card.suit, card.rank)
        if img is None:
            return 1
        img = MfxCanvasImage(game.canvas, self.x, self.y, image=img,
                             anchor=ANCHOR_NW, group=self.group)
        drag.shade_img = img
        # raise/lower the shade image to the correct stacking order
        img.tkraise(card.item)
        drag.shade_stack = self
        return 1

    def cancelDrag(self, event=None):
        if event is None:
            self._stopDrag()

    def _findCard(self, event):
        # we need to override this because the shade may be hiding
        # the tile (from Tk's stacking view)
        return len(self.cards) - 1

    def getBottomImage(self):
        return None


# ************************************************************************
# *
# ************************************************************************

class AbstractMahjonggGame(Game):
    Hint_Class = Mahjongg_Hint
    RowStack_Class = Mahjongg_RowStack

    GAME_VERSION = 3

    NCARDS = 144

    def getTiles(self):
        # decode tile positions
        L = self.L

        assert L[0] == "0"
        assert (len(L) - 1) % 3 == 0

        tiles = []
        max_tl, max_tx, max_ty = -1, -1, -1
        t = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
        for i in range(1, len(L), 3):
            n = t.find(L[i])
            level, height = n // 7, n % 7 + 1
            tx = t.find(L[i+1])
            ty = t.find(L[i+2])
            assert n >= 0 and tx >= 0 and ty >= 0
            max_tl = max(level + height - 1, max_tl)
            max_tx = max(tx, max_tx)
            max_ty = max(ty, max_ty)
            for tl in range(level, level + height):
                tiles.append((tl, tx, ty))
        assert len(tiles) == self.NCARDS
        # tiles.sort()
        # tiles = tuple(tiles)
        return tiles, max_tl, max_tx, max_ty

    #
    # game layout
    #

    def createGame(self):
        tiles, max_tl, max_tx, max_ty = self.getTiles()

        # start layout
        l, s = Layout(self), self.s
        show_removed = self.app.opt.mahjongg_show_removed

        # dx, dy = 2, -2
        # dx, dy = 3, -3
        cs = self.app.cardset
        if cs.version >= 6:
            dx = l.XOFFSET
            dy = -l.YOFFSET
            d_x = cs.SHADOW_XOFFSET
            d_y = cs.SHADOW_YOFFSET
            if self.preview:
                # Fixme
                dx, dy, d_x, d_y = dx//2, dy//2, d_x//2, d_y//2
            self._delta_x, self._delta_y = dx, -dy
        else:
            dx = 3
            dy = -3
            d_x = 0
            d_y = 0
            self._delta_x, self._delta_y = 0, 0
        # print dx, dy, d_x, d_y, cs.version

        font = self.app.getFont("canvas_default")

        # width of self.texts.info
        # ti_width = Font(self.canvas, font).measure(_('Remaining'))
        ti_width = 80

        # set window size
        dxx, dyy = abs(dx) * (max_tl+1), abs(dy) * (max_tl+1)
        # foundations dxx dyy
        if self.NCARDS > 144:
            fdxx = abs(dx)*8
            fdyy = abs(dy)*8
        else:
            fdxx = abs(dx)*4
            fdyy = abs(dy)*4
        cardw, cardh = l.CW - d_x, l.CH - d_y
        if show_removed:
            left_margin = l.XM + 4*cardw+fdxx+d_x + l.XM
        else:
            left_margin = l.XM
        tableau_width = (max_tx+2)*cardw//2+dxx+d_x
        right_margin = l.XM+ti_width+l.XM
        w = left_margin + tableau_width + right_margin
        h = l.YM + dyy + (max_ty + 2) * cardh // 2 + d_y + l.YM
        if show_removed:
            h = max(h, l.YM+fdyy+cardh*9+d_y+l.YM)
        self.setSize(w, h)

        # set game extras
        self.check_dist = l.CW*l.CW + l.CH*l.CH     # see _getClosestStack()

        # sort tiles (for 3D)
        tiles.sort(key=lambda x: (x[0], x[2]-x[1]))

        # create a row stack for each tile and compute the tilemap
        tilemap = {}
        x0 = left_margin
        y0 = l.YM + dyy
        for level, tx, ty in tiles:
            # print level, tx, ty
            x = x0 + (tx * cardw) // 2 + level * dx
            y = y0 + (ty * cardh) // 2 + level * dy
            stack = self.RowStack_Class(x, y, self)
            # stack.G = (level, tx, ty)
            stack.CARD_XOFFSET = dx
            stack.CARD_YOFFSET = dy
            s.rows.append(stack)
            # tilemap - each tile covers 4 positions
            tilemap[(level, tx, ty)] = stack
            tilemap[(level, tx+1, ty)] = stack
            tilemap[(level, tx, ty+1)] = stack
            tilemap[(level, tx+1, ty+1)] = stack

        # compute blockmap
        for stack in s.rows:
            level, tx, ty = tiles[stack.id]
            above, below, left, right = {}, {}, {}, {}
            # above blockers
            for tl in range(level+1, level+2):
                above[tilemap.get((tl, tx, ty))] = 1
                above[tilemap.get((tl, tx+1, ty))] = 1
                above[tilemap.get((tl, tx, ty+1))] = 1
                above[tilemap.get((tl, tx+1, ty+1))] = 1
            #
            for tl in range(level):
                below[tilemap.get((tl, tx, ty))] = 1
                below[tilemap.get((tl, tx+1, ty))] = 1
                below[tilemap.get((tl, tx, ty+1))] = 1
                below[tilemap.get((tl, tx+1, ty+1))] = 1
            # left blockers
            left[tilemap.get((level, tx-1, ty))] = 1
            left[tilemap.get((level, tx-1, ty+1))] = 1
            # right blockers
            right[tilemap.get((level, tx+2, ty))] = 1
            right[tilemap.get((level, tx+2, ty+1))] = 1
            # up blockers
            # up[tilemap.get((level, tx, ty-1))] = 1
            # up[tilemap.get((level, tx+1, ty-1))] = 1
            # bottom blockers
            # bottom[tilemap.get((level, tx, ty+2))] = 1
            # bottom[tilemap.get((level, tx+1, ty+2))] = 1
            # sanity check - assert that there are no overlapping tiles
            assert tilemap.get((level, tx, ty)) is stack
            assert tilemap.get((level, tx+1, ty)) is stack
            assert tilemap.get((level, tx, ty+1)) is stack
            assert tilemap.get((level, tx+1, ty+1)) is stack
            #
            above = tuple([_f for _f in above.keys() if _f])
            below = tuple([_f for _f in below.keys() if _f])
            left = tuple([_f for _f in left.keys() if _f])
            right = tuple([_f for _f in right.keys() if _f])
            # up = tuple(filter(None, up.keys()))
            # bottom = tuple(filter(None, bottom.keys()))

            # assemble
            stack.blockmap = Struct(
                above=above,
                below=below,
                left=left,
                right=right,
                # up=up,
                # bottom=bottom,
                all_left=None,
                all_right=None,
            )

        def get_all_left(s):
            if s.blockmap.all_left is None:
                s.blockmap.all_left = {}
            for t in s.blockmap.left:
                if t.blockmap.all_left is None:
                    get_all_left(t)
                s.blockmap.all_left.update(t.blockmap.all_left)
                s.blockmap.all_left[t] = 1

        def get_all_right(s):
            if s.blockmap.all_right is None:
                s.blockmap.all_right = {}
            for t in s.blockmap.right:
                if t.blockmap.all_right is None:
                    get_all_right(t)
                s.blockmap.all_right.update(t.blockmap.all_right)
                s.blockmap.all_right[t] = 1

        for r in s.rows:
            get_all_left(r)
            get_all_right(r)
        for r in s.rows:
            r.blockmap.all_left = tuple(r.blockmap.all_left.keys())
            r.blockmap.all_right = tuple(r.blockmap.all_right.keys())

        # create other stacks
        for i in range(4):
            for j in range(9):
                if show_removed:
                    x = l.XM+i*cardw
                    y = l.YM+fdyy+j*cardh
                else:
                    if TOOLKIT == 'tk':
                        x = -l.XS-self.canvas.xmargin
                        y = l.YM+dyy
                    elif TOOLKIT == 'kivy':
                        x = -1000
                        y = l.YM+dyy
                    elif TOOLKIT == 'gtk':
                        # FIXME
                        x = self.width - l.XS
                        y = self.height - l.YS
                stack = Mahjongg_Foundation(x, y, self)
                if show_removed:
                    stack.CARD_XOFFSET = dx
                    stack.CARD_YOFFSET = dy
                s.foundations.append(stack)

        self.texts.info = MfxCanvasText(self.canvas,
                                        self.width - l.XM - ti_width,
                                        l.YM + dyy,
                                        anchor="nw", font=font)
        # the Talon is invisble
        s.talon = InitialDealTalonStack(-l.XS-self.canvas.xmargin,
                                        self.height-dyy, self)

        # Define stack groups
        l.defaultStackGroups()

    #
    # game overrides
    #

    def _shuffleHook(self, cards):
        if self.app.opt.mahjongg_create_solvable == 0:
            return cards
        # try to create a solvable game
        if self.app.opt.mahjongg_create_solvable == 1:
            # easy
            return self._shuffleHook1(cards[:])
        # hard
        new_cards = self._shuffleHook2(self.s.rows, cards)
        if new_cards is None:
            return cards
        return new_cards

    def _shuffleHook1(self, cards):
        # old version; it generate a very easy layouts
        old_cards = cards[:]
        rows = self.s.rows

        def is_blocked(s, new_cards):
            # any of above blocks
            for stack in s.blockmap.above:
                if new_cards[stack.id] is None:
                    return True
            # any of left blocks - but we can try right as well
            for stack in s.blockmap.left:
                if new_cards[stack.id] is None:
                    break
            else:
                return False
            # any of right blocks
            for stack in s.blockmap.right:
                if new_cards[stack.id] is None:
                    return True
            return False

        def create_solvable(cards, new_cards):
            if not cards:
                return new_cards
            # select two matching cards
            c1 = cards[0]
            del cards[0]
            c2 = None
            for i in range(len(cards)):
                if self.cardsMatch(c1, cards[i]):
                    c2 = cards[i]
                    del cards[i]
                    break
            #
            free_stacks = []            # none-blocked stacks
            for r in rows:
                if new_cards[r.id] is None and not is_blocked(r, new_cards):
                    free_stacks.append(r)
            if len(free_stacks) < 2:
                return None             # try another way
            #
            i = factorial(len(free_stacks))//2//factorial(len(free_stacks)-2)
            old_pairs = []
            for j in range(i):
                nc = new_cards[:]
                while True:
                    # create uniq pair
                    r1 = self.random.randrange(0, len(free_stacks))
                    r2 = self.random.randrange(0, len(free_stacks)-1)
                    if r2 >= r1:
                        r2 += 1
                    if (r1, r2) not in old_pairs and (r2, r1) not in old_pairs:
                        old_pairs.append((r1, r2))
                        break
                # add two selected cards to new_cards
                s1 = free_stacks[r1]
                s2 = free_stacks[r2]
                nc[s1.id] = c1
                nc[s2.id] = c2
                # check if this layout is solvable (backtracking)
                nc = create_solvable(cards[:], nc)
                if nc:
                    return nc
            return None                 # try another way

        new_cards = create_solvable(cards, [None]*len(cards))
        if new_cards:
            new_cards.reverse()
            return new_cards
        print('oops! can\'t create a solvable game')
        return old_cards

    def _shuffleHook2(self, rows, cards):

        start_time = time.time()
        iters = [0]
        # limitations
        max_time = 5.0                  # seconds
        max_iters = 2*len(cards)

        def is_suitable(stack, cards):
            for s in stack.blockmap.below:
                if cards[s.id] == 1:
                    continue
                # check if below stacks are non-empty
                if cards[s.id] is None:
                    return False

            for s in stack.blockmap.left:
                if cards[s.id] == 1:
                    continue
                if cards[s.id] is None:
                    for t in s.blockmap.all_left:
                        if cards[t.id] == 1:
                            continue
                        if cards[t.id] is not None:
                            # we have empty stack between two non-empty
                            return False

            for s in stack.blockmap.right:
                if cards[s.id] == 1:
                    continue
                if cards[s.id] is None:
                    for t in s.blockmap.all_right:
                        if cards[t.id] == 1:
                            continue
                        if cards[t.id] is not None:
                            # we have empty stack between two non-empty
                            return False
            return True

        def create_solvable(cards, new_cards):
            iters[0] += 1
            if iters[0] > max_iters:
                return None
            if time.time() - start_time > max_time:
                return None
            if not cards:
                return new_cards

            nc = new_cards[:]

            # select two matching cards
            c1 = cards[0]
            del cards[0]
            c2 = None
            for i in range(len(cards)):
                if self.cardsMatch(c1, cards[i]):
                    c2 = cards[i]
                    del cards[i]
                    break

            # find suitable stacks
            #  suitable_stacks = []
            #  for r in rows:
            #      if nc[r.id] is None and is_suitable(r, nc):
            #          suitable_stacks.append(r)
            suitable_stacks = [r for r in rows
                               if nc[r.id] is None and is_suitable(r, nc)]

            old_pairs = []
            i = factorial(len(suitable_stacks))//2 \
                // factorial(len(suitable_stacks)-2)
            for j in range(i):
                if iters[0] > max_iters:
                    return None
                if time.time() - start_time > max_time:
                    return None

                # select two suitable stacks
                while True:
                    # create a uniq pair
                    r1 = self.random.randrange(0, len(suitable_stacks))
                    r2 = self.random.randrange(0, len(suitable_stacks))
                    if r1 == r2:
                        continue
                    if (r1, r2) not in old_pairs and (r2, r1) not in old_pairs:
                        old_pairs.append((r1, r2))
                        break
                s1 = suitable_stacks[r1]
                s2 = suitable_stacks[r2]
                # check if s1 don't block s2
                nc[s1.id] = c1
                if not is_suitable(s2, nc):
                    nc[s1.id] = None
                    continue
                nc[s2.id] = c2
                # check if this layout is solvable (backtracking)
                ret = create_solvable(cards[:], nc)
                if ret:
                    ret = [x for x in ret if x != 1]
                    return ret
                nc[s1.id] = nc[s2.id] = None  # try another way

            return None

        new_cards = [None]*len(self.s.rows)  # None - empty stack, 1 - non-used
        drows = dict.fromkeys(rows)     # optimization
        for r in self.s.rows:
            if r not in drows:
                new_cards[r.id] = 1
        del drows

        while True:
            ret = create_solvable(cards[:], new_cards)
            if DEBUG:
                print('create_solvable time:', time.time() - start_time)
            if ret:
                ret.reverse()
                return ret
            if time.time() - start_time > max_time or \
                    iters[0] <= max_iters:
                print('oops! can\'t create a solvable game')
                return None
            iters = [0]
        print('oops! can\'t create a solvable game')
        return None

    def _mahjonggShuffle(self):
        talon = self.s.talon
        rows = []
        cards = []

        for r in self.s.rows:
            if r.cards:
                rows.append(r)
                cards.append(r.cards[0])
        if not rows:
            return

        if self.app.opt.mahjongg_create_solvable == 0:
            self.playSample('turnwaste')
            old_state = self.enterState(self.S_FILL)
            self.saveSeedMove()
            for r in rows:
                self.moveMove(1, r, talon, frames=0)
            self.shuffleStackMove(talon)
            for r in rows:
                self.moveMove(1, talon, r, frames=0)
            self.leaveState(old_state)
            self.finishMove()
            return

        self.playSample('turnwaste')
        old_state = self.enterState(self.S_FILL)
        self.saveSeedMove()

        new_cards = self._shuffleHook2(rows, cards)
        if new_cards is None:
            if TOOLKIT != 'kivy':
                MfxMessageDialog(self.top, title=_('Warning'),
                                 text=_('''\
Sorry, I can\'t find
a solvable configuration.'''),
                                 bitmap='warning')

            self.leaveState(old_state)
            # self.finishMove()
            # hack
            am = self.moves.current[0]
            am.undo(self)               # restore random
            self.moves.current = []
            return

        self.stats.shuffle_moves += 1
        # move new_cards to talon
        for c in new_cards:
            for r in rows:
                if r.cards and r.cards[0] is c:
                    self.moveMove(1, r, talon, frames=0)
                    break
        # deal
        for r in rows:
            self.moveMove(1, talon, r, frames=0)

        self.leaveState(old_state)
        self.finishMove()

    def canShuffle(self):
        return True

    def startGame(self):
        assert len(self.s.talon.cards) == self.NCARDS
        # self.s.talon.dealRow(rows = self.s.rows, frames = 0)
        n = 12
        self.s.talon.dealRow(rows=self.s.rows[:self.NCARDS-n], frames=0)
        self.startDealSample()
        self.s.talon.dealRow(rows=self.s.rows[self.NCARDS-n:])
        assert len(self.s.talon.cards) == 0

    def isGameWon(self):
        return sum([len(f.cards) for f in self.s.foundations]) == self.NCARDS

    def shallHighlightMatch(self, stack1, card1, stack2, card2):
        if stack1.basicIsBlocked() or stack2.basicIsBlocked():
            return 0
        return self.cardsMatch(card1, card2)

    def getAutoStacks(self, event=None):
        return ((), (), ())

    def updateText(self):
        if self.preview > 1 or self.texts.info is None:
            return

        # find matching tiles
        stacks = []
        for r in self.s.rows:
            if r.cards and not r.basicIsBlocked():
                stacks.append(r)
        f, i = 0, 0
        for r in stacks:
            n = 0
            for t in stacks[i+1:]:
                if self.cardsMatch(r.cards[0], t.cards[0]):
                    n += 1
            # if n == 3: n = 1
            # elif n == 2: n = 0
            n = n % 2
            f += n
            i += 1

        if f == 0:
            f = _('No Free\nMatching\nPairs')
        else:
            f = ungettext('%d Free\nMatching\nPair',
                          '%d Free\nMatching\nPairs',
                          f) % f
        t = sum([len(ii.cards) for ii in self.s.foundations])
        r1 = ungettext('%d\nTile\nRemoved\n\n',
                       '%d\nTiles\nRemoved\n\n',
                       t) % t
        r2 = ungettext('%d\nTile\nRemaining\n\n',
                       '%d\nTiles\nRemaining\n\n',
                       self.NCARDS - t) % (self.NCARDS - t)

        t = r1 + r2 + f
        self.texts.info.config(text=t)

    #
    # Mahjongg special overrides
    #

    def getHighlightPilesStacks(self):
        # Mahjongg special: highlight all moveable tiles
        return ((self.s.rows, 1),)

    def _highlightCards(self, info, sleep=1.5, delta=(1, 1, 1, 1)):
        if not Image:
            delta = (-self._delta_x, 0, 0, -self._delta_y)
            return Game._highlightCards(self, info, sleep=sleep, delta=delta)

        if not info:
            return 0
        if self.pause:
            return 0
        self.stopWinAnimation()
        items = []
        for s, c1, c2, color in info:
            assert c1 is c2
            assert c1 in s.cards
            x, y = s.x, s.y
            img = self.app.images.getHighlightedCard(
                c1.deck, c1.suit, c1.rank, 'black')
            if img is None:
                continue
            img = MfxCanvasImage(self.canvas, x, y, image=img,
                                 anchor=ANCHOR_NW, group=s.group)
            if self.drag.stack and s is self.drag.stack:
                img.tkraise(self.drag.shade_img)
            else:
                img.tkraise(c1.item)
            items.append(img)
        if not items:
            return 0
        self.canvas.update_idletasks()
        if sleep:
            self.sleep(sleep)
            items.reverse()
            for r in items:
                r.delete()
            self.canvas.update_idletasks()
            return EVENT_HANDLED
        else:
            # remove items later (find_card_dialog)
            return items

    def getCardFaceImage(self, deck, suit, rank):
        if suit == 3:
            cs = self.app.cardset
            if len(cs.ranks) >= 12 and len(cs.suits) >= 4:
                # make Mahjongg type games playable with other cardsets
                if rank >= 8:       # flower
                    suit = 1
                    rank = len(cs.ranks) - 2
                elif rank >= 4:     # season
                    rank = max(10, len(cs.ranks) - 3)
                else:               # wind
                    suit = rank
                    rank = len(cs.ranks) - 1
        return self.app.images.getFace(deck, suit, rank)

    def getCardBackImage(self, deck, suit, rank):
        # We avoid screen updates caused by flipping cards - all
        # cards are face up anyway. The Talon should be invisible
        # or else the top tile of the Talon will be visible during
        # game start.
        return self.getCardFaceImage(deck, suit, rank)

    def _createCard(self, id, deck, suit, rank, x, y):
        # if deck >= 1 and suit == 3 and rank >= 4:
        if deck % 4 and suit == 3 and rank >= 4:
            return None
        return Game._createCard(self, id, deck, suit, rank, x, y)

    def _getClosestStack(self, cx, cy, stacks, dragstack):
        closest, cdist = None, 999999999
        # Since we only compare distances,
        # we don't bother to take the square root.
        for stack in stacks:
            dist = (stack.x - cx)**2 + (stack.y - cy)**2
            if dist < cdist:
                # Mahjongg special: if the stack is very close, do
                # not consider blocked stacks
                if dist > self.check_dist or not stack.basicIsBlocked():
                    closest, cdist = stack, dist
        return closest

    #
    # Mahjongg extras
    #

    def cardsMatch(self, card1, card2):
        if card1.suit != card2.suit:
            return 0
        if card1.suit == 3:
            if card1.rank >= 8:
                return card2.rank >= 8
            if card1.rank >= 4:
                return 7 >= card2.rank >= 4
        return card1.rank == card2.rank


#  mahjongg util
def comp_cardset(ncards):
    # calc decks, ranks & trumps
    assert ncards % 4 == 0
    assert 0 < ncards <= 288  # ???
    decks = 1
    cards = ncards//4
    if ncards > 144:
        assert ncards % 8 == 0
        decks = 2
        cards = cards//2
    ranks, trumps = divmod(cards, 3)
    if ranks > 10:
        trumps += (ranks-10)*3
        ranks = 10
    if trumps > 4:
        trumps = 4+(trumps-4)*4
    assert 0 <= ranks <= 10 and 0 <= trumps <= 12
    return decks, ranks, trumps

# ************************************************************************
# * register a Mahjongg type game
# ************************************************************************


def r(id, short_name, name=None, ncards=144, layout=None):
    assert layout
    if not name:
        name = "Mahjongg " + short_name
    classname = re.sub('\\W', '', name)
    # create class
    gameclass = type(classname, (AbstractMahjonggGame,), {})
    gameclass.L = layout
    gameclass.NCARDS = ncards
    decks, ranks, trumps = comp_cardset(ncards)
    gi = GameInfo(id, gameclass, name,
                  GI.GT_MAHJONGG, 4*decks, 0,  # GI.SL_MOSTLY_SKILL,
                  category=GI.GC_MAHJONGG, short_name=short_name,
                  suits=list(range(3)), ranks=list(range(ranks)),
                  trumps=list(range(trumps)),
                  si={"decks": decks, "ncards": ncards})
    gi.ncards = ncards
    gi.rules_filename = "mahjongg.html"
    registerGame(gi)
    return gi
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.games.mahjongg.mahjongg import r

# ************************************************************************
# * game definitions
# ************************************************************************

r(5001, "Altar", layout="0aaaacaaiaakaama" +
    "aoaaqaasaauaawaa" +
    "CaaEaaacaccaicck" +
    "ccmccoccqccsccuc" +
    "awcaCcaEcaieckec" +
    "mecoecqecsecueaw" +
    "eaigckgcmgcogcqg" +
    "csgcugawgaiiakia" +
    "miaoiaqiasiauiaw" +
    "iaokaqkaamacmaom" +
    "aqmaCmaEmaaoacoa" +
    "ooaqoaCoaEohabhc" +
    "bhCbhEbkpijpkipm" +
    "hanhcnhCnhEnhpoo" +
    "bboDbobnoDnvlcvn" +
    "cvpcvrcvtcvlevne" +
    "vpevrevtevlgwngw" +
    "pgwrgvtgCocCqcCm" +
    "eCoeCqeCse")
r(5002, "Arena", layout="0eaadcaceabgaaia" +
    "aqabsacuadwaeyad" +
    "accccbecagcakcbm" +
    "caocascbuccwcdyc" +
    "caebceaeeameaueb" +
    "wecyebagacgakgbm" +
    "gaogawgbygcaibci" +
    "aeiamiauibwicyid" +
    "akcckbekagkakkbm" +
    "kaokaskbukcwkdyk" +
    "eamdcmcembgmaima" +
    "qmbsmcumdwmeym")
r(5003, "Arena 2", layout="0daadcabeabgaaia" +
    "akaamaaoaaqaasab" +
    "uabwadyadAadaccc" +
    "cbecagcaucbwccyc" +
    "dAcdaecceaeeawec" +
    "yedAedagccgaegaw" +
    "gcygdAgdaicciaei" +
    "awicyidAidakcckb" +
    "ekagkaukbwkcykdA" +
    "kdamdcmbembgmaim" +
    "asmbumbwmdymdAm")
#
r(5004, "Arrow", layout="0aaaaqbaacaccasc" +
    "aqdaudaaeaceaeea" +
    "geaieakeameaoeas" +
    "eaweaqfaufayfaag" +
    "acgaegaggaigakga" +
    "mgaogasgawgaAgaC" +
    "gaqhauhayhaaiaci" +
    "aeiagiaiiakiamia" +
    "oiasiawiaqjaujaa" +
    "kackaskaqlaamhbc" +
    "hrdhbehdehfehheh" +
    "jehlehnehpehtehr" +
    "fhvfhbghdghfghhg" +
    "hjghlghnghpghtgh" +
    "xghrhhvhhbihdihf" +
    "ihhihjihlihnihpi" +
    "htihrjhbkoceoeeo" +
    "geoieokeomeooeoq" +
    "eosfocgoegoggoig" +
    "okgomgoogoqgougo" +
    "shocioeiogioiiok" +
    "iomiooioqivfevhe" +
    "vjevlevnevpevfgv" +
    "hgvjgvlgvngvpgvr" +
    "gvfivhivjivlivni" +
    "vpiCkeCmeCoeCkgC" +
    "mgCogCqgCkiCmiCo" +
    "i")
r(5005, "Art Moderne", layout="0acaaeaagaaiaaka" +
    "amaaoaauaawaaaba" +
    "lcapcatcavcaxcaa" +
    "daddaleapeaseaue" +
    "bxeaafacfalganga" +
    "pgargatgavgaxgaa" +
    "hachaliapiasiaui" +
    "bxiaajadjalkapka" +
    "tkavkaxkaalacmae" +
    "magmaimakmammaom" +
    "aumawmhdahfahhah" +
    "jahlahnahvahxahu" +
    "chwchychedhldhpd" +
    "haehtehvehdfhlfh" +
    "pfhaghsghughwghd" +
    "hhlhhphhaihtihvi" +
    "hejhljhpjhukhwkh" +
    "ykhdmhfmhhmhjmhl" +
    "mhnmhvmhxmowaoya" +
    "ovcoxcozcofdokdo" +
    "ueoweoyeoefokfom" +
    "gotgovgoehokhoui" +
    "owioyiofjokjovko" +
    "xkozkowmoymvgdvj" +
    "dvffvjfvlgvfhvjh" +
    "vgjvjjChdCgfCifC" +
    "kgCghCihChj")
r(5006, "Balance", layout="0eoaeebbgbbibbkb" +
    "bmbbqbbsbbubbwbe" +
    "ybeoccedcydcoecc" +
    "faefcgfcwfayfcAf" +
    "cogachaghawhaAhc" +
    "oiaajacjaejagjai" +
    "jaujawjayjaAjaCj" +
    "cokadlaflaxlazlc" +
    "omagoaioakoamoao" +
    "oaqoasoauoawohbj" +
    "hdjhfjhhjhvjhxjh" +
    "zjhBjjeljylhhoij" +
    "ojloknokpojroito" +
    "hvoocjoejogjowjo" +
    "yjoAjvdjvfjvxjvz" +
    "jCejCyj")
r(5007, "Bat", layout="0ecaeAaaabalbanb" +
    "apbarbaCbcccaeca" +
    "yccAcaadandapdaC" +
    "dcceaeebgeaieaue" +
    "bweayecAeaafanfa" +
    "pfaCfbcgbegaggbi" +
    "gakgasgbugawgbyg" +
    "bAgaahamhbohaqha" +
    "Chbcibeiagibiiak" +
    "iasibuiawibyibAi" +
    "aajamjbojaqjaCjc" +
    "ckaekbgkaikakkas" +
    "kaukbwkaykcAkaal" +
    "aolaClccmaemaima" +
    "kmasmaumaymcAmaa" +
    "naCnecobkobsoeAo" +
    "hobhodhofhaghCgh" +
    "aihCi")
#
r(5008, "Beatle", layout="0aeaagaauaawaaic" +
    "akcamcaocaqcasca" +
    "eeageaieakeameao" +
    "eaqeaseaueadgafg" +
    "ahgajgalgangapga" +
    "rgatgavgaeiagiai" +
    "iakiamiaoiaqiasi" +
    "auiaikakkamkaoka" +
    "qkaskaemagmaumaw" +
    "mhhbhtbhjchlchnc" +
    "hpchrchdehfehheh" +
    "jehlehnehpehreht" +
    "eiegiggiigikgimg" +
    "iogiqgisghughdih" +
    "fihhihjihlihnihp" +
    "ihrihtihjkhlkhnk" +
    "hpkhrkhhlhtloceo" +
    "geoieokeomeooeoq" +
    "eoseociogioiioki" +
    "omiooioqiosivbdv" +
    "hevjevlevnevpevr" +
    "evfgvhgvjgvlgvng" +
    "vpgvrgvhivjivliv" +
    "nivpivrivbjCaaCa" +
    "cCggCigCkgCmgCog" +
    "CqgCakCam")
r(5009, "Big Hole", layout="0daadcadeadgadia" +
    "dkadmadoaaaccccd" +
    "ecdgcdicdkccmcao" +
    "caaeccedeedkecme" +
    "aoeaagccgdegdkgc" +
    "mgaogaaiccideidg" +
    "idiidkicmiaoidak" +
    "dckdekdgkdikdkkd" +
    "mkdok")
r(5010, "Bizarre", layout="0aaaaGadkbdmbdob" +
    "dqbdsbdubdwbdkdc" +
    "mdcodcqdcsdcuddw" +
    "ddkfcmfbofbqfbsf" +
    "cufdwfdkhcmhboha" +
    "qhbshcuhdwhakjbm" +
    "jcojdqjcsjbujawj" +
    "aklbmlcolcqlcslb" +
    "ulawlaknbmnbonbq" +
    "nbsnbunawnakpamp" +
    "aopaqpaspaupawpa" +
    "aqaGq")
r(5011, "Boat", layout="0alaapaataajcblc" +
    "apcbtcavcahebjec" +
    "leapectebveaxeaf" +
    "gbhgcjgdlgapgdtg" +
    "cvgbxgazgadibfic" +
    "hidjieliapietidv" +
    "icxibziaBiapkaam" +
    "bcmbembgmbimbkmb" +
    "mmbombqmbsmbumbw" +
    "mbymbAmbCmaEmado" +
    "bfobhobjoblobnob" +
    "pobrobtobvobxobz" +
    "oaBoaiqbkqbmqboq" +
    "bqqbsqbuqawq")
r(5012, "Bug", layout="0bhabnabtaajbapb" +
    "avbcadaidakdamda" +
    "odaqdasdaudawdac" +
    "eayeagfbifbkfbmf" +
    "bofbqfbsfbufbwfa" +
    "Afdegaygbchbghci" +
    "hckhcmhcohcqhcsh" +
    "cuhbwhaAhdeiayia" +
    "gjbijbkjbmjbojbq" +
    "jbsjbujbwjaAjack" +
    "aykcalailaklamla" +
    "olaqlaslaulawlaj" +
    "napnavnbhobnobto" +
    "hyhojfolfonfopfo" +
    "rfotfovfojjoljon" +
    "jopjorjotjovjvjh" +
    "vlhvnhvphvrhvthC" +
    "khCmhCohCqhCsh")
r(5013, "Butterfly", layout="0dmadqaaabaebayb" +
    "aCbagccocawcaada" +
    "edaidaudaydaCdac" +
    "eageakedoeaseawe" +
    "aAeaafaefbifamfa" +
    "qfbufayfaCfacgag" +
    "gbkgeogbsgawgaAg" +
    "aahaehbihbmhbqhb" +
    "uhayhaChaciagibk" +
    "ieoibsiawiaAiaaj" +
    "aejbijamjaqjbuja" +
    "yjaCjackagkakkeo" +
    "kaskawkaAkaalael" +
    "ailaulaylaClacma" +
    "gmeomawmaAmaanae" +
    "naynaCncoohgdhwd" +
    "heehyehcfhgfhwfh" +
    "AfhaghCghaihCihc" +
    "jhgjhwjhAjhekhyk" +
    "hglhwl")
#
r(5014, "Castle", layout="0eaaccaceacgacia" +
    "ckaemacacaccaeca" +
    "gcaicakccmcdaeac" +
    "eaeeageaieakedme" +
    "aoecagacgaegagga" +
    "igakgcmgbogaqgda" +
    "iaciaeiagiaiiaki" +
    "dmiaoicakackaeka" +
    "gkaikakkcmkeamcc" +
    "mcemcgmcimckmemm" +
    "hddhfdhhdhjdhdfh" +
    "ffhhfhjfhdhhfhhh" +
    "hhjhhdjhfjhhjhjj" +
    "oeeogeoieoegoggo" +
    "igoeiogioiivffvh" +
    "fvfhvhhCgg")
r(5015, "Cat and Mouse", layout="0cfabhacjablacna" +
    "bpacrabtacBacFab" +
    "dbbvbbbcbxcbBccD" +
    "cbFcahdajdaldbzd" +
    "baecBebDecFeahfa" +
    "jfalfbagahhajhal" +
    "hbuhbBhbbibsibwi" +
    "bFibqjbBjbckbokb" +
    "xkbFkcelbglcilbk" +
    "lcmlbsmbwmbunbAo" +
    "cCocEocGohiehkeh" +
    "ighkgohdojdoldoh" +
    "fojfolfohhojholh" +
    "oBkoFloAnvievkev" +
    "igvkgvBlvFmCjdCh" +
    "fClfCjh")
r(5016, "Ceremonial", layout="0bcabeaajaalaana" +
    "apaaraataavabAab" +
    "CabdcbfcbzcbBcaa" +
    "dapdaEdbeebgeane" +
    "arebyebAeaafbifb" +
    "kfapfbufbwfaEfbm" +
    "gbsgaahaphaEhbmi" +
    "bsiaajbijbkjapjb" +
    "ujbwjaEjbekbgkan" +
    "karkbykbAkaalapl" +
    "aElbdmbfmbzmbBmb" +
    "cobeoajoaloanoap" +
    "oaroatoavobAobCo" +
    "hkahmahoahqahsah" +
    "uahaehoehqehEeha" +
    "gipghEghaiipihEi" +
    "hakhokhqkhEkhkoh" +
    "mohoohqohsohuoon" +
    "aopaoraopeoahoEh" +
    "opkonoopoorovph")
r(5017, "Checkered", layout="0baabCaacbbebagb" +
    "bibakbbmbaobbqba" +
    "sbbubawbbybaAbbc" +
    "daedbgdaidbkdamd" +
    "bodaqdbsdaudbwda" +
    "ydbAdacfbefagfbi" +
    "fakfbmfaofbqfasf" +
    "bufawfbyfaAfbcha" +
    "ehbghaihbkhamhbo" +
    "haqhbshauhbwhayh" +
    "bAhacjbejagjbija" +
    "kjbmjaojbqjasjbu" +
    "jawjbyjaAjbclael" +
    "bglailbklamlbola" +
    "qlbslaulbwlaylbA" +
    "lacnbenagnbinakn" +
    "bmnaonbqnasnbuna" +
    "wnbynaAnbaobCo")
#
r(5018, "Chip", layout="0aeaaiaamaaqaata" +
    "becbgcbicbkcbmcb" +
    "ocbqcbscbucbwcaa" +
    "dbcdbydaAdbeecge" +
    "cieckecmecoecqec" +
    "secuebweaagbcgbe" +
    "gdggbigakgamgaog" +
    "aqgbsgdugbwgbyga" +
    "Agbeicgiciickicm" +
    "icoicqicsicuibwi" +
    "aajbcjbyjaAjbekb" +
    "gkbikbkkbmkbokbq" +
    "kbskbukbwkaemaim" +
    "ammaqmaum")
r(5019, "Columns", layout="0egaaiaakaamaaoa" +
    "aqaasaauaewaaeba" +
    "ybagcaicaocaucaw" +
    "ceadbcdaedaydbAd" +
    "eCdageekeameaoea" +
    "qeeseawebafbCfag" +
    "gakgasgawgaahamh" +
    "eohaqhaChagiakia" +
    "siawibajbCjagkdk" +
    "kamkaokaqkeskawk" +
    "ealbclaelaylbAle" +
    "Clagmaimaomaumaw" +
    "maenaynegoaioako" +
    "amoaooaqoasoauoe" +
    "wohgfhwfjghjwhhg" +
    "jhwj")
r(5020, "Crown", layout="0baabcabeabgabka" +
    "bmaboabqabsabwab" +
    "yabAabCabacaccae" +
    "cbgcbkcamcbocaqc" +
    "bscbwcaycaAcbCcb" +
    "aeaeebgebkeameaq" +
    "ebsebweayebCebag" +
    "aegbggbigbkgamga" +
    "qgbsgbugbwgaygbC" +
    "gbaiaeiagiaiiaki" +
    "amiaqiasiauiawia" +
    "yibCibakbCkbamac" +
    "maemagmaimakmbom" +
    "asmaumawmaymaAmb" +
    "Cmbaobcobeobgobi" +
    "obkoamobooaqobso" +
    "buobwobyobAobCo")
#
r(5021, "Cupola", layout="0aiaakaamaaoaaqa" +
    "asaagbaubaecawca" +
    "cdaydabfeofazfaa" +
    "hajhalhanhapharh" +
    "athaAhaajeojaAja" +
    "blazlacnaynaeoaw" +
    "oagpaupaiqakqamq" +
    "aoqaqqasqhjbhlbh" +
    "nbhpbhrbhhchtchf" +
    "dhvdhdehxehcghyg" +
    "hkhhmhhohhqhhshh" +
    "bihzihckhykhdmhx" +
    "mhfnhvnhhohtohjp" +
    "hlphnphpphrpokco" +
    "mcoocoqcoidosdog" +
    "eoueoefowfodholh" +
    "onhophorhoxhodjo" +
    "xjoelowlogmoumoi" +
    "nosnokoomoooooqo" +
    "vldvndvpdvjevrev" +
    "hfvtfvfgvvgvmhvo" +
    "hvqhveivwivfkvvk" +
    "vhlvtlvjmvrmvlnv" +
    "nnvpnCifCsfCggCu" +
    "gCnhCphCfiCviCgk" +
    "CukCilCsl")
r(5022, "Deep Well", layout="0acaaeaagaaiaaka" +
    "amaaaccccceccgcc" +
    "icckccmcaocaaecc" +
    "eeeeegeeieekecme" +
    "aoeaagccgeegekgc" +
    "mgaogaaiccieeiek" +
    "icmiaoiaakcckeek" +
    "egkeikekkcmkaoka" +
    "amccmcemcgmcimck" +
    "mcmmaomacoaeoago" +
    "aioakoamo")
r(5023, "Dragon", layout="0bgaaiaegceicdkc" +
    "cmcbocbqcbscbuca" +
    "wcaycaceaeeageai" +
    "eakebmeboeaqease" +
    "aueaweayeadgbfga" +
    "hgajgalgangapgaE" +
    "gayhaChaaiaciaei" +
    "agiaiiakiamiaoia" +
    "qiasiauiaAiaEiaC" +
    "jabkadkafkahkajk" +
    "alkaEkaamacmaema" +
    "gmbimakmaaoacobe" +
    "oagoaiockoamoixc" +
    "hdejhejigkkgjmgh" +
    "Ehhbihdikhikjijl" +
    "iiniipihrihtihCi" +
    "hEjhckhgkhkkhbmh" +
    "fmhboihopneocioE" +
    "iobn")
r(5024, "Dude", layout="0bfabtabhbbjbblb" +
    "brbaBbatcavcaxca" +
    "zcaedagdbldbndbp" +
    "dbrdacebjebueaye" +
    "aAeaCeaafbhfcmfc" +
    "ofcqfcsfbwfaEfbf" +
    "gckgcugbygcphbAh" +
    "beickicuicpjbBjc" +
    "jkclkcnkcrkctkcv" +
    "kcjmclmcnmcrmctm" +
    "cvmcpncjocvockqc" +
    "mqcoqcqqcsqcuq")
# r(5025, "Eagle", layout="0cmadoacqaasbbmc" +
#    "bocaedagdaudawdb" +
#    "cebieakebmeboeaq" +
#    "ebsebyeaefagfauf" +
#    "awfbcgbigakgbmgb" +
#    "ogaqgbsgbygaehag" +
#    "hauhawhaaiacibmi" +
#    "boiayiaAibejbwja" +
#    "akackbmkbokaykaA" +
#    "kaambkmanmbqmaAm" +
#    "cioclocpocsoheeh" +
#    "gehuehweheghgghu" +
#    "ghwghbihzihbkhzk" +
#    "omdoododeofeoheo" +
#    "teoveoxeomfoofod" +
#    "gofgohgotgovgoxg" +
#    "omhoohobjomjoojo" +
#    "zjvndveevgevuevw" +
#    "evnfvegvggvugvwg" +
#    "vnhvnjCfeCveCfgC" +
#    "vg")
r(5026, "Enterprise", layout="0agaaiaakaamaaoa" +
    "aqaasaauaawaayaa" +
    "acbccbecbgcbicbk" +
    "cbmcbocbqcbscbuc" +
    "bwcbycbAcbCcaEcd" +
    "qedogdmhaAiaajbc" +
    "jcejdgjeijekjemj" +
    "eojcqjayjaCjaAkh" +
    "haijailainaipair" +
    "aitaivahxaiAjodc" +
    "ofcohcojcolconco" +
    "pcorcotcovcoxcoz" +
    "coBcvkavmavoavqa" +
    "vsavecvgcvicvkcv" +
    "mcvocvqcvscvucvw" +
    "cvycChcCjcClcCnc" +
    "CpcCrcCtcCvc")
#
r(5027, "Eye", layout="0amaaoaakbaqbaic" +
    "amcaocascagdakda" +
    "qdaudaeeaieameao" +
    "easeaweacfagfakf" +
    "aqfaufayfaagaega" +
    "igamgaogasgawgaA" +
    "gachaghakhaqhauh" +
    "ayhaeiaiiamiaoia" +
    "siawiagjakjaqjau" +
    "jaikamkaokaskakl" +
    "aqlammaomhlbhobh" +
    "jchqchhdhldhodhs" +
    "dhfehjehqehuehdf" +
    "hhfhlfhofhsfhwfh" +
    "fghjghqghughdhhh" +
    "hhlhhohhshhwhhfi" +
    "hjihqihuihhjhljh" +
    "ojhsjhjkhqkhllho" +
    "lolcoocojdoqdohe" +
    "oleooeoseoffojfo" +
    "qfoufohgolgoogos" +
    "gowgofhojhoqhouh" +
    "ohioliooiosiojjo" +
    "qjolkookvldvodvj" +
    "evqevhfvlfvofvsf" +
    "vfgvjgvqgvhhvlhv" +
    "ohvshvjivqivljvo" +
    "j")
r(5028, "F-15 Eagle", layout="0aobaqbasbaubbEc" +
    "bGcandapdardatda" +
    "lebDebFeajfanfap" +
    "farfalgatgavgaxg" +
    "azgaBgaDgabhadha" +
    "fhahhajhanhaphar" +
    "haliatiaviaxiazi" +
    "aBiaDiajjanjapja" +
    "rjalkbDkbFkanlap" +
    "larlatlbEmbGmaon" +
    "aqnasnaunhpahrah" +
    "tahvahochqchschu" +
    "chmehoehqehsehif" +
    "hkfhmghoghqghsgh" +
    "ughwghyghAghCgia" +
    "hichjehjghjihjkh" +
    "hmihoihqihsihuih" +
    "wihyihAihCihijhk" +
    "jhmkhokhqkhskhom" +
    "hqmhsmhumhpohroh" +
    "tohvoozfoBfoDfom" +
    "hozjoBjoDjvAfvCf" +
    "vAjvCjCBfCDfCfhC" +
    "hhCjhCBjCDj")
r(5029, "Farandole", layout="0beabgabmaboabqa" +
    "bwabyabcbbibbkbb" +
    "sbbubbAbafcaxcbb" +
    "dbBdckecmecqecse" +
    "bbfbgfcifcufbwfb" +
    "Bfbegbygbahbchaj" +
    "hblhcnhcphbrhath" +
    "bAhbChbeibyibbjb" +
    "gjcijcujbwjbBjck" +
    "kcmkcqkcskbblbBl" +
    "afmaxmbcnbinbknb" +
    "snbunbAnbeobgobm" +
    "oboobqobwobyo")
r(5030, "Fish", layout="0afaajaasaauaawa" +
    "bhbaobaqbaybacca" +
    "mcbscbucbwcaAcak" +
    "dbodbqdaydaCdace" +
    "aeeaiebmebsebueb" +
    "weaEeagfbkfbofbq" +
    "fayfaCfacgaegaig" +
    "bmgbsgbugbwgaAga" +
    "EgakhbohbqhbyhaC" +
    "haciamibsibuibwi" +
    "aAiaojaqjayjahka" +
    "skaukawkbjlcemal" +
    "mbcndgnbCnaaoeio" +
    "aqoasodAoaEodkpb" +
    "opbupdypcmqcwqhc" +
    "dhcfhefhifhchore" +
    "oteolfonfopfovfo" +
    "rgotgovhoxh")
#
r(5031, "Five Pyramids", layout="0aaaacaaeaagaaya" +
    "aAaaCaaEaaacacca" +
    "ecagcapcaycaAcaC" +
    "caEcaaeaceaeeage" +
    "apeayeaAeaCeaEea" +
    "agacgaegaggangap" +
    "gargaygaAgaCgaEg" +
    "alhathaniapiaria" +
    "akackaekagkapkay" +
    "kaAkaCkaEkaamacm" +
    "aemagmapmaymaAma" +
    "CmaEmaaoacoaeoag" +
    "oayoaAoaCoaEoaaq" +
    "acqaeqagqayqaAqa" +
    "CqaEqhbbhdbhfbhz" +
    "bhBbhDbhbdhddhfd" +
    "hpdhzdhBdhDdhbfh" +
    "dfhffipfhzfhBfhD" +
    "fhnhhphhrhipjhbl" +
    "hdlhflhplhzlhBlh" +
    "DlhbnhdnhfnhznhB" +
    "nhDnhbphdphfphzp" +
    "hBphDpoccoecoAco" +
    "CcoceoeeoAeoCeoo" +
    "hoqhocmoemoAmoCm" +
    "ocooeooAooCovddv" +
    "BdvphvdnvBn")
# r(5032, "Five Pyramids 2", layout="0aoaaabacbaebagb" +
#    "awbaybaAbaCbboca" +
#    "adacdaedagdaidak" +
#    "damdaqdasdaudawd" +
#    "aydaAdaCdcoeaafa" +
#    "cfaefagfawfayfaA" +
#    "faCfamgdogaqgadh" +
#    "azhagibiickidmid" +
#    "oidqicsibuiawiad" +
#    "jazjamkdokaqkaal" +
#    "aclaelaglawlayla" +
#    "AlaClcomaanacnae" +
#    "nagnainaknamnaqn" +
#    "asnaunawnaynaAna" +
#    "Cnbooaapacpaepag" +
#    "pawpaypaApaCpaoq" +
#    "hbchdchfchxchzch" +
#    "Bchbehdehfehxehz" +
#    "ehBehbmhdmhfmhxm" +
#    "hzmhBmhbohdohfoh" +
#    "xohzohBoocdoedoy" +
#    "doAdocnoenoynoAn")
r(5033, "Flowers", layout="0baaccaceabgaaka" +
    "bmaboaaqaauabwab" +
    "yaaAadacdgcckccq" +
    "ccuccAcbaeccecee" +
    "bgeakebmeboeaqea" +
    "uebwebyeaAeadgan" +
    "gaxgafhahhajhalh" +
    "apharhathavhadia" +
    "niaxiaakbckbekag" +
    "kakkbmkbokaqkauk" +
    "bwkbykaAkcamcgmc" +
    "kmcqmcumcAmaaobc" +
    "obeoagoakobmoboo" +
    "aqoauobwobyoaAoo" +
    "naoxaoneoxeodkon" +
    "koxkodoonooxovda" +
    "vde")
r(5034, "Flying Dragon", layout="0acaaeaagaaiaaka" +
    "amaaoaaqaasaauaa" +
    "waayaagcbicbkcbm" +
    "cbocbqcbscaucaee" +
    "agebieckecmecoec" +
    "qebseaueaweacgae" +
    "gaggbigckgdmgdog" +
    "cqgbsgaugawgayga" +
    "ahaAhaChaciaeiag" +
    "ibiickidmidoicqi" +
    "bsiauiawiayiaeka" +
    "gkbikckkcmkcokcq" +
    "kbskaukawkagmbim" +
    "bkmbmmbombqmbsma" +
    "umacoaeoagoaioak" +
    "oamoaooaqoasoauo" +
    "awoayoCnh")
r(5035, "Fortress Towers", layout="0faaecadeacgabia" +
    "bkacmadoaeqafsae" +
    "acaccagcaicakcam" +
    "caqcescdaeaceage" +
    "aieakeameaqedsed" +
    "agacgaggaigakgam" +
    "gaqgdsgeaiaciagi" +
    "aiiakiamiaqiesif" +
    "akeckdekcgkbikbk" +
    "kcmkdokeqkfskhjc" +
    "hjehjghji")
#
r(5036, "Full Vision", layout="0aaaaiaamaaoaaqa" +
    "asaawaaEaacbaeba" +
    "gbaybaAbaCbaacai" +
    "camcaocaqcascawc" +
    "aEcacdaedagdayda" +
    "AdaCdaaeaieaweaE" +
    "eaefamfasfaAfagg" +
    "aigakgaugawgayga" +
    "ehamhashaAhagiai" +
    "iakiauiawiayiaej" +
    "amjasjaAjaakaika" +
    "wkaEkaclaelaglay" +
    "laAlaClaamaimaom" +
    "aqmawmaEmacnaena" +
    "gnamnasnaynaAnaC" +
    "naaoaioaooaqoawo" +
    "aEohpahbbhhbhnbh" +
    "rbhxbhDbhdchfchp" +
    "chzchBchbdhhdhxd" +
    "hDdhfghlghtghzgh" +
    "hhhjhhvhhxhhfihl" +
    "ihtihzihblhhlhxl" +
    "hDlhdmhfmhzmhBmh" +
    "bnhhnhnnhpnhrnhx" +
    "nhDnooboqboccogc" +
    "oycoCcoghokhouho" +
    "yhocmogmoymoCmvp" +
    "b")
#
r(5037, "Full Vision 2", layout="0aaaacaafaahaaka" +
    "amaapaaraauaawaa" +
    "zaaBaaacaccafcah" +
    "cakcamcapcarcauc" +
    "awcazcaBcaaeacea" +
    "feaheakeameapear" +
    "eaueaweazeaBeaag" +
    "acgafgahgakgamga" +
    "pgargaugawgazgaB" +
    "gaajacjaejagjakj" +
    "amjapjarjavjaxja" +
    "zjaBjaalaclaelag" +
    "laklamlaplarlavl" +
    "axlazlaBlaeoagoa" +
    "ioakoamoapoaroat" +
    "oavoaxohbbhgbhlb" +
    "hqbhvbhAbhadhcdh" +
    "fdhhdhkdhmdhpdhr" +
    "dhudhwdhzdhBdhbf" +
    "hgfhlfhqfhvfhAfh" +
    "djhyjhbkhfkhkkhm" +
    "khpkhrkhwkhAkhdl" +
    "hylobcogcolcoqco" +
    "vcoAcobeogeoleoq" +
    "eoveoAeockoekolk" +
    "oqkoxkozkvbdvgdv" +
    "ldvqdvvdvAdvdkvy" +
    "k")
r(5038, "Future", layout="0cgaaiaakaamaboa" +
    "aqaasaauacwaagcc" +
    "icakcamcbocaqcas" +
    "ccucawcaeeageaie" +
    "bkebmeboebqebsea" +
    "ueaweayeacfaAfaa" +
    "gcegcggdigdkgdmg" +
    "dogdqgdsgdugcwgc" +
    "ygaCgachaAhaeiag" +
    "iaiibkibmiboibqi" +
    "bsiauiawiayiagkc" +
    "ikakkamkbokaqkas" +
    "kcukawkcgmaimakm" +
    "ammbomaqmasmaumc" +
    "wmhcghAgoneopeon" +
    "iopiClgCngCpgCrg")
r(5039, "Garden", layout="0adaafaaoaaqaaza" +
    "aBaaabaibalbatba" +
    "wbaEbaccaecagcan" +
    "capcarcaycaAcaCc" +
    "aadaidaldatdawda" +
    "Edaceaeeageaneap" +
    "eareayeaAeaCeaaf" +
    "aifalfatfawfaEfa" +
    "chaehaghanhaphar" +
    "hayhaAhaChaajaij" +
    "aljatjawjaEjacka" +
    "ekagkankapkarkay" +
    "kaAkaCkaalailall" +
    "atlawlaElacmaema" +
    "gmanmapmarmaymaA" +
    "maCmaanainalnatn" +
    "awnaEnadoafoaooa" +
    "qoazoaBoheahpahA" +
    "ahcdhedhgdhndhpd" +
    "hrdhydhAdhCdhdhh" +
    "fhhohhqhhzhhBhhc" +
    "lhelhglhnlhplhrl" +
    "hylhAlhClheohpoh" +
    "Aooddofdoodoqdoz" +
    "doBdoehophoAhodl" +
    "oflooloqlozloBlv" +
    "edvpdvAdvelvplvA" +
    "l")
r(5040, "Gayle's", layout="0dcaceabgaaiaaka" +
    "amaaoaaqaasabuac" +
    "wadyaagcbicckccm" +
    "ccoccqcbscaucake" +
    "bmeboeaqeacgaega" +
    "ggbigbkgbmgbogbq" +
    "gbsgaugawgaygaah" +
    "aAhaciaeiagibiib" +
    "kibmiboibqibsiau" +
    "iawiayiakkbmkbok" +
    "aqkagmbimckmcmmc" +
    "omcqmbsmaumdcoce" +
    "obgoaioakoamoaoo" +
    "aqoasobuocwodyoo" +
    "jholhonhophorhvn" +
    "cvmhvohvnmCnh")
r(5041, "Glade", layout="0aaaacaaCaaEaaac" +
    "accaCcaEcahdejdc" +
    "ldcndbpdcrdctdev" +
    "daxddhfcjfblfbnf" +
    "bpfbrfbtfcvfdxfc" +
    "hhbjhblhanharhbt" +
    "hbvhcxhdhjcjjblj" +
    "bnjbpjbrjbtjcvjd" +
    "xjahlejlcllcnlbp" +
    "lcrlctlevlaxlaam" +
    "acmaCmaEmaaoacoa" +
    "CoaEohbahDahbchD" +
    "chbmhDmhbohDoobb" +
    "oDbobnoDn")
r(5042, "H for Haga", layout="0aaaacaaeaagaaka" +
    "amaaoaaqaaacacca" +
    "ecagcakcamcaocaq" +
    "caaeaceaeeageake" +
    "ameaoeaqeaifaaga" +
    "cgaegaggakgamgao" +
    "gaqgaihaaiaciaei" +
    "agiakiamiaoiaqia" +
    "ijaakackaekagkak" +
    "kamkaokaqkaamacm" +
    "aemagmakmammaoma" +
    "qmaaoacoaeoagoak" +
    "oamoaooaqohbbhdb" +
    "hfbhlbhnbhpbhbdh" +
    "ddhfdhldhndhpdhb" +
    "fhdfhffhlfhnfhpf" +
    "hhghjghbhhdhhfhh" +
    "lhhnhhphhhihjihb" +
    "jhdjhfjhljhnjhpj" +
    "hblhdlhflhllhnlh" +
    "plhbnhdnhfnhlnhn" +
    "nhpnoccoecomcooc" +
    "oceoeeomeooeocgo" +
    "egomgoogoghoihok" +
    "hocioeiomiooiock" +
    "oekomkookocmoemo" +
    "mmoomvddvndvdlvn" +
    "l")
# r(5043, "H for Haga Traditional", layout="0acaaeaagaaiaaka" +
#    "amaaoaaqaasaauaa" +
#    "waayabgcbicakcam" +
#    "caocaqcbscbucaee" +
#    "bgebieakeameaoea" +
#    "qebsebueaweacgae" +
#    "gbggbigbkgbmgbog" +
#    "bqgbsgbugawgayga" +
#    "ahaAhaciaeibgibi" +
#    "ibkibmiboibqibsi" +
#    "buiawiayiaekbgkb" +
#    "ikakkamkaokaqkbs" +
#    "kbukawkbgmbimakm" +
#    "ammaomaqmbsmbuma" +
#    "coaeoagoaioakoam" +
#    "oaooaqoasoauoawo" +
#    "ayoklcknckpchdhh" +
#    "xhklmknmkpm")
r(5044, "Helios", layout="0eaadcaduaewadac" +
    "bccbucdwcbaeacea" +
    "eeaiedkedmeaoeas" +
    "eauebwebagacgaeg" +
    "aggdigdogaqgasga" +
    "ugbwgblhbaiaciae" +
    "iagidiidoiaqiasi" +
    "auibwibakackaeka" +
    "ikdkkdmkaokaskau" +
    "kbwkdambcmbumdwm" +
    "eaodcoduoewohchh" +
    "ehhghhqhhshhuhCl" +
    "eCihCohClk")
r(5045, "High and Low", layout="0eaadcaceabgaaia" +
    "bkacmadoaeqadacc" +
    "ccdecagcbicckcbm" +
    "ceocdqccaebceeee" +
    "bgeciedkeamedoec" +
    "qebagacgdegcggdi" +
    "gekgbmgcogbqgaai" +
    "bciceidgieiidkic" +
    "miboiaqiaekagkbi" +
    "kakkamkahmajmhim")
#
# r(5046, "Hourglass", layout="0aaaacaaeaagaaia" +
#    "akaamaaoaaqaasaa" +
#    "uaawaayaaacamcay" +
#    "cacdawdaaeaeeame" +
#    "aueayeacfagfasfa" +
#    "wfaagaegaigamgaq" +
#    "gaugaygachaghbkh" +
#    "bohashawhaaiaeia" +
#    "iiamiaqiauiayiac" +
#    "jagjasjawjaakaek" +
#    "amkaukaykaclawla" +
#    "amammaymaaoacoae" +
#    "oagoaioakoamoaoo" +
#    "aqoasoauoawoayoh" +
#    "abhmbhybhadhmdhy" +
#    "dhcehwehafhefhuf" +
#    "hyfhcghgghsghwgh" +
#    "ahhehhihhqhhuhhy" +
#    "hhcihgihsihwihaj" +
#    "hejhujhyjhckhwkh" +
#    "alhmlhylhanhmnhy" +
#    "noacoycoaeoyeoag" +
#    "oygoaioyioakoyko" +
#    "amoymvadvydvafvy" +
#    "fvahvyhvajvyjval" +
#    "vylCaeCyeCagCygC" +
#    "aiCyiCakCyk")
r(5047, "Inca", layout="0aoaaqaaibakbamb" +
    "asbaubawbbocbqca" +
    "idbkdbmdbsdbudaw" +
    "dcoecqeaifbkfcmf" +
    "csfbufawfaagacgd" +
    "ogdqgaCgaEgahhbj" +
    "hclhcthbvhaxhaai" +
    "acidoidqiaCiaEia" +
    "hjbjjcljctjbvjax" +
    "jaakackdokdqkaCk" +
    "aEkailbklcmlcslb" +
    "ulawlcomcqmainbk" +
    "nbmnbsnbunawnboo" +
    "bqoaipakpampaspa" +
    "upawpaoqaqqhbihD" +
    "iCphCpj")
r(5048, "Inner Circle", layout="0aaaacaayaaAaaac" +
    "eccceccgcbicbkca" +
    "mcaocbqcbsccuccw" +
    "ceycaAcccecyedgf" +
    "cifbkfbqfcsfdufb" +
    "cgbygaghbuhbciby" +
    "iegjdijckjbmjboj" +
    "cqjdsjeujcckcyka" +
    "amecmcemcgmbimbk" +
    "mbqmbsmcumcwmdym" +
    "aAmaaoacoakoaqoa" +
    "yoaAo")
r(5049, "Joker", layout="0aaaaAaadbafbahb" +
    "ajbalbanbapbarba" +
    "tbavbaxbabdbddbf" +
    "dbhdbjdbldbndbpd" +
    "brdbtdbvdbxdazdc" +
    "bfbdfaffahfajfal" +
    "fanfapfarfatfavf" +
    "bxfczfcbhbdhafha" +
    "vhbxhczhajiamiap" +
    "iasicbjbdjafjavj" +
    "bxjczjcblbdlafla" +
    "hlajlallanlaplar" +
    "latlavlbxlczlabn" +
    "bdnbfnbhnbjnblnb" +
    "nnbpnbrnbtnbvnbx" +
    "naznadpafpahpajp" +
    "alpanpapparpatpa" +
    "vpaxpaaqaAqhgghu" +
    "ghgkhuk")
r(5050, "K for Kyodai", layout="0caaccaceacmacoa" +
    "cqacacbcccecckcb" +
    "mccoccaebceceeci" +
    "ebkecmecagbcgceg" +
    "cggbigckgcaibcib" +
    "eibgiciicakbckce" +
    "kcgkbikckkcambcm" +
    "cemcimbkmcmmcaob" +
    "coceockobmocooca" +
    "qccqceqcmqcoqcqq")
# r(5051, "K for Kyodai Traditional", layout="0acaaeaagaaiaaka" +
#    "amaaoaaqaasaauaa" +
#    "waayaagcaicakcam" +
#    "caocaqcascaucaee" +
#    "ageaieakeameaoea" +
#    "qeaseaueaweacgae" +
#    "gaggaigakgamgaog" +
#    "aqgasgaugawgayga" +
#    "ahaAhaciaeiagiai" +
#    "iakiamiaoiaqiasi" +
#    "auiawiayiaekagka" +
#    "ikakkamkaokaqkas" +
#    "kaukawkagmaimakm" +
#    "ammaomaqmasmauma" +
#    "coaeoagoaioakoam" +
#    "oaooaqoasoauoawo" +
#    "ayokjckrckpdkjeh" +
#    "gfknfhufkjghghkl" +
#    "hhuhkjihgjknjhuj" +
#    "kjkkplkjmkrm")
r(5052, "Km", layout="0baabcabiaakaboa" +
    "cqacyabAabacaccb" +
    "gcaicbocaqcdscdw" +
    "caycbAcdudbaeace" +
    "beeageboeaqeasea" +
    "weayebAeeufbagac" +
    "gbegaggbogaqgayg" +
    "bAgduhbaiacibgia" +
    "iiboiaqiayibAiba" +
    "kbckbikakkbokbqk" +
    "bykbAkjcfhgfoabo" +
    "oboAboadoodoAdoa" +
    "foefoofoAfoahooh" +
    "oAhoajoojoAjvacv" +
    "ocvAcvaevoevAeva" +
    "gvogvAgvaivoivAi" +
    "CadCodCAdCafCofC" +
    "AfCahCohCAh")
r(5053, "Kujaku", layout="0bnabpabrabtabva" +
    "bxablbczbaBbbhcb" +
    "jcancapcarcatcav" +
    "caxcaddbfdaldazd" +
    "dBdaDdaheajeabfc" +
    "dfaffaAfdCfaEfba" +
    "hcchaehakhamhaoh" +
    "ashaAhdChaEhabjc" +
    "djafjaAjdCjaEjah" +
    "kajkadlbflallazl" +
    "dBlaDlbhmbjmanma" +
    "pmarmatmavmaxmbl" +
    "ncznaBnbnobpobro" +
    "btobvobxohnghpgh" +
    "tghjhhnihpihtioo" +
    "foqfoufoihoojoqj" +
    "oujvpevrevvfvhhv" +
    "vjvpkvrkCwgCCgCg" +
    "hCwiCCi")
r(5054, "Labyrinth", layout="0caaacaaeaagaaia" +
    "akaamaaoaaqaasaa" +
    "uaawaayaaAaaCacE" +
    "aaacbkcbocbucaEc" +
    "aaebcebeebgebkeb" +
    "oebsebuebyebAeaE" +
    "eaagbkgbygaEgaai" +
    "beibiibkiboibqib" +
    "sibuibwibyibAiaE" +
    "iaakbekbokbwkaEk" +
    "aambembgmbimbkmb" +
    "ombqmbsmbwmbAmbC" +
    "maEmaaobkobwoaEo" +
    "caqacqbeqdgqdkqb" +
    "mqaoqaqqasqauqbw" +
    "qdyqdCqbEq")
r(5055, "Lion", layout="0bdbbfbcjbclbawb" +
    "aybbbcbhcaucaAcc" +
    "jdcldasdaCdbaeaq" +
    "ecvfczfaDfbbgapg" +
    "aEhcbiceichickia" +
    "oicxiaFjcckcfkci" +
    "kclkbokcwkcykbul" +
    "bAlaElcbmcemchmc" +
    "kmcnmbqmaDnccocf" +
    "ocioclocooaroato" +
    "avoaxoazoaBohvah" +
    "xahzahtbhBbhrchD" +
    "dhpehEfhoghFhhni" +
    "hGjhFlhEnhsohCoh" +
    "uphwphyphApwkc")
r(5056, "Lost ", layout="0afaaxaabbadbahb" +
    "ajbblbbnbbpbbrba" +
    "tbavbazbaBbafcax" +
    "cabdaddbkdcodbsd" +
    "azdaBdbiebmebqeb" +
    "ueaafacfaefbgfdo" +
    "fbwfayfaAfaCfaah" +
    "aehbghcihckhdmhd" +
    "ohdqhcshcuhbwhay" +
    "haChaajacjaejbgj" +
    "dojbwjayjaAjaCjb" +
    "ikbmkbqkbukablad" +
    "lbklcolbslazlaBl" +
    "afmaxmabnadnahna" +
    "jnblnbnnbpnbrnat" +
    "navnaznaBnafoaxo" +
    "ombooboqbomnoono" +
    "qn")
r(5057, "Maya", layout="0aaaacaaeaagaaia" +
    "aqaasaauaawaayaa" +
    "acaccaecagcaicaq" +
    "cascaucawcaycaae" +
    "aceaeeageaieakea" +
    "meaoeaqeaseaueaw" +
    "eayeaigakgamgaog" +
    "aqgaiiakiamiaoia" +
    "qiaakackaekagkai" +
    "kakkamkaokaqkask" +
    "aukawkaykaamacma" +
    "emagmaimaqmasmau" +
    "mawmaymaaoacoaeo" +
    "agoaioaqoasoauoa" +
    "woayohcbhebhgbhs" +
    "bhubhwbhcdhedhgd" +
    "hsdhudhwdhkfhmfh" +
    "ofhkhhmhhohhkjhm" +
    "jhojhclhelhglhsl" +
    "hulhwlhcnhenhgnh" +
    "snhunhwnoccoecog" +
    "coscoucowcolfonf" +
    "olhonholjonjocmo" +
    "emogmosmoumowmvd" +
    "cvfcvtcvvcvmfvmh" +
    "vmjvdmvfmvtmvvmC" +
    "ecCucCmgCmiCemCu" +
    "m")
r(5058, "Mesh", layout="0baabcabeabiabka" +
    "bmabqabsabuabyab" +
    "AabCabacbecbicbm" +
    "cbqcbucbycbCcbae" +
    "bcebeeagebiebkeb" +
    "meaoebqebsebueaw" +
    "ebyebAebCeaegbig" +
    "bmgbqgbugaygbaib" +
    "cibeiagibiibkibm" +
    "iaoibqibsibuiawi" +
    "byibAibCibakbekb" +
    "ikbmkbqkbukbykbC" +
    "kbambcmbembimbkm" +
    "bmmbqmbsmbumbymb" +
    "AmbCm")
r(5059, "Moth", layout="0baaccaceabgaana" +
    "apaarabyacAacCab" +
    "Eaaibawbbccagcak" +
    "ccpcaucaycbCcaid" +
    "amdasdawdadeakeb" +
    "oebqeaueaBeamfas" +
    "facgaegahgajgbog" +
    "bqgavgaxgaAgaCga" +
    "mhashadiakiboibq" +
    "iauiaBiaijamjasj" +
    "awjbckagkakkcpka" +
    "ukaykbCkailawlcc" +
    "mcembgmbpmbymcAm" +
    "cCmbanbEnhoahqah" +
    "ichwchmehsehdghi" +
    "ghwghBghmihsihik" +
    "hwkopaoneopeorep" +
    "pgoniopiorivdavB" +
    "avoevqevoivqivdm" +
    "vBmCpeCpi")
r(5060, "N for Namida", layout="0caaccaceacgacqa" +
    "csacuacacbccbecb" +
    "gcbiccqcbsccucca" +
    "ebcebeebgebiebke" +
    "cqebsecuecagbcgc" +
    "egbigbkgbmgcqgbs" +
    "gcugcaibciceibki" +
    "bmiboibqibsicuic" +
    "akbckcekbmkbokbq" +
    "kbskcukcamccmcem" +
    "comcqmcsmcum")
# r(5061, "N for Namida Traditional", layout="0acaaeaagaaiaaka" +
#    "amaaoaaqaasaauaa" +
#    "waayacgcaicakcbm" +
#    "ccoccqcasccucaee" +
#    "cgecieakeameaoea" +
#    "qeasecueaweacgae" +
#    "gcggcigakgcmgaog" +
#    "aqgasgcugawgayga" +
#    "ahaAhaciaeicgiai" +
#    "iakicmiaoicqiasi" +
#    "cuiawiayiaekcgka" +
#    "ikakkamkaokcqkas" +
#    "kcukawkcgmaimckm" +
#    "cmmbomaqmasmcuma" +
#    "coaeoagoaioakoam" +
#    "oaooaqoasoauoawo" +
#    "ayoikfikhiohioji" +
#    "sjisl")
# r(5062, "Naoki Haga Traditional", layout="0acaaeaagaaiaaka" +
#    "amaaoaaqaasaauaa" +
#    "waayadgcaicakcdm" +
#    "caocaqcascaucaee" +
#    "dgeaiedkedmeaoec" +
#    "qecseaueaweacgae" +
#    "gdggaigakgdmgaog" +
#    "aqgasgaugawgayga" +
#    "ahaAhaciaeiagiai" +
#    "iakiamidoiaqiasi" +
#    "duiawiayiaekagkc" +
#    "ikckkamkdokdqkds" +
#    "kdukawkagmaimakm" +
#    "ammdomaqmasmduma" +
#    "coaeoagoaioakoam" +
#    "oaooaqoasoauoawo" +
#    "ayojidvrevjk")
#
r(5063, "New Layout", layout="0aeaagaaiaakabpa" +
    "auaawaayaaAaacca" +
    "Ccahdajdavdaxdaa" +
    "eacealeateaCeaEe" +
    "anfarfaagacgahga" +
    "pgaCgaEganharhaa" +
    "iacialiatiaCiaEi" +
    "ahjajjavjaxjacka" +
    "Ckaemagmaimakmbp" +
    "maumawmaymaAmhfa" +
    "hhahjahvahxahzah" +
    "cdhidhwdhCdhkehu" +
    "ehafhcfhmfhofhqf" +
    "hsfhCfhEfhahhchh" +
    "mhhohhqhhshhChhE" +
    "hhkihuihcjhijhwj" +
    "hCjhfmhhmhjmhvmh" +
    "xmhzmogaoiaowaoy" +
    "aoceojeoveoCeolf" +
    "otfoagocgongopgo" +
    "rgoCgoEgolhothoc" +
    "iojiovioCiogmoim" +
    "owmoymvhavxavcfv" +
    "kfvufvCfvmgvogvq" +
    "gvsgvchvkhvuhvCh" +
    "vhmvxmCcgClgCngC" +
    "pgCrgCtgCCg")
r(5064, "Order", layout="0afaahaajaalaana" +
    "apaaraataaabayba" +
    "icakcamcaocaqcba" +
    "dacdaedaudawdbyd" +
    "akebmeaoecafbcfa" +
    "efaufbwfcyfaggai" +
    "gakgbmgaogaqgasg" +
    "cahcchbehbuhcwhc" +
    "yhagiaiiakibmiao" +
    "iaqiasicajbcjaej" +
    "aujbwjcyjakkbmka" +
    "okbalaclaelaulaw" +
    "lbylaimakmammaom" +
    "aqmaanaynafoahoa" +
    "joaloanoapoaroat" +
    "ohgahiaikaimaioa" +
    "hqahsahlchnchghh" +
    "ihhkhhohhqhhshhl" +
    "mhnmhgohioikoimo" +
    "ioohqohsoomcpmho" +
    "mm")
r(5065, "Pattern", layout="0aaaacaafaahaaka" +
    "amaapaaraauabwab" +
    "zaaBaaacaccafcah" +
    "cakcamcapcarcbuc" +
    "cwcczcbBccafacfa" +
    "ffchfckfcmfapfar" +
    "fcufawfazfcBfaah" +
    "cchcfhahhakhamhc" +
    "phcrhcuhawhazhcB" +
    "haakackafkahkakk" +
    "cmkcpkarkcukcwkc" +
    "zkcBkaamacmafmah" +
    "mckmammapmcrmaum" +
    "cwmczmaBmibailai" +
    "fbihbibciqciqfil" +
    "hialihl")
# r(5066, "Phoenix", layout="0aaaacaapaaraaEa" +
#    "aGaaebatbaCbaaca" +
#    "gcapcarcaAcaGcai" +
#    "daydakeboebqebse" +
#    "aweaafacfaefamfa" +
#    "ufaCfaEfaGfaggbp" +
#    "gbrgaAgaahaihamh" +
#    "auhayhaGhaeiakic" +
#    "picriawiaCiaajam" +
#    "jaujaGjbpkbrkacl" +
#    "aelaglailamlaula" +
#    "ylaAlaClaElakmbp" +
#    "mbrmawmacnafnamn" +
#    "aunaBnaEnaioaooa" +
#    "soayoacpafpaBpaE" +
#    "pakqawqhbbhFbhdc" +
#    "hDchfdhBdhhehzeh" +
#    "jfhxfhdghlghvghD" +
#    "ghfhhBhhhihnihti" +
#    "hzihjjhxjhdkhlkh" +
#    "vkhDkhflhnlhtlhB" +
#    "lhhmhzmhjnhxnhlo" +
#    "hvohnphtponfppfp" +
#    "rfotfoplorlvqivq" +
#    "lCqf")
r(5067, "Portal", layout="0accagcawcaAcaed" +
    "aydaceageaweaAea" +
    "mgaqgamiaqiackag" +
    "kawkaAkaelaylacm" +
    "agmawmaAmhbbhdbh" +
    "fbhhbhvbhxbhzbhB" +
    "bhbdhhdhvdhBdhbf" +
    "hdfhffhhfhlfhnfh" +
    "pfhrfhvfhxfhzfhB" +
    "fhlhhrhhbjhdjhfj" +
    "hhjhljhnjhpjhrjh" +
    "vjhxjhzjhBjhblhh" +
    "lhvlhBlhbnhdnhfn" +
    "hhnhvnhxnhznhBno" +
    "aaocaoeaogaoiaou" +
    "aowaoyaoAaoCaoac" +
    "oicoucoCcoaeoieo" +
    "keomeooeoqeoseou" +
    "eoCeoagocgoegogg" +
    "oigokgosgougowgo" +
    "ygoAgoCgoaiocioe" +
    "iogioiiokiosioui" +
    "owioyioAioCioako" +
    "ikokkomkookoqkos" +
    "koukoCkoamoimoum" +
    "oCmoaoocooeoogoo" +
    "ioouoowooyooAooC" +
    "o")
r(5068, "Rocket", layout="0amaaoaaqaazaaBa" +
    "aDaakbaicamcaoca" +
    "qcascaxcazcaBcaD" +
    "cagdakdaudaeeaie" +
    "ameaqeaseaweayea" +
    "cfagfakfaofaufaB" +
    "faegasgawgaygaah" +
    "bchbghbihbkhbmhb" +
    "ohcqhauhaAhaChae" +
    "iasiawiayiacjagj" +
    "akjaojaujaBjaeka" +
    "ikamkaqkaskawkay" +
    "kaglaklaulaimamm" +
    "aomaqmasmaxmazma" +
    "BmaDmaknamoaooaq" +
    "oazoaBoaDohnahpa" +
    "hlbhBbhjchnchpch" +
    "hdhsdhfehxehdfhs" +
    "fhughehhshiwhhyh" +
    "huihdjhsjhfkhxkh" +
    "hlhslhjmhnmhpmhl" +
    "nhBnhnohpoonbopb" +
    "osgodhofhohhojho" +
    "lhonhouhosionnop" +
    "nvobvehvghvihvsh" +
    "vonCfh")
r(5069, "Scorpion", layout="0avaacbaebagbaib" +
    "aacaxcazcagdaida" +
    "kdaoeaseayeaAeaa" +
    "facfaefagfaifakf" +
    "cmgaogcqgasgcuga" +
    "wgbygbAgckhciidm" +
    "iaoicqiasiduiawi" +
    "byibAickjcmkaokc" +
    "qkaskcukawkbykaa" +
    "laclaelaglailakl" +
    "aomasmawmagnaina" +
    "knaaoacpaepagpai" +
    "phdbhfbhhbhwbhbc" +
    "hychhdhzehbfhdfh" +
    "ffhhfhjfhofhsfho" +
    "hhshhwhhojhsjhwj" +
    "hblhdlhflhhlhjlh" +
    "olhslhwlhhnhbohd" +
    "phfphhpoogosgoyh" +
    "ooiosiowioyjooko" +
    "skvohvqhvshvojvq" +
    "jvsj")
r(5070, "Screw Up", layout="0ciackacmabgbbob" +
    "cecbicbkcbmccqcb" +
    "gdbodcceceeakeam" +
    "ecqecsebgfbofccg" +
    "cegakgamgcqgcsgb" +
    "ghbohcciceiaiiak" +
    "icqicsibgjbojcck" +
    "cekaikakkcqkcskb" +
    "glbolcembimbkmbm" +
    "mcqmbgnbonciocko" +
    "cmoilfikhijjvbfv" +
    "tfvbhvthvbjvtjCa" +
    "fCufCahCuhCajCuj")
#
r(5071, "Seven", layout="0aaaacaafaahaaka" +
    "amaapaaraauaawaa" +
    "zaaBaaEaaGaaacac" +
    "cafcahcakcamcapc" +
    "arcaucawcazcaBca" +
    "EcaGcaaeaceafeah" +
    "eakeameapeareaue" +
    "aweazeaBeaEeaGea" +
    "agacgafgahgakgam" +
    "gapgargaugawgazg" +
    "aBgaEgaGgaaiacia" +
    "fiahiakiamiapiar" +
    "iauiawiaziaBiaEi" +
    "aGiaakackafkahka" +
    "kkamkapkarkaukaw" +
    "kazkaBkaEkaGkaam" +
    "acmafmahmakmamma" +
    "pmarmaumawmazmaB" +
    "maEmaGmaaoacoafo" +
    "ahoakoamoapoaroa" +
    "uoawoazoaBoaEoaG" +
    "oaaqacqafqahqakq" +
    "amqapqarqauqawqa" +
    "zqaBqaEqaGqhqchl" +
    "ehvehggiqghAghbi" +
    "hlihvihFihgkiqkh" +
    "Akhlmhvmhqo")
#
r(5072, "Seven Pyramids", layout="0aaaacaaeaagaaoa" +
    "aqaayaaAaaCaaEaa" +
    "acaccaecagcaocaq" +
    "caycaAcaCcaEcaae" +
    "aceaeeageayeaAea" +
    "CeaEeaagacgaegag" +
    "gangapgargaygaAg" +
    "aCgaEganiapiaria" +
    "akackaekagkankap" +
    "karkaykaAkaCkaEk" +
    "aamacmaemagmayma" +
    "AmaCmaEmaaoacoae" +
    "oagoaooaqoayoaAo" +
    "aCoaEoaaqacqaeqa" +
    "gqaoqaqqayqaAqaC" +
    "qaEqhbbhdbhfbhpb" +
    "hzbhBbhDbhbdhddh" +
    "fdhzdhBdhDdhbfhd" +
    "fhffhzfhBfhDfhoh" +
    "hqhhojhqjhblhdlh" +
    "flhzlhBlhDlhbnhd" +
    "nhfnhznhBnhDnhbp" +
    "hdphfphpphzphBph" +
    "DpoccoecoAcoCcoc" +
    "eoeeoAeoCeopiocm" +
    "oemoAmoCmocooeoo" +
    "AooCovddvBdvdnvB" +
    "n")
r(5073, "Shield", layout="0aaaacaaeaagaaia" +
    "akaamaaoaaxaaaca" +
    "ccaecagcaicakcam" +
    "caocbxcaaeaceaee" +
    "ageaieakeameaoec" +
    "xeabgadgafgahgaj" +
    "galgangdxgaciaei" +
    "agiaiiakiamidxie" +
    "tjeBjaekagkaikak" +
    "kbvkexkbzkagmaim" +
    "cxmahodxohcbhebh" +
    "gbhibhkbhmbhcdhe" +
    "dhgdhidhkdhmdhcf" +
    "iefigfiifikfhmfh" +
    "dhifhihhijhhlhhe" +
    "jigjiijhkjhglhil" +
    "odbofbohbojbolbo" +
    "ddofdohdojdoldoh" +
    "lvfcvhcvjcvfevhe" +
    "vjevggvigvhiChdC" +
    "hf")
r(5074, "Siam", layout="0afaazaadbahbaxb" +
    "aBbacdaedagdaida" +
    "ndardawdaydaAdaC" +
    "daleateabfadfaff" +
    "ahfajfavfaxfazfa" +
    "BfaDfaahachaehag" +
    "haihakhamhaohaqh" +
    "ashauhawhayhaAha" +
    "ChaEhabjadjafjah" +
    "jajjavjaxjazjaBj" +
    "aDjalkatkaclaela" +
    "glailanlarlawlay" +
    "laAlaCladnahnaxn" +
    "aBnafoazohddhfdh" +
    "hdhxdhzdhBdhcfhe" +
    "fhgfhifhwfhyfhAf" +
    "hCfhbhhdhhfhhhhh" +
    "jhhlhhnhiphhrhht" +
    "hhvhhxhhzhhBhhDh" +
    "hcjhejhgjhijhwjh" +
    "yjhAjhCjhdlhflhh" +
    "lhxlhzlhBloedogd" +
    "oydoAdodfoffohfo" +
    "xfozfoBfochoehog" +
    "hoihowhoyhoAhoCh" +
    "odjofjohjoxjozjo" +
    "BjoelogloyloAl")
#
# r(5075, "Space Ship", layout="0afaahaajaalaana" +
#    "apaaraataavaadba" +
#    "xbabcancazcaaeaf" +
#    "eaheajealeaneape" +
#    "areateaveaAeadfa" +
#    "xfangadhaxhaniad" +
#    "jaxjankadlaxlanm" +
#    "adnaxnanohgahiah" +
#    "kahmahoahqahsahu" +
#    "ahebhwbhcchychad" +
#    "hmdhodhAdhgehieh" +
#    "kehqehsehuehmfho" +
#    "fhdghxghnhhdihxi" +
#    "hnjhdkhxkhnlhdmh" +
#    "xmhnnohaojaolaon" +
#    "aopaoraotaofbovb" +
#    "odcoxcobdozdoheo" +
#    "jeoleoneopeoreot" +
#    "eqngodhoxhqniodj" +
#    "oxjqnkodloxlqnmv" +
#    "iavkavmavoavqavs" +
#    "avgbvubvecvwcvcd" +
#    "vydvievkevmevoev" +
#    "qevsevdivxivdkvx" +
#    "kCnaCjeCleCneCpe" +
#    "CreCdjCxj")
#
r(5076, "Square", layout="0daadcadeadgadia" +
    "dkadacdccdecdgcd" +
    "icdkcdaedcedeedg" +
    "ediedkedagdcgdeg" +
    "dggdigdkgdaidcid" +
    "eidgidiidkidakdc" +
    "kdekdgkdikdkk")
r(5077, "Squares", layout="0caabcaceabgacia" +
    "bkacmaboacqabsac" +
    "uaaacauccddafdah" +
    "dajdaldandapdcrd" +
    "aaeauebdfbrfaagb" +
    "ggcigckgcmgbogau" +
    "gcdhcrhaaibgicii" +
    "ckicmiboiauibdjb" +
    "rjaakaukcdlaflah" +
    "lajlallanlaplcrl" +
    "aamaumcaobcoceob" +
    "gociobkocmoboocq" +
    "obsocuohidikdhmd" +
    "hiliklhmlvjgvlgv" +
    "jivli")
r(5078, "Squaring", layout="0caaacaceaciaaka" +
    "cmacqaasacuacyaa" +
    "AacCaaacaecaicdk" +
    "camcaqcaucaycdAc" +
    "aCccaeaceceeciea" +
    "kecmecqeasecuecy" +
    "eaAecCecahachceh" +
    "cihakhcmhcqhashc" +
    "uhcyhaAhcChaajdc" +
    "jaejaijamjaqjdsj" +
    "aujayjaCjcalaclc" +
    "elcilaklcmlcqlas" +
    "lculcylaAlcCl")
r(5079, "Stairs", layout="0aoaaebaybeacdcc" +
    "agcaicakcbmccocb" +
    "qcascaucawcdAceC" +
    "caedayddaeaieaoe" +
    "auedCebefbyfaaga" +
    "igaogaugaCgbchce" +
    "hbghakhbmhbqhash" +
    "bwhcyhbAhaaiaiia" +
    "oiauiaCibejbyjda" +
    "kaikaokaukdCkael" +
    "ayleamdcmagmaima" +
    "kmbmmcombqmasmau" +
    "mawmdAmeCmaenayn" +
    "aoohechychofhahk" +
    "ohhChhojhemhym")
r(5080, "Star Ship", layout="0eoaaabdmbdqbaCb" +
    "accckccscaAcaadb" +
    "idbudaCdbceageco" +
    "eawebAeaafaefamf" +
    "aqfayfaCfecgagga" +
    "igbkgdogbsgaugaw" +
    "geAgaahaehamhaqh" +
    "ayhaChbciagicoia" +
    "wibAiaajbijbujaC" +
    "jackckkcskaAkaal" +
    "dmldqlaCleomhach" +
    "CchaehCehaghegim" +
    "giqghyghCghaihCi" +
    "hakhCkoadoCdoafo" +
    "CfoahoChoajoCjva" +
    "evCevagvCgvaivCi" +
    "CafCCfCahCCh")
#
r(5081, "Steps Pyramid", layout="0aaaacaaeaagaaia" +
    "akaamaaoaaqaaaca" +
    "ccaecagcaicakcam" +
    "caocaqcaaeaceaoe" +
    "aqeaagacgaogaqga" +
    "aiaciaoiaqiaakac" +
    "kaekagkaikakkamk" +
    "aokaqkaamacmaema" +
    "gmaimakmammaomaq" +
    "mhbbhdbhfbhhbhjb" +
    "hlbhnbhpbhbdhddh" +
    "fdhhdhjdhldhndhp" +
    "dhbfhdfhnfhpfhbh" +
    "hdhhnhhphhbjhdjh" +
    "fjhhjhjjhljhnjhp" +
    "jhblhdlhflhhlhjl" +
    "hllhnlhplpccoeco" +
    "gcoicokcomcpococ" +
    "epeepgepiepkepme" +
    "ooeocgpegpmgoogo" +
    "cipeipgipiipkipm" +
    "iooipckoekogkoik" +
    "okkomkpokCffChfC" +
    "jfClfCfhChhCjhCl" +
    "h")
r(5082, "Stonehenge", layout="0cdachackacoacra" +
    "cvacyacCacaccFca" +
    "jeaneareavecagcF" +
    "gddhdhhdlhdphdth" +
    "dxhdBhcajcFjajka" +
    "nkarkavkcancFncd" +
    "pchpckpcopcrpcvp" +
    "cypcCpveavgavlav" +
    "navsavuavzavBava" +
    "dvFdvafvFfvakvFk" +
    "vamvFmvepvgpvlpv" +
    "npvspvupvzpvBpCe" +
    "hCghCihCkhCmhCoh" +
    "CqhCshCuhCwhCyhC" +
    "Ah")
r(5083, "SunMoon", layout="0dgaciabkaamabya" +
    "debbrbbBbdccbvcc" +
    "addcecheckecnebD" +
    "ecafbtfbAfdcgdjg" +
    "dlgbxgcahchhcnhd" +
    "cidjidlibribDica" +
    "jbvjdckchkckkcnk" +
    "bAkcalbsldcmbxmd" +
    "enbBndgociobkoam" +
    "obuovaevagvaivak" +
    "Ckh")
r(5084, "Temple", layout="0baaacaaeaalaana" +
    "apaaraataaAaaCab" +
    "Eaaacaccalcbncbp" +
    "cbrcatcaCcaEcajd" +
    "avdaaeblebnebpeb" +
    "rebteaEeaffahfaj" +
    "favfaxfazfblgbng" +
    "bpgbrgbtgadhafha" +
    "hhajhavhaxhazhaB" +
    "hblibnibpibribti" +
    "afjahjajjavjaxja" +
    "zjaakblkbnkbpkbr" +
    "kbtkaEkajlavlaam" +
    "acmalmbnmbpmbrma" +
    "tmaCmaEmbaoacoae" +
    "oaloanoapoaroato" +
    "aAoaCobEohhghjgh" +
    "vghxghhihjihvihx" +
    "iooeoqeokgomgoog" +
    "oqgosgougokiomio" +
    "oioqiosiouiookoq" +
    "kvpgvpi")
#
# r(5085, "Teotihucan", layout="0aaaacaaeaagaaia" +
#    "akaamaaoaaqaasaa" +
#    "acascaaeaseaagcg" +
#    "gckgcogasgaaicgi" +
#    "ckicoiasiaakaska" +
#    "amasmaaoacoaeoag" +
#    "oaioakoamoaooaqo" +
#    "asoajqhbbhdbhfbh" +
#    "hbhjbhlbhnbhpbhr" +
#    "bhbdhrdhbfhrfhbh" +
#    "hrhhbjhrjhblhrlh" +
#    "bnhdnhfnhhnhjnhl" +
#    "nhnnhpnhrnhjpocc" +
#    "oecogcoicokcomco" +
#    "ocoqcoceoqeocgoq" +
#    "gocioqiockoqkocm" +
#    "oemogmoimokmommo" +
#    "omoqmojovddvfdvh" +
#    "dvjdvldvndvpdvdf" +
#    "vffvhfvjfvlfvnfv" +
#    "pfvdhwfhvhhwjhvl" +
#    "hwnhvphvdjvfjvhj" +
#    "vjjvljvnjvpjvdlv" +
#    "flvhlvjlvllvnlvp" +
#    "lvjn")
r(5086, "The Door", layout="0amaaoaaqaeicekc" +
    "emceoceqcesceuca" +
    "gediedueaweaegag" +
    "gdigdugawgaygaei" +
    "bgidiiduibwiayia" +
    "ckaekcgkdikakkas" +
    "kdukcwkaykaAkaam" +
    "acmbemcgmdimakma" +
    "smdumcwmbymaAmaC" +
    "maaobcobeocgodio" +
    "akoasoduocwobyob" +
    "AoaCo")
#
r(5087, "The Great Wall", layout="0aaaacaaeaagaaia" +
    "akaamaaoaaqaasaa" +
    "uaawaayaaAaaCaaE" +
    "aaacaccaecagcaic" +
    "akcamcaocaqcasca" +
    "ucawcaycaAcaCcaE" +
    "caaeaceaeeageaie" +
    "akeameaoeaqeasea" +
    "ueaweayeaAeaCeaE" +
    "eaagacgaegaggaig" +
    "akgamgaogaqgasga" +
    "ugawgaygaAgaCgaE" +
    "gaaiaciaeiagiaii" +
    "akiamiaoiaqiasia" +
    "uiawiayiaAiaCiaE" +
    "iaakackaekagkaik" +
    "akkamkaokaqkaska" +
    "ukawkaykaAkaCkaE" +
    "kaamacmaemagmaim" +
    "akmammaomaqmasma" +
    "umawmaymaAmaCmaE" +
    "maaoacoaeoagoaio" +
    "akoamoaooaqoasoa" +
    "uoawoayoaAoaCoaE" +
    "oaaqacqaeqagqaiq" +
    "akqamqaoqaqqasqa" +
    "uqawqayqaAqaCqaE" +
    "q")
r(5088, "Theater", layout="0baaccaceabgaaia" +
    "amaaqabsacuacwab" +
    "yacaccccbecagcak" +
    "cbmcaocascbuccwc" +
    "cyccaebceaeeaieb" +
    "kebmeboeaqeauebw" +
    "ecyebagacgaggaig" +
    "akgbmgaogaqgasga" +
    "wgbygcaibciaeiai" +
    "ibkibmiboiaqiaui" +
    "bwicyicakcckbeka" +
    "gkakkbmkaokaskbu" +
    "kcwkcykbamccmcem" +
    "bgmaimammaqmbsmc" +
    "umcwmbym")
r(5089, "Tile Fighter", layout="0bfaahaatabvadcc" +
    "becakcbmcbocaqcb" +
    "wcdycbaecceaiebk" +
    "ebmeboebqeasecye" +
    "bAebagbigckgamga" +
    "ogcqgbsgbAgcchae" +
    "haghauhawhcyhbai" +
    "biickiamiaoicqib" +
    "sibAibakcckaikbk" +
    "kbmkbokbqkaskcyk" +
    "bAkdcmbemakmbmmb" +
    "omaqmbwmcymbfoah" +
    "oatobvohnhonepaf" +
    "pAfpahpAhpajpAjo" +
    "nk")
r(5090, "Tilepiles", layout="0aaaacaaeaagaaia" +
    "aobaqbasbaubayba" +
    "AbaCbaEbahcajcal" +
    "cacdaedardatdaxd" +
    "azdaBdakeameaoea" +
    "ffahfaufawfayfan" +
    "gapgargaihakhaxh" +
    "azhaqiasiauiajja" +
    "ljanjaAjaCjatkav" +
    "kaxkaelaglailakl" +
    "aolaqlawmaymaAma" +
    "CmaEmabnadnafnah" +
    "najnhbahdahfahha" +
    "hpbhrbhtbhzbhBbh" +
    "Dbhichkchddhsdhy" +
    "dhAdhlehnehgfhvf" +
    "hxfhoghqghjhhyhh" +
    "rihtihkjhmjhBjhu" +
    "khwkhflhhlhjlhpl" +
    "hxmhzmhBmhDmhcnh" +
    "enhgnhinocaoeaog" +
    "aoqbosboAboCbojc" +
    "ozdomeowfopgosio" +
    "ljovkogloiloymoA" +
    "moCmodnofnohnvda" +
    "vfavrbvBbvhlvzmv" +
    "BmvenvgnCeaCAmCf" +
    "n")
r(5091, "Time Tunnel", layout="0aaabcaceaegaeia" +
    "ekaemacoabqaasaa" +
    "acccceeceoccqcas" +
    "caaecceeeeeoecqe" +
    "aseaagccgeegeogc" +
    "qgasgaaiccieeieo" +
    "icqiasiaakbckcek" +
    "egkeikekkemkcokb" +
    "qkaskvcdvqdwcfwq" +
    "fvchvqh")
r(5092, "Tomb", layout="0eaabcabeabgabia" +
    "bkabmaboabqaesab" +
    "accccceccgccicck" +
    "ccmccoccqcbscaae" +
    "dcebeeageaieakea" +
    "meboedqeasebagcc" +
    "gcegeggaigakgemg" +
    "cogcqgbsgdaibcib" +
    "eidgiaiiakidmibo" +
    "ibqidsibgkaikakk" +
    "bmkaimakmhjevfcv" +
    "hcvjcvlcvncCgcCi" +
    "cCkcCmc")
#
# r(5093, "Tower and Walls", layout="0ekadmaeoadqaesa" +
#    "dkccmccoccqcdscd" +
#    "aeecedeeegedieek" +
#    "ecmedoecqeesedue" +
#    "ewedyeeAedCedkgc" +
#    "mgcogcqgdsgekidm" +
#    "ieoidqiesi")
r(5094, "Traditional Reviewed", layout="0acaaeaaiaakaama" +
    "aoaaqaasaawaayaa" +
    "gcaicbkccmccocbq" +
    "cascaucaeeagebie" +
    "bkecmecoebqebsea" +
    "ueaweacgaegbggci" +
    "gckgcmgcogcqgcsg" +
    "bugawgaygaahaAha" +
    "ciaeibgiciickicm" +
    "icoicqicsibuiawi" +
    "ayiaekagkbikbkkc" +
    "mkcokbqkbskaukaw" +
    "kagmaimbkmcmmcom" +
    "bqmasmaumacoaeoa" +
    "ioakoamoaooaqoas" +
    "oawoayovnfvlhwnh" +
    "vphvnj")
r(5095, "Tree of Life", layout="0ababdacfadhacja" +
    "blaanaapabractad" +
    "vacxabzaaBaaccaA" +
    "caadbfdajdaldand" +
    "apdardatdbxdaCda" +
    "ceaAeaafaefagfai" +
    "fbkfbsfaufawfayf" +
    "aCfacgamgaqgaAga" +
    "ehaihauhayhalibo" +
    "iariagjawjblkaok" +
    "brkaambcmcembgma" +
    "imclmaomcrmaumbw" +
    "mcymbAmaCmacoago" +
    "cloaoocroawoaAoa" +
    "iqakqamqcoqaqqas" +
    "qauqhoaicdimdiqd" +
    "iAdhdfiffhhfixfh" +
    "zfilqirq")
#
r(5096, "Twin Temples", layout="0aaaacaaeaagaaia" +
    "akaaqaasaauaawaa" +
    "yaaAaaacakcaqcaA" +
    "camdaodaaeakeaqe" +
    "aAeagfaifamfaofa" +
    "sfaufaagakgaqgaA" +
    "gamhaohaaiakiaqi" +
    "aAiaakackaekagka" +
    "ikakkaqkaskaukaw" +
    "kaykaAkhbbhdbhfb" +
    "hhbhjbhrbhtbhvbh" +
    "xbhzbhbdhjdhldhp" +
    "dhrdhzdhbfhffhvf" +
    "hzfhbhhjhhlhhphh" +
    "rhhzhhbjhdjhfjhh" +
    "jhjjhrjhtjhvjhxj" +
    "hzjoccoecogcoico" +
    "scoucowcoycokdoq" +
    "doceoieoseoyeocg" +
    "oigosgoygokhoqho" +
    "cioeiogioiiosiou" +
    "iowioyivddvfdvhd" +
    "vjdvrdvtdvvdvxdv" +
    "dfvhfvjfvrfvtfvx" +
    "fvdhvfhvhhvjhvrh" +
    "vthvvhvxhCeeCgeC" +
    "ueCweCegCggCugCw" +
    "g")
r(5097, "Vi", layout="0aaaaEaaacaccaCc" +
    "aEcbaeaceaeeaAea" +
    "CebEecagbcgaegag" +
    "gaygaAgbCgcEgcai" +
    "bcibeiagiaiiawia" +
    "yibAibCicEicakcc" +
    "kbekbgkaikakkauk" +
    "awkbykbAkcCkcEkd" +
    "amccmcembgmbimak" +
    "mammasmaumbwmbym" +
    "cAmcCmdEmeaodcoc" +
    "eocgobiobkoamoao" +
    "oaqoasobuobwocyo" +
    "cAodCoeEo")
r(5098, "Victory Arrow", layout="0ataaabbcbbebbgb" +
    "bibbkbambavbaxca" +
    "adamdbvdazdadebf" +
    "ebheajeaBeaafamf" +
    "aofbvfbxfbzfaDfa" +
    "dgajgaqgaahagham" +
    "haohbshbuhbwhbyh" +
    "bAhbChbEhadiajia" +
    "qiaajamjaojbvjbx" +
    "jbzjaDjadkbfkbhk" +
    "ajkaBkaalamlbvla" +
    "zlaxmaanbcnbenbg" +
    "nbinbknamnavnato" +
    "hachmchaehmehdfh" +
    "jfhaghmghoghdhhj" +
    "hhqhhaihmihoihdj" +
    "hjjhakhmkhamhmmo" +
    "dbofbohbojboadom" +
    "doafomfoahonhoph" +
    "orhothovhoxhozho" +
    "Bhoajomjoalomlod" +
    "nofnohnojn")
r(5099, "Wavelets", layout="0agaaqaaAaagcaqc" +
    "aAccaeaeeaieaoea" +
    "seayeaCecGeaggaq" +
    "gaAgcaiaeiaiiaoi" +
    "asiayiaCicGiagka" +
    "qkaAkcamaemaimao" +
    "masmaymaCmcGmago" +
    "aqoaAoagqaqqaAqh" +
    "gbhqbhAbhdehjehn" +
    "ehtehxehDehghhqh" +
    "hAhhdihjihnihtih" +
    "xihDihgjhqjhAjhd" +
    "mhjmhnmhtmhxmhDm" +
    "hgphqphApogcoqco" +
    "Acoceokeomeoueow" +
    "eoEeoggoqgoAgoci" +
    "okiomiouiowioEio" +
    "gkoqkoAkocmokmom" +
    "moumowmoEmogooqo" +
    "oAovgdvqdvAdvbev" +
    "levvevFevgfvqfvA" +
    "fvghvqhvAhvbivli" +
    "vvivFivgjvqjvAjv" +
    "glvqlvAlvbmvlmvv" +
    "mvFmvgnvqnvAn")
r(5100, "Well", layout="0aiaakaamaaoaagc" +
    "aicakcamcaocaqca" +
    "cebeeegeeieekeem" +
    "eeoeeqebseaueaaf" +
    "awfacgbegeggaiga" +
    "kgamgaogeqgbsgau" +
    "gaahawhacibeiegi" +
    "aiiakiamiaoieqib" +
    "siauiaajawjackbe" +
    "kegkeikekkemkeok" +
    "eqkbskaukbimakma" +
    "mmbomaioakoamoao" +
    "ohcfhufhchhuhhcj" +
    "huj")
# r(5101, "What a Pyramid", layout="0aaaacaaeaagaaia" +
#    "akaamaaoaaqaasaa" +
#    "uaawaaacaccbecbg" +
#    "cbicbkcbmcbocbqc" +
#    "bscaucawcaceaeeb" +
#    "geciedkedmecoebq" +
#    "easeaueaegbggdig" +
#    "bkgbmgdogbqgasga" +
#    "eibgidiibkibmido" +
#    "ibqiasiackaekbgk" +
#    "cikdkkdmkcokbqka" +
#    "skaukaamacmbembg" +
#    "mbimbkmbmmbombqm" +
#    "bsmaumawmaaoacoa" +
#    "eoagoaioakoamoao" +
#    "oaqoasoauoawo")
r(5102, "Yummy", layout="0aoaaibakbbmbbqb" +
    "asbaubaocagdbidb" +
    "kdbmdbqdbsdbudaw" +
    "daoeaefbgfcifckf" +
    "dmfdqfcsfcufbwfa" +
    "yfaogaahachbehcg" +
    "hbihakhashbuhcwh" +
    "byhaAhaChaoiaejb" +
    "gjcijckjdmjdqjcs" +
    "jcujbwjayjaokagl" +
    "bilbklbmlbqlbslb" +
    "ulawlaomainaknbm" +
    "nbqnasnaunaooiob" +
    "iodkofkohkojioli" +
    "on")
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.games.mahjongg.mahjongg import r

# test
# r(5991, "AAA 1", ncards=4, layout="0daa")
# r(5992, "AAA 2", ncards=8, layout="0daadca")
# r(5993, "AAA 3", ncards=20, layout="0daaCabdacKbbdca" +
#    "Ccbdcc")
# r(5994, "AAA 4", ncards=20, layout="0daaDabdacdcaDcb" +
#    "dcc")

# ************************************************************************
# * game definitions
# ************************************************************************

r(5401, "Taipei", layout="0aagabbabdabjabl" +
    "hccacfachhckadba" +
    "ddhdehdghdiadjad" +
    "lhecaefoegaehhek" +
    "afcifehfgvfgifia" +
    "fkagahgcageaggog" +
    "gagihgkagmhhaahc" +
    "ohehhfvhfhhhvhho" +
    "hiahkhhmaiahidai" +
    "eaigoigCigaiihij" +
    "aimhjbajcojehjfv" +
    "jfJjghjhvjhojiaj" +
    "khjlakahkdakeakg" +
    "okgCkgQkgakihkja" +
    "kmhlbalcolehlfvl" +
    "fJlghlhvlholialk" +
    "hllamahmdameamgo" +
    "mgCmgamihmjammhn" +
    "aanconehnfvnfhnh" +
    "vnhoniankhnmaoah" +
    "ocaoeaogoogaoiho" +
    "kaomapcipehpgvpg" +
    "ipiapkhqcaqfoqga" +
    "qhhqkarbardhrehr" +
    "ghriarjarlhscasf" +
    "ashhskatbatdatja" +
    "tlaug")
r(5402, "Hare", layout="0aacaamacabccace" +
    "ackbcmacobeacecb" +
    "eebekcembeoofavf" +
    "cofeofkvfmofobga" +
    "cgcbgebgkcgmbgoa" +
    "iabicbiebikbimai" +
    "oakcakebkhakkakm" +
    "amebmgbmiamkbogo" +
    "ohboicqfcqhcqjas" +
    "ejsfasgjshasijsj" +
    "askCtgCtibuddufd" +
    "uhdujbulovdCvgCv" +
    "iovlbwddwfdwhdwj" +
    "bwlcyfcyhcyjbAhb" +
    "Ch")
r(5403, "Horse", layout="0bafbahbajbcdbch" +
    "bclaedbefbehbeja" +
    "elagfaghagjaifhi" +
    "gaihhiiaijakfhkg" +
    "akhhkiakjbmecmgc" +
    "mibmkcodcofcohco" +
    "jcolcqdcqfvqgcqh" +
    "vqicqjcqlbsbcsfv" +
    "sgcshvsicsjbsnot" +
    "botnbubcudcufvug" +
    "cuhvuicujculbunb" +
    "wbcwdcwfcwhcwjcw" +
    "lbwnbycayfbyhayj" +
    "bymaAbaAnaCaaCo")
r(5404, "Rat", layout="0aaabacoadbaeaag" +
    "bcacccccebcgvddo" +
    "dgbeacecceebegag" +
    "abgcbggagmbicbie" +
    "aigaimckeckgckia" +
    "kmblcblkcmevmfcm" +
    "gvmhcmibmmamobnc" +
    "Cngbnkhnocoevofc" +
    "ogvohcoibomaoobp" +
    "cbpkcqecqgcqiaqm" +
    "bscbseasgasmauab" +
    "ucbugaumbwacwccw" +
    "ebwgvxdoxgbyacyc" +
    "cyebygaAabAcoAdb" +
    "AeaAg")
r(5405, "Tiger", layout="0baabacbambaobca" +
    "bccbcmbcobebaegh" +
    "ehaeibenbgbbggbg" +
    "ibgnaibbidcifcih" +
    "dijbilainakdhkea" +
    "kfokfhkgakhpkhhk" +
    "iakjokjhkkaklbme" +
    "pmfbmgomhbmiomjb" +
    "mkboeoofbogoohbo" +
    "ipojbokbqeoqfbqg" +
    "pqhbqioqjbqkbsdd" +
    "sfcshcsjbslbubbu" +
    "dbuhbulbunbwbbwi" +
    "bwnbybbygbynbAbb" +
    "AibAnbCbbCgbCn")
r(5406, "Ram", layout="0aacaaeaagaaihbe" +
    "hbghbibccaceocea" +
    "cgaciociackadaod" +
    "chdehdihdkheabec" +
    "aeepeeaeioeiaeka" +
    "faofchfehfihfkhg" +
    "abgcageogeaggagi" +
    "ogiagkahahhehhgh" +
    "hibicaieaigaiibk" +
    "cblgbmcbmeamione" +
    "hniankanmcocboev" +
    "oebogaoiooihokho" +
    "mbooopehpiapkapm" +
    "bqcbqeaqibrgbscb" +
    "ucaueaugauiavahv" +
    "ehvghvihwabwcawe" +
    "oweawgawiowiawka" +
    "xaoxchxehxihxkhy" +
    "abycayepyeayioyi" +
    "aykazaozchzehzih" +
    "zkbAcaAeoAeaAgaA" +
    "ioAiaAkhBehBghBi" +
    "aCcaCeaCgaCi")
r(5407, "Wedges", layout="0aagbaicakdamaca" +
    "acibckccmbeaaeca" +
    "ekbemcgabgcageag" +
    "mdiacicbieaigeka" +
    "dkcckebkgakiakoh" +
    "lofmaemcdmecmgbm" +
    "iamkammamoomohno" +
    "eoaeocdoecogaoia" +
    "oodqadqccqeaqgcs" +
    "acscaseasmbuaauc" +
    "aukbumawaawibwkc" +
    "wmaygbyicykdym")
r(5408, "Monkey", layout="0aaahabaacoachad" +
    "aaeaakbcaaceackh" +
    "clacmocmhcnacood" +
    "abeabeoofoagahgb" +
    "agcaghbgobicbigb" +
    "iiaimhinaioojgbk" +
    "cdkebkgvkgdkibkk" +
    "bkmolgdmebmgvmgd" +
    "miongdoebogvogdo" +
    "iaokholaomaooopg" +
    "hpobqcdqebqgvqgd" +
    "qiaqooqoorghroas" +
    "ahsbascbsgasmaso" +
    "auaaughuhauiawih" +
    "wjawkowkhwlawmby" +
    "maAchAdaAeoAehAf" +
    "vAfaAgoAgCAghAhv" +
    "AhaAioAiCAihAjvA" +
    "jaAkoAkhAlaAmaCa" +
    "hCbaCc")
r(5409, "Rooster", layout="0aaaaagabchcccce" +
    "ccgadcvdfadiceec" +
    "egaeohfoageagoog" +
    "ohhoaiehifaigaim" +
    "aiohjmbkeokfbkgo" +
    "khbkiakkakmamccm" +
    "evmfcmgvmhcmiamk" +
    "anahncCnghoaaoco" +
    "occoevofcogvohco" +
    "iapaopahpchqaaqc" +
    "oqcbqeoqfbqgvqgo" +
    "qhbqiaqkaqmaraor" +
    "ahrchrmhsaascbsg" +
    "oshbsiaskasmasoa" +
    "taotahtohuaaufhu" +
    "gauhauoavabweowf" +
    "bwgowhbwivxgayab" +
    "ycoydbyeoyfbygoy" +
    "hbyihzaaAaaAeaAj" +
    "hAkaAlhBaaCaaCeh" +
    "CfaCgaCl")
r(5410, "Dog", layout="0aaeaaghbehbgacc" +
    "aceoceacgocgacia" +
    "ckhdchdehdghdihd" +
    "kaecoecaeeaegaei" +
    "aekhfcagcaichida" +
    "ieoiehifaigvjebk" +
    "ackcckeckgbkibkk" +
    "vlcoliolkbmacmcc" +
    "mgbmibmkamoonavn" +
    "conkboacoccoecog" +
    "bokaomaooopavpco" +
    "pkbqacqccqgbqibq" +
    "kvrcoriorkbsacsc" +
    "csecsgbsibskvtea" +
    "uchudaueouehufau" +
    "gawchxcaycoycaye" +
    "aygayiaykhzchzeh" +
    "zghzihzkaAcaAeoA" +
    "eaAgoAgaAiaAkhBe" +
    "hBgaCeaCg")
r(5411, "Snake", layout="0bagbaiobhbcgbci" +
    "bdebecbegbfebgcb" +
    "habicbiicikcimbj" +
    "avjlbkcbkebkgbki" +
    "ckkckmakooleolgo" +
    "livllhlobmcbmebm" +
    "gbmicmkcmmamoomo" +
    "vnlhnocokcomaooo" +
    "oovplhpobqcbqebq" +
    "gbqicqkcqmaqoore" +
    "orgorivrlbscbseb" +
    "sgbsicskcsmbtabu" +
    "cbvabwcbwebwgbwi" +
    "bwkbycbyebygbyib" +
    "ykbAjaCj")
r(5412, "Boar", layout="0aacaaehafaagoag" +
    "hahaaiaakhbchbka" +
    "ccoccaciackockac" +
    "mhdchdkhdmaecaee" +
    "aekoekaemoemhfkh" +
    "fmagiagkogkagmhh" +
    "kaiiaikakcbkgbki" +
    "akmolgolibmcbmeb" +
    "mgbmibmkbmmoncon" +
    "epngpnionkonmano" +
    "aoabocvocboevoeb" +
    "ogboibokvokbomvo" +
    "mhooopcopeppgppi" +
    "opkopmapobqcbqeb" +
    "qgbqibqkbqmorgor" +
    "iascbsgbsiasmaui" +
    "aukhvkawiawkowka" +
    "wmhxkhxmaycayeay" +
    "koykaymoymhzchzk" +
    "hzmaAcoAcaAiaAko" +
    "AkaAmhBchBkaCcaC" +
    "ehCfaCgoCghChaCi" +
    "aCk")
r(5413, "Ox", layout="0aahabeabkbcgoch" +
    "bciaeaaecbegbeia" +
    "emaeohfbhfnagaag" +
    "cagebggbgiagkagm" +
    "agoaicbiebigbiib" +
    "ikaimakcbkeckgck" +
    "ibkkakmbmecmgcmi" +
    "bmkaodioeaofjoga" +
    "ohjoiaojiokaolcq" +
    "edqgdqicqkcsedsg" +
    "dsicskaucbuecugc" +
    "uibukaumawcbwecw" +
    "gcwibwkawmayaayc" +
    "ayebygbyiaykayma" +
    "yohzbhznaAaaAcaA" +
    "haAmaAo")
r(5414, "Bridge 2", layout="0daadacdaedagdai" +
    "dakdamdaocccccec" +
    "cgccicckccmbeebe" +
    "gbeibekaggagiaih" +
    "hjhakhokhhlhvlha" +
    "mfamhomhCmhhnhvn" +
    "hJnhanjaofaohooh" +
    "Cohhphvphaqhoqhh" +
    "rhashaugauibwebw" +
    "gbwibwkcyccyecyg" +
    "cyicykcymdAadAcd" +
    "AedAgdAidAkdAmdA" +
    "o")

# r(5501, "Big X", layout="0aacaamhbchbmacb" +
#    "occacdaclocmacnh" +
#    "dbhddhdlhdnaeaae" +
#    "coedaeeaekoelaem" +
#    "aeohfchfehfkhfma" +
#    "gbagdogeagfagjog" +
#    "kaglagnhhdhhfhhj" +
#    "hhlaicaieoifaiga" +
#    "iioijaikaimhjehj" +
#    "ghjihjkakdakfokg" +
#    "akhokiakjaklhlfh" +
#    "lhhljameamgomgam" +
#    "iomiamkhnfhnhhnj" +
#    "aofoofaohoohaojo" +
#    "ojhpfhphhpjaqeaq" +
#    "goqgaqioqiaqkhrf" +
#    "hrhhrjasdasfosga" +
#    "shosiasjaslhteht" +
#    "ghtihtkaucaueouf" +
#    "augauioujaukaumh" +
#    "vdhvfhvjhvlawbaw" +
#    "doweawfawjowkawl" +
#    "awnhxchxehxkhxma" +
#    "yaaycoydayeaykoy" +
#    "laymayohzbhzdhzl" +
#    "hznaAboAcaAdaAlo" +
#    "AmaAnhBchBmaCcaC" +
#    "m")
# r(5502, "Axis", layout="0bafcahbajbbdvbh" +
#    "bblcchCchbdcvdhb" +
#    "dmcehCehbfbvfhbf" +
#    "ncghahaahohiahio" +
#    "ajabjhajohkabkfb" +
#    "kjhkoalabldbllal" +
#    "ohmacmhhmoanaanc" +
#    "vnhanmanoiobcohi" +
#    "onapbwphapniqbcq" +
#    "hiqnaraarcvrharm" +
#    "arohsacshhsoatab" +
#    "tdbtlatohuabufbu" +
#    "jhuoavabvhavohwa" +
#    "hwoaxaaxocyhbzbv" +
#    "zhbzncAhCAhbBcvB" +
#    "hbBmcChCChbDdvDh" +
#    "bDlbEfcEhbEj")
# r(5503, "Cobweb", layout="0aacaafhagaahoah" +
#    "haiaajaamacbhcca" +
#    "cdaclhcmacnadfhd" +
#    "gadhodhhdiadjaea" +
#    "aeohfaafcafeafha" +
#    "fkafmhfoagaogaag" +
#    "oogohhaahcahhahm" +
#    "hhoaiaoiaaiooioh" +
#    "jaajdajhajlhjoak" +
#    "aakoalealhalkama" +
#    "amoancanfhnganhh" +
#    "nianjanmaoahoboo" +
#    "gooihonaooopbapc" +
#    "bpgvpgbpivpiapmo" +
#    "pnaqahqboqgoqihq" +
#    "naqoarcarfhrgarh" +
#    "hriarjarmasaasoa" +
#    "teathatkauaauohv" +
#    "aavdavhavlhvoawa" +
#    "owaawoowohxaaxca" +
#    "xhaxmhxoayaoyaay" +
#    "ooyohzaazcazeazh" +
#    "azkazmhzoaAaaAoa" +
#    "BfhBgaBhoBhhBiaB" +
#    "jaCbhCcaCdaClhCm" +
#    "aCnaEcaEfhEgaEho" +
#    "EhhEiaEjaEm")
# r(5504, "Pyramids", layout="0aaaaacaakaamhbb" +
#    "abeabgabihblacaa" +
#    "ccackacmhdbadead" +
#    "gadihdlaeaaecaek" +
#    "aemaffhfgafhahba" +
#    "heahiahlhibhiehi" +
#    "ihilajbojbajdoje" +
#    "ajfajhojiajjajlo" +
#    "jlhkbvkbhkevkehk" +
#    "ghkivkihklvklalb" +
#    "olbClbaldoleClea" +
#    "lfolgalholiClial" +
#    "jallollCllhmbvmb" +
#    "hmevmehmgvmghmiv" +
#    "mihmlvmlanbonbCn" +
#    "bandoneCneanfong" +
#    "anhoniCnianjanlo" +
#    "nlCnlhobvobhoevo" +
#    "ehoghoivoiholvol" +
#    "apbopbapdopeapfa" +
#    "phopiapjaploplhq" +
#    "bhqehqihqlarbare" +
#    "ariarlatfhtgatha" +
#    "uaaucaukaumhvbav" +
#    "eavgavihvlawaawc" +
#    "awkawmhxbaxeaxga" +
#    "xihxlayaaycaykay" +
#    "m")
# r(5505, "Wicker", layout="0bafbakbbcbbhbbm" +
#    "bcebcjbdbbdgbdlb" +
#    "edbeibenbfabffbf" +
#    "kbgcbghbgmbhebhj" +
#    "bibbigbilbjdbjib" +
#    "jnbkabkfbkkblcbl" +
#    "hblmbmebmjbnbbng" +
#    "bnlbodboibonbpab" +
#    "pfbpkbqcbqhbqmbr" +
#    "ebrjbsbbsgbslbtd" +
#    "btibtnbuabufbukb" +
#    "vcbvhbvmbwebwjbx" +
#    "bbxgbxlbydbyibyn" +
#    "bzfbzkbAh")

r(5801, "Faro", name="Double Mahjongg Faro", ncards=288, layout="0aaaha" +
    "baachadaae" +
    "oaehafaagiahaaih" +
    "ajaakoakhalaamha" +
    "naaoobcvbhobmacb" +
    "hccvccacdacgichC" +
    "chaciaclhcmvcmac" +
    "nodcCdcvdhodmCdm" +
    "aebhecvecaedheea" +
    "efcehCehaejhekae" +
    "lhemvemaenofcvfh" +
    "ofmbgcagfhggagho" +
    "ghhgiagjbgmahaah" +
    "ohiahioajapjaajc" +
    "cjebjhcjkajmajop" +
    "johkahkcokhhkmhk" +
    "oalaalcqlcalfhlg" +
    "alhvlhhlialjalmq" +
    "lmalohmcomhCmhhm" +
    "manbqncandhneanf" +
    "bnhvnhanjhnkanlq" +
    "nmannhocooeoohoo" +
    "khomapcppcCpdbpe" +
    "vpebphwphbpkvpkC" +
    "plapmppmhqcoqeoq" +
    "hoqkhqmarbqrcard" +
    "hrearfbrhvrharjh" +
    "rkarlqrmarnhscos" +
    "hCshhsmataatcqtc" +
    "atfhtgathvthhtia" +
    "tjatmqtmatohuahu" +
    "couhhumhuoavapva" +
    "avccvebvhcvkavma" +
    "vopvohwahwoaxaax" +
    "obycayfhygayhoyh" +
    "hyiayjbymozcvzho" +
    "zmaAbhAcvAcaAdhA" +
    "eaAfcAhCAhaAjhAk" +
    "aAlhAmvAmaAnoBcC" +
    "BcvBhoBmCBmaCbhC" +
    "cvCcaCdaCgiChCCh" +
    "aCiaClhCmvCmaCno" +
    "DcvDhoDmaEahEbaE" +
    "chEdaEeoEehEfaEg" +
    "iEhaEihEjaEkoEkh" +
    "ElaEmhEnaEo")
# r(5802, "Big Square", name="Double Mahjongg Big Square", ncards=288,
# layout="0daadacdaedagdai" +
#    "dakdcadccdcedcgd" +
#    "cidckdeadecdeede" +
#    "gdeidekdgadgcdge" +
#    "dggdgidgkdiadicd" +
#    "iedigdiidikdkadk" +
#    "cdkedkgdkidkkdma" +
#    "dmcdmedmgdmidmkd" +
#    "oadocdoedogdoido" +
#    "kdqadqcdqedqgdqi" +
#    "dqkdsadscdsedsgd" +
#    "sidskduaducduedu" +
#    "gduidukdwadwcdwe" +
#    "dwgdwidwk")
r(5803, "Two Squares", name="Double Mahjongg Two Squares", ncards=288,
        layout="0daadacdaedagdai" +
    "dakdcadccdcedcgd" +
    "cidckdeadecdeede" +
    "gdeidekdgadgcdge" +
    "dggdgidgkdiadicd" +
    "iedigdiidikdkadk" +
    "cdkedkgdkidkkdoa" +
    "docdoedogdoidokd" +
    "qadqcdqedqgdqidq" +
    "kdsadscdsedsgdsi" +
    "dskduaducduedugd" +
    "uidukdwadwcdwedw" +
    "gdwidwkdyadycdye" +
    "dygdyidyk")
# r(5804, "Rows", name="Double Mahjongg Rows", ncards=288,
# layout="0daadacCaddaeCaf" +
#    "dagCahdaidakdcad" +
#    "ckeeadeceeeeegde" +
#    "ieekegaegkeiadic" +
#    "eieeigdiieikekae" +
#    "kkemadmcemeemgdm" +
#    "iemkeoaeokeqadqc" +
#    "eqeeqgdqieqkesae" +
#    "skeuaduceueeugdu" +
#    "ieukewaewkeyadyc" +
#    "eyeeygdyieykdAad" +
#    "AkdCadCcCCddCeCC" +
#    "fdCgCChdCidCk")
r(5805, "Twin Picks", name="Double Mahjongg Twin Picks", ncards=288,
        layout="0aacaaeaagaaiaak" +
    "aamhbdhbfhbhhbjh" +
    "blacaaccaceoceac" +
    "gocgaciociackock" +
    "acmacohdbhddhdfv" +
    "dfhdhvdhhdjvdjhd" +
    "lhdnaeaaecoecaee" +
    "oeeaegoegCegaeio" +
    "eiCeiaekoekaemoe" +
    "maeohfbhfdvfdhff" +
    "vffhfhvfhhfjvfjh" +
    "flvflhfnagaagcog" +
    "cageogeCgeaggogg" +
    "CggagiogiCgiagko" +
    "gkCgkagmogmagohh" +
    "bhhdvhdhhfvhfhhh" +
    "vhhhhjvhjhhlvhlh" +
    "hnaiaaicoicaieoi" +
    "eaigoigCigaiioii" +
    "Ciiaikoikaimoima" +
    "iohjbhjdhjfvjfhj" +
    "hvjhhjjvjjhjlhjn" +
    "akaakcakeokeakgo" +
    "kgakiokiakkokkak" +
    "makohldhlfhlhhlj" +
    "hllamcameamgamia" +
    "mkammapaapcapeap" +
    "gapiapkapmapoasc" +
    "aseasgasiaskasmh" +
    "tdhtfhthhtjhtlau" +
    "aaucaueoueaugoug" +
    "auiouiaukoukauma" +
    "uohvbhvdhvfvvfhv" +
    "hvvhhvjvvjhvlhvn" +
    "awaawcowcaweowea" +
    "wgowgCwgawiowiCw" +
    "iawkowkawmowmawo" +
    "hxbhxdvxdhxfvxfh" +
    "xhvxhhxjvxjhxlvx" +
    "lhxnayaaycoycaye" +
    "oyeCyeaygoygCyga" +
    "yioyiCyiaykoykCy" +
    "kaymoymayohzbhzd" +
    "vzdhzfvzfhzhvzhh" +
    "zjvzjhzlvzlhznaA" +
    "aaAcoAcaAeoAeaAg" +
    "oAgCAgaAioAiCAia" +
    "AkoAkaAmoAmaAohB" +
    "bhBdhBfvBfhBhvBh" +
    "hBjvBjhBlhBnaCaa" +
    "CcaCeoCeaCgoCgaC" +
    "ioCiaCkoCkaCmaCo" +
    "hDdhDfhDhhDjhDla" +
    "EcaEeaEgaEiaEkaE" +
    "m")
r(5806, "Roost", name="Double Mahjongg Roost", ncards=288,
        layout="0aaahabaacoachad" +
    "vadaaeoaehafvafa" +
    "agoaghahvahaaioa" +
    "ihajaakaamaaoCbf" +
    "hblhbnacbhccacdo" +
    "cdhcevceacfocfhc" +
    "gvcgachochhciacj" +
    "aclocmacnhdkhdma" +
    "eiaekoelaemaeoaf" +
    "aafcafehfjhflvfl" +
    "hfnhgchgeaghagjo" +
    "gkaglCglogmagnah" +
    "bohcahdoheahfhhi" +
    "hhkvhlhhmhibhidv" +
    "iehifaiioijaikoi" +
    "laimajaajcojdaje" +
    "Cjeojfajghjjvjkh" +
    "jlajohkcvkdhkevk" +
    "fhkgakjokkaklalb" +
    "olcaldolealfClfo" +
    "lgalhhlkblnhmbhm" +
    "dvmehmfvmghmhamk" +
    "omnanaancondaneo" +
    "nfangCngonhanian" +
    "mhnnanohochoevof" +
    "hogvohhoiapbapdo" +
    "peapfopgaphCphop" +
    "iapjhpkaploplhpm" +
    "apnhqchqevqfhqgv" +
    "qhhqiaraarcordar" +
    "eorfargCrgorhari" +
    "armhrnarohsbhsdv" +
    "sehsfvsghshaskos" +
    "natbotcatdoteatf" +
    "Ctfotgathhtkbtnh" +
    "ucvudhuevufhugau" +
    "joukaulavaavcovd" +
    "aveCveovfavghvjv" +
    "vkhvlavohwbhwdvw" +
    "ehwfawiowjawkowl" +
    "awmaxboxcaxdoxea" +
    "xfhxihxkvxlhxmhy" +
    "chyeayhayjoykayl" +
    "Cyloymaynazaazca" +
    "zehzjhzlvzlhznaA" +
    "iaAkoAlaAmaAohBk" +
    "hBmaCbhCcaCdoCdh" +
    "CevCeaCfoCfhCgvC" +
    "gaChoChhCiaCjaCl" +
    "oCmaCnCDfhDlhDna" +
    "EahEbaEcoEchEdvE" +
    "daEeoEehEfvEfaEg" +
    "oEghEhvEhaEioEih" +
    "EjaEkaEmaEo")
r(5807, "Castle", name="Double Mahjongg Big Castle", ncards=288,
        layout="0eaadacdaeeageai" +
    "dakdameaodcadcoc" +
    "ddvdecdfvdgcdhCd" +
    "hvdicdjvdkcdldea" +
    "deoafdaflcgacgoa" +
    "hdahlciacioajdaj" +
    "lckahkdhklckoald" +
    "elfblheljallcmah" +
    "mdhmlcmoandbnfbn" +
    "janleoahodoofooj" +
    "holeooapdbpfvpfb" +
    "pjvpjapleqahqdoq" +
    "foqjhqleqoardbrf" +
    "brjarlcsahsdhslc" +
    "soatdetfbthetjat" +
    "lcuahudhulcuoavd" +
    "avlcwacwoaxdaxlc" +
    "yacyoazdazldAadA" +
    "ocBdvBecBfvBgcBh" +
    "CBhvBicBjvBkcBld" +
    "CadCoeEadEcdEeeE" +
    "geEidEkdEmeEo")
r(5808, "Eight Squares", name="Double Mahjongg Eight Squares", ncards=288,
        layout="0daadacdaedahdaj" +
    "daldcadccdcedchd" +
    "cjdcldeadecdeede" +
    "hdejdeldhadhcdhe" +
    "dhhdhjdhldjadjcd" +
    "jedjhdjjdjldladl" +
    "cdledlhdljdlldoa" +
    "docdoedohdojdold" +
    "qadqcdqedqhdqjdq" +
    "ldsadscdsedshdsj" +
    "dsldvadvcdvedvhd" +
    "vjdvldxadxcdxedx" +
    "hdxjdxldzadzcdze" +
    "dzhdzjdzl")
r(5809, "Big Flying Dragon", name="Double Mahjongg Big Flying Dragon",
        ncards=288, layout="0aajacaaciackacs" +
    "aeaaegaeihejaeka" +
    "emaesagaageaggbg" +
    "ibgkagmagoagsaia" +
    "aicaiebigbiibikb" +
    "imaioaiqaisakabk" +
    "cbkebkgbkibkkbkm" +
    "bkobkqaksbmabmcc" +
    "mecmgcmicmkcmmcm" +
    "obmqbmsboaboccoe" +
    "dogdoidokdomcoob" +
    "oqbosbqabqccqedq" +
    "geqieqkdqmcqobqq" +
    "bqsJrjbsabsccsed" +
    "sgesieskdsmcsobs" +
    "qbssbuabuccuedug" +
    "duidukdumcuobuqb" +
    "usbwabwccwecwgcw" +
    "icwkcwmcwobwqbws" +
    "ayabycbyebygbyib" +
    "ykbymbyobyqaysaA" +
    "aaAcaAebAgbAibAk" +
    "bAmaAoaAqaAsaCaa" +
    "CeaCgbCibCkaCmaC" +
    "oaCsaEaaEgaEihEj" +
    "aEkaEmaEsaGaaGia" +
    "GkaGsaIaaIjaIsaK" +
    "j")
r(5810, "Sphere", name="Double Mahjongg Sphere", ncards=288,
        layout="0aajaalaanabhhbk" +
    "hbmabpacfhciacjo" +
    "ckaclocmacnhcoac" +
    "raddhdgadhodivdk" +
    "hdlvdmodoadphdqa" +
    "dtaefoegveihejae" +
    "koekaemoemhenveo" +
    "oeqaerafchfdhffh" +
    "fhafiafohfphfrhf" +
    "tafuageogeaggpgg" +
    "pgihgjpgkbglpgmh" +
    "gnpgoagqpgqagsog" +
    "sahbhhchhfhhhahj" +
    "ahnhhphhrhhuahva" +
    "idoidvieaifoigai" +
    "hoiihijoikbiloim" +
    "hinoioaipoiqairv" +
    "isaitoitajahjbhj" +
    "dhjfhjhvjlhjphjr" +
    "hjthjvajwakcokcv" +
    "kdakeokeakgokgak" +
    "iokiakkokkakmokm" +
    "akookoakqokqakso" +
    "ksvktakuokualahl" +
    "bhldhlfvlfhlhvlh" +
    "hljvljhllvllhlnv" +
    "lnhlpvlphlrvlrhl" +
    "thlvalwamcomcvmd" +
    "ameomeamgomgamio" +
    "miamkomkammommam" +
    "oomoamqomqamsoms" +
    "vmtamuomuanahnbh" +
    "ndhnfhnhvnlhnphn" +
    "rhnthnvanwaodood" +
    "voeaofoogaohooih" +
    "ojookboloomhonoo" +
    "oaopooqaorvosaot" +
    "ootapbhpchpfhpha" +
    "pjapnhpphprhpuap" +
    "vaqeoqeaqgpqgpqi" +
    "hqjpqkbqlpqmhqnp" +
    "qoaqqpqqaqsoqsar" +
    "chrdhrfhrhariaro" +
    "hrphrrhrtaruasfo" +
    "sgvsihsjaskoskas" +
    "mosmhsnvsoosqasr" +
    "atdhtgathotivtkh" +
    "tlvtmotoatphtqat" +
    "taufhuiaujoukaul" +
    "oumaunhuoauravhh" +
    "vkhvmavpawjawlaw" +
    "n")

# ----------------------------------------------------------------------

r(5901, "Happy New Year", name="Half Mahjongg Happy New Year", ncards=72,
        layout="0aafaajaanaceaci" +
    "acmbedbehaelofdo" +
    "fhhflbgdbghagloh" +
    "dohhaibbidaighih" +
    "aiiailhimainojma" +
    "kaakeckhakjbkmbk" +
    "oolmambbmdamghmh" +
    "amiamlhmmamnondo" +
    "nhbodbohaolopdop" +
    "hhplbqdbqhaqlase" +
    "asiasmaufaujaun")
# r(5902, "K 2", name="Half Mahjongg K 2", ncards=72,
# layout="0aagabcabehbfobg" +
#    "hbhabiabkacgvcga" +
#    "dbidgadlaegvegbf" +
#    "aifgbfmaggbhaihg" +
#    "bhmaigbjahjgbjma" +
#    "kgokgblahlgblmam" +
#    "gbnaingbnmaogbpa" +
#    "ipgbpmaqgvqgarbi" +
#    "rgarlasgvsgatcat" +
#    "ehtfotghthatiatk" +
#    "aug")
# r(5903, "Abstract", name="Half Mahjongg Abstract", ncards=72,
# layout="0aaaaagabcabebdd" +
#    "adgadioedhehafch" +
#    "fdafeafhagahhaah" +
#    "dahgaiahjaojbbjc" +
#    "ajfakaalcamfamha" +
#    "nbhncandhngaogbo" +
#    "iapdhqdaqiarcord" +
#    "arehrihsdasgasia" +
#    "tdauaaufhvbavcav" +
#    "iawaawehxeaxiayc" +
#    "ayebyghzdaAdaAha" +
#    "BbaBfhCfaCiaDcaD" +
#    "eaDghDhaEaaEi")
r(5904, "Smile", name="Half Mahjongg Smile", ncards=72,
        layout="0bagoahbaibbebbk" +
    "bccbcmbebbenaffb" +
    "fjbgahgfbgoahfbh" +
    "kbiabiobjlbkabko" +
    "bllbmabmoanfbnkb" +
    "oahofbooapfbpjbq" +
    "bbqnbscbsmbtebtk" +
    "bugouhbui")
r(5905, "Wall", name="Half Mahjongg Wall", ncards=72,
        layout="0eaabacbaebagbai" +
    "bakbameaoacaacoa" +
    "eaaeoagaagoaiaai" +
    "oakaakoamaamoaoa" +
    "aooaqaaqoasaasoa" +
    "uaauoawaawoayaay" +
    "oaAaaAoaCaaCoeEa" +
    "bEcbEebEgbEibEkb" +
    "EmeEo")

# ----------------------------------------------------------------------

# r(5601, "Skomoroh 1", ncards=28, layout="0aacaaeaaghbdhbf" +
#    "acaacdoceacfacih" +
#    "ddhdfaebaeeoeeae" +
#    "hhfdhffagaagdoge" +
#    "agfagihhdhhfaica" +
#    "ieaig")
# r(5602, "Skomoroh 2", ncards=116, layout="0aaeaaghahaaiaak" +
#    "abaaboacfbchacja" +
#    "daadoaeghehaeiaf" +
#    "aafocghahaahcahf" +
#    "vhhahjahmahohidc" +
#    "ihhilajaajdajfwj" +
#    "hajjajlajohkdhkg" +
#    "akhokhhkihklalaa" +
#    "lcalewlhalkalmal" +
#    "ohmfamgimhamihmj" +
#    "anaancanewnhanka" +
#    "nmanohodhogaohoo" +
#    "hhoiholapaapdapf" +
#    "wphapjaplapohqdc" +
#    "qhhqlaraarcarfvr" +
#    "harjarmarocshata" +
#    "atoaughuhauiavaa" +
#    "voawfbwhawjaxaax" +
#    "oayeayghyhayiayk")
# r(5603, "Skomoroh 3", ncards=132, layout="0aachadaaeoaeXae" +
#    "hafyafaagoagXagh" +
#    "ahaaiabaabkhcahc" +
#    "kadaadeadgadkhea" +
#    "hefhekafaafeafga" +
#    "fkhgahgfhgkahaah" +
#    "eahgahkhiahifhik" +
#    "ajaajeajgajkhkah" +
#    "kfhkkalaalealgal" +
#    "khmahmfhmkanaane" +
#    "onfangankhofXofa" +
#    "pbapdapfspfaphap" +
#    "jhqfXqfaraareorf" +
#    "argarkhsahsfhska" +
#    "taateatgatkhuahu" +
#    "fhukavaaveavgavk" +
#    "hwahwfhwkaxaaxea" +
#    "xgaxkhyahyfhykaz" +
#    "aazeazgazkhAahAf" +
#    "hAkaBaaBeaBgaBkh" +
#    "CahCkaDaaDkaEchE" +
#    "daEeoEeXEehEfyEf" +
#    "aEgoEgXEghEhaEi")
# r(5604, "Skomoroh 4", ncards=52, layout="0aajaalaanabhabp" +
#    "acfacnacraddadla" +
#    "dtaejafcafuagiah" +
#    "bbhoahvaiiajaajw" +
#    "akjalaalwamkamma" +
#    "naanwaonapaapwaq" +
#    "oarbbriarvasoatc" +
#    "atuaunavdavlavta" +
#    "wfawjawraxhaxpay" +
#    "jaylayn")
# r(5605, "Skomoroh 5", ncards=208, layout="0aahaajaalaanaap" +
#    "hbihbkoblhbmhboa" +
#    "ccaceacgaciackac" +
#    "macoacqacsacuaec" +
#    "aeuagdagjaglagna" +
#    "gthhkhhmaieaijai" +
#    "loilainaishjkhjm" +
#    "akfakjakloklakna" +
#    "krhlkhlmameamgam" +
#    "jamlomlamnamqams" +
#    "anchndhnkhnmhnta" +
#    "nuaoeaohaojaoloo" +
#    "laonaopaosapchpd" +
#    "hpkhpmhptapuaqea" +
#    "qhaqjaqlaqnaqpaq" +
#    "saraarchrdhrtaru" +
#    "arwaseasgasiaska" +
#    "smasoasqassataht" +
#    "batchtdhtfithitj" +
#    "itlitnitphtrhtta" +
#    "tuhtvatwaueaugau" +
#    "iaukaumauoauqaus" +
#    "avaavchvdhvtavua" +
#    "vwaweawhawjawlaw" +
#    "nawpawsaxchxdhxk" +
#    "hxmhxtaxuayeayha" +
#    "yjayloylaynaypay" +
#    "sazchzdhzkhzmhzt" +
#    "azuaAeaAgaAjaAlo" +
#    "AlaAnaAqaAshBkhB" +
#    "maCfaCjaCloClaCn" +
#    "aCrhDkhDmaEeaEja" +
#    "EloElaEnaEshFkhF" +
#    "maGdaGjaGlaGnaGt" +
#    "aIcaIuaKcaKeaKga" +
#    "KiaKkaKmaKoaKqaK" +
#    "saKuhLihLkoLlhLm" +
#    "hLoaMhaMjaMlaMna" +
#    "Mp")
# r(5606, "Skomoroh 6", layout="0aadaafaahaajaal" +
#    "aanaapadaaddadfa" +
#    "dhadjadladnadpad" +
#    "sheehegheihekhem" +
#    "heoafaafdaffoffa" +
#    "fhofhafjofjaflof" +
#    "lafnofnafpafshge" +
#    "hggvgghgivgihgkv" +
#    "gkhgmvgmhgoahaCh" +
#    "hChjChlahsaidaif" +
#    "oifaihoihJiiaijo" +
#    "ijJikailoilainoi" +
#    "naipajahjehjgvjg" +
#    "CjhhjivjihjkvjkC" +
#    "jlhjmvjmhjoajsak" +
#    "dakfokfakhokhJki" +
#    "akjokjJkkaklokla" +
#    "knoknakpalaClhCl" +
#    "jCllalshmehmgvmg" +
#    "hmivmihmkvmkhmmv" +
#    "mmhmoanaandanfon" +
#    "fanhonhanjonjanl" +
#    "onlannonnanpansh" +
#    "oehoghoihokhomho" +
#    "oapaapdapfaphapj" +
#    "aplapnappapsasda" +
#    "sfashasjaslasnas" +
#    "p")
# r(5607, "Skomoroh 7", ncards=56, layout="0aabaadaafaahaaj" +
#    "aapaaraatablabwa" +
#    "daadmadwafaafnaf" +
#    "wahaahnahwajfajh" +
#    "ajmajwakdakjalbd" +
#    "llalvamnamtanaan" +
#    "kanpanrapaapjapw" +
#    "araarjarwataatka" +
#    "twavaavlawdawfaw" +
#    "hawnawpawrawtawv")
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

from pysollib.gamedb import GI, GameInfo, registerGame
from pysollib.games.mahjongg.mahjongg import AbstractMahjonggGame, \
        Mahjongg_RowStack, \
        comp_cardset
from pysollib.hint import AbstractHint
from pysollib.layout import Layout
from pysollib.mfxutil import kwdefault
from pysollib.mygettext import _
from pysollib.mygettext import ungettext
from pysollib.pysoltk import MfxCanvasLine, MfxCanvasText
from pysollib.settings import TOOLKIT
from pysollib.stack import \
        AbstractFoundationStack, \
        InitialDealTalonStack
from pysollib.util import ANY_SUIT

from six.moves import range


class Shisen_Hint(AbstractHint):
    TOP_MATCHING = False
    # FIXME: no intelligence whatsoever is implemented here

    def computeHints(self):
        game = self.game
        # get free stacks
        stacks = []
        for r in game.s.rows:
            if r.cards:
                stacks.append(r)
        # find matching tiles
        i = 0
        for r in stacks:
            for t in stacks[i+1:]:
                # if game.cardsMatch(r.cards[0], t.cards[0]):
                if r.acceptsCards(t, t.cards):
                    # simple scoring...
                    if self.TOP_MATCHING:
                        score = 2000 - r.rown - t.rown
                    else:
                        score = 1000 + r.rown + t.rown
                    self.addHint(score, 1, r, t)
            i += 1


class NotShisen_Hint(Shisen_Hint):
    TOP_MATCHING = True


# ************************************************************************
# * Shisen-Sho
# ************************************************************************


class Shisen_Foundation(AbstractFoundationStack):
    def __init__(self, x, y, game, suit=ANY_SUIT, **cap):
        kwdefault(cap, max_move=0, max_accept=0, max_cards=game.NCARDS)
        AbstractFoundationStack.__init__(self, x, y, game, suit, **cap)

    def acceptsCards(self, from_stack, cards):
        # We do not accept any cards - pairs will get
        # delivered by _dropPairMove() below.
        return 0

    def basicIsBlocked(self):
        return 1

    def initBindings(self):
        pass


class Shisen_RowStack(Mahjongg_RowStack):

    def basicIsBlocked(self):
        return 0

    def acceptsCards(self, from_stack, cards):
        if not self.game.cardsMatch(self.cards[0], cards[-1]):
            return 0

        cols, rows = self.game.L
        game_cols = self.game.cols
        x1, y1 = self.coln+1, self.rown+1
        x2, y2 = from_stack.coln+1, from_stack.rown+1
        dx, dy = x2 - x1, y2 - y1

        a = []
        for i in range(cols+2):
            a.append([5]*(rows+2))

        def can_move(x, y, nx, ny, direct, d, direct_chng_cnt):
            if nx == x2 and ny == y2:
                return 1
            if nx < 0 or ny < 0 or nx > cols+1 or ny > rows+1:
                return 0
            if nx in (0, cols+1) or ny in (0, rows+1) \
                    or not game_cols[nx-1][ny-1].cards:
                if direct_chng_cnt == 0:
                    return 1
                elif direct_chng_cnt == 1:
                    if direct != d:
                        if d == 1 and dy > 0:
                            return 1
                        elif d == 2 and dy < 0:
                            return 1
                        elif d == 3 and dx > 0:
                            return 1
                        elif d == 4 and dx < 0:
                            return 1
                    else:
                        return 1
                elif direct_chng_cnt == 2:
                    if direct != d:
                        if d in (1, 2) and x == x2:
                            return 1
                        elif y == y2:
                            return 1
                    else:
                        if d == 1 and y < y2:
                            return 1
                        elif d == 2 and y > y2:
                            return 1
                        elif d == 3 and x < x2:
                            return 1
                        elif d == 4 and x > x2:
                            return 1
                elif direct_chng_cnt == 3:
                    if direct == d:
                        return 1

            return 0

        res_path = [None]

        def do_accepts(x, y, direct, direct_chng_cnt, path):
            # if direct_chng_cnt > 3:
            #    return
            if a[x][y] < direct_chng_cnt:
                return
            # if res_path[0]:
            #    return
            a[x][y] = direct_chng_cnt
            if x == x2 and y == y2:
                res_path[0] = path
                return

            if can_move(x, y, x, y+1, direct, 1, direct_chng_cnt):  # 1
                # dcc = direct == 1 and direct_chng_cnt or direct_chng_cnt+1
                p = path[:]
                if direct == 1:
                    dcc = direct_chng_cnt
                else:
                    dcc = direct_chng_cnt+1
                    p.append((x, y))
                do_accepts(x, y+1, 1, dcc, p)
            if can_move(x, y, x, y-1, direct, 2, direct_chng_cnt):  # 2
                # dcc = direct == 2 and direct_chng_cnt or direct_chng_cnt+1
                p = path[:]
                if direct == 2:
                    dcc = direct_chng_cnt
                else:
                    dcc = direct_chng_cnt+1
                    p.append((x, y))
                do_accepts(x, y-1, 2, dcc, p)
            if can_move(x, y, x+1, y, direct, 3, direct_chng_cnt):  # 3
                # dcc = direct == 3 and direct_chng_cnt or direct_chng_cnt+1
                p = path[:]
                if direct == 3:
                    dcc = direct_chng_cnt
                else:
                    dcc = direct_chng_cnt+1
                    p.append((x, y))
                do_accepts(x+1, y, 3, dcc, p)
            if can_move(x, y, x-1, y, direct, 4, direct_chng_cnt):  # 4
                # dcc = direct == 4 and direct_chng_cnt or direct_chng_cnt+1
                p = path[:]
                if direct == 4:
                    dcc = direct_chng_cnt
                else:
                    dcc = direct_chng_cnt+1
                    p.append((x, y))
                do_accepts(x-1, y, 4, dcc, p)

        do_accepts(x1, y1, 0, 0, [])
        # from pprint import pprint
        # pprint(a)

        if a[x2][y2] > 3:
            return None

        res_path = res_path[0]
        res_path.append((x2, y2))
        # print res_path
        return res_path

    def fillStack(self):
        self.game.fillStack(self)

    def moveMove(self, ncards, to_stack, frames=-1, shadow=-1):
        assert ncards == 1 and to_stack in self.game.s.rows
        if to_stack.cards:
            self._dropPairMove(ncards, to_stack, frames=-1, shadow=shadow)
        else:
            Mahjongg_RowStack.moveMove(self, ncards, to_stack, frames=frames,
                                       shadow=shadow)

    def _dropPairMove(self, n, other_stack, frames=-1, shadow=-1):
        game = self.game
        old_state = game.enterState(game.S_FILL)
        f = game.s.foundations[0]
        game.updateStackMove(game.s.talon, 2 | 16)            # for undo
        if not game.demo:
            if game.app.opt.shisen_show_hint:
                self.drawArrow(other_stack, game.app.opt.timeouts['hint'])
            game.playSample("droppair", priority=200)
        #
        game.moveMove(n, self, f, frames=frames, shadow=shadow)
        game.moveMove(n, other_stack, f, frames=frames, shadow=shadow)
        self.fillStack()
        other_stack.fillStack()
        game.updateStackMove(game.s.talon, 1 | 16)            # for redo
        game.leaveState(old_state)

    def drawArrow(self, other_stack, sleep):
        game = self.game
        images = game.app.images
        cs = game.app.cardset
        path = self.acceptsCards(other_stack, [other_stack.cards[-1]])
        # print path
        x0, y0 = game.XMARGIN, game.YMARGIN
        cardw, cardh = images.CARDW, images.CARDH
        if cs.version >= 6:
            cardw -= cs.SHADOW_XOFFSET
            cardh -= cs.SHADOW_YOFFSET
        coords = []
        dx = game._delta_x
        xf, yf = images._xfactor, images._yfactor
        for x, y in path:
            if x == 0:
                coords.append(6)
            elif x == game.L[0]+1:
                coords.append(int(round(xf * (x0+cardw*(x-1)+10+dx))))
            else:
                coords.append(int(round(xf * (x0+cardw/2+cardw*(x-1)+dx))))
            if y == 0:
                coords.append(6)
            elif y == game.L[1]+1:
                coords.append(int(round(yf * (y0+cardh*(y-1)+6))))
            else:
                coords.append(int(round(yf * (y0+cardh/2+cardh*(y-1)))))
        # print coords
        # s1 = min(cardw/2, cardh/2, 30)
        # w = min(s1/3, 7)
        # s2 = min(w, 10)
        w = 7
        arrow = MfxCanvasLine(game.canvas,
                              coords,
                              {'width': w,
                               'fill': game.app.opt.colors['hintarrow'],
                               # 'arrow': 'last',
                               # 'arrowshape': (s1, s1, s2)
                               }
                              )
        game.canvas.update_idletasks()
        if TOOLKIT == "kivy":
            arrow.delete_deferred(sleep)
            return
        game.sleep(sleep)
        if arrow is not None:
            arrow.delete()
        game.canvas.update_idletasks()


class AbstractShisenGame(AbstractMahjonggGame):
    Hint_Class = NotShisen_Hint  # Shisen_Hint
    RowStack_Class = Shisen_RowStack

    # NCARDS = 144
    GRAVITY = True

    def createGame(self):
        cols, rows = self.L
        assert cols*rows == self.NCARDS

        # start layout
        l, s = Layout(self), self.s
        # dx, dy = 3, -3

        cs = self.app.cardset
        if cs.version >= 6:
            dx = l.XOFFSET
            dy = -l.YOFFSET
            d_x = cs.SHADOW_XOFFSET
            d_y = cs.SHADOW_YOFFSET
            self._delta_x, self._delta_y = dx, -dy
        else:
            dx = 3
            dy = -3
            d_x = 0
            d_y = 0
            self._delta_x, self._delta_y = 0, 0

        font = self.app.getFont("canvas_default")

        # width of self.texts.info
        # ti_width = Font(self.canvas, font).measure(_('Remaining'))
        ti_width = 80

        # set window size
        dxx, dyy = abs(dx), abs(dy)
        cardw, cardh = l.CW - d_x, l.CH - d_y
        w = l.XM+dxx + cols*cardw+d_x + l.XM+ti_width+l.XM
        h = l.YM+dyy + rows*cardh+d_y + l.YM
        self.setSize(w, h)
        self.XMARGIN = l.XM+dxx
        self.YMARGIN = l.YM+dyy

        # set game extras
        self.check_dist = l.CW*l.CW + l.CH*l.CH     # see _getClosestStack()

        #
        self.cols = [[] for i in range(cols)]
        cl = range(cols)
        if dx > 0:
            cl = reversed(cl)
        for col in cl:
            for row in range(rows):
                x = l.XM + dxx + col * cardw
                y = l.YM + dyy + row * cardh
                stack = self.RowStack_Class(x, y, self)
                stack.CARD_XOFFSET = 0
                stack.CARD_YOFFSET = 0
                stack.coln, stack.rown = col, row
                s.rows.append(stack)
                self.cols[col].append(stack)
        # from pprint import pprint
        # pprint(self.cols)

        # create other stacks
        y = l.YM + dyy
        ivx = -l.XS-self.canvas.xmargin
        if TOOLKIT == 'kivy':
            ivx = -1000
        s.foundations.append(Shisen_Foundation(ivx, y, self))
        self.texts.info = MfxCanvasText(self.canvas,
                                        self.width - l.XM - ti_width, y,
                                        anchor="nw", font=font)
        # the Talon is invisble
        s.talon = InitialDealTalonStack(-l.XS-self.canvas.xmargin,
                                        self.height-dyy, self)

        # Define stack groups
        l.defaultStackGroups()

    def fillStack(self, stack):
        if not self.GRAVITY:
            return
        to_stack = stack
        for from_stack in self.cols[stack.coln][stack.rown+1::-1]:
            if not from_stack.cards:
                continue
            self.moveMove(1, from_stack, to_stack, frames=0)
            to_stack = from_stack

    def updateText(self):
        if self.preview > 1 or self.texts.info is None:
            return

        if self.app.opt.shisen_show_matching:
            # find matching tiles
            stacks = self.s.rows
            f, i = 0, 0
            for r in stacks:
                i = i + 1
                if not r.cards:
                    continue
                for t in stacks[i:]:
                    if not t.cards:
                        continue
                    if r.acceptsCards(t, t.cards):
                        f += 1
            if f == 0:
                f = _('No Free\nMatching\nPairs')
            else:
                f = ungettext('%d Free\nMatching\nPair',
                              '%d Free\nMatching\nPairs',
                              f) % f
        else:
            f = ''

        t = len(self.s.foundations[0].cards)
        r1 = ungettext('%d\nTile\nRemoved\n\n',
                       '%d\nTiles\nRemoved\n\n',
                       t) % t
        r2 = ungettext('%d\nTile\nRemaining\n\n',
                       '%d\nTiles\nRemaining\n\n',
                       self.NCARDS - t) % (self.NCARDS - t)

        t = r1 + r2 + f
        self.texts.info.config(text=t)

    def drawHintArrow(self, from_stack, to_stack, ncards, sleep):
        from_stack.drawArrow(to_stack, sleep)

    def _shuffleHook(self, cards):
        return cards

    def canShuffle(self):
        return False


class Shisen_18x8(AbstractShisenGame):
    L = (18, 8)


class Shisen_14x6(AbstractShisenGame):
    L = (14, 6)
    NCARDS = 84


class Shisen_24x12(AbstractShisenGame):
    L = (24, 12)
    NCARDS = 288


class Shisen_18x8_NoGravity(AbstractShisenGame):
    L = (18, 8)
    GRAVITY = False


class Shisen_14x6_NoGravity(AbstractShisenGame):
    L = (14, 6)
    NCARDS = 84
    GRAVITY = False


class Shisen_24x12_NoGravity(AbstractShisenGame):
    L = (24, 12)
    NCARDS = 288
    GRAVITY = False


# ************************************************************************
# * Not Shisen-Sho
# ************************************************************************

class NotShisen_RowStack(Shisen_RowStack):
    def acceptsCards(self, from_stack, cards):
        if not self.game.cardsMatch(self.cards[0], cards[-1]):
            return 0
        if self.coln != from_stack.coln and self.rown != from_stack.rown:
            return 0
        return [(self.coln+1, self.rown+1),
                (from_stack.coln+1, from_stack.rown+1)]


class NotShisen_14x6(AbstractShisenGame):
    Hint_Class = NotShisen_Hint
    RowStack_Class = NotShisen_RowStack
    L = (14, 6)
    NCARDS = 84


class NotShisen_18x8(AbstractShisenGame):
    Hint_Class = NotShisen_Hint
    RowStack_Class = NotShisen_RowStack
    L = (18, 8)


class NotShisen_24x12(AbstractShisenGame):
    Hint_Class = NotShisen_Hint
    RowStack_Class = NotShisen_RowStack
    L = (24, 12)
    NCARDS = 288


# ************************************************************************
# * register a Shisen-Sho type game
# ************************************************************************

def r(id, gameclass, name, rules_filename="shisensho.html"):
    decks, ranks, trumps = comp_cardset(gameclass.NCARDS)
    gi = GameInfo(id, gameclass, name,
                  GI.GT_SHISEN_SHO, 4*decks, 0, GI.SL_MOSTLY_SKILL,
                  category=GI.GC_MAHJONGG, short_name=name,
                  suits=list(range(3)), ranks=list(range(ranks)),
                  trumps=list(range(trumps)),
                  si={"decks": decks, "ncards": gameclass.NCARDS})
    gi.ncards = gameclass.NCARDS
    gi.rules_filename = rules_filename
    registerGame(gi)
    return gi


r(11001, Shisen_14x6, "Shisen-Sho 14x6")
r(11002, Shisen_18x8, "Shisen-Sho 18x8")
r(11003, Shisen_24x12, "Shisen-Sho 24x12")
r(11004, Shisen_14x6_NoGravity, "Shisen-Sho (No Gravity) 14x6")
r(11005, Shisen_18x8_NoGravity, "Shisen-Sho (No Gravity) 18x8")
r(11006, Shisen_24x12_NoGravity, "Shisen-Sho (No Gravity) 24x12")
r(11011, NotShisen_14x6, "Not Shisen-Sho 14x6", "notshisensho.html")
r(11012, NotShisen_18x8, "Not Shisen-Sho 18x8", "notshisensho.html")
r(11013, NotShisen_24x12, "Not Shisen-Sho 24x12", "notshisensho.html")


del r
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

# This layouts converted from Kyodai Mahjongg game
# http://www.kyodai.com/index.en.html
# http://files.cyna.net/layouts.zip

from pysollib.games.mahjongg.mahjongg import r

# ************************************************************************
# * game definitions
# ************************************************************************

#
r(5200, "Another Round", ncards=140, layout="0aagaaihbhacfach" +
    "acjhdghdiaecaeea" +
    "egoehaeiaekaemhf" +
    "dhffhfhhfjhflaga" +
    "agcageogeaggogga" +
    "giogiagkogkagmag" +
    "ohhbhhdhhfhhhhhj" +
    "hhlhhnaiaaicoica" +
    "ieoieaigoigaiioi" +
    "iaikoikaimoimaio" +
    "hjbhjdhjfhjhhjjh" +
    "jlhjnakaakcakeak" +
    "gakiakkakmakoama" +
    "amcammamoaoaaoca" +
    "oeaogaoiaokaomao" +
    "ohpbhpdhpfhphhpj" +
    "hplhpnaqaaqcoqca" +
    "qeoqeaqgoqgaqioq" +
    "iaqkoqkaqmoqmaqo" +
    "hrbhrdhrfhrhhrjh" +
    "rlhrnasaascaseos" +
    "easgosgasiosiask" +
    "oskasmasohtdhtfh" +
    "thhtjhtlaucaueau" +
    "gouhauiaukaumhvg" +
    "hviawfawhawjhxha" +
    "ygayi")
r(5201, "Aqab's", layout="0caedagcaicccbcg" +
    "cckceabegcembgga" +
    "hdahjbigbkabkeck" +
    "gbkibkmbmabmccme" +
    "dmgcmibmkbmmboac" +
    "ocdoedogdoicokbo" +
    "mbqabqccqedqgcqi" +
    "bqkbqmbsabsecsgb" +
    "sibsmbugawdbwgaw" +
    "jcyabygcymcAcbAg" +
    "cAkcCedCgcCi")
#
r(5202, "Big Mountain", layout="0aaaaaqaeihfiagh" +
    "ogiagjhhhvhihhja" +
    "igoihaiiCiioijai" +
    "khjgvjhhjivjjhjk" +
    "akfokgakhCkhokia" +
    "kjCkjokkaklhlfvl" +
    "ghlhvlihljvlkhll" +
    "ameomfamgomhCmha" +
    "miomjCmjamkomlam" +
    "mhnehngvnghnivni" +
    "hnkvnkhnmaodaofo" +
    "ofaohoohCohaojoo" +
    "jCojaoloolaonhpe" +
    "hpgvpghpivpihpkv" +
    "pkhpmaqdaqfoqfaq" +
    "hoqhCqhaqjoqjCqj" +
    "aqloqlaqnhrehrgv" +
    "rghrivrihrkvrkhr" +
    "maseosfasgoshCsh" +
    "asiosjCsjaskosla" +
    "smhtfvtghthvtiht" +
    "jvtkhtlaufougauh" +
    "CuhouiaujCujouka" +
    "ulhvgvvhhvivvjhv" +
    "kawgowhawiCwiowj" +
    "awkhxhvxihxjayho" +
    "yiayjhziaAiaGaaG" +
    "q")
#
r(5203, "Bridge", layout="0aaaaacaaeaagaai" +
    "hbahbchbehbghbio" +
    "caoccoceocgociwd" +
    "avdcvdevdgwdioeb" +
    "oedoefoehvfahfcv" +
    "fchfevfehfgvfgvf" +
    "iogbagdogdagfogf" +
    "oghvhahhcvhchhev" +
    "hehhgvhgvhioibai" +
    "doidaifoifoihvja" +
    "hjcvjchjevjehjgv" +
    "jgvjiokbokdokfok" +
    "hvlavlcvlevlgvli" +
    "CmaCmivnavncvnev" +
    "ngvniooboodoofoo" +
    "hvpahpcvpchpevpe" +
    "hpgvpgvpioqbaqdo" +
    "qdaqfoqfoqhvrahr" +
    "cvrchrevrehrgvrg" +
    "vriosbasdosdasfo" +
    "sfoshvtahtcvtcht" +
    "evtehtgvtgvtioub" +
    "oudoufouhwvavvcv" +
    "vevvgwviowaowcow" +
    "eowgowihxahxchxe" +
    "hxghxiayaaycayea" +
    "ygayi")
r(5204, "Butterfly 2", layout="0aaeaagabcabiadb" +
    "adjhefvefaenafaa" +
    "feofeafgofgaflaf" +
    "phgdvgdwgfhghvgh" +
    "ahaaheoheahgohga" +
    "hkahqhifvifcinbj" +
    "bbjjajqblcbliblq" +
    "bmocndcnhcnmapbb" +
    "pdapfbphapjbplap" +
    "nhqbpqdiqfpqhiqj" +
    "pqlhqnarbbrdarfb" +
    "rharjbrlarnctdct" +
    "hctmbuobvcbvibvq" +
    "bxbbxjaxqhyfvyfc" +
    "ynazaazeozeazgoz" +
    "gazkazqhAdvAdwAf" +
    "hAhvAhaBaaBeoBea" +
    "BgoBgaBlaBphCfvC" +
    "faCnaDbaDjaFcaFi" +
    "aGeaGg")
r(5205, "ChessMania", layout="0aaaaacaaeaagaaj" +
    "aalaanaapacaacgb" +
    "cmaeaaegaejaelae" +
    "naepaibbidaifbih" +
    "aijbilainbipbkba" +
    "kdbkfakhbkjaklbk" +
    "nakpambbmdamfbmh" +
    "amjbmlamnbmponfo" +
    "nhonjonlbobaodbo" +
    "faohbojaolbonaop" +
    "opfppioplaqbbqda" +
    "qfbqhaqjbqlaqnbq" +
    "porforlbsbasdbsf" +
    "ashbsjaslbsnaspa" +
    "ubbudaufbuhaujbu" +
    "launbupbwbawdbwf" +
    "awhbwjawlbwnawpa" +
    "BaaBcaBgaBjaBlaB" +
    "paDabDdaDgaDjbDm" +
    "aDpaFaaFeaFgaFja" +
    "FnaFp")
r(5206, "Cross", layout="0baebagbaiaccdce" +
    "bcgdciackaeacecd" +
    "eebegdeicekaemcg" +
    "adgcdgebggdgidgk" +
    "cgmbiabicaiebiga" +
    "iibikbimbkabkcak" +
    "ebkgakibkkbkmcma" +
    "dmcdmebmgdmidmkc" +
    "mmaoacocdoebogdo" +
    "icokaomaqcdqebqg" +
    "dqiaqkbsebsgbsi")
r(5207, "Cupido's Heart", layout="0aadaalbbfbbjcch" +
    "addadlbefcehbejc" +
    "ghdhfdidcihdjbdj" +
    "jckhdkldlacmhdmn" +
    "dnbdodcohdopeqed" +
    "qqdsddspdtbdundv" +
    "adwldxbdxjdyddyh" +
    "dzfcAhaCecChaCkb" +
    "EfcEhbEjcGh")
r(5208, "Diamond", ncards=140, layout="0aaiaakacgbcibck" +
    "acmaeebegceicekb" +
    "emaeoagcbgecggdg" +
    "idgkcgmbgoagqaia" +
    "bicciedigeiieikd" +
    "imciobiqaisakabk" +
    "cckedkgekiekkdkm" +
    "ckobkqaksamcbmec" +
    "mgdmidmkcmmbmoam" +
    "qaoebogcoicokbom" +
    "aooaqgbqibqkaqma" +
    "siask")
r(5209, "Dragon 2", layout="0bafbbdobeobgbbh" +
    "bcfbcmbdkodlodnb" +
    "dobecaegbemofcbg" +
    "abgcbghbgjagloha" +
    "vhbohcbiabicbijb" +
    "ilojbbjhojjojlbk" +
    "bbkfokhbkjvkjbkl" +
    "vklolbolfblholjo" +
    "llbmbcmdbmfbmjbm" +
    "lboioojbokaoohpo" +
    "bqhbqjaqobrforho" +
    "rjasdosfbshvshbs" +
    "jvsjbslbsnhtdbtf" +
    "othotjaubaudbuhb" +
    "ujbwgbwkbwmbydoy" +
    "ebyfbymayohzobAc" +
    "aAobBjbCdoCebCfo" +
    "CgbCh")
r(5210, "Empty Pyramids", layout="0aaiabghbiabkacc" +
    "acehcgocihckacma" +
    "coadghdiadkaeiah" +
    "iaighiiaikajehjg" +
    "ojihjkajmakchkeo" +
    "kgvkiokkhkmakoal" +
    "ahlcolevlgClivlk" +
    "olmhloalqhmaamch" +
    "meomgvmiomkhmmam" +
    "ohmqonahncanehng" +
    "onihnkanmhnoonqv" +
    "oaoochoeaoghoiao" +
    "khomooovoqCpavpc" +
    "opehpgapiopihpko" +
    "pmvpoCpqvqaoqchq" +
    "eaqghqiaqkhqmoqo" +
    "vqqorahrcarehrgo" +
    "rihrkarmhroorqhs" +
    "aaschseosgvsiosk" +
    "hsmasohsqatahtco" +
    "tevtgCtivtkotmht" +
    "oatqauchueougvui" +
    "oukhumauoavehvgo" +
    "vihvkavmawghwiaw" +
    "kaxiaAiaBghBiaBk" +
    "aCcaCehCgoCihCka" +
    "CmaCoaDghDiaDkaE" +
    "i")
r(5211, "Fish face", layout="0bajbciocjbckvdj" +
    "behoeibejoekbelc" +
    "ggcgmchichkcifci" +
    "ncjhcjlckebkjcko" +
    "clgclmcmebmiomjb" +
    "mkcmocnccnqcoebo" +
    "ioojbokcoobpbcpg" +
    "cpmbprcqebqjcqoa" +
    "racrhcrlarsbsfbs" +
    "nbtiotjbtkbugbum" +
    "bwhbwlbyibykcAjc" +
    "BhcBlbDgbDmaFfaF" +
    "n")
r(5212, "Floating City", layout="0oagoaiocdocfoch" +
    "ocjoclocphdahdch" +
    "dmhdoaeboebaedae" +
    "faehaejaelaenoen" +
    "hfahfcvfchfmvfmh" +
    "foagbagnahdvheah" +
    "fahhahjvhkahlaib" +
    "ainvjgvjiakbCkha" +
    "knhlfhlhhljambam" +
    "damfomgamhCmhomi" +
    "amjamlamnomphnfh" +
    "nhhnjjoaaobCobao" +
    "dCodaofCofoogaoh" +
    "CohooiaojCojaolC" +
    "olaonConjooCopoo" +
    "qhpfhphhpjaqbaqd" +
    "aqfoqgaqhCqhoqia" +
    "qjaqlaqnoqphrfhr" +
    "hhrjasbCshasnvtg" +
    "vtiaubaunavdvvea" +
    "vfavhavjvvkavlaw" +
    "bawnhxahxcvxchxm" +
    "vxmhxoayboybayda" +
    "yfayhayjaylaynoy" +
    "nhzahzchzmhzooAd" +
    "oAfoAhoAjoAloApo" +
    "CgoCi")
# r(5213, "Flowers 2", layout="0aaiacgbciackadc" +
#    "adoaeiafabfcafea" +
#    "fmbfoafqahcahoai" +
#    "haijhjiakfakhakj" +
#    "aklhlghlihlkamda" +
#    "mfamhomhamjomjam" +
#    "lamnhnehnghnivni" +
#    "hnkhnmaobaodaofo" +
#    "ofaohoohaojoojao" +
#    "loolaonaophpchpe" +
#    "hpgvpghpivpihpkv" +
#    "pkhpmhpoaqbaqdoq" +
#    "daqfoqfaqhoqhCqh" +
#    "aqjoqjCqjaqloqla" +
#    "qnoqnaqphrchrehr" +
#    "gvrghrivrihrkvrk" +
#    "hrmhroasbasdasfo" +
#    "sfashoshasjosjas" +
#    "loslasnasphtehtg" +
#    "htivtihtkhtmauda" +
#    "ufauhouhaujoujau" +
#    "launhvghvihvkawf" +
#    "awhawjawlhxiayha" +
#    "yjazcazoaBabBcaB" +
#    "eaBmbBoaBqaCiaDc" +
#    "aDoaEgbEiaEkaGi")
# r(5214, "Full Vision 3", layout="0aaeaagaaihbehbi" +
#    "acbhccacdacfhcga" +
#    "chacjhckaclacnhc" +
#    "oacpaeahebaecaee" +
#    "aegaeiaekhelaema" +
#    "gbhgcagdagfhggag" +
#    "hagjhgkaglagnhgo" +
#    "agphhehhiaieaiga" +
#    "iiainhioaiphjgak" +
#    "eakgakiaknhkoakp" +
#    "hlehliambhmcamda" +
#    "mfhmgamhamjhmkam" +
#    "lamnhmoampaoahob" +
#    "aocaoehofaogaoia" +
#    "okholaomaqbhqcaq" +
#    "daqfhqgaqhaqjhqk" +
#    "aqlaqnhqoaqphreh" +
#    "riaseasgasiasnhs" +
#    "oasphtgaueaugaui" +
#    "aunhuoauphvehvia" +
#    "wbhwcawdawfhwgaw" +
#    "hawjhwkawlawnhwo" +
#    "awpayahybaycayea" +
#    "ygayiaykhylaymaA" +
#    "bhAcaAdaAfhAgaAh" +
#    "aAjhAkaAlaAnhAoa" +
#    "AphBehBiaCeaCgaC" +
#    "i")
r(5215, "Hidden Words", layout="0haahachaehaghal" +
    "abaabcobdabeabga" +
    "bjablbbnabphcahc" +
    "chceocghchhckhcq" +
    "adgadmodohefheih" +
    "emheoafgafjofjaf" +
    "lafnafphgfogghgk" +
    "hgmhgohichiehikh" +
    "inajaojaajcojdaj" +
    "eajghjhajjajlajn" +
    "ajphkbhkfokjhklh" +
    "kpalaalghlialjal" +
    "mombhmchmehmnana" +
    "ancanebnganjanla" +
    "nnbnphochoiholhq" +
    "chqfhqihqkaraarc" +
    "arearjhschshhslh" +
    "snhspatgatjatlat" +
    "natphuchuhhunava" +
    "avcaveavjhvkhwdh" +
    "wfhxihxmhxqayahy" +
    "baycayeaygayjayl" +
    "aynhyoayphzfhzka" +
    "AabAdaAghAhaAjaA" +
    "maAphBlhBnhBqaCa" +
    "hCbaCghCiaCjaCph" +
    "DfhDp")
r(5216, "Hovercraft", layout="0aadaafaahaajjbg" +
    "dccdceacgdcidckj" +
    "dgaedaefaehaejhf" +
    "gagfpggaghhhgaig" +
    "ajajjgajmhkaakgh" +
    "kmalaolaalmolmhm" +
    "avmaemghmmvmmana" +
    "onaCnaenceneenie" +
    "nkanmonmCnmhoavo" +
    "aeoghomvomapaopa" +
    "apmopmhqaaqghqma" +
    "rajrgarmasghtgau" +
    "fpugauhhvgawdawf" +
    "awhawjjxgdycdyea" +
    "ygdyidykjzgaAdaA" +
    "faAhaAj")
r(5217, "Hurdles", layout="0aaaaacaaeaagaai" +
    "aakaamaaohbahbch" +
    "behbghbihbkhbmhb" +
    "oacaocaaccoccace" +
    "oceacgocgaciocia" +
    "ckockacmocmacooc" +
    "ohdahdchdehdghdi" +
    "hdkhdmhdoaeaaeca" +
    "eeaegaeiaekaemae" +
    "oagaagcageaggagi" +
    "agkagmagohhahhch" +
    "hehhghhihhkhhmhh" +
    "oaiaoiaaicoicaie" +
    "oieaigoigaiioiia" +
    "ikoikaimoimaiooi" +
    "ohjahjchjehjghji" +
    "hjkhjmhjoakaakca" +
    "keakgakiakkakmak" +
    "oamaamcameamgami" +
    "amkammamohnahnch" +
    "nehnghnihnkhnmhn" +
    "oaoaooaaocoocaoe" +
    "ooeaogoogaoiooia" +
    "okookaomoomaoooo" +
    "ohpahpchpehpghpi" +
    "hpkhpmhpoaqaaqca" +
    "qeaqgaqiaqkaqmaq" +
    "o")
r(5218, "Tornado", layout="0babaadaambaoabi" +
    "begbekofdbfeoffa" +
    "fiofioflbfmofnbg" +
    "chgibgoahaahiohi" +
    "ahqhibhiihipajba" +
    "jeijfajgvjgajioj" +
    "iajkvjkijlajmajp" +
    "hkbhkihkpalcalia" +
    "lohmchmoandinean" +
    "fanianlinmannapb" +
    "ipdapevpeipfapga" +
    "pkiplapmvpmipnap" +
    "pardirearfariarl" +
    "irmarnhschsoatca" +
    "tiatohubhuihupav" +
    "baveivfavgvvgavi" +
    "oviavkvvkivlavma" +
    "vphwbhwihwpaxaax" +
    "ioxiaxqbychyibyo" +
    "ozdbzeozfaziozio" +
    "zlbzmoznbAgbAkaD" +
    "ibEbaEdaEmbEo")
#
r(5219, "IloveU", layout="0caddafcahdaldan" +
    "dapdcbcciceacejc" +
    "gacgkdibcilckdck" +
    "mcmecmndngdnpcoe" +
    "concqdcqmdsbcslc" +
    "uacukcwacwjdybcy" +
    "idzldzndzpcAddAf" +
    "cAhdBpdDldDndDp")
r(5220, "Inazuma", layout="0caaaaocaqcccacm" +
    "ccoacqceebeiaekc" +
    "emaeoagacggcgkag" +
    "mciaaicciibimaka" +
    "ckcakeckkamccmea" +
    "mgcmmaoecogaoico" +
    "ocqaaqgdqiaqkcqq" +
    "cscasicskasmcuea" +
    "ukcumauocwgawmcw" +
    "oawqbyecyiayocyq" +
    "aAecAgcAkaAqaCcc" +
    "CeaCgbCicCmaEacE" +
    "caEecEocGaaGccGq")
r(5221, "JPs", layout="0baabakbbmbcabck" +
    "bcobdmbdqbeabeob" +
    "fqbgabhobhqbiabi" +
    "cbiebigbiibikbim" +
    "bjobkabkcbkebkgb" +
    "kibkkbkmamqbqabq" +
    "cbqebqgbqibqkbqm" +
    "bqobqqbsabscbseb" +
    "sgbsibskbsmbsobs" +
    "qbuabuhbujbwabwh" +
    "bwjaxqbyabyhbyjb" +
    "AabAcbAgbAibCabC" +
    "cbCebCgbCibEabEc" +
    "bEebEgbEibGe")
r(5222, "Japan", ncards=96, layout="0baabacbaebagbai" +
    "bcaacebcibeaaeeb" +
    "eibgabgcbgebggbg" +
    "iahoajkajoalgali" +
    "alkhllalmaloangb" +
    "nibnkanmapebpgbp" +
    "iapkapmbrebrgari" +
    "arkatehtfatgatia" +
    "vaavcavebwibwoax" +
    "aaxcbxmbyiaykaza" +
    "bAgbAibAkbAmbAob" +
    "CiaCkbDmbEibEo")
r(5223, "Krebs", layout="0aaaaacaaeaagbai" +
    "balaanaapaaraata" +
    "caactaeaaetagaag" +
    "taiaCikaitvjkaka" +
    "CkjokkCklaktvljh" +
    "lkvllamaCmiomjam" +
    "kCmkomlCmmamtvni" +
    "hnjvnkhnlvnmaoaC" +
    "ohooiaojCojookao" +
    "lColoomConaotvph" +
    "hpivpjhpkvplhpmv" +
    "pnbqaCqgoqhaqiCq" +
    "ioqjaqkCqkoqlaqm" +
    "CqmoqnCqobqtvrhh" +
    "rivrjhrkvrlhrmvr" +
    "nCshosiasjCsjosk" +
    "aslCslosmCsnbtav" +
    "tihtjvtkhtlvtmbt" +
    "tCuioujaukCukoul" +
    "Cumavavvjhvkvvla" +
    "vtCwjowkCwlaxavx" +
    "kaxtCykazaaztaBa" +
    "aBtaDaaDtaFaaFta" +
    "HaaHcaHeaHgdHidH" +
    "laHnaHpaHraHt")
r(5224, "Kumo", layout="0caadaccaecagbai" +
    "bamdaqdcacccaceb" +
    "cgbckdcoceaaecce" +
    "ebeidembeqcgabgc" +
    "cggdgkbgobiabied" +
    "iibimbiqbkcdkgck" +
    "kbkockqbmadmebmi" +
    "cmmamocmqdocbogb" +
    "okaomcoodoqdqabq" +
    "ebqicqkcqmdqocqq")
r(5225, "Kyodai 14", layout="0aaiachhciacjodi" +
    "aefhegaehheiveia" +
    "ejhekaelofhCfiof" +
    "jagchgdagehgfagg" +
    "hghagivgihgjagkh" +
    "glagmhgnagoohiai" +
    "bhicaidaihhiiaij" +
    "ainhioaipakcbkgo" +
    "khbkivkiokjbkkak" +
    "ohlchloamcbmfbml" +
    "amoaoahobaochoda" +
    "oeooehofvofaogoo" +
    "ghohvohaoiooihoj" +
    "vojaokookholvola" +
    "omoomhonaoohopao" +
    "qaqcbqfbqlaqohrc" +
    "hroascbsgoshbsiv" +
    "siosjbskasoaubhu" +
    "caudauhhuiaujaun" +
    "huoaupoviawchwda" +
    "wehwfawghwhawivw" +
    "ihwjawkhwlawmhwn" +
    "awooxhCxioxjayfh" +
    "ygayhhyivyiayjhy" +
    "kayloziaAhhAiaAj" +
    "aCi")
r(5226, "Kyodai 17", layout="0daacaccaecagcai" +
    "cakdamccaccgccmc" +
    "eacegcemcgacgccg" +
    "ecggcgicgkcgmcia" +
    "digcimckadkgckmc" +
    "macmccmecmgcmicm" +
    "kcmmcoacogcomcqa" +
    "cqgcqmdsacsccsec" +
    "sgcsicskdsm")
#
r(5227, "Kyodai 18", layout="0daidchdcjdegdek" +
    "dgfdgldiedimdkda" +
    "kidkndmcamhamjdm" +
    "odobaogaoiaokdop" +
    "dqaaqfaqhaqjaqld" +
    "qqdsbasgasiaskds" +
    "pducauhaujduodwd" +
    "awidwndyedymdAfd" +
    "AldCgdCkdEhdEjdG" +
    "i")
r(5228, "Kyodai 20", layout="0aaeaagaaiaakaam" +
    "aaohbjacdaciacka" +
    "cpaecbehbelaeqag" +
    "baggagmagraiaaif" +
    "higaihoihhiiviia" +
    "ijoijCijhikvikai" +
    "loilhimainaisaka" +
    "akebkjakoaksamaa" +
    "mdcmhamjcmlampam" +
    "saoahobaocoochod" +
    "vodaoeooeCoehofv" +
    "ofaogooghohaoiko" +
    "jaokholaomoomhon" +
    "vonaoooooCoohopv" +
    "opaoqooqhoraosaq" +
    "aaqdcqhaqjcqlaqp" +
    "aqsasaasebsjasoa" +
    "ssauaaufhugauhou" +
    "hhuivuiaujoujCuj" +
    "hukvukauloulhuma" +
    "unausawbawgawmaw" +
    "raycbyhbylayqaAd" +
    "aAiaAkaAphBjaCea" +
    "CgaCiaCkaCmaCo")
#
r(5229, "Kyodai 23", layout="0aaehbeacdoceacf" +
    "hdevdeaecaeeoeea" +
    "eghfdvfehffagaag" +
    "cageogeaggagihhb" +
    "hhdhhfhhhaiaaico" +
    "icaieoieaigoigai" +
    "ihjbhjdvjdhjfvjf" +
    "hjhakaakcokcakeo" +
    "keCkeakgokgakihl" +
    "bhldvldhlfvlfhlh" +
    "amaamcomcameomea" +
    "mgomgamihnbhndhn" +
    "fhnhaoaaocaoeooe" +
    "aogaoihpdhpfaqaa" +
    "qcaqeoqeaqgaqihr" +
    "bhrdhrfhrhasaasc" +
    "oscaseoseasgosga" +
    "sihtbhtdvtdhtfvt" +
    "fhthauaaucoucaue" +
    "oueCueaugougauih" +
    "vbhvdvvdhvfvvfhv" +
    "hawaawcowcaweowe" +
    "awgowgawihxbhxdh" +
    "xfhxhayaaycayeoy" +
    "eaygayihzdvzehzf" +
    "aAcaAeoAeaAghBev" +
    "BeaCdoCeaCfhDeaE" +
    "e")
#
r(5230, "Kyodai 24", layout="0aaaiabaacaaejaf" +
    "aagaaiiajaakvbci" +
    "bdCbfibhvbiacaic" +
    "baccacevceicfacg" +
    "vcgaciicjackvdci" +
    "ddCddCdfidhCdhvd" +
    "iaeaiebaecaeevee" +
    "iefaegvegaeiieja" +
    "ekvfcifdCfdifhCf" +
    "hvfiagaigbagcage" +
    "vgeigfaggvggagii" +
    "gjagkvhcihdChdih" +
    "hChhvhiaiaiibaic" +
    "aievieiifaigviga" +
    "iiiijaikvjcijdCj" +
    "dCjfijhCjhvjiaka" +
    "ikbakcakevkeikfa" +
    "kgvkgakiikjakkvl" +
    "cildClfilhvliama" +
    "imbamcamejmfamga" +
    "miimjamk")
r(5231, "Kyodai 25", layout="0cagbaicakbcgbck" +
    "odgodkbegbekcggc" +
    "gkbieoifbigciibi" +
    "koilbimbkiolicma" +
    "bmicmqboabogdoib" +
    "okboqcqabqcoqdbq" +
    "edqgdqkbqmoqnbqo" +
    "cqqbsabsgdsibskb" +
    "sqcuabuicuqovibw" +
    "ibyeoyfbygcyibyk" +
    "oylbymcAgcAkbCgb" +
    "CkoDgoDkbEgbEkcG" +
    "gbGicGk")
#
r(5232, "Kyodai 26", layout="0aahhbhacgacihdg" +
    "hdiaefaehaejhffh" +
    "fhhfjageaggagiag" +
    "khhehhghhihhkaid" +
    "aifaihaijailhjdh" +
    "jhhjlakcakeakgak" +
    "iakkakmhlchlehlg" +
    "hlihlkhlmambamda" +
    "mfamhamjamlamnhn" +
    "bhnfhnhhnjhnnaoa" +
    "aocaoeaogaoiaoka" +
    "omaoohpahpchpehp" +
    "ghpihpkhpmhpoaqa" +
    "aqcaqeaqgaqiaqka" +
    "qmaqohrahrchrehr" +
    "ghrihrkhrmhroasa" +
    "ascaseasgasiaska" +
    "smasohtbhtfhthht" +
    "jhtnaubaudaufauh" +
    "aujaulaunhvchveh" +
    "vghvihvkhvmawcaw" +
    "eawgawiawkawmhxd" +
    "hxhhxlaydayfayha" +
    "yjaylhzehzghzihz" +
    "kaAeaAgaAiaAkhBf" +
    "hBhhBjaCfaChaCjh" +
    "DghDiaEgaEihFhaG" +
    "h")
#
r(5233, "Kyodai 27", layout="0aagacfhcgachaee" +
    "hefaegoeghehaeiv" +
    "fgagdhgeagfogfhg" +
    "gCggaghoghhgiagj" +
    "vhfvhhaichidaieo" +
    "iehifCifaigoighi" +
    "hCihaiioiihijaik" +
    "vjevjgvjiakbhkca" +
    "kdokdhkeCkeakfok" +
    "fhkgCkgakhokhhki" +
    "Ckiakjokjhkkaklv" +
    "ldvlfvlhvljamahm" +
    "bamcomchmdameome" +
    "hmfCmfamgomghmhC" +
    "mhamiomihmjamkom" +
    "khmlammvndvnfvnh" +
    "vnjaobhocaodoodh" +
    "oeCoeaofoofhogCo" +
    "gaohoohhoiCoiaoj" +
    "oojhokaolvpevpgv" +
    "piaqchqdaqeoqehq" +
    "fCqfaqgoqghqhCqh" +
    "aqioqihqjaqkvrfv" +
    "rhasdhseasfosfhs" +
    "gCsgashoshhsiasj" +
    "vtgauehufaugough" +
    "uhauiawfhwgawhay" +
    "g")
#
r(5234, "Kyodai 28", layout="0baibbgbbkbcebci" +
    "bcmbdcbdobeabeib" +
    "eqbgacggvghcgiCg" +
    "ivgjcgkbgqbiacif" +
    "ciicilbiqbkackea" +
    "khakjckmbkqhlhhl" +
    "jbmacmdamgamiomi" +
    "amkcmnbmqhnhhnjb" +
    "oacoeaohaojcombo" +
    "qbqacqfcqicqlbqq" +
    "bsacsgvshcsiCsiv" +
    "sjcskbsqbuabuibu" +
    "qbvcbvobwebwibwm" +
    "bxgbxkbyi")
#
r(5235, "Kyodai 41", layout="0CaeCagCaivbevbg" +
    "vbiCcdoceocgociC" +
    "cjvddhdevdfhdgCd" +
    "gvdhhdivdjCecaee" +
    "oeeCeeaegoegaeio" +
    "eiCeiCekCfavfbof" +
    "chfdvfdhffvffCfg" +
    "hfhvfhhfjvfjofkv" +
    "flCfmCgdageogeag" +
    "goggagiogiCgjCha" +
    "vhbohchhdvhdhhfv" +
    "hfChghhhvhhhhjvh" +
    "johkvhlChmCicaie" +
    "oieCieaigoigaiio" +
    "iiCiiCikCjavjboj" +
    "chjdvjdhjfvjfCjg" +
    "hjhvjhhjjvjjojkv" +
    "jlCjmCkdakeokeak" +
    "gokgakiokiCkjCla" +
    "vlbolchldvldhlfv" +
    "lfClghlhvlhhljvl" +
    "jolkvllClmCmcame" +
    "omeCmeamgomgamio" +
    "miCmiCmkvndhnevn" +
    "fhngCngvnhhnivnj" +
    "CodooeoogooiCojv" +
    "pevpgvpiCqeCqgCq" +
    "i")
#
r(5236, "Kyodai 42", layout="0oaboadCagoajoal" +
    "hbahbcvbchbeobfv" +
    "bgobhhbihbkvbkhb" +
    "macbacdacjaclhdb" +
    "hddodevdfCdgvdho" +
    "dihdjhdlaecaekhf" +
    "chfeoffvfgofhhfi" +
    "hfkagdCggagjhhdh" +
    "hfhhhhhjaieaiihj" +
    "ehjghjiakfCkgakh" +
    "hlfvlghlhCmfamgo" +
    "mgCmhhnfvnghnhao" +
    "gCoghpfhphCqcvqd" +
    "oqeCqeaqgoqgoqiC" +
    "qivqjCqkhrfhrhas" +
    "gCsghtfvtghthCuf" +
    "augougCuhhvfvvgh" +
    "vhawfCwgawhhxehx" +
    "ghxiayeayihzdhzf" +
    "hzhhzjaAdCAgaAjh" +
    "BchBeoBfvBgoBhhB" +
    "ihBkaCcaCkhDbhDd" +
    "oDevDfCDgvDhoDih" +
    "DjhDlaEbaEdaEjaE" +
    "lhFahFcvFchFeoFf" +
    "vFgoFhhFihFkvFkh" +
    "FmoGboGdCGgoGjoG" +
    "l")
r(5237, "Lattice", layout="0aaiacebciacmaec" +
    "beeaegbeiaekbema" +
    "eoagecgiagmaicbi" +
    "eaigciiaikbimaio" +
    "akeckiakmamcbmeb" +
    "mgdmibmkbmmamobo" +
    "eeoibomaqabqccqe" +
    "eqgdqieqkcqmbqoa" +
    "qqbseesibsmaucbu" +
    "ebugduibukbumauo" +
    "awecwiawmaycbyea" +
    "ygcyiaykbymayoaA" +
    "ecAiaAmaCcbCeaCg" +
    "bCiaCkbCmaCoaEeb" +
    "EiaEmaGi")
#
# r(5238, "Leo", layout="0aapabiablhbphcf" +
#    "acghchhclacnocpa" +
#    "djodladpvdpheeae" +
#    "fheiaelvelhepCep" +
#    "ofihflCflafnofph" +
#    "gdagevgiagjoglag" +
#    "pvgphhiChiahlvhl" +
#    "hhpChphicaidoiih" +
#    "ilCilainoipvjiaj" +
#    "jojlajpvjpbkabkc" +
#    "hkiCkiaklvklhkpC" +
#    "kpolbolihllalnol" +
#    "pbmabmcvmiamjoml" +
#    "ampvmphnianlhnpo" +
#    "oiholaonoophpfap" +
#    "hapjappaqfhqiaql" +
#    "hqphrdarnasehsqh" +
#    "tcatpaudbumhuphv" +
#    "bcvgavqawccwlhwq" +
#    "hxbcxjaxpayccylh" +
#    "yphzbczgazqaAdbA" +
#    "mhAqhBcaBpaCehCp" +
#    "hDeaDgaDohEgaEia" +
#    "EmhEohFiaFkhFmhG" +
#    "k")
#
r(5239, "Loose Ends", layout="0aaaoabaaioapaaq" +
    "hbahbihbqacbocca" +
    "chociacjocoacphd" +
    "bhdivdihdpaecoed" +
    "aegaeioeiaekoena" +
    "eohfchfivfihfoag" +
    "dogeaghogiagjogm" +
    "agnhhdhhivhihhna" +
    "ieoifaiioiioilai" +
    "mhjfhjihjlakgokg" +
    "akiakkokkhlholih" +
    "ljamahmbamcomchm" +
    "dvmdameomehmfvmf" +
    "amgvmhamiCmivmja" +
    "mkhmlvmlammommhm" +
    "nvmnamoomohmpamq" +
    "hnhonihnjaogooga" +
    "oiaokookhpfhpihp" +
    "laqeoqfaqioqioql" +
    "aqmhrdhrivrihrna" +
    "sdoseashosiasjos" +
    "masnhtchtivtihto" +
    "aucoudaugauiouia" +
    "ukounauohvbhvivv" +
    "ihvpawbowcawhowi" +
    "awjowoawphxahxih" +
    "xqayaoybayioypay" +
    "q")
r(5240, "Mini Traditional", ncards=48, layout="0aaeacdacfhdeaec" +
    "aeeoeeaeghfdvfeh" +
    "ffagbagdogeagfag" +
    "hhhchhevhehhgaia" +
    "aicoicaieoieaigo" +
    "igaiihjchjevjehj" +
    "gakbakdokeakfakh" +
    "hldvlehlfamcameo" +
    "meamghneaodaofaq" +
    "e")
r(5241, "Mini-Layout", ncards=8, layout="0aabaadacahcbhcd" +
    "aceaebaed")
r(5242, "Mission Impossible", layout="0baabamaapccaccm" +
    "acpdeacecbeeaegb" +
    "eicekdemaepcgacg" +
    "magpbiabimaipakp" +
    "bmacmcdmeemgdmic" +
    "mkbmmampcocaopdq" +
    "eaqpcscaspbuacuc" +
    "dueeugduicukbuma" +
    "upawpbyabycbyeby" +
    "gbyibykbymaypcAa" +
    "cAgaApdCadCgaCpe" +
    "EaaEp")
#
r(5243, "Multi X", layout="0aaaaaiaaqhbbhbh" +
    "hbjhbpoccocgocko" +
    "covddvdfvdlvdnce" +
    "eCeecemCemvfdvff" +
    "vflvfnogcoggogko" +
    "gohhbhhhhhjhhpai" +
    "aaiiaiqhjbojcvjd" +
    "Cjevjfojghjhojih" +
    "jjojkvjlCjmvjnoj" +
    "ohjpakaakiakqhlb" +
    "hlhhljhlpomcomgo" +
    "mkomovndvnfvnlvn" +
    "ncoeCoecomComvpd" +
    "vpfvplvpnoqcoqgo" +
    "qkoqohrbhrhhrjhr" +
    "pasaasiasqhtbotc" +
    "vtdCtevtfotghtho" +
    "tihtjotkvtlCtmvt" +
    "notohtpauaauiauq" +
    "hvbhvhhvjhvpowco" +
    "wgowkowovxdvxfvx" +
    "lvxncyeCyecymCym" +
    "vzdvzfvzlvznoAco" +
    "AgoAkoAohBbhBhhB" +
    "jhBpaCaaCiaCq")
# r(5244, "New Layout 2", layout="0CabCadCafacapca" +
#    "hccvccacepcehcgv" +
#    "cgheaveaaecpeche" +
#    "eveeaegpegCfaCfc" +
#    "CfeCfgagapgahgcv" +
#    "gcagepgehggvggCh" +
#    "aChcCheChghiavia" +
#    "aicpichievieaigp" +
#    "igakaqkahkcwkcak" +
#    "eqkehkgwkghmawma" +
#    "amcqmchmewmeamgq" +
#    "mgaoaqoahocwocao" +
#    "eqoehogwoghqavqa" +
#    "aqcpqchqevqeaqgp" +
#    "qgCraCrcCreCrgas" +
#    "apsahscvscasepse" +
#    "hsgvsgCtaCtcCteC" +
#    "tghuavuaaucpuchu" +
#    "evueaugpugawapwa" +
#    "hwcvwcawepwehwgv" +
#    "wgCybCydCyf")
r(5245, "Okie's Nitemare", layout="0aaoaaqbbeabmhbp" +
    "acoacqcddbdgadmh" +
    "dpaeoaeqbfccffaf" +
    "mhfpagoagqbhehhp" +
    "aiiaioaiqhjihjqa" +
    "kiakqalohlqammhm" +
    "oamqandankhnmano" +
    "onohnqaobaoihoka" +
    "ompomhooaoqapghp" +
    "iapkopkhpmapoopo" +
    "hpqaqabqcoqdbqeo" +
    "qfhqgaqioqihqkvq" +
    "kCqlaqmpqmhqoaqq" +
    "arghriarkorkhrma" +
    "roorohrqasbasihs" +
    "kasmpsmhsoasqatd" +
    "atkhtmatootohtqa" +
    "umhuoauqavohvqaw" +
    "iawqhxihxqbyeayi" +
    "ayoayqhzpbAccAfa" +
    "AoaAqaBmhBpcCdbC" +
    "gaCoaCqaDmhDpbEe" +
    "aEoaEqaFmhFpaGoa" +
    "Gq")
r(5246, "Orbital", ncards=84, layout="0dafdahdajdchceh" +
    "bghbihbkhclablfb" +
    "ljclocnabncbnebn" +
    "kbnmcnocpabpfbpj" +
    "cpobqhbshbuhcwhd" +
    "yhdAfdAhdAj")
r(5247, "Owl", layout="0baebagbaibakbam" +
    "bcdbcncecbejbeoc" +
    "gbbghcgjbglbgpci" +
    "cbijbiobkdbkncla" +
    "blpbmebmmcnbanpc" +
    "odaofbohbojbolbo" +
    "nhopipfappoppcqd" +
    "aqfbqhbqjbqlbqnh" +
    "qpcrbarpbsebsmct" +
    "abtpbudbuncwcbwj" +
    "bwocybbyhcyjbylb" +
    "ypcAcbAjbAobCdbC" +
    "nbEebEgbEibEkbEm")
r(5248, "Pantheon", layout="0baebcebdgbdqbee" +
    "aeiaekaemaeobfcb" +
    "fgbfqbgebhcbiebj" +
    "cojdbjgbjqbkabke" +
    "akiakkakmakoolbb" +
    "lcoldblgblqbmabm" +
    "eonbbncboaoodboe" +
    "opbbpcbpgbpqbqab" +
    "qeaqiaqkaqmaqoor" +
    "bbrcbrgbrqbsaosd" +
    "bseotbbtcbuabueo" +
    "vbbvcovdbvgbvqbw" +
    "abweawiawkawmawo" +
    "bxcoxdbxgbxqbyeb" +
    "zcbAebBcbBgbBqbC" +
    "eaCiaCkaCmaCobDg" +
    "bDqbEebGe")
#
r(5249, "Papillon", layout="0bagbaibakobhobj" +
    "bcfbchbcjbclodho" +
    "djbecbeebegbeibe" +
    "kbembeoofdofnbgd" +
    "bgnbiebimojeojmb" +
    "kdbkfbklbknbmcbm" +
    "gbmkbmobobbohboj" +
    "bopopibqabqibqqo" +
    "ribsbbshbsjbspbu" +
    "cbugbukbuobwdbwf" +
    "bwlbwnoxeoxmbyeb" +
    "ymbAdbAnoBdoBnbC" +
    "cbCebCgbCibCkbCm" +
    "bCooDhoDjbEfbEhb" +
    "EjbEloFhoFjbGgbG" +
    "ibGk")
r(5250, "Pyramid 1", layout="0aagaaiaceacghch" +
    "aciackaecbeebegb" +
    "eibekaemagabgcbg" +
    "ecggcgibgkbgmago" +
    "aiabicciecigvihc" +
    "iicikbimaioakabk" +
    "cckedkgdkickkbkm" +
    "akoamabmccmedmgd" +
    "micmkbmmamoaoabo" +
    "ccoecogvohcoicok" +
    "bomaooaqabqcbqec" +
    "qgcqibqkbqmaqoas" +
    "cbsebsgbsibskasm" +
    "aueaughuhauiauka" +
    "wgawi")
r(5251, "Pyramid 2", layout="0aaeaagaaiaccbce" +
    "bcgbciackaeabecb" +
    "eeoefbegoehbeibe" +
    "kaemagacgcdgedgg" +
    "dgicgkagmbiadice" +
    "ieeigeiidikbimbk" +
    "adkcekeekgekidkk" +
    "bkmamacmcdmedmgd" +
    "micmkammaoabocbo" +
    "eoofbogoohboibok" +
    "aomaqcbqebqgbqia" +
    "qkaseasgasi")
#
r(5252, "Quad", layout="0baabacbaeaagbai" +
    "bakbamobbobdobjo" +
    "blbcabccvccbceac" +
    "gbcibckvckbcmodb" +
    "oddodjodlbeabecv" +
    "ecbeeaegbeibekve" +
    "kbemofbofdofjofl" +
    "bgabgcbgeaggbgib" +
    "gkbgmaiaaicaiebi" +
    "gaiiaikaimbkabkc" +
    "bkeakgbkibkkbkmo" +
    "lboldoljollbmabm" +
    "cvmcbmeamgbmibmk" +
    "vmkbmmonbondonjo" +
    "nlboabocvocboeao" +
    "gboibokvokbomopb" +
    "opdopjoplbqabqcb" +
    "qeaqgbqibqkbqm")
#
r(5253, "Rectangle", layout="0daadacdaedagdca" +
    "dccdcedcgdeadecd" +
    "eedegdgadgcdgedg" +
    "gdiadicdiedigdka" +
    "dkcdkedkgdmadmcd" +
    "medmgdoadocdoedo" +
    "gdqadqcdqedqg")
r(5254, "Reindeer", ncards=64, layout="0haeabdocchdbadn" +
    "aecheehemaffafla" +
    "fohgkahfahhahjaj" +
    "fajjalfalhaljall" +
    "hmmanfanjonnaooa" +
    "pfaphapjarfarjas" +
    "latfathatjhtmoua" +
    "hufounhvbhvjavoa" +
    "wchwfawkhxdaxghx" +
    "hhxlayioymazevzn" +
    "aAiaBchBdaBgaBoh" +
    "CbhChaCioDaoDivE" +
    "h")
r(5255, "Rings", layout="0aahabfhbhabjacd" +
    "hcfachochhcjaclh" +
    "ddadfodfhdhvdhad" +
    "jodjhdlaebaedhef" +
    "aehoehhejaelaenh" +
    "fcaffhfhafjhfmag" +
    "caghagmhhchhmaic" +
    "aihaimhjcajfhjha" +
    "jjhjmakbakdhkfak" +
    "hokhhkjaklaknhld" +
    "alfolfhlhvlhaljo" +
    "ljhllamdhmfamhom" +
    "hhmjamlanfhnhanj" +
    "aoaaohaooaqaaqha" +
    "qoarfhrharjasdhs" +
    "fashoshhsjaslhtd" +
    "atfotfhthvthatjo" +
    "tjhtlaubaudhufau" +
    "houhhujaulaunhvc" +
    "avfhvhavjhvmawca" +
    "whawmhxchxmaycay" +
    "haymhzcazfhzhazj" +
    "hzmaAbaAdhAfaAho" +
    "AhhAjaAlaAnhBdaB" +
    "foBfhBhvBhaBjoBj" +
    "hBlaCdhCfaChoChh" +
    "CjaClaDfhDhaDjaE" +
    "h")
r(5256, "River Bridge", ncards=116, layout="0aafaalacfachacj" +
    "aclhdfhdhhdjhdlo" +
    "efoehoejoelvffvf" +
    "loggogiogkvhfhhh" +
    "hhjvhloigaiioiio" +
    "ikvjfhjhhjjvjlaj" +
    "oakcokgakiokiokk" +
    "akmakqalavlfhlhh" +
    "ljvllomgamiomiom" +
    "kvnfhnhhnjvnloog" +
    "aoiooiookvpfhphh" +
    "pjvploqgaqioqioq" +
    "kvrfhrhhrjvrlosg" +
    "asiosioskvtfhthh" +
    "tjvtlaucougauiou" +
    "ioukauoavavvfhvh" +
    "hvjvvlavmavqowga" +
    "wiowiowkvxfhxhhx" +
    "jvxloygoyioykvzf" +
    "vzloAfoAhoAjoAlh" +
    "BfhBhhBjhBlaCfaC" +
    "haCjaClaEfaEl")
#
r(5257, "Roman Arena", layout="0CaaCacCaeCagCai" +
    "vbbvbdvbfvbhCcao" +
    "ccoceocgCcivdbhd" +
    "dadehdfvdhCeaoec" +
    "oegCeivfbhfdafeh" +
    "ffvfhCgaogcoggCg" +
    "ivhbhhdahehhfvhh" +
    "CiaoicoigCiivjbh" +
    "jdajehjfvjhCkaok" +
    "cokgCkivlbhldale" +
    "hlfvlhCmaomcCmcC" +
    "meomgCmgCmivnbhn" +
    "dvndanehnfvnfvnh" +
    "CoaoocooeCoeoogC" +
    "oivpbhpdvpdapehp" +
    "fvpfvphCqaoqcCqc" +
    "CqeoqgCqgCqivrbh" +
    "rdarehrfvrhCsaos" +
    "cosgCsivtbhtdate" +
    "htfvthCuaoucougC" +
    "uivvbhvdavehvfvv" +
    "hCwaowcowgCwivxb" +
    "hxdaxehxfvxhCyao" +
    "ycoygCyivzbhzdaz" +
    "ehzfvzhCAaoAcoAe" +
    "oAgCAivBbvBdvBfv" +
    "BhCCaCCcCCeCCgCC" +
    "i")
r(5258, "Rugby", layout="0aafaahaceacgaci" +
    "aecaeeaegaeiaeka" +
    "gaagcagehgfagghg" +
    "hagiagkagmaiaaic" +
    "hidaiehifaighiha" +
    "iihijaikaimakahk" +
    "bakchkdakeikfakg" +
    "ikhakihkjakkhkla" +
    "kmamahmbamchmdam" +
    "eimfamgvmgimhami" +
    "hmjamkhmlammondo" +
    "njaoahobaochodao" +
    "evoeiofaogvogioh" +
    "aoivoihojaokhola" +
    "omopdopjaqahqbaq" +
    "chqdaqeiqfaqgvqg" +
    "iqhaqihqjaqkhqla" +
    "qmasahsbaschsdas" +
    "eisfasgishasihsj" +
    "askhslasmauaauch" +
    "udauehufaughuhau" +
    "ihujaukaumawaawc" +
    "awehwfawghwhawia" +
    "wkawmaycayeaygay" +
    "iaykaAeaAgaAiaCf" +
    "aCh")
r(5259, "Shapeshifter", layout="0aaoacmhcnacoaek" +
    "hemaenheoaepagih" +
    "gkaglogmhgnagohg" +
    "paiaaighiiaijoij" +
    "hilaimoinbiohjaa" +
    "kaokaakehkgakhok" +
    "hhkjakkokkokmhkn" +
    "akohkphlavlaamao" +
    "maamchmeamfomghm" +
    "hamiomiomkhmlamm" +
    "omnbmohnavnavngv" +
    "nivnkaoaooaCoaho" +
    "caodooehofaogoog" +
    "CogooiCoihojaoko" +
    "okCokoomhonaooho" +
    "phpavpavpgvpivpk" +
    "aqaoqaaqchqeaqfo" +
    "qghqhaqioqioqkhq" +
    "laqmoqnbqohravra" +
    "asaosaasehsgasho" +
    "shhsjaskoskosmhs" +
    "nasohsphtaauaaug" +
    "huiaujoujhulaumo" +
    "unbuoawihwkawlow" +
    "mhwnawohwpaykhym" +
    "aynhyoaypaAmhAna" +
    "AoaCo")
#
r(5260, "Space Bridge", layout="0aaaaacaaeaagaai" +
    "aakaamaaoaaqhbbh" +
    "bdhbfhbhhbjhblhb" +
    "nhbpacaoccoceocg" +
    "ociockocmocoacqh" +
    "dbvddvdfvdivdlvd" +
    "nhdpaeaoecCeeCei" +
    "Cemoeoaeqhfbvfdv" +
    "fnhfpagaogcogoag" +
    "qhhbhhpaiaoicoio" +
    "aiqhjbajfajlhjpa" +
    "kaokchkghkkokoak" +
    "qhlbvldClealholh" +
    "aljoljClmvlnhlpa" +
    "maomchmivmiomoam" +
    "qhnbanhonhanjonj" +
    "hnpaoaoochoghoko" +
    "ooaoqhpbapfaplhp" +
    "paqaoqcoqoaqqhrb" +
    "vrdvrnhrpasaoscC" +
    "seCsiCsmosoasqht" +
    "bvtdvtfvtivtlvtn" +
    "htpauaoucoueougo" +
    "uioukoumouoauqhv" +
    "bhvdhvfhvhhvjhvl" +
    "hvnhvpawaawcawea" +
    "wgawiawkawmawoaw" +
    "q")
r(5261, "Space Shuttle", layout="0aalaanacibckbcm" +
    "aeebegbeibekbemb" +
    "gcbgecggcgicgkcg" +
    "mbiacicciedigdii" +
    "dikdimckadkcekee" +
    "kgekiekkekmbmacm" +
    "ccmedmgdmidmkdmm" +
    "bocboecogcoicokc" +
    "omaqebqgbqibqkbq" +
    "masibskbsmaulaun")
r(5262, "Stage 1", layout="0aaebagaaiaccbce" +
    "ccgbciackaeabecc" +
    "eevefcegvehceibe" +
    "kaemagacgcdgedgg" +
    "dgicgkagmaiadicd" +
    "iedigdiidikaimak" +
    "adkcdkedkgdkidkk" +
    "akmamacmcdmedmgd" +
    "micmkammaoabocco" +
    "evofcogvohcoibok" +
    "aomaqcbqecqgbqia" +
    "qkasebsgasi")
r(5263, "Stage 2", layout="0aafaahaceacgaci" +
    "aeeaegaeiagcbgeb" +
    "ggbgiagkaiabicci" +
    "ecigciibikaimbka" +
    "ckcckeckgckickkb" +
    "kmbmaombbmcomdbm" +
    "epmfbmgpmhbmiomj" +
    "bmkomlbmmboaoobb" +
    "ocoodboepofbogpo" +
    "hboioojbokoolbom" +
    "bqacqccqecqgcqic" +
    "qkbqmasabsccsecs" +
    "gcsibskasmaucbue" +
    "bugbuiaukaweawga" +
    "wiayeaygayiaAfaA" +
    "h")
r(5264, "Stairs 2", layout="0aaadacaaedagaai" +
    "dakacadccacedcga" +
    "cidckbeadecbeede" +
    "gbeidekbgacgcbge" +
    "cggbgicgkciacicc" +
    "iecigciicikckabk" +
    "cckebkgckibkkdma" +
    "bmcdmebmgdmibmkd" +
    "oaaocdoeaogdoiao" +
    "kdqaaqcdqeaqgdqi" +
    "aqk")
r(5265, "Stairs 3", layout="0eaeeageaieakeam" +
    "dcfdchdcjdclcegc" +
    "eicekbgabghbgjbg" +
    "qaicaiiaioalfali" +
    "allhmibnaanibnqa" +
    "ocioiaoobpaapibp" +
    "qhqiarfariarlauc" +
    "auiauobwabwhbwjb" +
    "wqcygcyicykdAfdA" +
    "hdAjdAleCeeCgeCi" +
    "eCkeCm")
r(5266, "Stargate", layout="0hagobeabgobgobi" +
    "hcehcghcjoddadeo" +
    "dgadiodkhechelaf" +
    "cofcafgpfgafkofm" +
    "hgbhgghgnahaohap" +
    "hgahmohohiahilhi" +
    "pajaojavjcvjevjg" +
    "vjivjkajoojphkav" +
    "kaokdokfokhokjhk" +
    "palaolaClavlchle" +
    "hlghlivlkolpalqh" +
    "mavmaomdamfamhom" +
    "jhmpanaonaCnavnc" +
    "hnehnivnkanopnph" +
    "oavoaoodaofaohoo" +
    "jhopapaopaCpavpc" +
    "hpehpghpivpkoppa" +
    "pqhqavqaoqdoqfoq" +
    "hoqjhqparaoravrc" +
    "vrevrgvrivrkaroo" +
    "rphsahslhspataot" +
    "aptgatmotohubhug" +
    "hunavcovcavgpvga" +
    "vkovmhwchwloxdax" +
    "eoxgaxioxkhyehyg" +
    "hyjozeazgozgozih" +
    "Ag")
#
r(5267, "Sukis", layout="0aaaaacaaeaagaai" +
    "aakaamaaoaaqhbbh" +
    "bfhbjhbnacaaccac" +
    "eacgaciackacmaco" +
    "acqafaafcafeafga" +
    "fiafkafmafoafqhg" +
    "bhgpahaahcaheahg" +
    "ahiahkahmahoahqa" +
    "kahkbakcakeakgak" +
    "iakkakmakoakqhlp" +
    "amaamcameamgamia" +
    "mkammamoamqapaap" +
    "capeapgapiapkapm" +
    "apoapqhqbhqparaa" +
    "rcareargariarkar" +
    "maroarqauaaucaue" +
    "augauiaukaumauoa" +
    "uqhvpawahwbawcaw" +
    "eawgawiawkawmawo" +
    "awqazaazcazeazga" +
    "ziazkazmazoazqhA" +
    "bhApaBaaBcaBeaBg" +
    "aBiaBkaBmaBoaBqa" +
    "EaaEcaEeaEgaEiaE" +
    "kaEmaEoaEqhFbhFf" +
    "hFjhFnaGaaGcaGea" +
    "GgaGiaGkaGmaGoaG" +
    "q")
#
r(5268, "Temple 1", layout="0aaaaaeaaiabchbd" +
    "abghbhacahcbocca" +
    "cehcfocgaciadchd" +
    "dodeadghdhaeaheb" +
    "oecaeehefoegaeia" +
    "fchfdpfeafghfhag" +
    "ahgbogcagehgfogg" +
    "agiahchhdvhdohev" +
    "hfahghhhaiahiboi" +
    "caiehifoigaiiajc" +
    "hjdvjdojeCjevjfa" +
    "jghjhakahkbokcak" +
    "ehkfokgakialchld" +
    "vldoleClevlfalgh" +
    "lhamahmbomcamehm" +
    "fomgamianchndvnd" +
    "oneCnevnfanghnha" +
    "oahoboocaoehofoo" +
    "gaoiapchpdvpdope" +
    "vpfapghphaqahqbo" +
    "qcaqehqfoqgaqiar" +
    "chrdprearghrhasa" +
    "hsboscasehsfosga" +
    "siatchtdoteatght" +
    "hauahuboucauehuf" +
    "ougauiavchvdavgh" +
    "vhawaaweawi")
#
r(5269, "Temple 2", layout="0aacaagaakabahbb" +
    "abehbfabihbjacco" +
    "cchcdacgocghchac" +
    "kadahdbadeodehdf" +
    "adiodihdjaecoech" +
    "edaegoeghehaekaf" +
    "ahfbafeofehffafi" +
    "ofihfjagcogchgda" +
    "ggpgghghagkahahh" +
    "bahephehhfahiohi" +
    "hhjaicoichidaigp" +
    "ighihaikajahjbaj" +
    "epjehjfajiojihjj" +
    "akcokchkdakgpkgh" +
    "khakkalahlbalepl" +
    "ehlfaliolihljamc" +
    "omchmdamgpmghmha" +
    "mkanahnbaneonehn" +
    "fanionihnjaocooc" +
    "hodaogooghohaoka" +
    "pahpbapeopehpfap" +
    "iopihpjaqcoqchqd" +
    "aqgoqghqhaqkarah" +
    "rbareorehrfarior" +
    "ihrjaschsdasghsh" +
    "askataateati")
r(5270, "Totally Random-Made", layout="0aaevajaaoabbhbh" +
    "obioceCceacgaclC" +
    "clpcmhddvddwdhhd" +
    "moecaedCedoeghej" +
    "oenhffafgCfhafjo" +
    "fjCfkvfmagaCgfvg" +
    "gvgjhgkCgnahfohh" +
    "Chjahlohlahoaibh" +
    "ichieaihvihhiioj" +
    "cajdojeCjiojjwjl" +
    "ojookmhkovkoClcC" +
    "lfvlgolhvliCljpl" +
    "khlmvlmalpClpvmd" +
    "hmghmjammCmmCnco" +
    "ndCnganhCniankho" +
    "dvodaoeCoehofhoh" +
    "vohvokoolvomaooC" +
    "phopibplCpnvqhar" +
    "ahreorfCrharkhrl" +
    "ormasfashvsiCsjh" +
    "tfCthotiatjptnht" +
    "oaucoufhuhvuhauo" +
    "hvbavgovjCvjavkv" +
    "vkhwghwjawnawpbx" +
    "daxjoxkayfaymayo" +
    "aCdaCiaEiaFe")
r(5271, "Trika", layout="0hagaahiaiaajhak" +
    "abfablhceicihcma" +
    "ddoddodfadhvdhCd" +
    "iadjvdjodladnodn" +
    "heeieihemaffaflh" +
    "ggaghigiagjhgkci" +
    "iakgokghkhakioki" +
    "hkjakkokkhlfhlla" +
    "meomeamiammommhn" +
    "dhnnaocoocaogaoi" +
    "aokaooooohpbhphh" +
    "pjhppaqapqaaqehq" +
    "faqioqihqlaqmaqq" +
    "pqqhrbhrhhrjhrpa" +
    "scoscasgasiaskas" +
    "oosohtdhtnaueoue" +
    "auiaumoumhvfhvla" +
    "wgowghwhawiowihw" +
    "jawkowkcyihAgaAh" +
    "iAiaAjhAkaBfaBlh" +
    "CeiCihCmaDdoDdoD" +
    "faDhvDhCDiaDjvDj" +
    "oDlaDnoDnhEeiEih" +
    "EmaFfaFlhGgaGhiG" +
    "iaGjhGk")
r(5272, "Twin", layout="0aaeaagaaibccbce" +
    "bcgbcibckaeabecc" +
    "eecegceibekaemag" +
    "abgccgedggcgibgk" +
    "agmaiabicciecigc" +
    "iibikaimbkcbkebk" +
    "gbkibkkbmebmgbmi" +
    "bocboebogboiboka" +
    "qabqccqecqgcqibq" +
    "kaqmasabsccsedsg" +
    "csibskasmauabucc" +
    "uecugcuibukaumbw" +
    "cbwebwgbwibwkaye" +
    "aygayi")
#
r(5273, "Two Domes", layout="0aaiabghbiabkace" +
    "hcghckacmhdeodho" +
    "djhdmaecoefveioe" +
    "laeohfdvfgvfkhfn" +
    "agbogeCghCgjogma" +
    "gphhcvhfvhlhhoai" +
    "aoidCigCikoinaiq" +
    "hjcvjfajhvjlhjoa" +
    "kbokeCkhCkjokmak" +
    "phldvlgvlkhlnamc" +
    "omfvmiomlamohneo" +
    "nhonjhnmaoehogho" +
    "kaomapghpiapkaqe" +
    "hqgoqhaqivqioqjh" +
    "qkaqmarghriarkas" +
    "ehsghskasmhteoth" +
    "otjhtmaucoufvuio" +
    "ulauohvdvvgvvkhv" +
    "nawboweCwhCwjowm" +
    "awphxcvxfvxlhxoa" +
    "yaoydCygCykoynay" +
    "qhzcvzfazhvzlhzo" +
    "aAboAeCAhCAjoAma" +
    "AphBdvBgvBkhBnaC" +
    "coCfvCioClaCohDe" +
    "oDhoDjhDmaEehEgh" +
    "EkaEmaFghFiaFkaG" +
    "i")
#
r(5274, "Vagues", layout="0aacCaeaagCaiaak" +
    "Camhbcvbehbgvbih" +
    "bkvbmoccoceocgoc" +
    "iockocmvdchdevdg" +
    "hdivdkhdmCecaeeC" +
    "egaeiCekaemvfchf" +
    "evfghfivfkhfmaga" +
    "ogcogeoggogiogko" +
    "gmagohhahhcvhehh" +
    "gvhihhkvhmhhooia" +
    "aicCieaigCiiaikC" +
    "imoiovjahjcvjehj" +
    "gvjihjkvjmvjoCka" +
    "okcokeokgokiokko" +
    "kmCkovlavlchlevl" +
    "ghlivlkhlmvlooma" +
    "CmcameCmgamiCmka" +
    "mmomohnavnchnevn" +
    "ghnivnkhnmhnoaoa" +
    "oocooeoogooiooko" +
    "omaoohpcvpehpgvp" +
    "ihpkvpmaqcCqeaqg" +
    "CqiaqkCqmhrcvreh" +
    "rgvrihrkvrmoscos" +
    "eosgosioskosmvtc" +
    "htevtghtivtkhtmC" +
    "ucaueCugauiCukau" +
    "m")
r(5275, "Well2", layout="0aaaaacaaeaagaai" +
    "aakaamaaoacacccc" +
    "ceccgccicckccmac" +
    "oaeadecdeedegdei" +
    "dekdemaeoagadgcd" +
    "gedgkdgmagoaiadi" +
    "cdiedikdimaioaka" +
    "dkcdkedkgdkidkkd" +
    "kmakoamacmccmecm" +
    "gcmicmkcmmamoaoa" +
    "aocaoeaogaoiaoka" +
    "omaoo")
#
r(5276, "Whatever", layout="0oaeoaghbdhbfhbh" +
    "hcbaceoceacgocgh" +
    "cjadcadiheboeeoe" +
    "ghejafcafihgboge" +
    "ogghgjahcwhfahio" +
    "iahiboicoieoigoi" +
    "ihijoikajcvjdwjf" +
    "vjhajiokahkbokcC" +
    "kdokeokgCkhokihk" +
    "jokkalcvldwlfvlh" +
    "aliomahmbvmbomcC" +
    "mdomeomgCmhomihm" +
    "jvmjomkancvndwnf" +
    "vnhaniooahobvobo" +
    "ocCodooeoogCohoo" +
    "ihojvojookapcvpd" +
    "wpfvphapioqahqbo" +
    "qcCqdoqeoqgCqhoq" +
    "ihqjoqkarcvrdwrf" +
    "vrhariosahsbosco" +
    "seosgosihsjoskat" +
    "cwtfatihuboueoug" +
    "hujavcavihwboweo" +
    "wghwjaxcaxihybay" +
    "eoyeaygoyghyjhzd" +
    "hzfhzhoAeoAg")
r(5277, "Win", layout="0aaeaahaakaanbed" +
    "begbejbembepbheb" +
    "hhbhkbhnbhqbjdbj" +
    "gbjjbjmbjpbmcbme" +
    "bmgbmibmkbmmbmoc" +
    "occoicoocqbcqhcq" +
    "ncsbcshcsncuacuc" +
    "cuecugcuicukcumc" +
    "wbcwhcwncybcyhcy" +
    "ncAccAicAocCccCe" +
    "cCgcCicCkcCmcCo")
r(5278, "X-Files", layout="0aaaaaiaaqhbiacb" +
    "acgaciociackacph" +
    "dibecaeiaeoegdeg" +
    "neieeiidimdkfckl" +
    "ekpelbbmgbmkaocb" +
    "ohooibojaooaqahq" +
    "baqcoqchqdaqeaqi" +
    "aqmhqnaqooqohqpa" +
    "qqascbshosibsjas" +
    "obugbukewbcwfcwl" +
    "ewpdyeeyidymeAde" +
    "AnaCcaCiaCohDiaE" +
    "baEgaEioEiaEkaEp" +
    "hFiaGaaGiaGq")
r(5279, "X-Shape", layout="0aaibbabbqcdabdc" +
    "bdocdqaeicfacfcb" +
    "febfmcfocfqchabh" +
    "cchebhgbhkchmbho" +
    "chqbjabjecjgbjic" +
    "jkbjmbjqblgdlibl" +
    "kbnabnecngbnicnk" +
    "bnmbnqcpabpccpeb" +
    "pgbpkcpmbpocpqcr" +
    "acrcbrebrmcrocrq" +
    "asictabtcbtoctqb" +
    "vabvqawi")
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##
from . import mahjongg1  # noqa: F401
from . import mahjongg2  # noqa: F401
from . import mahjongg3  # noqa: F401
from . import shisensho  # noqa: F401
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.mfxutil import KwStruct
from pysollib.mygettext import _
from pysollib.tile.basetilemfxdialog import BaseTileMfxDialog
from pysollib.ui.tktile.solverdialog import BaseSolverDialog, solver_dialog

from .tkwidget import PysolCombo


# ************************************************************************
# *
# ************************************************************************

class SolverDialog(BaseSolverDialog, BaseTileMfxDialog):
    def _createGamesVar(self, frame, row):
        cb = PysolCombo(frame, values=tuple(self.gamenames),
                        selectcommand=self.gameSelected,
                        state='readonly', width=40)
        cb.grid(row=row, column=1, sticky='ew', padx=2, pady=2)
        return cb

    def _createPresetVar(self, frame, row):
        cb = PysolCombo(frame, values=tuple(self.presets), state='readonly',
                        selectcommand=self._OnAssignToPreset)
        cb.grid(row=row, column=1, sticky='ew', padx=2, pady=2)
        cb.current(0)
        return cb

    def _createShowProgressButton(self, frame):
        return self._calcToolkit().Checkbutton(
            frame, variable=self.progress_var,
            text=_('Show progress'))

    def initKw(self, kw):
        strings = [_('&Start'), _('&Play'), _('&New'), 'sep', _('&Close'), ]
        kw = KwStruct(kw,
                      strings=strings,
                      default=0,
                      )
        return self._calc_MfxDialog().initKw(self, kw)

    def connectGame(self, game):
        name = self.app.getGameTitleName(game.id)
        if name in self.gamenames:
            self.start_button.config(state='normal')
            i = self.gamenames.index(name)
            self.games_var.current(i)
        else:
            self.start_button.config(state='disabled')
            self.games_var.current(0)
        self.play_button.config(state='disabled')


solver_dialog = solver_dialog


def create_solver_dialog(parent, game):
    global solver_dialog
    try:
        solver_dialog.top.wm_deiconify()
        solver_dialog.top.tkraise()
    except Exception:
        # traceback.print_exc()
        solver_dialog = SolverDialog(parent, game)
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

# imports
import os
import sys

from pysollib.mygettext import _

import six
from six.moves import tkinter
from six.moves import tkinter_ttk as ttk

from .tkwidget import MfxTooltip

if __name__ == '__main__':
    d = os.path.abspath(os.path.join(sys.path[0], os.pardir, os.pardir))
    sys.path.append(d)
    import gettext
    gettext.install('pysol', d, unicode=True)

# ************************************************************************
# *
# ************************************************************************


class MfxStatusbar:
    def __init__(self, top, row, column, columnspan):
        self.top = top
        self._show = True
        self._widgets = []
        self._tooltips = []
        #
        self._row = row
        self._column = column
        self._columnspan = columnspan
        self._label_column = 0
        #
        self.padx = 1
        self.label_relief = 'sunken'
        self.top_frame = ttk.Frame(self.top)
        self.top_frame.grid(row=self._row, column=self._column,
                            columnspan=self._columnspan, sticky='ew')
        self.frame = ttk.Frame(self.top_frame)
        self.frame.pack(side='left', expand=True, fill='both', padx=0, pady=1)

    # util
    def _createLabel(self, name, expand=False, width=0, tooltip=None):
        frame = ttk.Frame(self.frame, borderwidth=1, relief=self.label_relief)
        frame.grid(row=0, column=self._label_column,
                   sticky='nsew', padx=self.padx)
        if expand:
            self.frame.grid_columnconfigure(self._label_column,
                                            weight=1)
        self._label_column += 1
        setattr(self, name + '_frame', frame)
        self._widgets.append(frame)
        label = ttk.Label(frame, width=width, anchor='center')
        label.pack(expand=True, fill='both')
        setattr(self, name + '_label', label)
        self._widgets.append(label)
        if tooltip:
            b = MfxTooltip(label)
            self._tooltips.append(b)
            b.setText(tooltip)
        return label

    def _createSizegrip(self):
        sg = ttk.Sizegrip(self.top_frame)
        sg.pack(side='right', anchor='se')

    #
    # public methods
    #

    def updateText(self, **kw):
        for k, v in kw.items():
            label = getattr(self, k + '_label')
            text = six.text_type(v)
            width = label['width']
            if width and len(text) > width:
                label['width'] = len(text)
            label['text'] = text

    def config(self, name, show):
        frame = getattr(self, name + '_frame')
        if show:
            frame.grid()
        else:
            frame.grid_remove()

    def configLabel(self, name, **kw):
        if 'fg' in kw:
            kw['foreground'] = kw['fg']
            del kw['fg']
        label = getattr(self, name + '_label')
        label.config(**kw)

    def show(self, show=True, resize=False):
        if self._show == show:
            return False
        if resize:
            self.top.wm_geometry('')    # cancel user-specified geometry
        if not show:
            # hide
            self.top_frame.grid_forget()
        else:
            # show
            self.top_frame.grid(row=self._row, column=self._column,
                                columnspan=self._columnspan, sticky='ew')
        self._show = show
        return True

    def hide(self, resize=False):
        self.show(False, resize)

    def destroy(self):
        for w in self._tooltips:
            if w:
                w.destroy()
        self._tooltips = []
        for w in self._widgets:
            if w:
                w.destroy()
        self._widgets = []


class PysolStatusbar(MfxStatusbar):
    def __init__(self, top):
        MfxStatusbar.__init__(self, top, row=4, column=0, columnspan=3)
        #
        for n, t, w in (
            ('stuck',       _("'You Are Stuck' indicator"), 3),
            ('time',        _('Playing time'),            10),
            ('moves',       _('Moves/Total moves'),       10),
            ('gamenumber',  _('Game number'),             26),
            ('stats',       _('Games played: won/lost'),  12),
                ):
            self._createLabel(n, tooltip=t, width=w)
        #
        label = self._createLabel('info', expand=True)
        label.config(padding=(8, 0))
        self._createSizegrip()


class HelpStatusbar(MfxStatusbar):
    def __init__(self, top):
        MfxStatusbar.__init__(self, top, row=3, column=0, columnspan=3)
        label = self._createLabel('info', expand=True)
        label.config(justify='left', anchor='w', padding=(8, 0))


class HtmlStatusbar(MfxStatusbar):
    def __init__(self, top, row, column, columnspan):
        MfxStatusbar.__init__(self, top, row=row, column=column,
                              columnspan=columnspan)
        label = self._createLabel('url', expand=True)
        label.config(justify='left', anchor='w', padding=(8, 0))
        self._createSizegrip()


# ************************************************************************
# *
# ************************************************************************


class TestStatusbar(PysolStatusbar):
    def __init__(self, top, args):
        PysolStatusbar.__init__(self, top)
        # test some settings
        self.updateText(moves=999, gamenumber='#0123456789ABCDEF0123')
        self.updateText(info='Some info text.')


def statusbar_main(args):
    tk = tkinter.Tk()
    TestStatusbar(tk, args)
    tk.mainloop()
    return 0


if __name__ == '__main__':
    sys.exit(statusbar_main(sys.argv))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.mfxutil import KwStruct
from pysollib.mygettext import _

from six.moves import tkinter
from six.moves import tkinter_ttk as ttk

from .tkwidget import MfxDialog


class PlayerOptionsDialog(MfxDialog):
    def __init__(self, parent, title, app, **kw):
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.createBitmaps(top_frame, kw)
        self.app = app
        #
        self.update_stats_var = tkinter.BooleanVar()
        self.update_stats_var.set(app.opt.update_player_stats != 0)
        self.confirm_var = tkinter.BooleanVar()
        self.confirm_var.set(app.opt.confirm != 0)
        self.win_animation_var = tkinter.BooleanVar()
        self.win_animation_var.set(app.opt.win_animation != 0)
        #
        frame = ttk.Frame(top_frame)
        frame.pack(expand=True, fill='both', padx=5, pady=10)
        widget = ttk.Label(frame, text=_("\nPlease enter your name"),
                           takefocus=0)
        widget.grid(row=0, column=0, columnspan=2, sticky='ew', padx=0, pady=5)
        #
        w = kw.get("e_width", 30)    # width in characters
        names = self.app.getAllUserNames()
        self.player_var = ttk.Combobox(frame, width=w, values=tuple(names))
        self.player_var.current(names.index(app.opt.player))
        self.player_var.grid(row=1, column=0, sticky='ew', padx=0, pady=5)
        #
        widget = ttk.Checkbutton(frame, variable=self.confirm_var,
                                 text=_("Confirm quit"))
        widget.grid(row=2, column=0, columnspan=2, sticky='ew', padx=0, pady=5)
        widget = ttk.Checkbutton(frame, variable=self.update_stats_var,
                                 text=_("Update statistics and logs"))
        widget.grid(row=3, column=0, columnspan=2, sticky='ew', padx=0, pady=5)
        #  widget = ttk.Checkbutton(frame, variable=self.win_animation_var,
        #                               text="Win animation")
        #  widget.pack(side='top', padx=kw.padx, pady=kw.pady)
        frame.columnconfigure(0, weight=1)
        #
        self.player = self.player_var.get()
        self.confirm = self.confirm_var.get()
        self.update_stats = self.update_stats_var.get()
        self.win_animation = self.win_animation_var.get()
        #
        focus = self.createButtons(bottom_frame, kw)
        self.mainloop(focus, kw.timeout)

    def mDone(self, button):
        self.button = button
        self.player = self.player_var.get()
        self.confirm = self.confirm_var.get()
        self.update_stats = self.update_stats_var.get()
        self.win_animation = self.win_animation_var.get()
        raise SystemExit

    def initKw(self, kw):
        kw = KwStruct(kw,
                      strings=(_("&OK"), _("&Cancel")), default=0,
                      padx=10, pady=10,
                      )
        return MfxDialog.initKw(self, kw)
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

import os

from pysollib.mfxutil import Image, ImageOps, ImageTk
from pysollib.mygettext import _, n_
from pysollib.settings import TITLE
from pysollib.ui.tktile.menubar import MfxMenu, createToolbarMenu
from pysollib.ui.tktile.tkconst import EVENT_HANDLED
from pysollib.ui.tktile.tkutil import loadImage
from pysollib.util import IMAGE_EXTENSIONS
from pysollib.winsystems import TkSettings

from six.moves import tkinter
from six.moves import tkinter_ttk as ttk

from .tkwidget import MfxTooltip


class AbstractToolbarButton:
    def __init__(self, parent, toolbar, toolbar_name, position):
        self.toolbar = toolbar
        self.toolbar_name = toolbar_name
        self.position = position
        self.visible = False

    def show(self, orient, force=False):
        if self.visible and not force:
            return
        self.visible = True
        if orient == 'horizontal':
            padx, pady = TkSettings.toolbar_button_padding
            self.grid(row=0,
                      column=self.position,
                      padx=padx, pady=pady,
                      sticky='nsew')
        else:
            pady, padx = TkSettings.toolbar_button_padding
            self.grid(row=self.position,
                      column=0,
                      padx=padx, pady=pady,
                      sticky='nsew')

    def hide(self):
        if not self.visible:
            return
        self.visible = False
        self.grid_forget()


class ToolbarCheckbutton(AbstractToolbarButton, ttk.Checkbutton):
    def __init__(self, parent, toolbar, toolbar_name, position, **kwargs):
        kwargs['style'] = 'Toolbutton'
        ttk.Checkbutton.__init__(self, parent, **kwargs)
        AbstractToolbarButton.__init__(
            self, parent, toolbar, toolbar_name, position)


class ToolbarButton(AbstractToolbarButton, ttk.Button):
    def __init__(self, parent, toolbar, toolbar_name, position, **kwargs):
        kwargs['style'] = 'Toolbutton'
        ttk.Button.__init__(self, parent, **kwargs)
        AbstractToolbarButton.__init__(
            self, parent, toolbar, toolbar_name, position)


class ToolbarSeparator(ttk.Separator):
    def __init__(self, parent, toolbar, position, **kwargs):
        kwargs['orient'] = 'vertical'
        ttk.Separator.__init__(self, parent, **kwargs)
        self.toolbar = toolbar
        self.position = position
        self.visible = False

    def show(self, orient, force=False):
        if self.visible and not force:
            return
        self.visible = True
        if orient == 'horizontal':
            padx, pady = 4, 6
            self.config(orient='vertical')
            self.grid(row=0,
                      column=self.position,
                      padx=padx, pady=pady,
                      sticky='nsew')
        else:
            padx, pady = 4, 6
            self.config(orient='horizontal')
            self.grid(row=self.position,
                      column=0,
                      padx=pady, pady=padx,
                      sticky='nsew')

    def hide(self):
        if not self.visible:
            return
        self.visible = False
        self.grid_forget()


class ToolbarLabel(tkinter.Message):
    def __init__(self, parent, toolbar, toolbar_name, position, **kwargs):
        tkinter.Message.__init__(self, parent, **kwargs)
        self.toolbar = toolbar
        self.toolbar_name = toolbar_name
        self.position = position
        self.visible = False

    def show(self, orient, force=False):
        if self.visible and not force:
            return
        self.visible = True
        padx, pady = TkSettings.toolbar_label_padding
        if orient == 'horizontal':
            self.grid(row=0,
                      column=self.position,
                      padx=padx, pady=pady,
                      sticky='nsew')
        else:
            self.grid(row=self.position,
                      column=0,
                      padx=padx, pady=pady,
                      sticky='nsew')

    def hide(self):
        if not self.visible:
            return
        self.visible = False
        self.grid_forget()


# ************************************************************************
# * Note: Applications should call show/hide after constructor.
# ************************************************************************

class PysolToolbarTk:

    def __init__(self, top, menubar, dir,
                 size=0, relief='flat', compound='none'):
        self.top = top
        self.menubar = menubar
        self.side = -1
        self._tooltips = []
        self._widgets = []
        self.dir = dir
        self.size = size
        self.compound = compound
        self.orient = 'horizontal'
        #
        self.frame = ttk.Frame(top, class_='Toolbar',
                               relief=TkSettings.toolbar_relief,
                               borderwidth=TkSettings.toolbar_borderwidth)
        #
        for label, f, t in (
            (n_("New"),      self.mNewGame,   _("New game")),
            (n_("Restart"),  self.mRestart,   _("Restart the\ncurrent game")),
            (None,           None,            None),
            (n_("Open"),     self.mOpen,      _("Open a\nsaved game")),
            (n_("Save"),     self.mSave,      _("Save game")),
            (None,           None,            None),
            (n_("Undo"),     self.mUndo,      _("Undo last move")),
            (n_("Redo"),     self.mRedo,      _("Redo last move")),
            (n_("Autodrop"), self.mDrop,      _("Auto drop cards")),
            (n_("Shuffle"),  self.mShuffle,   _("Shuffle tiles")),
            (n_("Pause"),    self.mPause,     _("Pause game")),
            (None,           None,            None),
            (n_("Statistics"), self.mPlayerStats, _("View statistics")),
            (n_("Rules"),    self.mHelpRules, _("Rules for this game")),
            (None,           None,            None),
            (n_("Quit"),     self.mQuit,      _("Quit %s") % TITLE),
                ):
            if label is None:
                sep = self._createSeparator()
                sep.bind("<3>", self.rightclickHandler)
            elif label == 'Pause':
                self._createButton(label, f, check=True, tooltip=t)
            else:
                self._createButton(label, f, tooltip=t)
        self.pause_button.config(variable=menubar.tkopt.pause)

        self.popup = MfxMenu(master=None, label=n_('Toolbar'), tearoff=0)
        createToolbarMenu(menubar, self.popup)

        position = len(self._widgets)
        self.frame.rowconfigure(position, weight=1)
        self.frame.columnconfigure(position, weight=1)
        #
        self._createLabel("player", label=n_('Player'),
                          tooltip=_("Player options"))
        #
        self.player_label.bind("<1>", self.mOptPlayerOptions)
        self.frame.bind("<3>", self.rightclickHandler)
        #
        self.setCompound(compound, force=True)

    def config(self, w, v):
        if w == 'player':
            # label
            if v:
                self.player_label.show(orient=self.orient)
            else:
                self.player_label.hide()
        else:
            # button
            widget = getattr(self, w+'_button')
            if v:
                widget.show(orient=self.orient)
            else:
                widget.hide()
        #
        prev_visible = None
        last_visible = None
        for w in self._widgets:
            if isinstance(w, ToolbarSeparator):
                if prev_visible is None or isinstance(prev_visible,
                                                      ToolbarSeparator):
                    w.hide()
                else:
                    w.show(orient=self.orient)
            if w.visible:
                prev_visible = w
                if not isinstance(w, ToolbarLabel):
                    last_visible = w
        if isinstance(last_visible, ToolbarSeparator):
            last_visible.hide()

    # util
    def _loadImage(self, name):
        file = os.path.join(self.dir, name)
        image = None
        for ext in IMAGE_EXTENSIONS:
            file = os.path.join(self.dir, name+ext)
            if os.path.isfile(file):
                image = loadImage(file=file)
                break
        return image

    def _createSeparator(self):
        position = len(self._widgets)
        sep = ToolbarSeparator(self.frame,
                               position=position,
                               toolbar=self,
                               takefocus=0)
        sep.show(orient=self.orient)
        self._widgets.append(sep)
        return sep

    def _createDisabledButtonImage(self, tkim):
        # grayscale and light-up image
        if not tkim:
            return None
        im = tkim._pil_image
        dis_im = ImageOps.grayscale(im)
        # color = '#ffffff'
        # factor = 0.6
        color = '#dedede'
        factor = 0.7
        sh = Image.new(dis_im.mode, dis_im.size, color)
        tmp = Image.blend(dis_im, sh, factor)
        dis_im = Image.composite(tmp, im, im)
        dis_tkim = ImageTk.PhotoImage(image=dis_im)
        return dis_tkim

    def _setButtonImage(self, button, name):
        image = self._loadImage(name)
        setattr(self, name + "_image", image)
        if Image:
            dis_image = self._createDisabledButtonImage(image)
            if dis_image:
                setattr(self, name + "_disabled_image", dis_image)
                button.config(image=(image, 'disabled', dis_image))
        else:
            button.config(image=image)

    def _createButton(self, label, command, check=False, tooltip=None):
        name = label.lower()
        position = len(self._widgets)
        kw = {
            'position': position,
            'toolbar': self,
            'toolbar_name': name,
            'command': command,
            'takefocus': 0,
            'text': _(label),
            }

        if check:
            button = ToolbarCheckbutton(self.frame, **kw)
        else:
            button = ToolbarButton(self.frame, **kw)
        self._setButtonImage(button, name)
        button.show(orient=self.orient)
        setattr(self, name + "_button", button)
        self._widgets.append(button)
        if tooltip:
            b = MfxTooltip(button)
            self._tooltips.append(b)
            b.setText(tooltip)
        return button

    def _createLabel(self, name, label=None, tooltip=None):
        aspect = (400, 300)[self.getSize() != 0]
        position = len(self._widgets)+1
        label = ToolbarLabel(self.frame,
                             position=position,
                             toolbar=self,
                             toolbar_name=name,
                             relief="ridge",
                             justify="center",
                             aspect=aspect)
        label.show(orient=self.orient)
        setattr(self, name + "_label", label)
        self._widgets.append(label)
        if tooltip:
            b = MfxTooltip(label)
            self._tooltips.append(b)
            b.setText(tooltip)
        return label

    def _busy(self):
        if not self.side or not self.game or not self.menubar:
            return 1
        self.game.stopDemo()
        self.game.interruptSleep()
        return self.game.busy

    #
    # public methods
    #

    def show(self, side=1, resize=1):
        if self.side == side:
            return 0
        if resize:
            self.top.wm_geometry("")    # cancel user-specified geometry
        if not side:
            # hide
            self.frame.grid_forget()
        else:
            # show
            pack_func = self.frame.grid_configure

            if side == 1:
                # top
                padx, pady = TkSettings.horizontal_toolbar_padding
                pack_func(row=0, column=1, sticky='ew', padx=padx, pady=pady)
            elif side == 2:
                # bottom
                padx, pady = TkSettings.horizontal_toolbar_padding
                pack_func(row=2, column=1, sticky='ew', padx=padx, pady=pady)
            elif side == 3:
                # left
                padx, pady = TkSettings.vertical_toolbar_padding
                pack_func(row=1, column=0, sticky='ns', padx=padx, pady=pady)
            else:
                # right
                padx, pady = TkSettings.vertical_toolbar_padding
                pack_func(row=1, column=2, sticky='ns', padx=padx, pady=pady)
            # set orient
            orient = side in (1, 2) and 'horizontal' or 'vertical'
            self._setOrient(orient)
        self.side = side
        return 1

    def hide(self, resize=1):
        self.show(0, resize)

    def destroy(self):
        for w in self._tooltips:
            if w:
                w.destroy()
        self._tooltips = []
        for w in self._widgets:
            if w:
                w.destroy()
        self._widgets = []

    def setCursor(self, cursor):
        if self.side:
            self.frame.config(cursor=cursor)
            self.frame.update_idletasks()

    def updateText(self, **kw):
        for name in kw.keys():
            label = getattr(self, name + "_label")
            label["text"] = kw[name]

    def updateImages(self, dir, size):
        if dir == self.dir and size == self.size:
            return 0
        if not os.path.isdir(dir):
            return 0
        self.dir, self.size = dir, size
        data = []
        for w in self._widgets:
            if not isinstance(w, (ToolbarButton, ToolbarCheckbutton)):
                continue
            name = w.toolbar_name
            data.append((name, w))
        label = self.player_label
        aspect = (400, 300)[size != 0]
        label.config(aspect=aspect)
        for name, w in data:
            self._setButtonImage(w, name)
        self.setCompound(self.compound, force=True)
        return 1

    def setCompound(self, compound, force=False):
        if not force and self.compound == compound:
            return False
        for w in self._widgets:
            if not isinstance(w, (ToolbarButton, ToolbarCheckbutton)):
                continue
            w.config(compound=compound)
        self.compound = compound
        return True

    def _setOrient(self, orient='horizontal', force=False):
        if not force and self.orient == orient:
            return False
        for w in self._widgets:
            if w.visible:
                w.show(orient=orient, force=True)
        self.orient = orient
        return True

    #
    # Mouse event handlers
    #

    def rightclickHandler(self, event):
        if self._busy():
            return EVENT_HANDLED
        if self.popup:
            self.popup.tk_popup(event.x_root, event.y_root)
        return EVENT_HANDLED

    def getSize(self):
        if self.compound == 'text':
            return 0
        size = self.size
        comp = int(self.compound in ('top', 'bottom'))
        return int((size+comp) != 0)
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.ui.tktile.selecttree import BaseSelectDialogTreeCanvas
from pysollib.ui.tktile.selecttree import BaseSelectDialogTreeLeaf
from pysollib.ui.tktile.selecttree import BaseSelectDialogTreeNode

from .tktree import MfxTreeInCanvas, MfxTreeLeaf, MfxTreeNode

# ************************************************************************
# * Nodes
# ************************************************************************


class SelectDiagCommon:
    def _calc_MfxTreeNode(self):
        return MfxTreeNode

    def _calc_MfxTreeInCanvas(self):
        return MfxTreeInCanvas

    def _calc_MfxTreeLeaf(self):
        return MfxTreeLeaf


class SelectDialogTreeLeaf(SelectDiagCommon,
                           BaseSelectDialogTreeLeaf, MfxTreeLeaf):
    pass


class SelectDialogTreeNode(SelectDiagCommon,
                           BaseSelectDialogTreeNode, MfxTreeNode):
    pass

# ************************************************************************
# * Canvas that shows the tree (left side)
# ************************************************************************


class SelectDialogTreeCanvas(SelectDiagCommon,
                             BaseSelectDialogTreeCanvas, MfxTreeInCanvas):
    pass
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.mfxutil import KwStruct
from pysollib.mygettext import _

from six.moves import tkinter
from six.moves import tkinter_ttk as ttk

from .tkwidget import MfxDialog, PysolScale


class TimeoutsDialog(MfxDialog):
    def __init__(self, parent, title, app, **kw):
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        # self.createBitmaps(top_frame, kw)

        frame = ttk.Frame(top_frame)
        frame.pack(expand=True, fill='both', padx=5, pady=10)
        frame.columnconfigure(0, weight=1)

        self.demo_sleep_var = tkinter.DoubleVar()
        self.demo_sleep_var.set(app.opt.timeouts['demo'])
        self.hint_sleep_var = tkinter.DoubleVar()
        self.hint_sleep_var.set(app.opt.timeouts['hint'])
        self.raise_card_sleep_var = tkinter.DoubleVar()
        self.raise_card_sleep_var.set(app.opt.timeouts['raise_card'])
        self.highlight_piles_sleep_var = tkinter.DoubleVar()
        self.highlight_piles_sleep_var.set(app.opt.timeouts['highlight_piles'])
        self.highlight_cards_sleep_var = tkinter.DoubleVar()
        self.highlight_cards_sleep_var.set(app.opt.timeouts['highlight_cards'])
        self.highlight_samerank_sleep_var = tkinter.DoubleVar()
        self.highlight_samerank_sleep_var.set(
            app.opt.timeouts['highlight_samerank'])
        #
        lframe = ttk.LabelFrame(frame, text=_('Set delays in seconds'),
                                padding=(10, 5))
        lframe.pack(expand=True, fill='both', padx=4)
        row = 0
        for title, var in (
            (_('Demo:'),                self.demo_sleep_var),
            (_('Hint:'),                self.hint_sleep_var),
            (_('Raise card:'),          self.raise_card_sleep_var),
            (_('Highlight piles:'),     self.highlight_piles_sleep_var),
            (_('Highlight cards:'),     self.highlight_cards_sleep_var),
            (_('Highlight same rank:'), self.highlight_samerank_sleep_var),
                ):
            ttk.Label(
                lframe, text=title, anchor='w').grid(
                    row=row, column=0, sticky='we')
            widget = PysolScale(lframe, from_=0.2, to=9.9, value=var.get(),
                                resolution=0.1, orient='horizontal',
                                length="3i", variable=var, takefocus=0)
            widget.grid(row=row, column=1)
            row += 1
        #
        focus = self.createButtons(bottom_frame, kw)
        self.mainloop(focus, kw.timeout)
        #
        self.demo_timeout = self.demo_sleep_var.get()
        self.hint_timeout = self.hint_sleep_var.get()
        self.raise_card_timeout = self.raise_card_sleep_var.get()
        self.highlight_piles_timeout = self.highlight_piles_sleep_var.get()
        self.highlight_cards_timeout = self.highlight_cards_sleep_var.get()
        self.highlight_samerank_timeout = \
            self.highlight_samerank_sleep_var.get()

    def initKw(self, kw):
        kw = KwStruct(kw,
                      strings=(_("&OK"), _("&Cancel")), default=0,
                      padx=10, pady=10,
                      )
        return MfxDialog.initKw(self, kw)
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

import os

from pysollib.mfxutil import KwStruct
from pysollib.mygettext import _
from pysollib.pysolaudio import pysolsoundserver
from pysollib.settings import TITLE
from pysollib.ui.tktile.tkconst import EVENT_HANDLED

from six.moves import tkinter
from six.moves import tkinter_ttk as ttk

from .tkwidget import MfxDialog, MfxMessageDialog
from .tkwidget import PysolScale


class SoundOptionsDialog(MfxDialog):

    def __init__(self, parent, title, app, **kw):
        self.app = app
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.createBitmaps(top_frame, kw)
        #
        self.saved_opt = app.opt.copy()
        self.sound = tkinter.BooleanVar()
        self.sound.set(app.opt.sound != 0)
        self.sound_mode = tkinter.BooleanVar()
        self.sound_mode.set(app.opt.sound_mode != 0)
        self.sample_volume = tkinter.IntVar()
        self.sample_volume.set(app.opt.sound_sample_volume)
        self.music_volume = tkinter.IntVar()
        self.music_volume.set(app.opt.sound_music_volume)
        self.samples = [
            ('areyousure',    _('Are You Sure'),   tkinter.BooleanVar()),

            ('deal',          _('Deal'),           tkinter.BooleanVar()),
            ('dealwaste',     _('Deal waste'),     tkinter.BooleanVar()),

            ('turnwaste',     _('Turn waste'),     tkinter.BooleanVar()),
            ('startdrag',     _('Start drag'),     tkinter.BooleanVar()),

            ('drop',          _('Drop'),           tkinter.BooleanVar()),
            ('droppair',      _('Drop pair'),      tkinter.BooleanVar()),
            ('autodrop',      _('Auto drop'),      tkinter.BooleanVar()),

            ('flip',          _('Flip'),           tkinter.BooleanVar()),
            ('autoflip',      _('Auto flip'),      tkinter.BooleanVar()),
            ('move',          _('Move'),           tkinter.BooleanVar()),
            ('nomove',        _('No move'),        tkinter.BooleanVar()),

            ('undo',          _('Undo'),           tkinter.BooleanVar()),
            ('redo',          _('Redo'),           tkinter.BooleanVar()),

            ('autopilotlost', _('Autopilot lost'), tkinter.BooleanVar()),
            ('autopilotwon',  _('Autopilot won'),  tkinter.BooleanVar()),

            ('gamefinished',  _('Game finished'),  tkinter.BooleanVar()),
            ('gamelost',      _('Game lost'),      tkinter.BooleanVar()),
            ('gamewon',       _('Game won'),       tkinter.BooleanVar()),
            ('gameperfect',   _('Perfect game'),   tkinter.BooleanVar()),
            ]

        #
        frame = ttk.Frame(top_frame)
        frame.pack(expand=True, fill='both', padx=5, pady=5)
        frame.columnconfigure(1, weight=1)
        #
        row = 0
        w = ttk.Checkbutton(frame, variable=self.sound,
                            text=_("Sound enabled"))
        w.grid(row=row, column=0, columnspan=2, sticky='ew')
        #
        if os.name == "nt" and pysolsoundserver:
            row += 1
            w = ttk.Checkbutton(frame, variable=self.sound_mode,
                                text=_("Use DirectX for sound playing"),
                                command=self.mOptSoundDirectX)
            w.grid(row=row, column=0, columnspan=2, sticky='ew')
        #
        if app.audio.CAN_PLAY_MUSIC:  # and app.startup_opt.sound_mode > 0:
            row += 1
            ttk.Label(frame, text=_('Sample volume:'), anchor='w'
                      ).grid(row=row, column=0, sticky='ew')
            w = PysolScale(frame, from_=0, to=128, resolution=1,
                           orient='horizontal', takefocus=0,
                           length="3i",  # label=_('Sample volume'),
                           variable=self.sample_volume)
            w.grid(row=row, column=1, sticky='w', padx=5)
            row += 1
            ttk.Label(frame, text=_('Music volume:'), anchor='w'
                      ).grid(row=row, column=0, sticky='ew')
            w = PysolScale(frame, from_=0, to=128, resolution=1,
                           orient='horizontal', takefocus=0,
                           length="3i",  # label=_('Music volume'),
                           variable=self.music_volume)
            w.grid(row=row, column=1, sticky='w', padx=5)

        else:
            # remove "Apply" button
            kw.strings[1] = None
        #
        frame = ttk.LabelFrame(top_frame, text=_('Enable samples'))
        frame.pack(expand=True, fill='both', padx=5, pady=5)
        frame.columnconfigure(0, weight=1)
        frame.columnconfigure(1, weight=1)
        #
        row = 0
        col = 0
        for n, t, v in self.samples:
            v.set(app.opt.sound_samples[n])
            w = ttk.Checkbutton(frame, text=t, variable=v)
            w.grid(row=row, column=col, sticky='ew', padx=3, pady=1)
            if col == 1:
                col = 0
                row += 1
            else:
                col = 1
        #
        top_frame.columnconfigure(1, weight=1)
        #
        focus = self.createButtons(bottom_frame, kw)
        self.mainloop(focus, kw.timeout)

    def initKw(self, kw):
        strings = [_("&OK"), _("&Apply"), _("&Cancel"), ]
        kw = KwStruct(kw,
                      strings=strings,
                      default=0,
                      )
        return MfxDialog.initKw(self, kw)

    def mDone(self, button):
        if button == 0 or button == 1:
            self.app.opt.sound = self.sound.get()
            self.app.opt.sound_mode = int(self.sound_mode.get())
            self.app.opt.sound_sample_volume = self.sample_volume.get()
            self.app.opt.sound_music_volume = self.music_volume.get()
            for n, t, v in self.samples:
                self.app.opt.sound_samples[n] = v.get()
        elif button == 2:
            self.app.opt = self.saved_opt
        if self.app.audio:
            self.app.audio.updateSettings()
            if button == 1:
                self.app.audio.playSample("drop", priority=1000)
        if button == 1:
            return EVENT_HANDLED
        return MfxDialog.mDone(self, button)

    def mCancel(self, *event):
        return self.mDone(2)

    def wmDeleteWindow(self, *event):
        return self.mDone(0)

    def mOptSoundDirectX(self, *event):
        # print self.sound_mode.get()
        MfxMessageDialog(
            self.top, title=_("Sound preferences info"),
            text=_("""\
Changing DirectX settings will take effect
the next time you restart """)+TITLE,
            bitmap="warning",
            default=0, strings=(_("&OK"),))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.tile.basetilemfxdialog import BaseTileMfxDialog
from pysollib.ui.tktile.colorsdialog import BaseColorsDialog

# ************************************************************************
# *
# ************************************************************************


class ColorsDialog(BaseColorsDialog, BaseTileMfxDialog):
    pass
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

import os
import time

from pysollib.mfxutil import KwStruct
from pysollib.mfxutil import format_time
from pysollib.mygettext import _
from pysollib.settings import TOP_TITLE
from pysollib.stats import ProgressionFormatter, PysolStatsFormatter
from pysollib.ui.tktile.tkutil import bind, loadImage

from six.moves import tkinter
from six.moves import tkinter_font
from six.moves import tkinter_ttk as ttk

from .tkwidget import MfxDialog, MfxMessageDialog


# ************************************************************************
# *
# ************************************************************************

class StatsDialog(MfxDialog):
    SELECTED_TAB = 0

    def __init__(self, parent, title, app, player, gameid, **kw):

        kw = self.initKw(kw)
        title = _('Statistics')
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)

        self.font = app.getFont('default')
        self.tkfont = tkinter_font.Font(parent, self.font)
        self.font_metrics = self.tkfont.metrics()
        style = ttk.Style(parent)
        heading_font = style.lookup('Heading', 'font')  # treeview heading
        self.heading_tkfont = tkinter_font.Font(parent, heading_font)

        self.selected_game = None

        top_frame, bottom_frame = self.createFrames(kw)
        notebook = ttk.Notebook(top_frame)
        notebook.pack(expand=True, fill='both', padx=10, pady=10)

        self.notebook_tabs = []

        single_frame = SingleGameFrame(self, notebook, app, player, gameid)
        notebook.add(single_frame, text=_('Current game'))
        self.notebook_tabs.append(single_frame._w)

        all_frame = AllGamesFrame(self, notebook, app, player)
        notebook.add(all_frame, text=_('All games'))
        self.all_games_frame = all_frame
        self.notebook_tabs.append(all_frame._w)

        top_frame = TopFrame(self, notebook, app, player, gameid)
        notebook.add(top_frame, text=TOP_TITLE)
        self.notebook_tabs.append(top_frame._w)

        if player is not None:
            progr_frame = ProgressionFrame(self, notebook, app, player, gameid)
            notebook.add(progr_frame, text=_('Progression'))
            self.notebook_tabs.append(progr_frame._w)

        if StatsDialog.SELECTED_TAB < len(self.notebook_tabs):
            notebook.select(StatsDialog.SELECTED_TAB)
        bind(notebook, '<<NotebookTabChanged>>', self.tabChanged)
        # notebook.enableTraversal()
        self.notebook = notebook

        focus = self.createButtons(bottom_frame, kw)
        self.tabChanged()               # configure buttons state
        self.mainloop(focus, kw.timeout)

    def initKw(self, kw):
        kw = KwStruct(
            kw,
            strings=((_("&Play this game"), 401),
                     "sep", _("&OK"),
                     (_("&Reset..."), 500)),
            default=0,
            separator=False,
        )
        return MfxDialog.initKw(self, kw)

    def tabChanged(self, *args):
        w = self.notebook.select()
        run_button = self.buttons[0]
        indx = self.notebook_tabs.index(w)
        if indx == 1:                   # "All games"
            g = self.all_games_frame.getSelectedGame()
            if g is None:
                run_button.config(state='disabled')
            else:
                run_button.config(state='normal')
        else:
            run_button.config(state='disabled')
        reset_button = self.buttons[2]
        if indx in (0, 1):              # "Current game" or "All games"
            reset_button.config(state='normal')
        else:
            reset_button.config(state='disabled')

    def mDone(self, button):
        self.selected_game = self.all_games_frame.getSelectedGame()
        w = self.notebook.select()
        indx = self.notebook_tabs.index(w)
        StatsDialog.SELECTED_TAB = indx
        if button == 500:               # "Reset..."
            assert indx in (0, 1)
            if indx == 0:               # "Current game"
                button = 302
            else:                       # "All games"
                button = 301
        MfxDialog.mDone(self, button)


SingleGame_StatsDialog = AllGames_StatsDialog = Top_StatsDialog = \
        ProgressionDialog = StatsDialog


# ************************************************************************
# *
# ************************************************************************

class SingleGameFrame(ttk.Frame):
    def __init__(self, dialog, parent, app, player, gameid, **kw):
        ttk.Frame.__init__(self, parent)

        self.oval_width = 120
        self.oval_height = 60

        left_label = ttk.Label(self, image=app.gimages.logos[5])
        left_label.pack(side='left', expand=True, fill='both')
        self.right_frame = ttk.Frame(self)
        self.right_frame.pack(side='right', expand=True)

        self.dialog = dialog
        self.app = app
        self.parent = parent
        self.player = player or _("Demo games")
        #
        self._calc_tabs()
        #
        won, lost = app.stats.getStats(player, gameid)
        self.createPieChart(app, won, lost, _("Total"))
        won, lost = app.stats.getSessionStats(player, gameid)
        self.createPieChart(app, won, lost, _("Current session"))
        #

    #
    # helpers
    #

    def _calc_tabs(self):
        #
        font = self.dialog.tkfont
        t0 = self.oval_width+70
        t = ''
        for i in (_("Won:"),
                  _("Lost:"),
                  _("Total:")):
            if len(i) > len(t):
                t = i
        t1 = font.measure(t)
        #  t1 = max(font.measure(_("Won:")),
        #           font.measure(_("Lost:")),
        #           font.measure(_("Total:")))
        t1 += 10
        # t2 = font.measure('99999')+10
        t2 = 45
        # t3 = font.measure('100%')+10
        t3 = 45
        tx = (t0, t0+t1+t2, t0+t1+t2+t3, t0+t1+t2+t3+20)
        #
        ls = self.dialog.font_metrics['linespace']
        ls += 5
        # ls = max(ls, 20)
        ty = (5, 5+ls, 5+2*ls+15, max(85, 5+3*ls+15))
        #
        self.tab_x, self.tab_y = tx, ty

    def _getPwon(self, won, lost):
        pwon, plost = 0.0, 0.0
        if won + lost > 0:
            pwon = float(won) / (won + lost)
            pwon = min(max(pwon, 0.00001), 0.99999)
            plost = 1.0 - pwon
        return pwon, plost

    def _createChartInit(self, text):
        frame = ttk.LabelFrame(self.right_frame, text=text)
        frame.pack(side='top', fill='both', expand=False, padx=20, pady=10)
        style = ttk.Style(self.parent)
        fg = style.lookup('.', 'foreground') or None  # use default if fg == ''
        bg = style.lookup('.', 'background') or None
        self.fg = fg
        #
        w, h = self.tab_x[-1], max(self.tab_y[-1], self.oval_height+40)
        c = tkinter.Canvas(frame, width=w, height=h,
                           bg=bg, highlightthickness=0)
        c.pack(fill='both', expand=True)
        self.canvas = c

    def _createChartTexts(self, tx, ty, won, lost):
        c, tfont, fg = self.canvas, self.dialog.font, self.fg
        pwon, plost = self._getPwon(won, lost)
        #
        x = tx[0]
        dy = int(self.dialog.font_metrics['ascent']) - 10
        dy //= 2
        c.create_text(x, ty[0]-dy, text=_("Won:"),
                      anchor="nw", font=tfont, fill=fg)
        c.create_text(x, ty[1]-dy, text=_("Lost:"),
                      anchor="nw", font=tfont, fill=fg)
        c.create_text(x, ty[2]-dy, text=_("Total:"),
                      anchor="nw", font=tfont, fill=fg)
        x = tx[1] - 16
        c.create_text(x, ty[0]-dy, text="%d" % won,
                      anchor="ne", font=tfont, fill=fg)
        c.create_text(x, ty[1]-dy, text="%d" % lost,
                      anchor="ne", font=tfont, fill=fg)
        c.create_text(x, ty[2]-dy, text="%d" % (won + lost),
                      anchor="ne", font=tfont, fill=fg)
        y = ty[2] - 11
        c.create_line(tx[0], y, x, y, fill=fg)
        if won + lost > 0:
            x = tx[2]
            pw = int(round(100.0 * pwon))
            c.create_text(x, ty[0]-dy, text="%d%%" % pw,
                          anchor="ne", font=tfont, fill=fg)
            c.create_text(x, ty[1]-dy, text="%d%%" % (100-pw),
                          anchor="ne", font=tfont, fill=fg)

    def createPieChart(self, app, won, lost, text):
        # c, tfont, fg = self._createChartInit(frame, 300, 100, text)
        #
        self._createChartInit(text)
        c, tfont = self.canvas, self.dialog.font
        pwon, plost = self._getPwon(won, lost)
        #
        # tx = (160, 250, 280)
        # ty = (21, 41, 75)
        #
        tx, ty = self.tab_x, self.tab_y
        x0, y0 = 20, 10                 # base coords
        w = self.oval_width
        h = self.oval_height
        d = 9                           # delta
        if won + lost > 0:
            # s, ewon, elost = 90.0, -360.0 * pwon, -360.0 * plost
            s, ewon, elost = 0.0, 360.0 * pwon, 360.0 * plost
            c.create_arc(x0, y0+d, x0+w, y0+h+d, fill="#007f00",
                         start=s, extent=ewon)
            c.create_arc(x0, y0+d, x0+w, y0+h+d, fill="#7f0000",
                         start=s+ewon, extent=elost)
            c.create_arc(x0, y0,   x0+w, y0+h,   fill="#00ff00",
                         start=s, extent=ewon)
            c.create_arc(x0, y0,   x0+w, y0+h,   fill="#ff0000",
                         start=s+ewon, extent=elost)
            x, y = tx[0] - 25, ty[0]
            c.create_rectangle(x, y, x+10, y+10, fill="#00ff00")
            y = ty[1]
            c.create_rectangle(x, y, x+10, y+10, fill="#ff0000")
        else:
            c.create_oval(x0, y0+d, x0+w, y0+h+d, fill="#7f7f7f")
            c.create_oval(x0, y0,   x0+w, y0+h,   fill="#f0f0f0")
            c.create_text(x0+w//2, y0+h//2, text=_("No games"),
                          anchor="center", font=tfont, fill="#bfbfbf")
        #
        self._createChartTexts(tx, ty, won, lost)


# ************************************************************************
# *
# ************************************************************************

class TreeFormatter(PysolStatsFormatter):
    MAX_ROWS = 10000

    def __init__(self, app, tree, parent_window, font, w, h):
        self.app = app
        self.tree = tree
        self.parent_window = parent_window
        self.tkfont = font
        self.gameid = None
        self.gamenumber = None
        self._tabs = None
        self.w = w
        self.h = h

    def _calc_tabs(self, arg):
        if self.parent_window.tree_tabs:
            self._tabs = self.parent_window.tree_tabs
            return
        tw = 20*self.w
        # tw = 160
        self._tabs = [tw]
        measure = self.tkfont.measure
        for t in arg[1:]:
            tw = measure(t)+8
            self._tabs.append(tw)
        self._tabs.append(10)
        self.parent_window.tree_tabs = self._tabs

    def createHeader(self, player, header):
        i = 0
        for column in ('#0',) + self.parent_window.COLUMNS:
            text = header[i]
            self.tree.heading(
                column, text=text,
                command=lambda par=self.parent_window, col=column:
                    par.headerClick(col))
            self.tree.column(column, width=16)
            i += 1

    def resizeHeader(self, player, header, tree_width=0):
        if self._tabs is not None:
            return
        self._calc_tabs(header)
        # set first column width
        if tree_width != 0:
            tab = tree_width - sum(self._tabs[1:])
            tab = min(tree_width, self._tabs[0])
        else:
            tab = self._tabs[0]
        self.tree.column('#0', width=tab)
        # other column
        i = 1
        for column in self.parent_window.COLUMNS:
            tab = self._tabs[i]
            self.tree.column(column, width=tab)
            i += 1

    def writeStats(self, player, sort_by='name'):
        header = self.getStatHeader()
        tree_width = self.tree.winfo_width()
        self.resizeHeader(player, header, tree_width)

        for result in self.getStatResults(player, sort_by):
            # result == [name, won+lost, won, lost, time, moves, perc, id]
            t1, t2, t3, t4, t5, t6, t7, t8 = result
            id = self.tree.insert("", "end", text=t1,
                                  values=(t2, t3, t4, t5, t6, t7))
            self.parent_window.tree_items.append(id)
            self.parent_window.games[id] = t8

        total, played, won, lost, time_, moves, perc = self.getStatSummary()
        text = _("Total (%(played)d out of %(total)d games)") % {
            'played': played, 'total': total}
        id = self.tree.insert("", "end", text=text,
                              values=(won+lost, won, lost, time_, moves, perc))
        self.parent_window.tree_items.append(id)
        return 1

    def writeLog(self, player, prev_games):
        if not player or not prev_games:
            return 0
        num_rows = 0
        for result in self.getLogResults(player, prev_games):
            t1, t2, t3, t4, t5, t6 = result
            id = self.tree.insert("", "end", text=t1, values=(t2, t3, t4))
            self.parent_window.tree_items.append(id)
            num_rows += 1
            if num_rows > self.MAX_ROWS:
                break
        return 1

    def writeFullLog(self, player):
        prev_games = self.app.stats.prev_games.get(player)
        return self.writeLog(player, prev_games)

    def writeSessionLog(self, player):
        prev_games = self.app.stats.session_games.get(player)
        return self.writeLog(player, prev_games)


# ************************************************************************
# *
# ************************************************************************

class AllGamesFrame(ttk.Frame):

    COLUMNS = ('played', 'won', 'lost', 'time', 'moves', 'percent')

    def __init__(self, dialog, parent, app, player, **kw):
        ttk.Frame.__init__(self, parent)
        #
        self.dialog = dialog
        self.app = app
        self.CHAR_H = self.dialog.font_metrics['linespace']
        self.CHAR_W = self.dialog.tkfont.measure('M')
        #
        self.player = player
        self.sort_by = 'name'
        self.tree_items = []
        self.tree_tabs = None
        self.games = {}                 # tree_itemid: gameid
        #
        frame = ttk.Frame(self)
        frame.pack(fill='both', expand=True, padx=10, pady=10)
        vsb = ttk.Scrollbar(frame)
        vsb.grid(row=0, column=1, sticky='ns')
        self.tree = ttk.Treeview(frame, columns=self.COLUMNS,
                                 selectmode='browse')
        self.tree.grid(row=0, column=0, sticky='nsew')
        self.tree.config(yscrollcommand=vsb.set)
        vsb.config(command=self.tree.yview)
        frame.rowconfigure(0, weight=1)
        frame.columnconfigure(0, weight=1)
        hsb = ttk.Scrollbar(frame, orient='horizontal')
        hsb.grid(row=1, column=0, sticky='ew')
        self.tree.config(xscrollcommand=hsb.set)
        hsb.config(command=self.tree.xview)
        bind(self.tree, '<<TreeviewSelect>>', self.treeviewSelected)
        #
        self.formatter = TreeFormatter(self.app, self.tree, self,
                                       self.dialog.heading_tkfont,
                                       self.CHAR_W, self.CHAR_H)
        self.createHeader(player)
        bind(self.tree, '<Map>', self.mapEvent)

    def getSelectedGame(self):
        sel = self.tree.selection()
        if sel and len(sel) == 1:
            if sel[0] in self.games:
                return self.games[sel[0]]
        return None

    def treeviewSelected(self, *args):
        sel = self.tree.selection()
        run_button = self.dialog.buttons[0]
        if sel and len(sel) == 1:
            if sel[0] not in self.games:  # "Total"
                run_button.config(state='disabled')
            else:
                run_button.config(state='normal')
        else:
            run_button.config(state='disabled')

    def mapEvent(self, *args):
        if not self.tree_items:
            self.fillTreeview(self.player)

    def headerClick(self, column):
        if column == '#0':
            sort_by = 'name'
        else:
            sort_by = column
        if self.sort_by == sort_by:
            return
        self.sort_by = sort_by
        self.fillTreeview(self.player)

    def createHeader(self, player):
        header = self.formatter.getStatHeader()
        self.formatter.createHeader(player, header)

    def fillTreeview(self, player):
        if self.tree_items:
            self.tree.delete(tuple(self.tree_items))
            self.tree_items = []
        self.formatter.writeStats(player, sort_by=self.sort_by)
        if self.dialog.buttons:
            run_button = self.dialog.buttons[0]
            run_button.config(state='disabled')


# ************************************************************************
# *
# ************************************************************************

class LogDialog(MfxDialog):
    SELECTED_TAB = 0

    def __init__(self, parent, title, app, player, **kw):

        self.font = app.getFont('default')
        self.tkfont = tkinter_font.Font(parent, self.font)
        style = ttk.Style(parent)
        heading_font = style.lookup('Heading', 'font')  # treeview heading
        self.heading_tkfont = tkinter_font.Font(parent, heading_font)
        self.font_metrics = self.tkfont.metrics()

        self.CHAR_H = self.font_metrics['linespace']
        self.CHAR_W = self.tkfont.measure('M')

        kw = self.initKw(kw)
        title = _('Log')
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)

        # self.selected_game = None

        top_frame, bottom_frame = self.createFrames(kw)
        notebook = ttk.Notebook(top_frame)
        notebook.pack(expand=True, fill='both', padx=10, pady=10)

        self.notebook_tabs = []

        full_frame = FullLogFrame(self, notebook, app, player)
        notebook.add(full_frame, text=_('Full log'))
        self.notebook_tabs.append(full_frame._w)

        session_frame = SessionLogFrame(self, notebook, app, player)
        notebook.add(session_frame, text=_('Session log'))
        self.notebook_tabs.append(session_frame._w)

        notebook.select(LogDialog.SELECTED_TAB)
        #  bind(notebook, '<<NotebookTabChanged>>', self.tabChanged)

        self.notebook = notebook

        focus = self.createButtons(bottom_frame, kw)
        # self.tabChanged()               # configure buttons state
        self.mainloop(focus, kw.timeout)

    def initKw(self, kw):
        kw = KwStruct(kw,
                      strings=(_("&OK"),
                               (_("&Save to file"), 500)),
                      default=0,
                      width=76*self.CHAR_W,
                      separator=False,
                      )
        return MfxDialog.initKw(self, kw)

    def mDone(self, button):
        # self.selected_game = self.all_games_frame.getSelectedGame()
        w = self.notebook.select()
        indx = self.notebook_tabs.index(w)
        LogDialog.SELECTED_TAB = indx
        if button == 500:               # "Save to file"
            assert indx in (0, 1)
            if indx == 0:               # "Full log"
                button = 203
            else:                       # "Session log"
                button = 204
        MfxDialog.mDone(self, button)


FullLog_StatsDialog = SessionLog_StatsDialog = LogDialog


# ************************************************************************
# *
# ************************************************************************

class FullLogFrame(AllGamesFrame):

    COLUMNS = ('gamenumber', 'date', 'status')

    def __init__(self, dialog, parent, app, player, **kw):
        AllGamesFrame.__init__(self, dialog, parent, app, player, **kw)
        header = ('', '99999999999999999999', '9999-99-99  99:99',
                  'XXXXXXXXXXXX')
        self.formatter.resizeHeader(player, header)

    def createHeader(self, player):
        header = self.formatter.getLogHeader()
        self.formatter.createHeader(player, header)

    def fillTreeview(self, player):
        if self.tree_items:
            return
        self.formatter.writeFullLog(player)

    def treeviewSelected(self, *args):
        pass

    def headerClick(self, column):
        pass


class SessionLogFrame(FullLogFrame):
    def fillTreeview(self, player):
        if self.tree_items:
            return
        self.formatter.writeSessionLog(player)


# ************************************************************************
# *
# ************************************************************************

class Status_StatsDialog(MfxMessageDialog):
    def __init__(self, parent, game):
        stats, gstats = game.stats, game.gstats
        w1 = w2 = ""
        n = 0
        for s in game.s.foundations:
            n = n + len(s.cards)
        w1 = (_("Highlight piles: ") + str(stats.highlight_piles) + "\n" +
              _("Highlight cards: ") + str(stats.highlight_cards) + "\n" +
              _("Highlight same rank: ") +
              str(stats.highlight_samerank) + "\n")
        if game.s.talon:
            if game.gameinfo.redeals != 0:
                w2 = w2 + _("\nRedeals: ") + str(game.s.talon.round - 1)
            w2 = w2 + _("\nCards in Talon: ") + str(len(game.s.talon.cards))
        if game.s.waste and game.s.waste not in game.s.foundations:
            w2 = w2 + _("\nCards in Waste: ") + str(len(game.s.waste.cards))
        if game.s.foundations:
            w2 = w2 + _("\nCards in Foundations: ") + str(n)
        #
        date = time.strftime(
            "%Y-%m-%d %H:%M", time.localtime(game.gstats.start_time))
        MfxMessageDialog.__init__(
            self, parent, title=_("Game status"),
            text=game.getTitleName() + "\n" +
            game.getGameNumber(format=1) + "\n" +
            _("Playing time: ") + game.getTime() + "\n" +
            _("Started at: ") + date + "\n\n" +
            _("Moves: ") + str(game.moves.index) + "\n" +
            _("Undo moves: ") + str(stats.undo_moves) + "\n" +
            _("Bookmark moves: ") + str(gstats.goto_bookmark_moves) + "\n" +
            _("Demo moves: ") + str(stats.demo_moves) + "\n" +
            _("Total player moves: ") + str(stats.player_moves) + "\n" +
            _("Total moves in this game: ") + str(stats.total_moves) + "\n" +
            _("Hints: ") + str(stats.hints) + "\n" +
            "\n" +
            w1 + w2,
            strings=((_("&Statistics..."), 101),
                     'sep',
                     _("&OK")),
            image=game.app.gimages.logos[3],
            image_side="left", image_padx=20,
            padx=20,
            )


# ************************************************************************
# *
# ************************************************************************

class _TopDialog(MfxDialog):
    def __init__(self, parent, title, app, gameid, top, **kw):
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.createBitmaps(top_frame, kw)

        cnf = {'master': top_frame,
               'padding': (4, 1),
               }
        frame = ttk.Frame(**cnf)
        frame.pack(expand=True, fill='both', padx=10, pady=10)
        frame.columnconfigure(0, weight=1)
        cnf['master'] = frame
        cnf['text'] = _('N')
        label = ttk.Label(**cnf)
        label.grid(row=0, column=0, sticky='ew')
        if gameid == 'all':
            cnf['text'] = _('Game')
            label = ttk.Label(**cnf)
            label.grid(row=0, column=1, sticky='ew')
        cnf['text'] = _('Game number')
        label = ttk.Label(**cnf)
        label.grid(row=0, column=2, sticky='ew')
        cnf['text'] = _('Started at')
        label = ttk.Label(**cnf)
        label.grid(row=0, column=3, sticky='ew')
        cnf['text'] = _('Result')
        label = ttk.Label(**cnf)
        label.grid(row=0, column=4, sticky='ew')

        row = 1
        for i in top:
            # N
            cnf['text'] = str(row)
            label = ttk.Label(**cnf)
            label.grid(row=row, column=0, sticky='ew')
            if gameid == 'all':
                name = app.getGameTitleName(i.gameid)
                if name is None:
                    name = _("** UNKNOWN %d **") % i.gameid
                cnf['text'] = name
                label = ttk.Label(**cnf)
                label.grid(row=row, column=1, sticky='ew')
            # Game number
            cnf['text'] = '#'+str(i.game_number)
            label = ttk.Label(**cnf)
            label.grid(row=row, column=2, sticky='ew')
            # Start time
            t = time.strftime(
                '%Y-%m-%d %H:%M', time.localtime(i.game_start_time))
            cnf['text'] = t
            label = ttk.Label(**cnf)
            label.grid(row=row, column=3, sticky='ew')
            # Result
            if isinstance(i.value, float):
                # time
                s = format_time(i.value)
            else:
                # moves
                s = str(i.value)
            cnf['text'] = s
            label = ttk.Label(**cnf)
            label.grid(row=row, column=4, sticky='ew')
            row += 1

        focus = self.createButtons(bottom_frame, kw)
        self.mainloop(focus, kw.timeout)

    def initKw(self, kw):
        kw = KwStruct(kw, strings=(_('&OK'),), default=0, separator=True)
        return MfxDialog.initKw(self, kw)


class TopFrame(ttk.Frame):
    def __init__(self, dialog, parent, app, player, gameid):
        ttk.Frame.__init__(self, parent)

        self.app = app
        self.dialog = dialog

        left_label = ttk.Label(self, image=app.gimages.logos[5])
        left_label.pack(side='left', expand=True, fill='both')

        frame = ttk.LabelFrame(self, text=_('Current game'),
                               padding=(10, 5, 10, 10))
        frame.pack(side='top', expand=True, fill='x', padx=10, pady=10)
        # frame.columnconfigure(0, weight=1)
        if not self.createTopFrame(frame, player, gameid):
            ttk.Label(frame, text=_('No TOP for this game')
                      ).pack(padx=10, pady=10)

        frame = ttk.LabelFrame(self, text=_('All games'),
                               padding=(10, 5, 10, 10))
        frame.pack(side='top', expand=True, fill='x', padx=10, pady=10)
        # frame.columnconfigure(0, weight=1)
        if not self.createTopFrame(frame, player, 'all'):
            ttk.Label(frame, text=_('No TOP for all games')
                      ).pack(padx=10, pady=10)

    def createTopFrame(self, frame, player, gameid):
        app = self.app

        cond = (player not in app.stats.games_stats or
                gameid not in app.stats.games_stats[player] or
                not app.stats.games_stats[player][gameid].time_result.top)
        if cond:
            return False

        ttk.Label(frame, text=_('Minimum')
                  ).grid(row=0, column=1, padx=5, pady=5)
        ttk.Label(frame, text=_('Maximum')
                  ).grid(row=0, column=2, padx=5, pady=5)
        ttk.Label(frame, text=_('Average')
                  ).grid(row=0, column=3, padx=5, pady=5)
        # ttk.Label(frame, text=_('Total')).grid(row=0, column=4)

        s = app.stats.games_stats[player][gameid]

        row = 1
        ll = [
            (_('Playing time:'),
             format_time(s.time_result.min),
             format_time(s.time_result.max),
             format_time(s.time_result.average),
             format_time(s.time_result.total),
             s.time_result.top,
             ),
            (_('Moves:'),
             s.moves_result.min,
             s.moves_result.max,
             round(s.moves_result.average, 2),
             s.moves_result.total,
             s.moves_result.top,
             ),
            (_('Total moves:'),
             s.total_moves_result.min,
             s.total_moves_result.max,
             round(s.total_moves_result.average, 2),
             s.total_moves_result.total,
             s.total_moves_result.top,
             ),
            ]
        #  if s.score_result.min:
        #      ll.append(('Score:',
        #                 s.score_result.min,
        #                 s.score_result.max,
        #                 round(s.score_result.average, 2),
        #                 s.score_result.top,
        #                 ))
        #  if s.score_casino_result.min:
        #      ll.append(('Casino Score:',
        #                 s.score_casino_result.min,
        #                 s.score_casino_result.max,
        #                 round(s.score_casino_result.average, 2), ))
        for l, min, max, avr, tot, top in ll:
            ttk.Label(frame, text=l
                      ).grid(row=row, column=0, padx=5, pady=5)
            ttk.Label(frame, text=str(min)
                      ).grid(row=row, column=1, padx=5, pady=5)
            ttk.Label(frame, text=str(max)
                      ).grid(row=row, column=2, padx=5, pady=5)
            ttk.Label(frame, text=str(avr)
                      ).grid(row=row, column=3, padx=5, pady=5)
            # ttk.Label(frame, text=str(tot)).grid(row=row, column=4)

            def command(gameid=gameid, top=top):
                self.showTop(gameid, top)
            b = ttk.Button(frame, text=TOP_TITLE+' ...',
                           width=10, command=command)
            b.grid(row=row, column=5)
            row += 1
        return True

    def showTop(self, gameid, top):
        _TopDialog(self.dialog.top, TOP_TITLE, self.app, gameid, top)


# ************************************************************************
# *
# ************************************************************************

class ProgressionFrame(ttk.Frame):

    def __init__(self, dialog, parent, app, player, gameid, **kw):
        ttk.Frame.__init__(self, parent)

        self.mapped = False

        self.dialog = dialog
        self.app = app
        self.player = player
        self.gameid = gameid
        self.items = []
        self.formatter = ProgressionFormatter(app, player, gameid)

        frame = ttk.Frame(self)
        frame.pack(expand=True, fill='both', padx=5, pady=10)
        frame.columnconfigure(0, weight=1)

        # constants
        w = dialog.tkfont.measure('M') * 42
        w = max(w, 500)
        w = min(w, 600)
        self.canvas_width, self.canvas_height = w, 250
        cond = parent.winfo_screenwidth() < 800 or \
            parent.winfo_screenheight() < 600
        if cond:
            self.canvas_width, self.canvas_height = 400, 200
        self.xmargin, self.ymargin = 10, 10
        self.graph_dx, self.graph_dy = 10, 10
        self.played_color = '#ff7ee9'
        self.won_color = '#00dc28'
        self.percent_color = 'blue'
        # create canvas
        self.canvas = canvas = tkinter.Canvas(frame, bg='#dfe8ff', bd=0,
                                              highlightthickness=1,
                                              highlightbackground='black',
                                              width=self.canvas_width,
                                              height=self.canvas_height)
        canvas.pack(side='left', padx=5)

        # right frame
        right_frame = ttk.Frame(frame)
        right_frame.pack(side='left', fill='x', padx=5)
        self.all_games_variable = var = tkinter.StringVar()
        var.set('all')
        b = ttk.Radiobutton(right_frame, text=_('All games'),
                            variable=var, value='all',
                            command=self.updateGraph)
        b.pack(fill='x', expand=True, padx=3, pady=1)
        b = ttk.Radiobutton(right_frame, text=_('Current game'),
                            variable=var, value='current',
                            command=self.updateGraph)
        b.pack(fill='x', expand=True, padx=3, pady=1)
        label_frame = ttk.LabelFrame(right_frame, text=_('Statistics for'))
        label_frame.pack(side='top', fill='x', pady=10)
        self.variable = var = tkinter.StringVar()
        var.set('week')
        for v, t in (
            ('week',  _('Last 7 days')),
            ('month', _('Last month')),
            ('year',  _('Last year')),
            ('all',   _('All time')),
                ):
            b = ttk.Radiobutton(label_frame, text=t, variable=var,
                                value=v, command=self.updateGraph)
            b.pack(fill='x', expand=True, padx=3, pady=1)
        label_frame = ttk.LabelFrame(right_frame, text=_('Show graphs'))
        label_frame.pack(side='top', fill='x')
        self.played_graph_var = tkinter.BooleanVar()
        self.played_graph_var.set(True)
        b = ttk.Checkbutton(label_frame, text=_('Played'),
                            command=self.updateGraph,
                            variable=self.played_graph_var)
        b.pack(fill='x', expand=True, padx=3, pady=1)
        self.won_graph_var = tkinter.BooleanVar()
        self.won_graph_var.set(True)
        b = ttk.Checkbutton(label_frame, text=_('Won'),
                            command=self.updateGraph,
                            variable=self.won_graph_var)
        b.pack(fill='x', expand=True, padx=3, pady=1)
        self.percent_graph_var = tkinter.BooleanVar()
        self.percent_graph_var.set(True)
        b = ttk.Checkbutton(label_frame, text=_('% won'),
                            command=self.updateGraph,
                            variable=self.percent_graph_var)
        b.pack(fill='x', expand=True, padx=3, pady=1)

        # self.createGraph()
        bind(canvas, '<Map>', self.createGraph)

    def createGraph(self, event):
        if self.mapped:
            return
        self.mapped = True

        canvas = self.canvas

        self.text_height = self.dialog.font_metrics['linespace']
        measure = self.dialog.tkfont.measure
        self.text_width_1 = measure('XX.XX')
        self.text_width_2 = measure('XX.XX.XX')

        dir = os.path.join('images', 'stats')
        try:
            fn = self.app.dataloader.findImage('progression', dir)
            self.bg_image = loadImage(fn)
            canvas.create_image(0, 0, image=self.bg_image, anchor='nw')
        except Exception:
            pass
        #
        tw = max(measure(_('Games/day')),
                 measure(_('Games/week')),
                 measure(_('% won')))
        self.left_margin = self.xmargin+tw//2
        self.right_margin = self.xmargin+tw//2
        self.top_margin = 15+self.text_height
        self.bottom_margin = 15+self.text_height+10+self.text_height
        #
        x0, y0 = self.left_margin, self.canvas_height-self.bottom_margin
        x1, y1 = self.canvas_width-self.right_margin, self.top_margin
        canvas.create_rectangle(x0, y0, x1, y1, fill='white')
        # horizontal axis
        canvas.create_line(x0, y0, x1, y0, width=3)

        # left vertical axis
        canvas.create_line(x0, y0, x0, y1, width=3)
        t = _('Games/day')
        self.games_text_id = canvas.create_text(x0-4, y1-4, anchor='s', text=t)

        # right vertical axis
        canvas.create_line(x1, y0, x1, y1, width=3)
        canvas.create_text(x1+4, y1-4, anchor='s', text=_('% won'))

        # caption
        d = self.text_height
        x, y = self.xmargin, self.canvas_height-self.ymargin
        canvas.create_rectangle(x, y, x+d, y-d, outline='black',
                                fill=self.played_color)
        x += d+5
        canvas.create_text(x, y, anchor='sw', text=_('Played'))
        x += measure(_('Played'))+20
        canvas.create_rectangle(x, y, x+d, y-d, outline='black',
                                fill=self.won_color)
        x += d+5
        canvas.create_text(x, y, anchor='sw', text=_('Won'))
        x += measure(_('Won'))+20
        canvas.create_rectangle(x, y, x+d, y-d, outline='black',
                                fill=self.percent_color)
        x += d+5
        canvas.create_text(x, y, anchor='sw', text=_('% won'))

        self.updateGraph()

    def updateGraph(self, *args):
        interval = self.variable.get()
        canvas = self.canvas
        if self.items:
            canvas.delete(*self.items)
        self.items = []

        all_games = (self.all_games_variable.get() == 'all')
        result = self.formatter.getResults(interval, all_games)

        if interval in ('week', 'month'):
            t = _('Games/day')
        else:
            t = _('Games/week')
        canvas.itemconfig(self.games_text_id, text=t)

        graph_width = self.canvas_width-self.left_margin-self.right_margin
        graph_height = self.canvas_height-self.top_margin-self.bottom_margin
        dx = (graph_width-2*self.graph_dx)//(len(result)-1)
        graph_dx = (graph_width-(len(result)-1)*dx)//2
        dy = (graph_height-self.graph_dy)//5
        x0, y0 = self.left_margin, self.canvas_height-self.bottom_margin
        x1, y1 = self.canvas_width-self.right_margin, self.top_margin
        td = self.text_height//2

        # vertical scale
        x = x0+graph_dx
        xx = -100                       # coord. of prev. text
        for res in result:
            text = res[0]
            text_width = 0
            if text is not None:
                if len(text) == 5:      # day.month
                    text_width = self.text_width_1
                else:                   # day.month.year
                    text_width = self.text_width_2
            if text is not None and x > xx+text_width+4:
                # id = canvas.create_line(x, y0, x, y0-5, width=3)
                # self.items.append(id)
                id = canvas.create_line(x, y0, x, y1, stipple='gray50')
                self.items.append(id)
                id = canvas.create_text(x, y0+td, anchor='n', text=text)
                self.items.append(id)
                xx = x
            else:
                id = canvas.create_line(x, y0, x, y0-3, width=1)
                self.items.append(id)
            x += dx

        # horizontal scale
        max_games = max([i[1] for i in result])
        games_delta = max_games//5+1
        percent = 0
        games = 0
        for y in range(y0, y1, -dy):
            if y != y0:
                id = canvas.create_line(x0, y, x1, y, stipple='gray50')
                self.items.append(id)
            id = canvas.create_text(x0-td, y, anchor='e', text=str(games))
            self.items.append(id)
            id = canvas.create_text(x1+td, y, anchor='w', text=str(percent))
            self.items.append(id)
            games += games_delta
            percent += 20

        # draw result
        games_resolution = float(dy)/games_delta
        percent_resolution = float(dy)/20
        played_coords = []
        won_coords = []
        percent_coords = []
        x = x0+graph_dx
        for res in result:
            played, won = res[1], res[2]
            y = y0 - int(games_resolution*played)
            played_coords += [x, y]
            y = y0 - int(games_resolution*won)
            won_coords += [x, y]
            if played > 0:
                percent = int(100.*won/played)
            else:
                percent = 0
            y = y0 - int(percent_resolution*percent)
            percent_coords += [x, y]
            x += dx
        if self.played_graph_var.get():
            id = canvas.create_line(fill=self.played_color, width=3,
                                    *played_coords)
            self.items.append(id)
        if self.won_graph_var.get():
            id = canvas.create_line(fill=self.won_color, width=3,
                                    *won_coords)
            self.items.append(id)
        if self.percent_graph_var.get():
            id = canvas.create_line(fill=self.percent_color, width=3,
                                    *percent_coords)
            self.items.append(id)
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

import os
import sys

from pysollib.mfxutil import Struct
from pysollib.mygettext import _
from pysollib.ui.tktile.tkhtml import Base_HTMLViewer

from six.moves import tkinter
from six.moves import tkinter_ttk as ttk

from .statusbar import HtmlStatusbar
from .tkwidget import MfxMessageDialog

if __name__ == '__main__':
    d = os.path.abspath(os.path.join(sys.path[0], '..', '..'))
    sys.path.append(d)
    import gettext
    gettext.install('pysol', d, unicode=True)

# ************************************************************************
# *
# ************************************************************************


class HTMLViewer(Base_HTMLViewer):
    symbols_fn = {}  # filenames, loaded in Application.loadImages3
    symbols_img = {}

    def _calc_MfxMessageDialog(self):
        return MfxMessageDialog

    def __init__(self, parent, app=None, home=None):
        self.parent = parent
        self.app = app
        self.home = home
        self.url = None
        self.history = Struct(
            list=[],
            index=0,
        )
        self.visited_urls = []
        # need to keep a reference because of garbage collection
        self.images = {}
        self.defcursor = parent["cursor"]
        # self.defcursor = 'xterm'
        self.handcursor = "hand2"

        frame = ttk.Frame(parent, width=640, height=440)
        frame.pack(expand=True, fill='both')
        frame.grid_propagate(False)

        # create buttons
        button_width = 8
        self.homeButton = ttk.Button(frame, text=_("Index"),
                                     width=button_width,
                                     command=self.goHome)
        self.homeButton.grid(row=0, column=0, sticky='w')
        self.backButton = ttk.Button(frame, text=_("Back"),
                                     width=button_width,
                                     command=self.goBack)
        self.backButton.grid(row=0, column=1, sticky='w')
        self.forwardButton = ttk.Button(frame, text=_("Forward"),
                                        width=button_width,
                                        command=self.goForward)
        self.forwardButton.grid(row=0, column=2, sticky='w')
        self.closeButton = ttk.Button(frame, text=_("Close"),
                                      width=button_width,
                                      command=self.destroy)
        self.closeButton.grid(row=0, column=3, sticky='e')

        # create text widget
        text_frame = ttk.Frame(frame)
        text_frame.grid(row=1, column=0, columnspan=4,
                        sticky='nsew', padx=1, pady=1)
        vbar = ttk.Scrollbar(text_frame)
        vbar.pack(side='right', fill='y')
        self.text = tkinter.Text(text_frame,
                                 fg='black', bg='white',
                                 bd=1, relief='sunken',
                                 cursor=self.defcursor,
                                 wrap='word', padx=10)
        self.text.pack(side='left', fill='both', expand=True)
        self.text["yscrollcommand"] = vbar.set
        vbar["command"] = self.text.yview

        # statusbar
        self.statusbar = HtmlStatusbar(frame, row=2, column=0, columnspan=4)

        frame.columnconfigure(2, weight=1)
        frame.rowconfigure(1, weight=1)

        # load images
        for name, fn in self.symbols_fn.items():
            self.symbols_img[name] = self.getImage(fn)

        self.initBindings()


# ************************************************************************
# *
# ************************************************************************


def tkhtml_main(args):
    try:
        url = args[1]
    except Exception:
        url = os.path.join(os.pardir, os.pardir, "data", "html", "index.html")
    top = tkinter.Tk()
    top.tk.call("package", "require", "tile")
    top.wm_minsize(400, 200)
    viewer = HTMLViewer(top)
    viewer.app = None
    viewer.display(url)
    top.mainloop()
    return 0


if __name__ == "__main__":
    sys.exit(tkhtml_main(sys.argv))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.mygettext import _, n_
from pysollib.settings import TITLE
from pysollib.ui.tktile.findcarddialog import connect_game_find_card_dialog
from pysollib.ui.tktile.findcarddialog import destroy_find_card_dialog
from pysollib.ui.tktile.menubar import MfxMenu, PysolMenubarTkCommon
from pysollib.ui.tktile.solverdialog import connect_game_solver_dialog
from pysollib.util import CARDSET

from six.moves import tkinter_ttk as ttk

from .selectgame import SelectGameDialog, SelectGameDialogWithPreview
from .selecttile import SelectTileDialogWithPreview
from .soundoptionsdialog import SoundOptionsDialog
from .tkwidget import MfxMessageDialog

# ************************************************************************
# * - create menubar
# * - update menubar
# * - menu actions
# ************************************************************************


class PysolMenubarTk(PysolMenubarTkCommon):
    def __init__(self, app, top, progress=None):
        PysolMenubarTkCommon.__init__(self, app, top, progress)

    def _setOptions(self):
        PysolMenubarTkCommon._setOptions(self)
        tkopt, opt = self.tkopt, self.app.opt
        tkopt.theme.set(opt.tile_theme)

    def _connect_game_find_card_dialog(self, game):
        return connect_game_find_card_dialog(game)

    def _destroy_find_card_dialog(self):
        return destroy_find_card_dialog()

    def _connect_game_solver_dialog(self, game):
        return connect_game_solver_dialog(game)

    def _calcWizardDialog(self):
        from .wizarddialog import WizardDialog
        return WizardDialog

    def _calcSelectGameDialog(self):
        return SelectGameDialog

    def _calcSelectGameDialogWithPreview(self):
        return SelectGameDialogWithPreview

    def _calcSoundOptionsDialog(self):
        return SoundOptionsDialog

    def _calcSelectTileDialogWithPreview(self):
        return SelectTileDialogWithPreview

    def _calc_MfxMessageDialog(self):
        return MfxMessageDialog

    #
    # create the menubar
    #

    def mSelectCardsetDialog(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        key = self.app.nextgame.cardset.index
        cs = self.app.selectCardset(_("Select ")+CARDSET, key)
        if not cs:
            return
        self.app.nextgame.cardset = cs
        self._cancelDrag()
        self.game.endGame(bookmark=1)
        self.game.quitGame(bookmark=1)

    #
    # Tile (ttk)
    #

    def mOptTheme(self, *event):
        theme = self.tkopt.theme.get()
        self.app.opt.tile_theme = theme
        self._calc_MfxMessageDialog()(
            self.top, title=_("Change theme"),
            text=_("""\
These settings will take effect
the next time you restart %(app)s""") % {'app': TITLE},
            bitmap="warning",
            default=0, strings=(_("&OK"),))

    def createThemesMenu(self, menu):
        submenu = MfxMenu(menu, label=n_("Set t&heme"))
        all_themes = list(ttk.Style(self.top).theme_names())
        all_themes.sort()
        #
        tn = {
            'default':     n_('Default'),
            'classic':     n_('Classic'),
            'alt':         n_('Revitalized'),
            'winnative':   n_('Windows native'),
            'xpnative':    n_('XP Native'),
            'aqua':        n_('Aqua'),
            }
        for t in all_themes:
            try:
                n = tn[t]
            except KeyError:
                n = t.capitalize()
            submenu.add_radiobutton(label=n, variable=self.tkopt.theme,
                                    value=t, command=self.mOptTheme)
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

import os

from pysollib.ui.tktile.tkutil import bind

from six.moves import tkinter

from .tkwidget import MfxScrolledCanvas


class MfxTreeBaseNode:
    def __init__(self, tree, parent_node, text, key):
        self.tree = tree
        self.parent_node = parent_node
        self.text = text
        self.key = key
        # state
        self.selected = 0
        self.subnodes = None
        # canvas item ids
        self.symbol_id = None
        self.text_id = None
        self.textrect_id = None

    def registerKey(self):
        if self.key is not None:
            lst = self.tree.keys.get(self.key, [])
            lst.append(self)
            self.tree.keys[self.key] = lst

    def whoami(self):
        if self.parent_node is None:
            return (self.text, )
        else:
            return self.parent_node.whoami() + (self.text, )

    def draw(self, x, y, lastx=None, lasty=None):
        canvas, style = self.tree.canvas, self.tree.style
        topleftx = x + style.distx
        toplefty = y - style.height // 2  # +++
        # draw the horizontal line
        if lastx is not None:
            canvas.create_line(
                x, y, topleftx, y, stipple=style.linestyle,
                fill=style.linecolor)
        # draw myself - ugly, ugly...
        self.selected = 0
        self.symbol_id = -1
        self.drawSymbol(topleftx, toplefty)
        linestart = style.distx + style.width + 5
        self.text_id = -1
        self.drawText(x + linestart, y)
        return x, y, x, y + style.disty

    #
    #
    #

    def drawText(self, x, y):
        canvas, style = self.tree.canvas, self.tree.style
        if self.selected:
            fg, bg = style.text_selected_fg, style.text_selected_bg
        else:
            fg, bg = style.text_normal_fg, style.text_normal_bg
        #
        if self.tree.nodes.get(self.text_id) is self:
            canvas.itemconfig(self.text_id, fill=fg)
        else:
            # note: I don't use Label + canvas.create_window here
            #   because it doesn't propagate events to the canvas
            #   and has some other re-display annoyances
            # print 'style.font:', style.font
            self.text_id = canvas.create_text(x+1, y, text=self.text,
                                              anchor="w", justify="left",
                                              font=style.font,
                                              fill=fg)
            self.tree.nodes[self.text_id] = self
        #
        if self.tree.nodes.get(self.textrect_id) is self:
            try:
                # _tkinter.TclError: unknown option "-fill" ???
                canvas.itemconfig(self.textrect_id, fill=bg)
            except tkinter.TclError:
                pass
        elif self.selected:
            b = canvas.bbox(self.text_id)
            self.textrect_id = canvas.create_rectangle(
                b[0]-1, b[1]-1, b[2]+1, b[3]+1,
                fill=bg, outline="")
            canvas.tag_lower(self.textrect_id, self.text_id)
            self.tree.nodes[self.textrect_id] = self

    def updateText(self):
        if self.tree.nodes.get(self.text_id) is self:
            self.drawText(-1, -1)

    #
    #
    #

    def drawSymbol(self, x, y, **kw):
        canvas, style = self.tree.canvas, self.tree.style
        color = kw.get("color")
        if color is None:
            if self.selected:
                color = "darkgreen"
            else:
                color = "green"
        # note: rectangle outline is one pixel
        if self.tree.nodes.get(self.symbol_id) is self:
            canvas.itemconfig(self.symbol_id, fill=color)
        else:
            self.symbol_id = canvas.create_rectangle(
                x+1, y+1, x + style.width, y + style.height, fill=color)
            self.tree.nodes[self.symbol_id] = self

    def updateSymbol(self):
        if self.tree.nodes.get(self.symbol_id) is self:
            self.drawSymbol(-1, -1)


# ************************************************************************
# * Terminal and non-terminal nodes
# ************************************************************************

class MfxTreeLeaf(MfxTreeBaseNode):
    def drawText(self, x, y):
        if self.text_id < 0:
            self.registerKey()
        MfxTreeBaseNode.drawText(self, x, y)


class MfxTreeNode(MfxTreeBaseNode):
    def __init__(self, tree, parent_node, text, key, expanded=0):
        MfxTreeBaseNode.__init__(self, tree, parent_node, text, key)
        self.expanded = expanded

    def drawChildren(self, x, y, lastx, lasty):
        # get subnodes
        self.subnodes = self.tree.getContents(self)
        # draw subnodes
        lx, ly = lastx, lasty
        nx, ny = x, y
        for node in self.subnodes:
            # update tree
            node.tree = self.tree
            # draw node
            lx, ly, nx, ny = node.draw(nx, ny, lx, ly)
        # draw the vertical line
        if self.subnodes:
            style = self.tree.style
            dy = (style.disty-style.width)//2
            y = y-style.disty//2-dy
            self.tree.canvas.create_line(x, y, nx, ly,
                                         stipple=style.linestyle,
                                         fill=style.linecolor)
        return ny

    def draw(self, x, y, ilastx=None, ilasty=None):
        # draw myself
        lx, ly, nx, ny = MfxTreeBaseNode.draw(self, x, y, ilastx, ilasty)
        if self.expanded:
            style = self.tree.style
            childx = nx + style.distx + style.width // 2
            childy = ny
            clastx = nx + style.distx + style.width // 2
            clasty = ly + style.height // 2
            ny = self.drawChildren(childx, childy, clastx, clasty)
        return lx, ly, x, ny

    #
    #
    #

    def drawSymbol(self, x, y, **kw):
        color = kw.get("color")
        if color is None:
            if self.expanded:
                color = "red"
            else:
                color = "pink"
        MfxTreeBaseNode.drawSymbol(self, x, y, color=color)


# ************************************************************************
# *
# ************************************************************************

class MfxTreeInCanvas(MfxScrolledCanvas):
    class Style:
        def __init__(self):
            self.distx = 16
            self.disty = 18
            self.width = 16         # width of symbol
            self.height = 16        # height of symbol
            self.originx = 0
            self.originy = 0
            self.text_normal_fg = "black"
            self.text_normal_bg = "white"
            self.text_selected_fg = "white"
            self.text_selected_bg = "#00008b"       # "darkblue"
            self.font = None
            self.linestyle = "gray50"
            self.linecolor = "black"

    def __init__(self, parent, rootnodes, **kw):
        kw['bd'] = 0
        kw['bg'] = 'white'
        MfxScrolledCanvas.__init__(self, parent, **kw)
        #
        self.rootnodes = rootnodes
        self.updateNodesWithTree(self.rootnodes, self)
        self.selection_key = None
        self.nodes = {}
        self.keys = {}
        #
        self.style = self.Style()
        # self.style.text_normal_fg = self.canvas.cget("insertbackground")
        # self.style.text_normal_fg = \
        #   self.canvas.option_get('foreground', '') or \
        #   self.canvas.cget("insertbackground")
        # self.style.text_normal_bg = self.canvas.option_get(
        #   'background', self.canvas.cget("background"))
        #
        bind(self.canvas, "<ButtonPress-1>", self.singleClick)
        bind(self.canvas, "<Double-Button-1>", self.doubleClick)
        # bind(self.canvas, "<ButtonRelease-1>", xxx)
        self.pack(fill='both', expand=True)

    def destroy(self):
        for node in self.keys.get(self.selection_key, []):
            node.selected = 0
        MfxScrolledCanvas.destroy(self)

    def findNode(self, event=None):
        id = self.canvas.find_withtag('current')
        if id:
            return self.nodes.get(id[0])
        return None

    #
    # draw nodes
    #

    def draw(self):
        nx, ny = self.style.originx, self.style.originy
        # Account for initial offsets, see topleft[xy] in BaseNode.draw().
        # We do this so that our bounding box always starts at (0,0)
        # and the yscrollincrement works nicely.
        nx -= self.style.distx
        ny += self.style.height // 2
        for node in self.rootnodes:
            # update tree
            node.tree = self
            # draw
            try:
                lx, ly, nx, ny = node.draw(nx, ny, None, None)
            except tkinter.TclError:
                # FIXME: Tk bug ???
                raise
        # set scroll region
        bbox = self.canvas.bbox("all")
        # self.canvas.config(scrollregion=bbox)
        # self.canvas.config(scrollregion=(0,0,bbox[2],bbox[3]))
        dx, dy = 8, 0  # margins
        self.canvas.config(scrollregion=(-dx, -dy, bbox[2]+dx, bbox[3]+dy))
        self.canvas.config(yscrollincrement=self.style.disty)

    def clear(self):
        self.nodes = {}
        self.keys = {}
        self.canvas.delete("all")

    def redraw(self):
        oldcur = self.canvas["cursor"]
        self.canvas["cursor"] = "watch"
        self.canvas.update_idletasks()
        self.clear()
        self.draw()
        self.updateSelection(self.selection_key)
        self.canvas["cursor"] = oldcur

    #
    #
    #

    def getContents(self, node):
        # Overload this, supposed to return a list of subnodes of node.
        pass

    def singleClick(self, event=None):
        # Overload this if you want to know when a node is clicked on.
        pass

    def doubleClick(self, event=None):
        # Overload this if you want to know when a node is d-clicked on.
        self.singleClick(event)

    #
    #
    #

    def updateSelection(self, key):
        l1 = self.keys.get(self.selection_key, [])
        l2 = self.keys.get(key, [])
        for node in l1:
            if node.selected and node not in l2:
                node.selected = 0
                node.updateSymbol()
                node.updateText()
        for node in l2:
            if not node.selected:
                node.selected = 1
                node.updateSymbol()
                node.updateText()
        self.selection_key = key

    def updateNodesWithTree(self, nodes, tree):
        for node in nodes:
            node.tree = tree
            if node.subnodes:
                self.updateNodesWithTree(node.subnodes, tree)


# ************************************************************************
# *
# ************************************************************************


class DirectoryBrowser(MfxTreeInCanvas):
    def __init__(self, parent, dirs):
        nodes = []
        if isinstance(dirs, str):
            dirs = (dirs,)
        for dir in dirs:
            self.addNode(nodes, None, dir, dir)
        # note: best results if height is a multiple of style.disty
        MfxTreeInCanvas.__init__(self, parent, nodes, height=25*18)
        self.draw()

    def addNode(self, list, node, filename, text):
        try:
            if os.path.isdir(filename):
                list.append(MfxTreeNode(self, node, text, key=filename))
            else:
                list.append(MfxTreeLeaf(self, node, text, key=filename))
        except EnvironmentError:
            pass

    def getContents(self, node):
        # use cached values
        if node.subnodes is not None:
            return node.subnodes
        #
        dir = node.key
        print("Getting %s" % dir)
        try:
            filenames = os.listdir(dir)
            filenames.sort()
        except EnvironmentError:
            return ()
        contents = []
        for filename in filenames:
            self.addNode(contents, node, os.path.join(dir, filename), filename)
        # print "gotten"
        return contents

    def singleClick(self, event=None):
        node = self.findNode(event)
        if not node:
            return
        print("Clicked node %s %s" % (node.text, node.key))
        if isinstance(node, MfxTreeLeaf):
            self.updateSelection(key=node.key)
        elif isinstance(node, MfxTreeNode):
            node.expanded = not node.expanded
            self.redraw()
        return "break"


if __name__ == "__main__":
    tk = tkinter.Tk()
    if os.name == "nt":
        app = DirectoryBrowser(tk, ("c:\\", "c:\\windows"))
    else:
        app = DirectoryBrowser(tk, ("/", "/home"))
    tk.mainloop()
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

from pysollib.mfxutil import KwStruct
from pysollib.mygettext import _
from pysollib.ui.tktile.tkutil import bind

from six.moves import tkinter
from six.moves import tkinter_font
from six.moves import tkinter_ttk as ttk

from .tkwidget import MfxDialog
from .tkwidget import PysolScale


# ************************************************************************
# *
# ************************************************************************

class FontChooserDialog(MfxDialog):
    def __init__(self, parent, title, init_font, **kw):
        # print init_font
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.createBitmaps(top_frame, kw)

        self.font_family = 'Helvetica'
        self.font_size = 12
        self.font_weight = 'normal'
        self.font_slant = 'roman'

        if init_font is not None:
            assert 2 <= len(init_font) <= 4
            assert isinstance(init_font[1], int)
            self.font_family, self.font_size = init_font[:2]
            if len(init_font) > 2:
                if init_font[2] in ['bold', 'normal']:
                    self.font_weight = init_font[2]
                elif init_font[2] in ['italic', 'roman']:
                    self.font_slant = init_font[2]
                else:
                    raise ValueError('invalid font style: '+init_font[2])
                if len(init_font) > 3:
                    if init_font[3] in ['bold', 'normal']:
                        self.font_weight = init_font[3]
                    elif init_font[2] in ['italic', 'roman']:
                        self.font_slant = init_font[3]
                    else:
                        raise ValueError('invalid font style: '+init_font[3])

        # self.family_var = tkinter.StringVar()
        self.weight_var = tkinter.BooleanVar()
        self.weight_var.set(self.font_weight == 'bold')
        self.slant_var = tkinter.BooleanVar()
        self.slant_var.set(self.font_slant == 'italic')
        self.size_var = tkinter.IntVar()
        self.size_var.set(self.font_size)
        #
        frame = ttk.Frame(top_frame)
        frame.pack(expand=True, fill='both', padx=5, pady=10)
        frame.columnconfigure(0, weight=1)
        # frame.rowconfigure(1, weight=1)
        self.entry = ttk.Entry(frame)
        self.entry.grid(row=0, column=0, columnspan=2, sticky='news')
        self.entry.insert('end', _('abcdefghABCDEFGH'))
        self.list_box = tkinter.Listbox(frame, width=36, exportselection=False)
        sb = ttk.Scrollbar(frame)
        self.list_box.configure(yscrollcommand=sb.set)
        sb.configure(command=self.list_box.yview)
        self.list_box.grid(row=1, column=0, sticky='news')  # rowspan=4
        sb.grid(row=1, column=1, sticky='ns')
        bind(self.list_box, '<<ListboxSelect>>', self.fontupdate)
        # self.list_box.focus()
        cb1 = ttk.Checkbutton(frame, text=_('Bold'),
                              command=self.fontupdate,
                              variable=self.weight_var)
        cb1.grid(row=2, column=0, columnspan=2, sticky='we')
        cb2 = ttk.Checkbutton(frame, text=_('Italic'),
                              command=self.fontupdate,
                              variable=self.slant_var)
        cb2.grid(row=3, column=0, columnspan=2, sticky='we')

        sc = PysolScale(frame, from_=6, to=40, resolution=1,
                        label=_('Size:'), orient='horizontal',
                        command=self.fontupdate, variable=self.size_var)
        sc.grid(row=4, column=0, columnspan=2, sticky='news')
        #
        font_families = list(tkinter_font.families())
        font_families.sort()
        selected = -1
        n = 0
        self.list_box.insert('end', *font_families)
        for font in font_families:
            if font.lower() == self.font_family.lower():
                selected = n
                break
            n += 1
        if selected >= 0:
            self.list_box.select_set(selected)
            self.list_box.see(selected)
        #
        focus = self.createButtons(bottom_frame, kw)
        self.mainloop(focus, kw.timeout)

        self.font = (self.font_family, self.font_size,
                     self.font_slant, self.font_weight)

    def fontupdate(self, *args):
        if self.list_box.curselection():
            self.font_family = self.list_box.get(self.list_box.curselection())
        self.font_weight = self.weight_var.get() and 'bold' or 'normal'
        self.font_slant = self.slant_var.get() and 'italic' or 'roman'
        self.font_size = self.size_var.get()
        self.entry.configure(font=(self.font_family, self.font_size,
                                   self.font_slant, self.font_weight))

    def initKw(self, kw):
        kw = KwStruct(kw,
                      strings=(_("&OK"), _("&Cancel")),
                      default=0,
                      )
        return MfxDialog.initKw(self, kw)

# ************************************************************************
# *
# ************************************************************************


class FontsDialog(MfxDialog):
    def __init__(self, parent, title, app, **kw):
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.createBitmaps(top_frame, kw)

        frame = ttk.Frame(top_frame)
        frame.pack(expand=True, fill='both', padx=5, pady=10)
        frame.columnconfigure(0, weight=1)

        self.fonts = {}
        row = 0
        for fn, title in (  # ('default',        _('Default')),
                          ('sans',           _('HTML: ')),
                          ('small',          _('Small: ')),
                          ('fixed',          _('Fixed: ')),
                          ('canvas_default', _('Tableau default: ')),
                          ('canvas_fixed',   _('Tableau fixed: ')),
                          ('canvas_large',   _('Tableau large: ')),
                          ('canvas_small',   _('Tableau small: ')),
                          ):
            font = app.opt.fonts[fn]
            self.fonts[fn] = font
            ttk.Label(frame, text=title, anchor='w'
                      ).grid(row=row, column=0, sticky='we')
            if font:
                title = ' '.join(
                    [str(i) for i in font if i not in ('roman', 'normal')])
            elif font is None:
                title = 'Default'
            label = ttk.Label(frame, font=font, text=title)
            label.grid(row=row, column=1, padx=8)
            b = ttk.Button(frame, text=_('Change...'), width=10,
                           command=lambda label=label,
                           fn=fn: self.selectFont(label, fn))
            b.grid(row=row, column=2)
            row += 1
        #
        focus = self.createButtons(bottom_frame, kw)
        self.mainloop(focus, kw.timeout)

    def selectFont(self, label, fn):
        d = FontChooserDialog(self.top, _('Select font'), self.fonts[fn])
        if d.status == 0 and d.button == 0:
            self.fonts[fn] = d.font
            title = ' '.join(
                [str(i) for i in d.font if i not in ('roman', 'normal')])
            label.configure(font=d.font, text=title)

    def initKw(self, kw):
        kw = KwStruct(kw,
                      strings=(_('&OK'), _('&Cancel')),
                      default=0,
                      )
        return MfxDialog.initKw(self, kw)
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.mfxutil import KwStruct
from pysollib.mygettext import _
from pysollib.ui.tktile.selecttree import SelectDialogTreeData

import six
from six.moves import tkinter
from six.moves import tkinter_colorchooser
from six.moves import tkinter_ttk as ttk

from .selecttree import SelectDialogTreeCanvas
from .selecttree import SelectDialogTreeLeaf, SelectDialogTreeNode
from .tkwidget import MfxDialog, MfxScrolledCanvas


# ************************************************************************
# * Nodes
# ************************************************************************

class SelectTileLeaf(SelectDialogTreeLeaf):
    pass


class SelectTileNode(SelectDialogTreeNode):
    def _getContents(self):
        contents = []
        for obj in self.tree.data.all_objects:
            if self.select_func(obj):
                node = SelectTileLeaf(
                    self.tree, self, text=obj.name, key=obj.index)
                contents.append(node)
        return contents or self.tree.data.no_contents


# ************************************************************************
# * Tree database
# ************************************************************************

class SelectTileData(SelectDialogTreeData):
    def __init__(self, manager, key):
        SelectDialogTreeData.__init__(self)
        self.all_objects = manager.getAllSortedByName()
        self.all_objects = [obj for obj in self.all_objects if not obj.error]
        self.all_objects = [tile for tile in self.all_objects
                            if tile.index > 0 and tile.filename]
        self.no_contents = [SelectTileLeaf(
            None, None, _("(no tiles)"), key=None), ]
        e1 = isinstance(key, str) or len(self.all_objects) <= 17
        e2 = 1
        self.rootnodes = (
            SelectTileNode(None, _("Solid Colors"), (
                SelectTileLeaf(None, None, _("Blue"), key="#0082df"),
                SelectTileLeaf(None, None, _("Green"), key="#008200"),
                SelectTileLeaf(None, None, _("Navy"), key="#000086"),
                SelectTileLeaf(None, None, _("Olive"), key="#868200"),
                SelectTileLeaf(None, None, _("Orange"), key="#f79600"),
                SelectTileLeaf(None, None, _("Teal"), key="#008286"),
            ), expanded=e1),
            SelectTileNode(
                None, _("All Backgrounds"),
                lambda tile: 1, expanded=e2),
        )


# ************************************************************************
# * Canvas that shows the tree
# ************************************************************************

class SelectTileTree(SelectDialogTreeCanvas):
    data = None


# ************************************************************************
# * Dialog
# ************************************************************************

class SelectTileDialogWithPreview(MfxDialog):
    Tree_Class = SelectTileTree
    TreeDataHolder_Class = SelectTileTree
    TreeData_Class = SelectTileData

    def __init__(self, parent, title, app, manager, key=None, **kw):
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.createBitmaps(top_frame, kw)
        #
        if key is None:
            key = manager.getSelected()
        self.app = app
        self.manager = manager
        self.key = key
        self.table_color = app.opt.colors['table']
        if self.TreeDataHolder_Class.data is None:
            self.TreeDataHolder_Class.data = self.TreeData_Class(manager, key)
        #
        self.top.wm_minsize(400, 200)
        if self.top.winfo_screenwidth() >= 800:
            w1, w2 = 200, 400
        else:
            w1, w2 = 200, 300
        font = app.getFont("default")
        padx, pady = 4, 4
        frame = ttk.Frame(top_frame)
        frame.pack(fill='both', expand=True,
                   padx=kw.padx-padx, pady=kw.pady-pady)
        self.tree = self.Tree_Class(self, frame, key=key, default=kw.default,
                                    font=font, width=w1)
        self.tree.frame.pack(side="left", fill='both', expand=False,
                             padx=padx, pady=pady)
        self.preview = MfxScrolledCanvas(frame, width=w2, hbar=0, vbar=0)
        self.preview.pack(side="right", fill='both', expand=True,
                          padx=padx, pady=pady)
        self.preview.canvas.preview = 1
        # create a preview of the current state
        self.preview_key = -1
        self.updatePreview(key)
        #
        focus = self.createButtons(bottom_frame, kw)
        focus = self.tree.frame
        self.mainloop(focus, kw.timeout)

    def destroy(self):
        self.tree.updateNodesWithTree(self.tree.rootnodes, None)
        self.tree.destroy()
        self.preview.unbind_all()
        MfxDialog.destroy(self)

    def initKw(self, kw):
        kw = KwStruct(kw,
                      strings=((_("&Solid color..."), 10),
                               'sep', _("&OK"), _("&Cancel"),),
                      default=0,
                      resizable=True,
                      font=None,
                      padx=10, pady=10,
                      )
        return MfxDialog.initKw(self, kw)

    def mDone(self, button):
        if button == 0:        # "OK" or double click
            if isinstance(self.tree.selection_key, six.string_types):
                self.key = str(self.tree.selection_key)
            else:
                self.key = self.tree.selection_key
            self.tree.n_expansions = 1  # save xyview in any case
        if button == 10:        # "Solid color..."
            try:
                c = tkinter_colorchooser.askcolor(
                    master=self.top,
                    initialcolor=self.table_color,
                    title=_("Select table color"))
            except tkinter.TclError:
                pass
            else:
                if c and c[1]:
                    color = str(c[1])
                    self.key = color.lower()
                    self.table_color = self.key
                    self.tree.updateSelection(self.key)
                    self.updatePreview(self.key)
            return
        MfxDialog.mDone(self, button)

    def updatePreview(self, key):
        if key == self.preview_key:
            return
        canvas = self.preview.canvas
        canvas.deleteAllItems()
        if isinstance(key, six.string_types):
            # solid color
            canvas.config(bg=key)
            canvas.setTile(None)
            canvas.setTextColor(None)
            self.preview_key = key
            self.table_color = key
        else:
            # image
            tile = self.manager.get(key)
            if tile:
                if self.preview.setTile(self.app, key):
                    return
            self.preview_key = -1
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

from pysollib.ui.tktile.tkconst import EVENT_HANDLED
from pysollib.ui.tktile.tkutil import makeToplevel, setTransient

from six.moves import tkinter
from six.moves import tkinter_ttk as ttk

# ************************************************************************
# * a simple progress bar
# ************************************************************************


class PysolProgressBar:
    def __init__(self, app, parent, title=None, images=None, color="blue",
                 width=300, height=25, show_text=1, norm=1):
        self.parent = parent
        self.percent = 0
        self.top = makeToplevel(parent, title=title)
        self.top.wm_protocol("WM_DELETE_WINDOW", self.wmDeleteWindow)
        self.top.wm_group(parent)
        self.top.wm_resizable(False, False)
        self.top.config(cursor="watch")
        #
        self.frame = ttk.Frame(self.top, relief='flat', borderwidth=0)
        self.progress = ttk.Progressbar(self.frame, maximum=100, length=250)
        # style = ttk.Style(self.progress)
        # style.configure('TProgressbar', background=color)
        if images:
            self.f1 = ttk.Label(self.frame, image=images[0])
            self.f1.pack(side='left', ipadx=8, ipady=4)
            self.progress.pack(side='left', expand=True, fill='x')
            self.f2 = ttk.Label(self.frame, image=images[1])
            self.f2.pack(side='left', ipadx=8, ipady=4)
        else:
            self.progress.pack(expand=True, fill='x')
        self.frame.pack(expand=True, fill='both')
        if 1:
            setTransient(self.top, None, relx=0.5, rely=0.5)
        else:
            self.update(percent=0)
        self.norm = norm
        self.steps_sum = 0

    def wmDeleteWindow(self):
        return EVENT_HANDLED

    def destroy(self):
        if self.top is None:        # already destroyed
            return
        self.top.wm_withdraw()
        self.top.quit()
        self.top.destroy()
        self.top = None

    def reset(self, percent=0):
        self.percent = percent

    def update(self, percent=None, step=1):
        self.steps_sum += step
        # print self.steps_sum
        step = step/self.norm
        if self.top is None:        # already destroyed
            return
        if percent is None:
            self.percent = self.percent + step
        elif percent > self.percent:
            self.percent = percent
        else:
            return
        self.percent = min(100, max(0, self.percent))
        self.progress.config(value=self.percent)
        # self.top.update_idletasks()
        self.top.update()


# ************************************************************************
# *
# ************************************************************************


class TestProgressBar:
    def __init__(self, parent):
        self.parent = parent
        self.progress = PysolProgressBar(
            None, parent, title="Progress", color="#008200")
        self.progress.pack(ipadx=10, ipady=10)
        self.progress.frame.after(1000, self.update)

    def update(self, event=None):
        if self.progress.percent >= 100:
            self.parent.after_idle(self.progress.destroy)
            return
        self.progress.update(step=1)
        self.progress.frame.after(30, self.update)


def progressbar_main(args):
    from pysollib.ui.tktile.tkutil import wm_withdraw
    tk = tkinter.Tk()
    wm_withdraw(tk)
    TestProgressBar(tk)
    tk.mainloop()
    return 0


if __name__ == "__main__":
    import sys
    sys.exit(progressbar_main(sys.argv))
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

import locale
import os
import time
import traceback

from pysollib.mfxutil import KwStruct, destruct, kwdefault, openURL
from pysollib.mygettext import _
from pysollib.settings import WIN_SYSTEM
from pysollib.ui.tktile.tkcanvas import MfxCanvas
from pysollib.ui.tktile.tkutil import after, after_cancel
from pysollib.ui.tktile.tkutil import bind, unbind_destroy
from pysollib.ui.tktile.tkutil import makeToplevel, setTransient

import six
from six import PY2
from six.moves import tkinter
from six.moves import tkinter_font
from six.moves import tkinter_ttk as ttk

# ************************************************************************
# * abstract base class for the dialogs in this module
# ************************************************************************


class MfxDialog:  # ex. _ToplevelDialog
    img = {}
    button_img = {}

    def __init__(self, parent, title="", resizable=False, default=-1):
        self.parent = parent
        self.status = 0
        self.button = default
        self.timer = None
        self.buttons = []
        self.accel_keys = {}
        self.top = makeToplevel(parent, title=title)
        # self._frame = ttk.Frame(self.top)
        # self._frame.pack(expand=True, fill='both')
        self._frame = self.top
        self.top.wm_resizable(resizable, resizable)
        # w, h = self.top.winfo_screenwidth(), self.top.winfo_screenheight()
        # self.top.wm_maxsize(w-4, h-32)
        bind(self.top, "WM_DELETE_WINDOW", self.wmDeleteWindow)

    def mainloop(self, focus=None, timeout=0, transient=True):
        bind(self.top, "<Escape>", self.mCancel)
        bind(self.top, '<Alt-Key>', self.altKeyEvent)  # for accelerators
        if focus is not None:
            focus.focus()
        if transient:
            setTransient(self.top, self.parent)
            try:
                self.top.grab_set()
            except tkinter.TclError:
                if traceback:
                    traceback.print_exc()
                pass
            if timeout > 0:
                self.timer = after(self.top, timeout, self.mTimeout)
            try:
                self.top.mainloop()
            except SystemExit:
                pass
            self.destroy()

    def destroy(self):
        after_cancel(self.timer)
        unbind_destroy(self.top)
        self.top.destroy()
        self.top.update_idletasks()
        self.top = None
        self.parent = None

    def wmDeleteWindow(self, *event):
        self.status = 1
        raise SystemExit
        # return EVENT_HANDLED

    def mCancel(self, *event):
        self.status = 1
        raise SystemExit

    def mTimeout(self, *event):
        self.status = 2
        raise SystemExit

    def mDone(self, button):
        self.button = button
        raise SystemExit

    def altKeyEvent(self, event):
        widget = None
        if event.keysym in self.accel_keys:
            widget = self.accel_keys[event.keysym]
        else:
            key = event.char
            try:
                if os.name == 'nt':
                    key = six.text_type(key, locale.getpreferredencoding())
                else:
                    key = six.text_type(key, 'utf-8')
            except Exception:
                pass
            else:
                key = key.lower()
                widget = self.accel_keys.get(key)
        if widget is not None:
            widget.event_generate('<<Invoke>>')

    def initKw(self, kw):
        kw = KwStruct(kw,
                      timeout=0, resizable=False,
                      text="", justify="center",
                      strings=(_("&OK"),),
                      default=0,
                      width=0,
                      padx=20, pady=20,
                      bitmap=None, bitmap_side="left",
                      bitmap_padx=10, bitmap_pady=20,
                      image=None, image_side="left",
                      image_padx=10, image_pady=20,
                      )
        # default to separator if more than one button
        sep = len(kw.strings) > 1
        kwdefault(kw.__dict__, separator=sep)
        return kw

    def createFrames(self, kw):
        bottom_frame = ttk.Frame(self._frame, relief='flat', borderwidth=4)
        bottom_frame.pack(side='bottom', fill='both', expand=False)
        if kw.separator:
            separator = ttk.Separator(self._frame)
            separator.pack(side='bottom', fill='x')
        top_frame = ttk.Frame(self._frame)
        top_frame.pack(side='top', fill='both', expand=1)
        return top_frame, bottom_frame

    def createBitmaps(self, frame, kw):
        if kw.bitmap:  # in ("error", "info", "question", "warning")
            img = self.img.get(kw.bitmap)
            b = ttk.Label(frame, image=img)
            b.pack(side=kw.bitmap_side,
                   padx=kw.bitmap_padx, pady=kw.bitmap_pady)
        elif kw.image:
            b = ttk.Label(frame, image=kw.image)
            b.pack(side=kw.image_side, padx=kw.image_padx, pady=kw.image_pady)

    def createButtons(self, frame, kw):
        padx, pady = 4, 4
        xbutton = column = -1
        focus = None
        max_len = 0
        if 'sep' in kw.strings:
            sep_column = list(kw.strings).index('sep')
            strings = kw.strings[sep_column+1:]
        else:
            sep_column = 0
            strings = kw.strings
        for s in strings:
            if isinstance(s, tuple):
                s = s[0]
            if s:
                s = s.replace('&', '')
                max_len = max(max_len, len(s))
            # print s, len(s)
        if max_len > 12 and WIN_SYSTEM == 'x11':
            button_width = max_len
        elif max_len > 9:
            button_width = max_len+1
        elif max_len > 6:
            button_width = max_len+2
        else:
            button_width = 8
        #
        for s in kw.strings:
            if s is None:
                xbutton += 1
                continue
            if s == 'sep':
                column += 1
                continue
            if isinstance(s, tuple):
                assert len(s) == 2
                button = int(s[1])
                s = s[0]
            else:
                xbutton += 1
                button = xbutton
            accel_indx = s.find('&')
            button_img = None
            if MfxDialog.button_img:
                button_img = MfxDialog.button_img.get(s)
            s = s.replace('&', '')
            if button < 0:
                widget = ttk.Button(frame, text=s, state="disabled")
            else:
                widget = ttk.Button(
                    frame, text=s, default="normal",
                    command=lambda self=self, button=button:
                    self.mDone(button))
                if button == kw.default:
                    focus = widget
                    focus.config(default="active")
            self.buttons.append(widget)
            #
            column += 1
            if column >= sep_column:
                widget.config(width=button_width)
            else:
                widget.config(width=max(button_width, len(s)))
            if accel_indx >= 0:
                # key accelerator
                widget.config(underline=accel_indx)
                key = s[accel_indx]
                self.accel_keys[key.lower()] = widget
            #
            if button_img:
                widget.config(compound='left', image=button_img)
            widget.grid(
                column=column, row=0, sticky="nse", padx=padx, pady=pady)
        if focus is not None:
            def cb(event=None, w=focus):
                return w.event_generate('<<Invoke>>')
            bind(self.top, "<Return>", cb)
            bind(self.top, "<KP_Enter>", cb)
        # right justify
        frame.columnconfigure(sep_column, weight=1)
        return focus


# ************************************************************************
# * replacement for the tk_dialog script
# ************************************************************************

class MfxMessageDialog(MfxDialog):
    def __init__(self, parent, title, **kw):
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.createBitmaps(top_frame, kw)
        #
        self.button = kw.default
        msg = ttk.Label(top_frame, text=kw.text, justify=kw.justify,
                        width=kw.width)
        msg.pack(fill='both', expand=True, padx=kw.padx, pady=kw.pady)
        #
        focus = self.createButtons(bottom_frame, kw)
        self.mainloop(focus, kw.timeout)


# ************************************************************************
# *
# ************************************************************************

class MfxExceptionDialog(MfxMessageDialog):
    def __init__(self, parent, ex, title="Error", **kw):
        kw = KwStruct(kw, bitmap="error")
        text = kw.get("text", "")
        if not text.endswith("\n"):
            text = text + "\n"
        text = text + "\n"
        if isinstance(ex, EnvironmentError) and ex.filename is not None:
            t = "[Errno %s] %s:\n%s" % \
                (ex.errno, ex.strerror, repr(ex.filename))
        else:
            t = str(ex)
        if PY2:
            t = six.text_type(t, errors='replace')
        kw.text = text + t
        MfxMessageDialog.__init__(self, parent, title, **kw.getKw())


# ************************************************************************
# *
# ************************************************************************

class PysolAboutDialog(MfxMessageDialog):
    def __init__(self, app, parent, title, **kw):
        self._url = kw['url']
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.createBitmaps(top_frame, kw)
        #
        self.button = kw.default
        frame = ttk.Frame(top_frame)
        frame.pack(fill='both', expand=True, padx=kw.padx, pady=kw.pady)
        msg = ttk.Label(frame, text=kw.text, justify=kw.justify,
                        width=kw.width)
        msg.pack(fill='both', expand=True)

        # font_name = msg.lookup('TLabel', 'font')
        font_name = 'TkDefaultFont'
        font = tkinter_font.Font(parent, name=font_name, exists=True)
        font = font.copy()
        font.configure(underline=True)
        url_label = ttk.Label(frame, text=kw.url, font=font,
                              foreground='blue', cursor='hand2')
        url_label.pack()
        url_label.bind('<1>', self._urlClicked)
        #
        focus = self.createButtons(bottom_frame, kw)
        self.mainloop(focus, kw.timeout)

    def _urlClicked(self, event):
        openURL(self._url)


# ************************************************************************
# *
# ************************************************************************

class MfxSimpleEntry(MfxDialog):
    def __init__(self, parent, title, label, value, **kw):
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.createBitmaps(top_frame, kw)
        #
        self.value = value
        if label:
            label = ttk.Label(top_frame, text=label, takefocus=0)
            label.pack(pady=5)
        w = kw.get("e_width", 0)    # width in characters
        self.var = ttk.Entry(top_frame, exportselection=1, width=w)
        self.var.insert(0, value)
        self.var.pack(side='top', padx=kw.padx, pady=kw.pady)
        #
        focus = self.createButtons(bottom_frame, kw)
        focus = self.var
        self.mainloop(focus, kw.timeout)

    def initKw(self, kw):
        kw = KwStruct(kw,
                      strings=(_("&OK"), _("&Cancel")), default=0,
                      separator=False,
                      )
        return MfxDialog.initKw(self, kw)

    def mDone(self, button):
        self.button = button
        self.value = self.var.get()
        raise SystemExit


# ************************************************************************
# * a simple tooltip
# ************************************************************************

class MfxTooltip:
    last_leave_time = 0

    def __init__(self, widget):
        # private vars
        self.widget = widget
        self.text = None
        self.timer = None
        self.cancel_timer = None
        self.tooltip = None
        self.label = None
        self.bindings = []
        self.bindings.append(self.widget.bind("<Enter>", self._enter))
        self.bindings.append(self.widget.bind("<Leave>", self._leave))
        self.bindings.append(self.widget.bind("<ButtonPress>", self._leave))
        # user overrideable settings
        self.timeout = 800                    # milliseconds
        self.cancel_timeout = 5000
        self.leave_timeout = 400
        self.relief = 'solid'
        self.justify = 'left'
        self.fg = "#000000"
        self.bg = "#ffffe0"
        self.xoffset = 0
        self.yoffset = 4

    def setText(self, text):
        self.text = text

    def _unbind(self):
        if self.bindings and self.widget:
            self.widget.unbind("<Enter>", self.bindings[0])
            self.widget.unbind("<Leave>", self.bindings[1])
            self.widget.unbind("<ButtonPress>", self.bindings[2])
            self.bindings = []

    def destroy(self):
        self._unbind()
        self._leave()

    def _enter(self, *event):
        after_cancel(self.timer)
        after_cancel(self.cancel_timer)
        self.cancel_timer = None
        if time.time() - MfxTooltip.last_leave_time < self.leave_timeout/1000.:
            self._showTip()
        else:
            self.timer = after(self.widget, self.timeout, self._showTip)

    def _leave(self, *event):
        after_cancel(self.timer)
        after_cancel(self.cancel_timer)
        self.timer = self.cancel_timer = None
        if self.tooltip:
            self.label.destroy()
            destruct(self.label)
            self.label = None
            self.tooltip.destroy()
            destruct(self.tooltip)
            self.tooltip = None
            MfxTooltip.last_leave_time = time.time()

    def _showTip(self):
        self.timer = None
        if self.tooltip or not self.text:
            return
        #  if isinstance(self.widget, (ttk.Button, ttk.Checkbutton)):
        #      if self.widget["state"] == 'disabled':
        #          return
        # x = self.widget.winfo_rootx()
        x = self.widget.winfo_pointerx()
        y = self.widget.winfo_rooty() + self.widget.winfo_height()
        x += self.xoffset
        y += self.yoffset
        self.tooltip = tkinter.Toplevel()
        self.tooltip.wm_iconify()
        self.tooltip.wm_overrideredirect(1)
        self.tooltip.wm_protocol("WM_DELETE_WINDOW", self.destroy)
        self.label = tkinter.Label(self.tooltip, text=self.text,
                                   relief=self.relief, justify=self.justify,
                                   fg=self.fg, bg=self.bg, bd=1, takefocus=0)
        self.label.pack(ipadx=1, ipady=1)
        self.tooltip.wm_geometry("%+d%+d" % (x, y))
        self.tooltip.wm_deiconify()
        self.cancel_timer = after(
            self.widget, self.cancel_timeout, self._leave)
        # self.tooltip.tkraise()


# ************************************************************************
# * A canvas widget with scrollbars and some useful bindings.
# ************************************************************************

class MfxScrolledCanvas:
    def __init__(self, parent, hbar=True, vbar=True, propagate=0, **kw):
        kwdefault(kw, highlightthickness=0, bd=1, relief='sunken')
        self.parent = parent
        self.createFrame(kw)
        self.canvas = None
        self.hbar = None
        self.vbar = None
        self.hbar_show = False
        self.vbar_show = False
        self.createCanvas(kw)
        self.frame.grid_rowconfigure(0, weight=1)
        self.frame.grid_columnconfigure(0, weight=1)
        self.frame.grid_propagate(propagate)
        if hbar:
            self.createHbar()
            self.bindHbar()
        if vbar:
            self.createVbar()
            self.bindVbar()
        # self.canvas.focus_set()

    #
    #
    #

    def destroy(self):
        self.unbind_all()
        self.canvas.destroy()
        self.frame.destroy()

    def pack(self, **kw):
        self.frame.pack(**kw)

    def grid(self, **kw):
        self.frame.grid(**kw)

    #
    #
    #

    def setTile(self, app, i, force=False):
        tile = app.tabletile_manager.get(i)
        if tile is None or tile.error:
            return False
        # print i, tile
        if i == 0:
            assert tile.color
            assert tile.filename is None
        else:
            assert tile.color is None
            assert tile.filename
            assert tile.basename
        if not force:
            if (i == app.tabletile_index and
                    tile.color == app.opt.colors['table']):
                return False
        #
        if not self.canvas.setTile(tile.filename, tile.stretch,
                                   tile.save_aspect):
            tile.error = True
            return False

        if i == 0:
            self.canvas.config(bg=tile.color)
            # app.top.config(bg=tile.color)
        else:
            self.canvas.config(bg=app.top_bg)
            # app.top.config(bg=app.top_bg)

        self.canvas.setTextColor(app.opt.colors['text'])

        return True

    #
    #
    #

    def unbind_all(self):
        unbind_destroy(self.hbar)
        unbind_destroy(self.vbar)
        unbind_destroy(self.canvas)
        unbind_destroy(self.frame)

    def createFrame(self, kw):
        width = kw.get("width")
        height = kw.get("height")
        self.frame = ttk.Frame(self.parent, width=width, height=height)

    def createCanvas(self, kw):
        bd = kw['bd']
        kw['bd'] = 0
        relief = kw['relief']
        del kw['relief']
        frame = tkinter.Frame(self.frame, bd=bd, relief=relief)
        frame.grid(row=0, column=0, sticky="news")
        self.canvas = MfxCanvas(frame, **kw)
        self.canvas.pack(expand=True, fill='both')

    def createHbar(self):

        self.hbar = ttk.Scrollbar(self.frame, takefocus=0,
                                  orient="horizontal")
        self.canvas["xscrollcommand"] = self._setHbar
        self.hbar["command"] = self.canvas.xview
        self.hbar.grid(row=1, column=0, sticky="we")
        self.hbar.grid_remove()

    def createVbar(self):
        self.vbar = ttk.Scrollbar(self.frame, takefocus=0)
        self.canvas["yscrollcommand"] = self._setVbar
        self.vbar["command"] = self.canvas.yview
        self.vbar.grid(row=0, column=1, sticky="ns")
        self.vbar.grid_remove()

    def bindHbar(self, w=None):
        if w is None:
            w = self.canvas
        bind(w, "<KeyPress-Left>", self.unit_left)
        bind(w, "<KeyPress-Right>", self.unit_right)

    def bindVbar(self, w=None):
        if w is None:
            w = self.canvas
        bind(w, "<KeyPress-Prior>", self.page_up)
        bind(w, "<KeyPress-Next>", self.page_down)
        bind(w, "<KeyPress-Up>", self.unit_up)
        bind(w, "<KeyPress-Down>", self.unit_down)
        bind(w, "<KeyPress-Begin>", self.scroll_top)
        bind(w, "<KeyPress-Home>", self.scroll_top)
        bind(w, "<KeyPress-End>", self.scroll_bottom)
        # mousewheel support
        if WIN_SYSTEM == 'x11':
            bind(w, '<4>', self.mouse_wheel_up)
            bind(w, '<5>', self.mouse_wheel_down)
        # don't work on Linux
        # bind(w, '<MouseWheel>', self.mouse_wheel)

    def mouse_wheel(self, *args):
        print('MfxScrolledCanvas.mouse_wheel', args)

    def _setHbar(self, first, last):
        if self.canvas.busy:
            return
        sb = self.hbar
        if float(first) <= 0 and float(last) >= 1:
            sb.grid_remove()
            self.hbar_show = False
        else:
            if self.canvas.winfo_ismapped():
                sb.grid()
                self.hbar_show = True
        sb.set(first, last)

    def _setVbar(self, first, last):
        if self.canvas.busy:
            return
        sb = self.vbar
        if float(first) <= 0 and float(last) >= 1:
            sb.grid_remove()
            self.vbar_show = False
        else:
            if self.canvas.winfo_ismapped():
                sb.grid()
                self.vbar_show = True
        sb.set(first, last)

    def _xview(self, *args):
        if self.hbar_show:
            self.canvas.xview(*args)
        return 'break'

    def _yview(self, *args):
        if self.vbar_show:
            self.canvas.yview(*args)
        return 'break'

    def page_up(self, *event):
        return self._yview('scroll', -1, 'page')

    def page_down(self, *event):
        return self._yview('scroll', 1, 'page')

    def unit_up(self, *event):
        return self._yview('scroll', -1, 'unit')

    def unit_down(self, *event):
        return self._yview('scroll', 1, 'unit')

    def mouse_wheel_up(self, *event):
        return self._yview('scroll', -5, 'unit')

    def mouse_wheel_down(self, *event):
        return self._yview('scroll', 5, 'unit')

    def page_left(self, *event):
        return self._xview('scroll', -1, 'page')

    def page_right(self, *event):
        return self._xview('scroll', 1, 'page')

    def unit_left(self, *event):
        return self._xview('scroll', -1, 'unit')

    def unit_right(self, *event):
        return self._xview('scroll', 1, 'unit')

    def scroll_top(self, *event):
        return self._yview('moveto', 0)

    def scroll_bottom(self, *event):
        return self._yview('moveto', 1)


# ************************************************************************
# *
# ************************************************************************

class StackDesc:

    def __init__(self, game, stack):
        self.game = game
        self.stack = stack
        self.canvas = game.canvas
        self.bindings = []

        font = game.app.getFont('canvas_small')
        # print self.app.cardset.CARDW, self.app.images.CARDW
        cardw = game.app.images.getSize()[0]
        x, y = stack.x+cardw//2, stack.y
        text = stack.getHelp()+'\n'+stack.getBaseCard()
        text = text.strip()
        if text:
            frame = tkinter.Frame(self.canvas)
            self.frame = frame
            label = tkinter.Message(frame, font=font, text=text,
                                    width=cardw-8, relief='solid',
                                    fg='#000000', bg='#ffffe0', bd=1)
            label.pack()
            self.label = label
            self.id = self.canvas.create_window(x, y, window=frame, anchor='n')
            self.bindings.append(label.bind('<ButtonPress>',
                                            self._buttonPressEvent))
            # self.bindings.append(label.bind('<Enter>', self._enterEvent))
        else:
            self.id = None

    def _buttonPressEvent(self, *event):
        # self.game.deleteStackDesc()
        self.frame.tkraise()

    def _enterEvent(self, *event):
        self.frame.tkraise()

    def delete(self):
        if self.id:
            self.canvas.delete(self.id)
            for b in self.bindings:
                self.label.unbind('<ButtonPress>', b)


# ************************************************************************
# * ttk.Scale workaround (label and resolution)
# ************************************************************************

class MyPysolScale:
    def __init__(self, parent, **kw):
        if 'resolution' in kw:
            self.resolution = kw['resolution']
            del kw['resolution']
        else:
            self.resolution = 1
        if 'from_' in kw:
            kw['from_'] //= self.resolution
        if 'to' in kw:
            kw['to'] //= self.resolution
        if 'variable' in kw:
            self.variable = kw['variable']
            del kw['variable']
        else:
            self.variable = None
        value = None
        if 'value' in kw:
            value = kw['value']
            del kw['value']
        elif self.variable:
            value = self.variable.get()
        self.value = value
        self.command = command = None
        if 'command' in kw:
            command = kw['command']
        kw['command'] = self._scale_command
        if 'label' in kw:
            self.label_text = kw['label']
            width = len(self.label_text)+4
            # width = None
            del kw['label']
        else:
            self.label_text = None
            width = 3

        # create widgets
        side = 'left'  # 'top'
        self.frame = ttk.Frame(parent)
        self.label = ttk.Label(self.frame, anchor='w',
                               width=width, padding=(5, 0))
        self.label.pack(side=side, expand=False, fill='x')
        self.scale = ttk.Scale(self.frame, **kw)
        self.scale.pack(side=side, expand=True, fill='both', pady=4)

        if self.variable:
            self.variable.trace('w', self._trace_var)
        if value is not None:
            self._set_text(self._round(value))
            if self.variable:
                self.variable.set(value)
        self.command = command

    def _round(self, value):
        return int(round(float(value)/self.resolution))*self.resolution

    def _trace_var(self, *args):
        self.scale.set(float(self.variable.get())/self.resolution)

    def _set_text(self, v):
        if self.label_text:
            t = self.label_text+' '+str(v)
        else:
            t = str(v)
        self.label.configure(text=t)

    def _scale_command(self, value):
        v = self._round(float(value)*self.resolution)
        self._set_text(v)
        self.variable.set(v)
        if value != self.value and self.command:
            self.command(value)
        self.value = value

    def pack(self, **kw):
        self.frame.pack(**kw)

    def grid(self, **kw):
        self.frame.grid(**kw)

    def configure(self, **kw):
        self.scale.configure(**kw)
    config = configure

    def state(self, v):
        self.scale.state(statespec=(v,))
        self.label.state(statespec=(v,))

    def get(self):
        return self.variable.get()

    def set(self, v):
        self.variable.set(v)


class TkinterScale(tkinter.Scale):
    def __init__(self, parent, **kw):
        if 'value' in kw:
            del kw['value']
        tkinter.Scale.__init__(self, parent, **kw)


PysolScale = MyPysolScale
# PysolScale = TkinterScale


# ************************************************************************
# * ttk.Combobox workaround (clear selection)
# ************************************************************************

class PysolCombo(ttk.Combobox):
    def __init__(self, master=None, **kw):
        self._command = None
        if 'selectcommand' in kw:
            self._command = kw['selectcommand']
            del kw['selectcommand']
        ttk.Combobox.__init__(self, master, **kw)
        self.bind('<<ComboboxSelected>>', self._callback)

    def _callback(self, *args):
        # self.selection_clear()
        self.selection_range(0, 0)
        if self._command is not None:
            return self._command(*args)
        return None
from six.moves import tkinter_ttk as ttk

from .tkwidget import MfxDialog


class BaseTileMfxDialog(MfxDialog):
    def _calcToolkit(self):
        return ttk

    def _calc_MfxDialog(self):
        return MfxDialog
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

from pysollib.mfxutil import KwStruct
from pysollib.mygettext import _
from pysollib.wizardpresets import presets
from pysollib.wizardutil import WizardWidgets

import six
from six.moves import tkinter
from six.moves import tkinter_ttk as ttk

from .tkwidget import MfxDialog
from .tkwidget import PysolCombo, PysolScale


class WizardDialog(MfxDialog):
    def __init__(self, parent, title, app, **kw):
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.createBitmaps(top_frame, kw)

        frame = ttk.Frame(top_frame)
        frame.pack(expand=True, fill='both', padx=10, pady=10)
        frame.columnconfigure(0, weight=1)

        notebook = ttk.Notebook(frame)
        notebook.pack(expand=True, fill='both')

        for w in WizardWidgets:
            if isinstance(w, six.string_types):
                frame = ttk.Frame(notebook)
                notebook.add(frame, text=w, sticky='nsew', padding=5)
                frame.columnconfigure(1, weight=1)
                row = 0
                continue

            ttk.Label(frame, text=w.label).grid(row=row, column=0)

            if w.widget == 'preset':
                if w.variable is None:
                    w.variable = tkinter.StringVar()
                values = [_(v) for v in w.values]
                default = _(w.default)
                values.remove(default)
                values.sort()
                values.insert(0, default)

                def callback(e, w=w):
                    self.presetSelected(e, w)
                cb = PysolCombo(frame, values=tuple(values),
                                textvariable=w.variable,
                                exportselection=False,
                                selectcommand=callback,
                                state='readonly', width=32)
                cb.grid(row=row, column=1, sticky='ew', padx=2, pady=2)
            elif w.widget == 'entry':
                if w.variable is None:
                    w.variable = tkinter.StringVar()
                en = ttk.Entry(frame, textvariable=w.variable)
                en.grid(row=row, column=1, sticky='ew', padx=2, pady=2)
            elif w.widget == 'menu':
                if w.variable is None:
                    w.variable = tkinter.StringVar()
                values = [_(v) for v in w.values]
                cb = PysolCombo(frame, values=tuple(values),
                                textvariable=w.variable,
                                exportselection=False,
                                state='readonly', width=32)
                cb.grid(row=row, column=1, sticky='ew', padx=2, pady=2)
            elif w.widget == 'spin':
                if w.variable is None:
                    w.variable = tkinter.IntVar()
                else:
                    # delete all trace callbacks
                    for mod, cbname in w.variable.trace_vinfo():
                        w.variable.trace_vdelete(mod, cbname)
                from_, to = w.values
                # s = Spinbox(
                #   frame, textvariable=w.variable, from_=from_, to=to)
                s = PysolScale(frame, from_=from_, to=to, resolution=1,
                               orient='horizontal',
                               variable=w.variable)
                s.grid(row=row, column=1, sticky='ew', padx=2, pady=2)
            elif w.widget == 'check':
                if w.variable is None:
                    w.variable = tkinter.BooleanVar()
                ch = ttk.Checkbutton(frame, variable=w.variable,
                                     takefocus=False)
                ch.grid(row=row, column=1, sticky='ew', padx=2, pady=2)

            if w.current_value is None:
                v = w.default
            else:
                v = w.current_value
            if w.widget in ('menu', 'preset'):
                v = _(v)
            w.variable.set(v)

            row += 1

        focus = self.createButtons(bottom_frame, kw)
        self.mainloop(focus, kw.timeout)

    def presetSelected(self, e, w):
        n = e.widget.get()
        n = w.translation_map[n]
        p = presets[n]
        for w in WizardWidgets:
            if isinstance(w, six.string_types):
                continue
            if w.var_name in p:
                v = p[w.var_name]
            else:
                v = w.default
            if w.widget in ('menu', 'preset', 'entry'):
                v = _(v)
            w.variable.set(v)

    def initKw(self, kw):
        kw = KwStruct(kw,
                      strings=(_('&OK'), _('&Cancel')),
                      default=0,
                      separator=False,
                      )
        return MfxDialog.initKw(self, kw)
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

import pysollib.ui.tktile.gameinfodialog
from pysollib.tile.basetilemfxdialog import BaseTileMfxDialog


class GameInfoDialog(pysollib.ui.tktile.gameinfodialog.BaseGameInfoDialog,
                     BaseTileMfxDialog):
    True
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

# imports

# Toolkit imports
from pysollib.tile.basetilemfxdialog import BaseTileMfxDialog
from pysollib.ui.tktile.edittextdialog import BaseEditTextDialog

# ************************************************************************
# *
# ************************************************************************


class EditTextDialog(BaseEditTextDialog, BaseTileMfxDialog):

    def _calc_Resizable(self):
        return False
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

import os

from pysollib.mfxutil import KwStruct, USE_PIL
from pysollib.mygettext import _
from pysollib.resource import CSI
from pysollib.ui.tktile.selecttree import SelectDialogTreeData
from pysollib.ui.tktile.tkcanvas import MfxCanvasImage
from pysollib.ui.tktile.tkutil import loadImage
from pysollib.util import CARDSET

from six.moves import tkinter
from six.moves import tkinter_ttk as ttk

from .selecttree import SelectDialogTreeCanvas
from .selecttree import SelectDialogTreeLeaf, SelectDialogTreeNode
from .tkwidget import MfxDialog, MfxScrolledCanvas, PysolScale


# ************************************************************************
# * Nodes
# ************************************************************************

class SelectCardsetLeaf(SelectDialogTreeLeaf):
    pass


class SelectCardsetNode(SelectDialogTreeNode):
    def _getContents(self):
        contents = []
        for obj in self.tree.data.all_objects:
            if self.select_func(obj):
                node = SelectCardsetLeaf(
                    self.tree, self, text=obj.name, key=obj.index)
                contents.append(node)
        return contents or self.tree.data.no_contents


# ************************************************************************
# * Tree database
# ************************************************************************

class SelectCardsetData(SelectDialogTreeData):
    def __init__(self, manager, key):
        SelectDialogTreeData.__init__(self)
        self.all_objects = manager.getAllSortedByName()
        self.all_objects = [obj for obj in self.all_objects if not obj.error]
        self.no_contents = [SelectCardsetLeaf(
            None, None, _("(no cardsets)"), key=None), ]
        #
        select_by_type = None
        items = list(CSI.TYPE.items())
        items.sort(key=lambda x: x[1])
        nodes = []
        for key, name in items:
            if manager.registered_types.get(key):
                nodes.append(
                    SelectCardsetNode(
                        None, name, lambda cs, key=key: key == cs.si.type))
        if nodes:
            select_by_type = SelectCardsetNode(
                None, _("by Type"), tuple(nodes), expanded=1)
        #
        select_by_style = None
        items = list(CSI.STYLE.items())
        items.sort(key=lambda x: x[1])
        nodes = []
        for key, name in items:
            if manager.registered_styles.get(key):
                nodes.append(
                    SelectCardsetNode(
                        None, name, lambda cs, key=key: key in cs.si.styles))
        if nodes:
            nodes.append(
                SelectCardsetNode(
                    None, _("Uncategorized"), lambda cs: not cs.si.styles))
            select_by_style = SelectCardsetNode(
                None, _("by Style"), tuple(nodes))
        #
        select_by_nationality = None
        items = list(CSI.NATIONALITY.items())
        items.sort(key=lambda x: x[1])
        nodes = []
        for key, name in items:
            if manager.registered_nationalities.get(key):
                nodes.append(
                    SelectCardsetNode(
                        None, name,
                        lambda cs, key=key: key in cs.si.nationalities))
        if nodes:
            nodes.append(
                SelectCardsetNode(
                    None, _("Uncategorized"),
                    lambda cs: not cs.si.nationalities))
            select_by_nationality = SelectCardsetNode(
                None, _("by Nationality"), tuple(nodes))
        #
        select_by_date = None
        items = list(CSI.DATE.items())
        items.sort(key=lambda x: x[1])
        nodes = []
        for key, name in items:
            if manager.registered_dates.get(key):
                nodes.append(
                    SelectCardsetNode(
                        None, name, lambda cs, key=key: key in cs.si.dates))
        if nodes:
            nodes.append(
                SelectCardsetNode(
                    None, _("Uncategorized"), lambda cs: not cs.si.dates))
            select_by_date = SelectCardsetNode(
                None, _("by Date"), tuple(nodes))
        #
        self.rootnodes = [_f for _f in (
            SelectCardsetNode(
                None, _("All Cardsets"),
                lambda cs: 1, expanded=len(self.all_objects) <= 12),
            SelectCardsetNode(
                None, _("by Size"),
                (SelectCardsetNode(
                    None, _("Tiny cardsets"),
                    lambda cs: cs.si.size == CSI.SIZE_TINY),
                 SelectCardsetNode(
                    None, _("Small cardsets"),
                    lambda cs: cs.si.size == CSI.SIZE_SMALL),
                 SelectCardsetNode(
                    None, _("Medium cardsets"),
                    lambda cs: cs.si.size == CSI.SIZE_MEDIUM),
                 SelectCardsetNode(
                    None, _("Large cardsets"),
                    lambda cs: cs.si.size == CSI.SIZE_LARGE),
                 SelectCardsetNode(
                    None, _("XLarge cardsets"),
                    lambda cs: cs.si.size == CSI.SIZE_XLARGE),
                 ), expanded=1),
            select_by_type,
            select_by_style,
            select_by_date,
            select_by_nationality,
        ) if _f]


class SelectCardsetByTypeData(SelectDialogTreeData):
    def __init__(self, manager, key):
        SelectDialogTreeData.__init__(self)
        self.all_objects = manager.getAllSortedByName()
        self.no_contents = [SelectCardsetLeaf(None, None, _("(no cardsets)"),
                            key=None), ]
        #
        items = list(CSI.TYPE.items())
        items.sort(key=lambda x: x[1])
        nodes = []
        for key, name in items:
            if manager.registered_types.get(key):
                nodes.append(
                    SelectCardsetNode(
                        None, name, lambda cs, key=key: key == cs.si.type))
        select_by_type = SelectCardsetNode(
            None, _("by Type"), tuple(nodes), expanded=1)
        #
        self.rootnodes = [_f for _f in (
            select_by_type,
        ) if _f]


# ************************************************************************
# * Canvas that shows the tree
# ************************************************************************

class SelectCardsetTree(SelectDialogTreeCanvas):
    data = None


class SelectCardsetByTypeTree(SelectDialogTreeCanvas):
    data = None


# ************************************************************************
# * Dialog
# ************************************************************************

class SelectCardsetDialogWithPreview(MfxDialog):
    Tree_Class = SelectCardsetTree
    TreeDataHolder_Class = SelectCardsetTree
    TreeData_Class = SelectCardsetData

    def __init__(self, parent, title, app, manager, key=None, **kw):
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.createBitmaps(top_frame, kw)
        #
        if key is None:
            key = manager.getSelected()
        self.manager = manager
        self.key = key
        self.app = app
        self.cardset_values = None
        # padx, pady = kw.padx, kw.pady
        padx, pady = 5, 5
        if self.TreeDataHolder_Class.data is None:
            self.TreeDataHolder_Class.data = self.TreeData_Class(manager, key)
        #
        self.top.wm_minsize(400, 200)
        if self.top.winfo_screenwidth() >= 800:
            w1, w2 = 240, 400
        else:
            w1, w2 = 200, 300
        paned_window = ttk.PanedWindow(top_frame, orient='horizontal')
        paned_window.pack(expand=True, fill='both')
        left_frame = ttk.Frame(paned_window)
        right_frame = ttk.Frame(paned_window)
        paned_window.add(left_frame)
        paned_window.add(right_frame)
        font = app.getFont("default")
        self.tree = self.Tree_Class(self, left_frame, key=key,
                                    default=kw.default,
                                    font=font, width=w1)
        self.tree.frame.grid(row=0, column=0, sticky='nsew',
                             padx=padx, pady=pady)
        if USE_PIL:
            #
            var = tkinter.DoubleVar()
            var.set(app.opt.scale_x)
            self.scale_x = PysolScale(
                left_frame, label=_('Scale X:'),
                from_=0.5, to=4.0, resolution=0.1,
                orient='horizontal', variable=var,
                value=app.opt.scale_x,
                command=self._updateScale)
            self.scale_x.grid(
                row=1, column=0, sticky='ew', padx=padx, pady=pady)
            #
            var = tkinter.DoubleVar()
            var.set(app.opt.scale_y)
            self.scale_y = PysolScale(
                left_frame, label=_('Scale Y:'),
                from_=0.5, to=4.0, resolution=0.1,
                orient='horizontal', variable=var,
                value=app.opt.scale_y,
                command=self._updateScale)
            self.scale_y.grid(
                row=2, column=0, sticky='ew', padx=padx, pady=pady)
            #
            self.auto_scale = tkinter.BooleanVar()
            self.auto_scale.set(app.opt.auto_scale)
            check = ttk.Checkbutton(
                left_frame, text=_('Auto scaling'),
                variable=self.auto_scale,
                takefocus=False,
                command=self._updateAutoScale
                )
            check.grid(row=3, column=0, columnspan=2, sticky='ew',
                       padx=padx, pady=pady)
            #
            self.preserve_aspect = tkinter.BooleanVar()
            self.preserve_aspect.set(app.opt.preserve_aspect_ratio)
            self.aspect_check = ttk.Checkbutton(
                left_frame, text=_('Preserve aspect ratio'),
                variable=self.preserve_aspect,
                takefocus=False,
                # command=self._updateScale
                )
            self.aspect_check.grid(row=4, column=0, sticky='ew',
                                   padx=padx, pady=pady)
            self._updateAutoScale()
        #
        left_frame.rowconfigure(0, weight=1)
        left_frame.columnconfigure(0, weight=1)
        #
        self.preview = MfxScrolledCanvas(right_frame, width=w2)
        self.preview.setTile(app, app.tabletile_index, force=True)
        self.preview.pack(fill='both', expand=True, padx=padx, pady=pady)
        self.preview.canvas.preview = 1
        # create a preview of the current state
        self.preview_key = -1
        self.preview_images = []
        self.scale_images = []
        self.updatePreview(key)
        #
        focus = self.createButtons(bottom_frame, kw)
        focus = self.tree.frame
        self.mainloop(focus, kw.timeout)

    def destroy(self):
        self.tree.updateNodesWithTree(self.tree.rootnodes, None)
        self.tree.destroy()
        self.preview.unbind_all()
        self.preview_images = []
        MfxDialog.destroy(self)

    def initKw(self, kw):
        if USE_PIL:
            s = (_("&Info / Settings..."), 10)
        else:
            s = (_("&Info..."), 10)
        kw = KwStruct(kw,
                      strings=(s, 'sep',
                               _("&OK"), _("&Cancel"),),
                      default=0,
                      resizable=True,
                      )
        return MfxDialog.initKw(self, kw)

    def mDone(self, button):
        if button in (0, 1):            # Load/Cancel
            self.key = self.tree.selection_key
            self.tree.n_expansions = 1  # save xyview in any case
            if USE_PIL:
                auto_scale = bool(self.auto_scale.get())
                if button == 1:
                    self.app.menubar.tkopt.auto_scale.set(auto_scale)
                if auto_scale:
                    self.scale_values = (self.app.opt.scale_x,
                                         self.app.opt.scale_y,
                                         auto_scale,
                                         bool(self.preserve_aspect.get()))
                else:
                    self.scale_values = (self.scale_x.get(),
                                         self.scale_y.get(),
                                         auto_scale,
                                         self.app.opt.preserve_aspect_ratio)
        if button == 10:                # Info
            cs = self.manager.get(self.tree.selection_key)
            if not cs:
                return
            # title = CARDSET+" "+cs.name
            title = CARDSET.capitalize()+" "+cs.name
            d = CardsetInfoDialog(self.top, title=title, cardset=cs,
                                  images=self.preview_images)
            self.cardset_values = d.cardset_values
            return
        MfxDialog.mDone(self, button)

    def _updateAutoScale(self, v=None):
        if self.auto_scale.get():
            self.aspect_check.config(state='normal')
            self.scale_x.state('disabled')
            self.scale_y.state('disabled')
        else:
            self.aspect_check.config(state='disabled')
            self.scale_x.state('!disabled')
            self.scale_y.state('!disabled')

    def _updateScale(self, v):
        self.updatePreview()

    def updatePreview(self, key=None):
        if key == self.preview_key:
            return
        if key is None:
            key = self.key
        canvas = self.preview.canvas
        canvas.deleteAllItems()
        self.preview_images = []
        cs = self.manager.get(key)
        if not cs:
            self.preview_key = -1
            return
        names, columns = cs.getPreviewCardNames()
        try:
            # ???names, columns = cs.getPreviewCardNames()
            for n in names:
                f = os.path.join(cs.dir, n + cs.ext)
                self.preview_images.append(loadImage(file=f))
        except Exception:
            self.preview_key = -1
            self.preview_images = []
            return
        i, x, y, sx, sy, dx, dy = 0, 10, 10, 0, 0, cs.CARDW + 10, cs.CARDH + 10
        if USE_PIL:
            xf = self.scale_x.get()
            yf = self.scale_y.get()
            dx = int(dx*xf)
            dy = int(dy*yf)
            self.scale_images = []
        for image in self.preview_images:
            if USE_PIL:
                image = image.resize(xf, yf)
                self.scale_images.append(image)
            MfxCanvasImage(canvas, x, y, anchor="nw", image=image)
            sx, sy = max(x, sx), max(y, sy)
            i = i + 1
            if i % columns == 0:
                x, y = 10, y + dy
            else:
                x = x + dx
        canvas.config(scrollregion=(0, 0, sx+dx, sy+dy),
                      width=sx+dx, height=sy+dy)
        # canvas.config(xscrollincrement=dx, yscrollincrement=dy)
        canvas.event_generate('<Configure>')  # update bg image
        self.preview_key = key
        self.key = key


class SelectCardsetByTypeDialogWithPreview(SelectCardsetDialogWithPreview):
    Tree_Class = SelectCardsetByTypeTree
    TreeDataHolder_Class = SelectCardsetByTypeTree
    TreeData_Class = SelectCardsetByTypeData

# ************************************************************************
# * Cardset Info
# ************************************************************************


class CardsetInfoDialog(MfxDialog):
    def __init__(self, parent, title, cardset, images, **kw):
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.createBitmaps(top_frame, kw)
        frame = ttk.Frame(top_frame)
        frame.pack(fill="both", expand=True, padx=5, pady=10)
        #
        #
        row = 0
        info_frame = ttk.LabelFrame(frame, text=_('About cardset'))
        info_frame.grid(row=row, column=0, columnspan=2, sticky='ew',
                        padx=0, pady=5, ipadx=5, ipady=5)
        row += 1
        styles = nationalities = year = None
        if cardset.si.styles:
            styles = '\n'.join([CSI.STYLE[i] for i in cardset.si.styles])
        if cardset.si.nationalities:
            nationalities = '\n'.join([CSI.NATIONALITY[i]
                                       for i in cardset.si.nationalities])
        if cardset.year:
            year = str(cardset.year)
        frow = 0
        for n, t in (
            # ('Version:', str(cardset.version)),
            (_('Type:'),          CSI.TYPE[cardset.type]),
            (_('Styles:'),        styles),
            (_('Nationality:'),   nationalities),
            (_('Year:'),          year),
            # (_('Number of cards:'), str(cardset.ncards)),
            (_('Size:'), '%d x %d' % (cardset.CARDW, cardset.CARDH)),
                ):
            if t is not None:
                label = ttk.Label(info_frame, text=n,
                                  anchor='w', justify='left')
                label.grid(row=frow, column=0, sticky='nw', padx=4)
                label = ttk.Label(info_frame, text=t,
                                  anchor='w', justify='left')
                label.grid(row=frow, column=1, sticky='nw', padx=4)
                frow += 1
        if images:
            try:
                from random import choice
                im = choice(images)
                f = os.path.join(cardset.dir, cardset.backname)
                self.back_image = loadImage(file=f)  # store the image
                label = ttk.Label(info_frame, image=im, padding=5)
                label.grid(row=0, column=2, rowspan=frow+1, sticky='ne')
                label = ttk.Label(info_frame, image=self.back_image,
                                  padding=(0, 5, 5, 5))  # left margin = 0
                label.grid(row=0, column=3, rowspan=frow+1, sticky='ne')

                info_frame.columnconfigure(2, weight=1)
                info_frame.rowconfigure(frow, weight=1)
            except Exception:
                pass
        if USE_PIL:
            padx = 4
            pady = 0
            settings_frame = ttk.LabelFrame(frame, text=_('Settings'))
            settings_frame.grid(row=row, column=0, columnspan=2, sticky='ew',
                                padx=0, pady=5, ipadx=5, ipady=5)
            row += 1
            var = tkinter.IntVar()
            self.x_offset = PysolScale(
                settings_frame, label=_('X offset:'),
                from_=5, to=40, resolution=1,
                orient='horizontal', variable=var,
                value=cardset.CARD_XOFFSET,
                # command=self._updateScale
                )
            self.x_offset.grid(row=0, column=0, sticky='ew',
                               padx=padx, pady=pady)
            var = tkinter.IntVar()
            self.y_offset = PysolScale(
                settings_frame, label=_('Y offset:'),
                from_=5, to=40, resolution=1,
                orient='horizontal', variable=var,
                value=cardset.CARD_YOFFSET,
                # command=self._updateScale
                )
            self.y_offset.grid(row=1, column=0, sticky='ew',
                               padx=padx, pady=pady)
            row += 1

        # bg = top_frame["bg"]
        bg = 'white'
        text_w = tkinter.Text(frame, bd=1, relief="sunken", wrap="word",
                              padx=4, width=64, height=16, bg=bg)
        text_w.grid(row=row, column=0, sticky='nsew')
        sb = ttk.Scrollbar(frame)
        sb.grid(row=row, column=1, sticky='ns')
        text_w.configure(yscrollcommand=sb.set)
        sb.configure(command=text_w.yview)
        frame.columnconfigure(0, weight=1)
        frame.rowconfigure(1, weight=1)
        #
        text = ''
        f = os.path.join(cardset.dir, "COPYRIGHT")
        try:
            text = open(f).read()
        except Exception:
            pass
        if text:
            text_w.config(state="normal")
            text_w.insert("insert", text)
        text_w.config(state="disabled")
        #
        focus = self.createButtons(bottom_frame, kw)
        # focus = text_w
        self.mainloop(focus, kw.timeout)

    def initKw(self, kw):
        if USE_PIL:
            strings = (_("&Save"), _("&Cancel"))
        else:
            strings = (_("&OK"),)
        kw = KwStruct(kw,
                      strings=strings,
                      default=0,
                      resizable=True,
                      separator=True,
                      )
        return MfxDialog.initKw(self, kw)

    def mDone(self, button):
        if USE_PIL and button == 0:
            self.cardset_values = self.x_offset.get(), self.y_offset.get()
        else:
            self.cardset_values = None
        MfxDialog.mDone(self, button)
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

import os

from pysollib.gamedb import GI
from pysollib.mfxutil import KwStruct, Struct, destruct
from pysollib.mfxutil import format_time
from pysollib.mygettext import _
from pysollib.resource import CSI
from pysollib.ui.tktile.selecttree import SelectDialogTreeData
from pysollib.ui.tktile.tkutil import unbind_destroy

from six.moves import UserList
from six.moves import tkinter_ttk as ttk

from .selecttree import SelectDialogTreeCanvas
from .selecttree import SelectDialogTreeLeaf, SelectDialogTreeNode
from .tkwidget import MfxDialog, MfxScrolledCanvas

# ************************************************************************
# * Nodes
# ************************************************************************


class SelectGameLeaf(SelectDialogTreeLeaf):
    pass


class SelectGameNode(SelectDialogTreeNode):
    def _getContents(self):
        contents = []
        if isinstance(self.select_func, UserList):
            # key/value pairs
            for id, name in self.select_func:
                if id and name:
                    node = SelectGameLeaf(self.tree, self, name, key=id)
                    contents.append(node)
        else:
            for gi in self.tree.data.all_games_gi:
                if gi and self.select_func is None:
                    # All games
                    # name = '%s (%s)' % (gi.name, CSI.TYPE_NAME[gi.category])
                    name = gi.name
                    node = SelectGameLeaf(self.tree, self, name, key=gi.id)
                    contents.append(node)
                elif gi and self.select_func(gi):
                    name = gi.name
                    node = SelectGameLeaf(self.tree, self, name, key=gi.id)
                    contents.append(node)
        return contents or self.tree.data.no_games


# ************************************************************************
# * Tree database
# ************************************************************************

class SelectGameData(SelectDialogTreeData):
    def __init__(self, app):
        SelectDialogTreeData.__init__(self)
        self.all_games_gi = list(map(
            app.gdb.get,
            app.gdb.getGamesIdSortedByName()))
        self.no_games = [SelectGameLeaf(None, None, _("(no games)"), None), ]
        #
        s_by_type = s_oriental = s_special = s_original = s_contrib = \
            s_mahjongg = None
        g = []
        for data in (GI.SELECT_GAME_BY_TYPE,
                     GI.SELECT_ORIENTAL_GAME_BY_TYPE,
                     GI.SELECT_SPECIAL_GAME_BY_TYPE,
                     GI.SELECT_ORIGINAL_GAME_BY_TYPE,
                     GI.SELECT_CONTRIB_GAME_BY_TYPE,
                     ):
            gg = []
            for name, select_func in data:
                if name is None or not list(filter(
                        select_func, self.all_games_gi)):
                    continue
                gg.append(SelectGameNode(None, _(name), select_func))
            g.append(gg)

        def select_mahjongg_game(gi):
            return gi.si.game_type == GI.GT_MAHJONGG

        gg = None
        if list(filter(select_mahjongg_game, self.all_games_gi)):
            gg = SelectGameNode(None, _("Mahjongg Games"),
                                select_mahjongg_game)
        g.append(gg)
        if g[0]:
            s_by_type = SelectGameNode(None, _("French games"),
                                       tuple(g[0]), expanded=1)
        if g[1]:
            s_oriental = SelectGameNode(None, _("Oriental Games"),
                                        tuple(g[1]))
        if g[2]:
            s_special = SelectGameNode(None, _("Special Games"),
                                       tuple(g[2]))
        if g[3]:
            s_original = SelectGameNode(None, _("Original Games"),
                                        tuple(g[3]))
        # if g[4]:
        #   s_contrib = SelectGameNode(None, "Contributed Games", tuple(g[4]))
        if g[5]:
            s_mahjongg = g[5]
        #
        s_by_compatibility, gg = None, []
        for name, games in GI.GAMES_BY_COMPATIBILITY:
            def select_func(gi, games=games):
                return gi.id in games
            if name is None or not list(filter(
                    select_func, self.all_games_gi)):
                continue
            gg.append(SelectGameNode(None, name, select_func))
        if 1 and gg:
            s_by_compatibility = SelectGameNode(None, _("by Compatibility"),
                                                tuple(gg))
        #
        s_by_pysol_version, gg = None, []
        for name, games in GI.GAMES_BY_PYSOL_VERSION:
            def select_func(gi, games=games):
                return gi.id in games
            if name is None or not list(filter(
                    select_func, self.all_games_gi)):
                continue
            name = _("New games in v. %(version)s") % {'version': name}
            gg.append(SelectGameNode(None, name, select_func))
        if 1 and gg:
            s_by_pysol_version = SelectGameNode(None, _("by PySol version"),
                                                tuple(gg))
        s_by_inventors, gg = None, []
        for name, games in GI.GAMES_BY_INVENTORS:
            def select_func(gi, games=games):
                return gi.id in games
            if name is None or not list(filter(
                    select_func, self.all_games_gi)):
                continue
            gg.append(SelectGameNode(None, name, select_func))
        if 1 and gg:
            s_by_inventors = SelectGameNode(None, _("by Inventors"),
                                            tuple(gg))
        #
        ul_alternate_names = UserList(
            list(app.gdb.getGamesTuplesSortedByAlternateName()))
        #
        self.rootnodes = [_f for _f in (
            SelectGameNode(None, _("All Games"), None, expanded=0),
            SelectGameNode(None, _("Alternate Names"), ul_alternate_names),
            SelectGameNode(None, _("Popular Games"),
                           lambda gi: gi.si.game_flags & GI.GT_POPULAR),
            s_by_type,
            s_mahjongg,
            s_oriental,
            s_special,
            SelectGameNode(None, _("Custom Games"),
                           lambda gi: gi.si.game_type == GI.GT_CUSTOM),
            SelectGameNode(None, _('by Skill Level'), (
                SelectGameNode(None, _('Luck only'),
                               lambda gi: gi.skill_level == GI.SL_LUCK),
                SelectGameNode(None, _('Mostly luck'),
                               lambda gi: gi.skill_level == GI.SL_MOSTLY_LUCK),
                SelectGameNode(None, _('Balanced'),
                               lambda gi: gi.skill_level == GI.SL_BALANCED),
                SelectGameNode(
                    None, _('Mostly skill'),
                    lambda gi: gi.skill_level == GI.SL_MOSTLY_SKILL),
                SelectGameNode(None, _('Skill only'),
                               lambda gi: gi.skill_level == GI.SL_SKILL),
                )),
            SelectGameNode(None, _("by Game Feature"), (
                SelectGameNode(None, _("by Number of Cards"), (
                    SelectGameNode(None, _("32 cards"),
                                   lambda gi: gi.si.ncards == 32),
                    SelectGameNode(None, _("48 cards"),
                                   lambda gi: gi.si.ncards == 48),
                    SelectGameNode(None, _("52 cards"),
                                   lambda gi: gi.si.ncards == 52),
                    SelectGameNode(None, _("64 cards"),
                                   lambda gi: gi.si.ncards == 64),
                    SelectGameNode(None, _("78 cards"),
                                   lambda gi: gi.si.ncards == 78),
                    SelectGameNode(None, _("104 cards"),
                                   lambda gi: gi.si.ncards == 104),
                    SelectGameNode(None, _("144 cards"),
                                   lambda gi: gi.si.ncards == 144),
                    SelectGameNode(
                        None, _("Other number"),
                        lambda gi: gi.si.ncards not in (32, 48, 52,
                                                        64, 78, 104, 144)),
                )),
                SelectGameNode(None, _("by Number of Decks"), (
                    SelectGameNode(None, _("1 deck games"),
                                   lambda gi: gi.si.decks == 1),
                    SelectGameNode(None, _("2 deck games"),
                                   lambda gi: gi.si.decks == 2),
                    SelectGameNode(None, _("3 deck games"),
                                   lambda gi: gi.si.decks == 3),
                    SelectGameNode(None, _("4 deck games"),
                                   lambda gi: gi.si.decks == 4),
                )),
                SelectGameNode(None, _("by Number of Redeals"), (
                    SelectGameNode(None, _("No redeal"),
                                   lambda gi: gi.si.redeals == 0),
                    SelectGameNode(None, _("1 redeal"),
                                   lambda gi: gi.si.redeals == 1),
                    SelectGameNode(None, _("2 redeals"),
                                   lambda gi: gi.si.redeals == 2),
                    SelectGameNode(None, _("3 redeals"),
                                   lambda gi: gi.si.redeals == 3),
                    SelectGameNode(None, _("Unlimited redeals"),
                                   lambda gi: gi.si.redeals == -1),
                    SelectGameNode(
                        None, _("Other number of redeals"),
                        lambda gi: gi.si.redeals not in (-1, 0, 1, 2, 3)),
                )),
                s_by_compatibility,
            )),
            s_by_pysol_version,
            s_by_inventors,
            SelectGameNode(None, _("Other Categories"), (
                SelectGameNode(None, _("Games for Children (very easy)"),
                               lambda gi: gi.si.game_flags & GI.GT_CHILDREN),
                SelectGameNode(None, _("Games with Scoring"),
                               lambda gi: gi.si.game_flags & GI.GT_SCORE),
                SelectGameNode(
                    None, _("Games with Separate Decks"),
                    lambda gi: gi.si.game_flags & GI.GT_SEPARATE_DECKS),
                SelectGameNode(None, _("Open Games (all cards visible)"),
                               lambda gi: gi.si.game_flags & GI.GT_OPEN),
                SelectGameNode(None, _("Relaxed Variants"),
                               lambda gi: gi.si.game_flags & GI.GT_RELAXED),
            )),
            s_original,
            s_contrib,
        ) if _f]


# ************************************************************************
# * Canvas that shows the tree
# ************************************************************************

class SelectGameTreeWithPreview(SelectDialogTreeCanvas):
    data = None


class SelectGameTree(SelectGameTreeWithPreview):
    def singleClick(self, event=None):
        self.doubleClick(event)


# ************************************************************************
# * Dialog
# ************************************************************************

class SelectGameDialog(MfxDialog):
    Tree_Class = SelectGameTree
    TreeDataHolder_Class = SelectGameTreeWithPreview
    TreeData_Class = SelectGameData

    def __init__(self, parent, title, app, gameid, **kw):
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.createBitmaps(top_frame, kw)
        #
        self.app = app
        self.gameid = gameid
        self.random = None
        if self.TreeDataHolder_Class.data is None:
            self.TreeDataHolder_Class.data = self.TreeData_Class(app)
        #
        self.top.wm_minsize(200, 200)
        font = app.getFont("default")
        self.tree = self.Tree_Class(self, top_frame, key=gameid,
                                    font=font, default=kw.default)
        self.tree.frame.pack(fill='both', expand=True,
                             padx=kw.padx, pady=kw.pady)
        #
        focus = self.createButtons(bottom_frame, kw)
        focus = self.tree.frame
        self.mainloop(focus, kw.timeout)

    def initKw(self, kw):
        kw = KwStruct(kw,
                      strings=(None, None, _("&Cancel"),), default=0,
                      resizable=True,
                      separator=True,
                      )
        return MfxDialog.initKw(self, kw)

    def destroy(self):
        self.app = None
        self.tree.updateNodesWithTree(self.tree.rootnodes, None)
        self.tree.destroy()
        MfxDialog.destroy(self)

    def mDone(self, button):
        if button == 0:                 # Ok or double click
            self.gameid = self.tree.selection_key
            self.tree.n_expansions = 1  # save xyview in any case
        if button == 10:                # Rules
            doc = self.app.getGameRulesFilename(self.tree.selection_key)
            if not doc:
                return
            dir = os.path.join("html", "rules")
            from pysollib.help import help_html
            help_html(self.app, doc, dir, self.top)
            self.top.grab_release()  # Don't want the help window appear frozen
            return
        MfxDialog.mDone(self, button)


# ************************************************************************
# * Dialog
# ************************************************************************

class SelectGameDialogWithPreview(SelectGameDialog):
    Tree_Class = SelectGameTreeWithPreview

    def __init__(self, parent, title, app, gameid, bookmark=None, **kw):
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.createBitmaps(top_frame, kw)
        #
        self.app = app
        self.gameid = gameid
        self.bookmark = bookmark
        self.random = None
        if self.TreeDataHolder_Class.data is None:
            self.TreeDataHolder_Class.data = self.TreeData_Class(app)
        #
        self.top.wm_minsize(400, 200)
        sw = self.top.winfo_screenwidth()
        if sw >= 1100:
            w1, w2 = 250, 600
        elif sw >= 900:
            w1, w2 = 250, 500
        elif sw >= 800:
            w1, w2 = 220, 480
        else:
            w1, w2 = 200, 300
        # print sw, w1, w2
        w2 = max(200, min(w2, 10 + 12*(app.subsampled_images.CARDW+10)))
        # print sw, w1, w2
        # padx, pady = kw.padx, kw.pady
        # padx, pady = kw.padx/2, kw.pady/2
        padx, pady = 4, 4
        # PanedWindow
        paned_window = ttk.PanedWindow(top_frame, orient='horizontal')
        paned_window.pack(expand=True, fill='both', padx=8, pady=8)
        left_frame = ttk.Frame(paned_window)
        right_frame = ttk.Frame(paned_window)
        paned_window.add(left_frame)
        paned_window.add(right_frame)
        # Tree
        font = app.getFont("default")
        self.tree = self.Tree_Class(self, left_frame, key=gameid,
                                    default=kw.default, font=font, width=w1)
        self.tree.frame.pack(padx=padx, pady=pady, expand=True, fill='both')
        # LabelFrame
        info_frame = ttk.LabelFrame(right_frame, text=_('About game'))
        info_frame.grid(row=0, column=0, padx=padx, pady=pady,
                        ipadx=4, ipady=4, sticky='nws')
        stats_frame = ttk.LabelFrame(right_frame, text=_('Statistics'))
        stats_frame.grid(row=0, column=1, padx=padx, pady=pady,
                         ipadx=4, ipady=4, sticky='nws')
        # Info
        self.info_labels = {}
        for n, t, f, row in (
            ('name',        _('Name:'),             info_frame,   0),
            ('altnames',    _('Alternate names:'),  info_frame,   1),
            ('category',    _('Category:'),         info_frame,   2),
            ('type',        _('Type:'),             info_frame,   3),
            ('skill_level', _('Skill level:'),      info_frame,   4),
            ('decks',       _('Decks:'),            info_frame,   5),
            ('redeals',     _('Redeals:'),          info_frame,   6),
            #
            ('played',      _('Played:'),           stats_frame,  0),
            ('won',         _('Won:'),              stats_frame,  1),
            ('lost',        _('Lost:'),             stats_frame,  2),
            ('time',        _('Playing time:'),     stats_frame,  3),
            ('moves',       _('Moves:'),            stats_frame,  4),
            ('percent',     _('% won:'),            stats_frame,  5),
                ):
            title_label = ttk.Label(f, text=t, justify='left', anchor='w')
            title_label.grid(row=row, column=0, sticky='nw', padx=4)
            text_label = ttk.Label(f, justify='left', anchor='w')
            text_label.grid(row=row, column=1, sticky='nw', padx=4)
            self.info_labels[n] = (title_label, text_label)
        # info_frame.columnconfigure(1, weight=1)
        info_frame.rowconfigure(6, weight=1)
        stats_frame.rowconfigure(6, weight=1)
        # Canvas
        self.preview = MfxScrolledCanvas(right_frame, width=w2)
        self.preview.setTile(app, app.tabletile_index, force=True)
        self.preview.grid(row=1, column=0, columnspan=3,
                          padx=padx, pady=pady, sticky='nsew')
        right_frame.columnconfigure(1, weight=1)
        right_frame.rowconfigure(1, weight=1)
        #
        focus = self.createButtons(bottom_frame, kw)
        # set the scale factor
        self.preview.canvas.preview = 2
        # create a preview of the current game
        self.preview_key = -1
        self.preview_game = None
        self.preview_app = None
        self.updatePreview(gameid, animations=0)
        # focus = self.tree.frame
        self.mainloop(focus, kw.timeout)

    def initKw(self, kw):
        kw = KwStruct(kw,
                      strings=((_("&Rules"), 10), 'sep',
                               _("&Select"), _("&Cancel"),),
                      default=0,
                      )
        return SelectGameDialog.initKw(self, kw)

    def destroy(self):
        self.deletePreview(destroy=1)
        self.preview.unbind_all()
        SelectGameDialog.destroy(self)

    def deletePreview(self, destroy=0):
        self.preview_key = -1
        # clean up the canvas
        if self.preview:
            unbind_destroy(self.preview.canvas)
            self.preview.canvas.deleteAllItems()
            if destroy:
                self.preview.canvas.delete("all")
        #
        # for l in self.info_labels.values():
        #    l.config(text='')
        # destruct the game
        if self.preview_game:
            self.preview_game.endGame()
            self.preview_game.destruct()
            destruct(self.preview_game)
        self.preview_game = None
        # destruct the app
        if destroy:
            if self.preview_app:
                destruct(self.preview_app)
            self.preview_app = None

    def updatePreview(self, gameid, animations=10):
        if gameid == self.preview_key:
            return
        self.deletePreview()
        canvas = self.preview.canvas
        #
        gi = self.app.gdb.get(gameid)
        if not gi:
            self.preview_key = -1
            return
        #
        if self.preview_app is None:
            self.preview_app = Struct(
                # variables
                audio=self.app.audio,
                canvas=canvas,
                cardset=self.app.cardset.copy(),
                gamerandom=self.app.gamerandom,
                gdb=self.app.gdb,
                gimages=self.app.gimages,
                images=self.app.subsampled_images,
                menubar=None,
                miscrandom=self.app.miscrandom,
                opt=self.app.opt.copy(),
                startup_opt=self.app.startup_opt,
                stats=self.app.stats.new(),
                top=None,
                top_cursor=self.app.top_cursor,
                toolbar=None,
                # methods
                constructGame=self.app.constructGame,
                getFont=self.app.getFont,
            )
            self.preview_app.opt.shadow = 0
            self.preview_app.opt.shade = 0
        #
        self.preview_app.audio = None    # turn off audio for initial dealing
        if animations >= 0:
            self.preview_app.opt.animations = animations
        #
        if self.preview_game:
            self.preview_game.endGame()
            self.preview_game.destruct()
        # self.top.wm_title("Select Game - " +
        #   self.app.getGameTitleName(gameid))
        title = self.app.getGameTitleName(gameid)
        self.top.wm_title(_("Playable Preview - %(game)s") % {'game': title})
        #
        self.preview_game = gi.gameclass(gi)
        self.preview_game.createPreview(self.preview_app)
        #
        random = None
        if gameid == self.gameid:
            random = self.app.game.random.copy()
        if gameid == self.gameid and self.bookmark:
            self.preview_game.restoreGameFromBookmark(self.bookmark)
        else:
            self.preview_game.newGame(random=random, autoplay=1)
        gw, gh = self.preview_game.width, self.preview_game.height
        canvas.config(scrollregion=(0, 0, gw, gh))
        canvas.xview_moveto(0)
        canvas.yview_moveto(0)
        #
        self.preview_app.audio = self.app.audio
        if self.app.opt.animations:
            self.preview_app.opt.animations = 10
        else:
            self.preview_app.opt.animations = 0
        # save seed
        self.random = self.preview_game.random.copy()
        self.random.origin = self.random.ORIGIN_PREVIEW
        self.preview_key = gameid
        #
        self.updateInfo(gameid)
        #
        rules_button = self.buttons[0]
        if self.app.getGameRulesFilename(gameid):
            rules_button.config(state="normal")
        else:
            rules_button.config(state="disabled")

    def updateInfo(self, gameid):
        gi = self.app.gdb.get(gameid)
        # info
        name = gi.name
        altnames = '\n'.join(gi.altnames)
        category = _(CSI.TYPE[gi.category])
        type = ''
        if gi.si.game_type in GI.TYPE_NAMES:
            type = _(GI.TYPE_NAMES[gi.si.game_type])
        sl = {
            GI.SL_LUCK:         _('Luck only'),
            GI.SL_MOSTLY_LUCK:  _('Mostly luck'),
            GI.SL_BALANCED:     _('Balanced'),
            GI.SL_MOSTLY_SKILL: _('Mostly skill'),
            GI.SL_SKILL:        _('Skill only'),
            }
        skill_level = sl.get(gi.skill_level)
        if gi.redeals == -2:
            redeals = _('variable')
        elif gi.redeals == -1:
            redeals = _('unlimited')
        else:
            redeals = str(gi.redeals)
        # stats
        won, lost, time, moves = self.app.stats.getFullStats(
            self.app.opt.player, gameid)
        if won+lost > 0:
            percent = "%.1f" % (100.0*won/(won+lost))
        else:
            percent = "0.0"
        time = format_time(time)
        moves = str(round(moves, 1))
        for n, t in (
            ('name',        name),
            ('altnames',    altnames),
            ('category',    category),
            ('type',        type),
            ('skill_level', skill_level),
            ('decks',       gi.decks),
            ('redeals',     redeals),
            ('played',      won+lost),
            ('won',         won),
            ('lost',        lost),
            ('time',        time),
            ('moves',       moves),
            ('percent',     percent),
                ):
            title_label, text_label = self.info_labels[n]
            if t in ('', None):
                title_label.grid_remove()
                text_label.grid_remove()
            else:
                title_label.grid()
                text_label.grid()
            text_label.config(text=t)
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##
"""
A number of function that enhance PySol on MacOSX when it used as a normal
GUI application (as opposed to an X11 application).
"""
import sys

from six.moves.tkinter import TclError


def runningAsOSXApp():
    """ Returns True if-and-only-if running from the
    PySol.app bundle on OSX """
    return (sys.platform == 'darwin' and 'PySol.app' in sys.argv[0])


def hideTkConsole(root):
    try:
        root.tk.call('console', 'hide')
    except TclError:
        pass


def setupApp(app):
    """
    Perform setup for the OSX application bundle.
    """
    if not runningAsOSXApp():
        return
    hideTkConsole(app.top)
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

import os
import traceback

from pysollib.settings import TITLE
from pysollib.settings import TOOLKIT, USE_TILE
from pysollib.winsystems.common import \
        BaseTkSettings, \
        base_init_root_window, \
        get_font_name

if TOOLKIT == 'tk':
    if USE_TILE:
        from six.moves import tkinter_ttk as ttk


# ************************************************************************
# * Init root window
# ************************************************************************

def init_root_window(root, app):

    base_init_root_window(root, app)

    # root.self.wm_maxsize(9999, 9999) # unlimited
    if TOOLKIT == 'gtk':
        pass
    elif TOOLKIT == 'kivy':
        pass
    elif USE_TILE:
        f = os.path.join(app.dataloader.dir, 'tcl', 'menu8.4.tcl')
        if os.path.exists(f):
            try:
                root.tk.evalfile(f)
            except Exception:
                traceback.print_exc()
        f = 'clrpick8.5.tcl'
        f = os.path.join(app.dataloader.dir, 'tcl', f)
        if os.path.exists(f):
            try:
                root.tk.evalfile(f)
            except Exception:
                traceback.print_exc()
        f = 'fsdialog8.5.tcl'
        f = os.path.join(app.dataloader.dir, 'tcl', f)
        if os.path.exists(f):
            try:
                root.tk.evalfile(f)
            except Exception:
                traceback.print_exc()
            else:
                from six.moves import tkinter_tkfiledialog
                tkinter_tkfiledialog.Open.command = 'ttk::getOpenFile'
                tkinter_tkfiledialog.SaveAs.command = 'ttk::getSaveFile'
                tkinter_tkfiledialog.Directory.command = 'ttk::chooseDirectory'

        style = ttk.Style(root)
        color = style.lookup('.', 'background')
        if color:
            root.tk_setPalette(color)

        root.option_add('*Menu.borderWidth', 1, 60)
        root.option_add('*Menu.activeBorderWidth', 1, 60)
        color = style.lookup('.', 'background', ['active'])
        if color:
            root.option_add('*Menu.activeBackground', color, 60)

        root.option_add('*Listbox.background', 'white', 60)
        root.option_add('*Listbox.foreground', 'black', 60)
        root.option_add('*Text.background', 'white', 60)
        root.option_add('*Text.foreground', 'black', 60)
        root.option_add('*selectForeground', 'white', 60)
        root.option_add('*selectBackground', '#0a5f89', 60)
        root.option_add('*inactiveSelectBackground', '#0a5f89', 60)  # Tk-8.5

        color = style.lookup('TEntry', 'selectbackground', ['focus'])
        if color:
            root.option_add('*selectBackground', color, 60)
            root.option_add('*inactiveSelectBackground', color, 60)
        color = style.lookup('TEntry', 'selectforeground', ['focus'])
        if color:
            root.option_add('*selectForeground', color, 60)

        root.option_add('*selectBorderWidth', 0, 60)

        font = root.option_get('font', TITLE)
        if font:
            # use font from xrdb
            fn = get_font_name(font)
            if fn:
                # root.option_add('*font', font)
                style.configure('.', font=font)
                app.opt.fonts['default'] = fn
                # treeview heading
                f = root.tk.splitlist(root.tk.call('font', 'actual', fn))
                root.tk.call('font', 'configure', 'TkHeadingFont', *f)
        else:
            # use font from ttk settings
            font = style.lookup('.', 'font')
            if font:
                fn = get_font_name(font)
                if fn:
                    root.option_add('*font', font)
                    app.opt.fonts['default'] = fn
        if app.opt.tile_theme == 'clam':
            style.configure('TLabelframe', labeloutside=False,
                            labelmargins=(8, 0, 8, 0))

    #
    else:
        root.option_add('*Entry.background', 'white', 60)
        root.option_add('*Entry.foreground', 'black', 60)
        root.option_add('*Listbox.background', 'white', 60)
        root.option_add('*Listbox.foreground', 'black', 60)
        root.option_add('*Text.background', 'white', 60)
        root.option_add('*Text.foreground', 'black', 60)
        root.option_add('*selectForeground', 'white', 60)
        root.option_add('*selectBackground', '#0a5f89', 60)
        root.option_add('*inactiveSelectBackground', '#0a5f89', 60)  # Tk-8.5
        root.option_add('*selectBorderWidth', 0, 60)
        # root.option_add('*borderWidth', '1', 50)
        # root.option_add('*Button.borderWidth', '1', 50)
        root.option_add('*Scrollbar.elementBorderWidth', 1, 60)
        root.option_add('*Scrollbar.borderWidth', 1, 60)
        root.option_add('*Menu.borderWidth', 1, 60)
        root.option_add('*Menu.activeBorderWidth', 1, 60)
        # root.option_add('*Button.HighlightBackground', '#595d59')
        # root.option_add('*Button.HighlightThickness', '1')
        font = root.option_get('font', TITLE)
        if font:
            fn = get_font_name(font)
            app.opt.fonts['default'] = fn
        else:
            root.option_add('*font', 'helvetica 12', 60)
            app.opt.fonts['default'] = ('helvetica', 12,
                                        'roman', 'normal')


class TkSettings(BaseTkSettings):
    pass
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

from pysollib.settings import TOOLKIT, USE_TILE
from pysollib.winsystems.common import BaseTkSettings, base_init_root_window

if USE_TILE:
    from six.moves import tkinter_ttk as ttk


def init_root_window(root, app):
    base_init_root_window(root, app)
    if TOOLKIT == 'gtk':
        pass
    elif USE_TILE:
        theme = app.opt.tile_theme
        style = ttk.Style(root)
        if theme not in ('winnative', 'xpnative'):
            color = style.lookup('.', 'background')
            if color:
                root.tk_setPalette(color)
            # root.option_add('*Menu.foreground', 'black')
            root.option_add('*Menu.activeBackground', '#08246b')
            root.option_add('*Menu.activeForeground', 'white')
        if theme == 'winnative':
            style.configure('Toolbutton', padding=2)
    else:
        # root.option_add(...)
        pass


class TkSettings(BaseTkSettings):
    canvas_padding = (1, 1)
    horizontal_toolbar_padding = (1, 0)
    toolbar_relief = 'groove'
    toolbar_borderwidth = 2
    if USE_TILE:
        toolbar_button_padding = (2, 0)
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.macosx.appSupport import hideTkConsole
from pysollib.settings import TOOLKIT, USE_TILE
from pysollib.winsystems.common import BaseTkSettings, base_init_root_window


def init_root_window(root, app):
    base_init_root_window(root, app)
    if TOOLKIT == 'tk':
        hideTkConsole(root)
    if TOOLKIT == 'gtk':
        pass
    elif USE_TILE:
        pass
    else:                               # pure Tk
        # root.option_add(...)
        pass


class TkSettings(BaseTkSettings):
    pass
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

import os
import traceback

from pysollib.mfxutil import print_err
from pysollib.mygettext import _
from pysollib.settings import DEBUG
from pysollib.settings import TITLE
from pysollib.settings import TOOLKIT, USE_TILE
from pysollib.settings import VERSION

if TOOLKIT == 'tk':
    from pysollib.ui.tktile.tkutil import loadImage
    if USE_TILE:
        from six.moves import tkinter_ttk as ttk


def init_tile(app, top):
    # load available themes
    d = os.path.join(app.dataloader.dir, 'themes')
    if os.path.isdir(d):
        top.tk.eval('global auto_path; lappend auto_path {%s}' % d)
        for t in os.listdir(d):
            if os.path.exists(os.path.join(d, t, 'pkgIndex.tcl')):
                try:
                    top.tk.eval('package require ttk::theme::'+t)
                    # print 'load theme:', t
                except Exception:
                    traceback.print_exc()
                    pass


def set_theme(app, top, theme):
    # set theme
    style = ttk.Style(top)
    try:
        style.theme_use(theme)
    except Exception:
        print_err(_('invalid theme name: ') + theme)
        style.theme_use(app.opt.default_tile_theme)


def get_font_name(font):
    # create font name
    # i.e. "helvetica 12" -> ("helvetica", 12, "roman", "normal")

    if (TOOLKIT == 'kivy'):
        return "helvetica 12"

    from six.moves.tkinter_font import Font
    font_name = None
    try:
        f = Font(font=font)
    except Exception:
        print_err(_('invalid font name: ') + font)
        if DEBUG:
            traceback.print_exc()
    else:
        fa = f.actual()
        font_name = (fa['family'],
                     fa['size'],
                     fa['slant'],
                     fa['weight'])
    return font_name


def base_init_root_window(root, app):
    # root.wm_group(root)
    root.wm_title(TITLE + ' ' + VERSION)
    root.wm_iconname(TITLE + ' ' + VERSION)

    if TOOLKIT == 'tk':
        icons = [loadImage(img) for img in app.dataloader.findAllIconSizes()]
        if icons:
            try:
                root.wm_iconphoto(True, *icons)
            except AttributeError:
                root.tk.call('wm', 'iconphoto', root, '-default', *icons)

    # set minsize
    sw, sh = (root.winfo_screenwidth(), root.winfo_screenheight())
    if sw < 640 or sh < 480:
        root.wm_minsize(400, 300)
    else:
        root.wm_minsize(520, 360)

    if TOOLKIT == 'gtk':
        pass
    if TOOLKIT == 'kivy':
        pass
    elif USE_TILE:
        theme = app.opt.tile_theme
        init_tile(app, root)
        set_theme(app, root, theme)
    else:
        pass


class BaseTkSettings:
    canvas_padding = (0, 0)
    horizontal_toolbar_padding = (0, 0)
    vertical_toolbar_padding = (0, 1)
    toolbar_button_padding = (2, 2)
    toolbar_label_padding = (4, 4)
    if USE_TILE:
        toolbar_relief = 'flat'
        toolbar_borderwidth = 0
    else:
        toolbar_relief = 'raised'
        toolbar_button_relief = 'flat'
        toolbar_separator_relief = 'sunken'
        toolbar_borderwidth = 1
        toolbar_button_borderwidth = 1
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.settings import WIN_SYSTEM

if WIN_SYSTEM == 'win32':
    from pysollib.winsystems import win32 as gui
elif WIN_SYSTEM == 'aqua':
    from pysollib.winsystems import aqua as gui
else:                                   # 'x11'
    from pysollib.winsystems import x11 as gui

init_root_window = gui.init_root_window
TkSettings = gui.TkSettings
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#

# imports

# PySol imports
# from pysollib.mfxutil import KwStruct
# from pysollib.settings import TITLE

# Toolkit imports
# from tkconst import EVENT_HANDLED
# from tkwidget import MfxDialog

# ************************************************************************
# *
# ************************************************************************

solver_dialog = None


def create_solver_dialog(parent, game):
    pass


def connect_game_solver_dialog(game):
    pass


def destroy_solver_dialog():
    global solver_dialog
    solver_dialog = None


def reset_solver_dialog():
    pass
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#

# imports
import os
import sys

if __name__ == '__main__':
    d = os.path.abspath(os.path.join(sys.path[0], os.pardir, os.pardir))
    sys.path.append(d)
    import gettext
    gettext.install('pysol', d, unicode=True)

# PySol imports

# Toolkit imports
# from pysollib.settings import WIN_SYSTEM

# ************************************************************************
# *
# ************************************************************************
# statusbar not used.


class MfxStatusbar:
    def __init__(self, top, row, column, columnspan):
        pass

    def _createLabel(self, name, expand=False, width=0, tooltip=None):
        pass

    def show(self, on):
        pass

    def updateText(self, **kw):
        pass

    def config(self, a, b):
        pass


class PysolStatusbar(MfxStatusbar):
    def __init__(self, top):
        pass


class HelpStatusbar(MfxStatusbar):
    def __init__(self, top):
        MfxStatusbar.__init__(self, top, row=4, column=0, columnspan=3)
        # l = self._createLabel('info', expand=True)
        # l.config(justify='left', anchor='w', padx=8)


class HtmlStatusbar(MfxStatusbar):
    def __init__(self, top, row, column, columnspan):
        MfxStatusbar.__init__(self, top, row=row,
                              column=column, columnspan=columnspan)
        # l = self._createLabel('url', expand=True)
        # l.config(justify='left', anchor='w', padx=8)


# ************************************************************************
# *
# ************************************************************************
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#

# Toolkit imports
from pysollib.pysoltk import MfxDialog

# ************************************************************************
# *
# ************************************************************************
# not implemented with kivy.


class PlayerOptionsDialog(MfxDialog):
    def __init__(self, parent, title, app, **kw):
        pass

# ************************************************************************
# *
# ************************************************************************
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
# Copyright (C) 2016-2017 LB
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#

# imports
import os

# PySol imports
from pysollib.mygettext import _, n_
from pysollib.settings import TITLE
from pysollib.util import IMAGE_EXTENSIONS
from pysollib.winsystems import TkSettings

# ************************************************************************
# *
# ************************************************************************


class AbstractToolbarButton:
    def __init__(self, parent, toolbar, toolbar_name, position):
        self.toolbar = toolbar
        self.toolbar_name = toolbar_name
        self.position = position
        self.visible = False

    def show(self, orient, force=False):
        if self.visible and not force:
            return
        self.visible = True
        padx, pady = 2, 2
        if orient == 'horizontal':
            self.grid(row=0,
                      column=self.position,
                      ipadx=padx, ipady=pady,
                      sticky='nsew')
        else:
            self.grid(row=self.position,
                      column=0,
                      ipadx=padx, ipady=pady,
                      sticky='nsew')

    def hide(self):
        if not self.visible:
            return
        self.visible = False
        self.grid_forget()

# ************************************************************************


if True:
    from pysollib.kivy.LApp import LImage
    from pysollib.kivy.LApp import LBase
    # from LApp import LMainWindow
    from kivy.uix.boxlayout import BoxLayout
    # from kivy.uix.button import Button
    from kivy.uix.behaviors import ButtonBehavior
    # from kivy.uix.behaviors import ToggleButtonBehavior
    from kivy.uix.image import Image as KivyImage

# ************************************************************************


class MyButton(ButtonBehavior, KivyImage, LBase):
    def __init__(self, **kwargs):
        super(MyButton, self).__init__(**kwargs)
        # super(MyButton, self).__init__()
        self.src = None
        if ('image' in kwargs):
            self.src = kwargs['image'].source
        self.command = None
        if ('command' in kwargs):
            self.command = kwargs['command']
        self.source = self.src
        self.allow_stretch = True

    def on_press(self):
        self.allow_stretch = False

    def on_release(self):
        self.allow_stretch = True
        if (self.command is not None):
            self.command()


class MyCheckButton(ButtonBehavior, KivyImage, LBase):
    def __init__(self, **kwargs):
        super(MyCheckButton, self).__init__(**kwargs)
        # super(MyCheckButton, self).__init__()
        self.src = None
        if ('image' in kwargs):
            self.src = kwargs['image'].source
        self.command = None
        if ('command' in kwargs):
            self.command = kwargs['command']
        self.variable = None
        if ('variable' in kwargs):
            self.variable = kwargs['variable']
        self.win = None
        if ('win' in kwargs):
            self.win = kwargs['win']
        self.source = self.src
        self.allow_stretch = True
        self.checked = False

        # self.variable = self.win.app.menubar.tkopt.pause
        if self.variable:
            self.variable.bind(value=self.updateState)

    def updateState(self, obj, val):
        if (val):
            self.allow_stretch = False
        else:
            self.allow_stretch = True

    def isChecked(self):
        return self.checked

    def on_press(self):
        if self.win is None:
            return
        if self.win.app is None:
            return
        if self.win.app.game is None:
            return

        game = self.win.app.game
        if game.finished:
            return
        if game.demo:
            return

        # if self.win.app.menubar == None: return
        # mb = self.win.app.menubar

        if game.pause:
            self.allow_stretch = True
            self.checked = False
            if (self.command is not None):
                self.command()
        else:
            self.allow_stretch = False
            self.checked = True
            if (self.command is not None):
                self.command()

    def on_release(self):
        pass

# ************************************************************************
# * Note: Applications should call show/hide after constructor.
# ************************************************************************


class PysolToolbarTk(BoxLayout):
    def __init__(
            self,
            top,
            menubar,
            dir,
            size=0,
            relief='flat',
            compound='none'):

        super(PysolToolbarTk, self).__init__(orientation='vertical')
        self.size_hint = (0.05, 1.0)
        # self.size_hint=(None, 1.0)
        # self.width = 50
        self.win = top
        self.menubar = menubar
        self.dir = dir
        self.win.setTool(self, 3)

        for label, f, t in (
            (n_("New"),      self.mNewGame,   _("New game")),
            (n_("Restart"),  self.mRestart,   _("Restart the\ncurrent game")),
            (None,           None,            None),
            # (n_("Open"),     self.mOpen,      _("Open a\nsaved game")),
            # (n_("Save"),     self.mSave,      _("Save game")),
            (None,           None,            None),
            (n_("Undo"),     self.mUndo,      _("Undo last move")),
            (n_("Redo"),     self.mRedo,      _("Redo last move")),
            (n_("Autodrop"), self.mDrop,      _("Auto drop cards")),
            (n_("Shuffle"),  self.mShuffle,   _("Shuffle tiles")),
            (n_("Pause"),    self.mPause,     _("Pause game")),
            (None,           None,            None),
            # (n_("Statistics"), self.mPlayerStats, _("View statistics")),
            (n_("Rules"),    self.mHelpRules, _("Rules for this game")),
            (None,           None,            None),
            (n_("Quit"),     self.mHoldAndQuit,      _("Quit %s") % TITLE),
        ):
            if label is None:
                # sep = self._createSeparator()
                # sep.bind("<1>", self.clickHandler)
                # sep.bind("<3>", self.rightclickHandler)
                pass
            elif label == 'Pause':
                self._createButton(label, f, check=True, tooltip=t)
            else:
                self._createButton(label, f, tooltip=t)

            # hier gibt es noch ein 'player label' mit contextmenu, wo
            # der spielername gewählt und die spielstatistik etc.
            # angezeigt werden könnte (TBD):
            '''
        sep = self._createFlatSeparator()
        sep.bind("<1>", self.clickHandler)
        sep.bind("<3>", self.rightclickHandler)
        self._createLabel("player", label=n_('Player'),
                          tooltip=_("Player options"))
        #
        self.player_label.bind("<1>", self.mOptPlayerOptions)
        # self.player_label.bind("<3>", self.mOptPlayerOptions)
        self.popup = MfxMenu(master=None, label=n_('Toolbar'), tearoff=0)
        createToolbarMenu(menubar, self.popup)
        self.frame.bind("<1>", self.clickHandler)
        self.frame.bind("<3>", self.rightclickHandler)
        #
        self.setCompound(compound, force=True)
            '''

    def show(self, on, **kw):
        side = self.menubar.tkopt.toolbar.get()
        self.win.setTool(None, side)
        return False

    def mHoldAndQuit(self, *args):
        if not self._busy():
            self.menubar.mHoldAndQuit()
        return 1

    def getSize(self):
        return 0

    def updateText(self, **kw):
        pass

    def config(self, w, v):
        print('PysolToolbarTk: config %s, %s' % (w, v))
        # y = self.yy
        pass

    # Lokale.

    def _loadImage(self, name):
        file = os.path.join(self.dir, name)
        image = None
        for ext in IMAGE_EXTENSIONS:
            file = os.path.join(self.dir, name + ext)
            if os.path.isfile(file):
                image = LImage(source=file)
                # print('_loadImage: file=%s' % file)
                # image = Tkinter.PhotoImage(file=file)
                break
        return image

    def _createButton(self, label, command, check=False, tooltip=None):
        name = label.lower()
        image = self._loadImage(name)
        # position = len(self._widgets)
        button_relief = TkSettings.toolbar_button_relief
        bd = TkSettings.toolbar_button_borderwidth
        padx, pady = TkSettings.toolbar_button_padding
        kw = {
            'toolbar': self,
            'toolbar_name': name,
            'command': command,
            'takefocus': 0,
            'text': _(label),
            'bd': bd,
            'relief': button_relief,
            'padx': padx,
            'pady': pady,
            'overrelief': 'raised',
        }
        # print ('toolbar:  print %s' % self.win)
        # print ('toolbar:  print %s' % self.win.app)
        kw['win'] = self.win
        if image:
            kw['image'] = image
        if check:
            kw['offrelief'] = button_relief
            kw['indicatoron'] = False
            kw['selectcolor'] = ''

            button = MyCheckButton(**kw)
        else:
            button = MyButton(**kw)

        # button.show(orient=self.orient)
        setattr(self, name + "_image", image)
        setattr(self, name + "_button", button)
        # self._widgets.append(button)
        self.add_widget(button)

        # TBD: tooltip ev. auf basis einer statuszeile implementieren
        # if tooltip:
        #   b = MfxTooltip(button)
        #   self._tooltips.append(b)
        #   b.setText(tooltip)
        return button

    def _busy(self):
        # if not self.side or not self.game or not self.menubar:
        #   return 1
        if not self.game or not self.menubar:
            return 1
        print('_busy:')
        self.game.stopDemo()
        self.game.interruptSleep()
        return self.game.busy
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#

# imports
# import tkFont

# Toolkit imports
from pysollib.kivy.tktree import MfxTreeInCanvas, MfxTreeLeaf, MfxTreeNode

# ************************************************************************
# * Nodes
# ************************************************************************


class SelectDialogTreeLeaf(MfxTreeLeaf):
    def drawSymbol(self, x, y, **kw):
        pass
        '''
        if self.tree.nodes.get(self.symbol_id) is not self:
            self.symbol_id = self.tree.canvas.create_image(x, y,
               image=self.tree.data.img[2 + (self.key is None)], anchor="nw")
            self.tree.nodes[self.symbol_id] = self
        '''


class SelectDialogTreeNode(MfxTreeNode):
    def __init__(self, tree, text, select_func, expanded=0, parent_node=None):
        MfxTreeNode.__init__(self, tree, parent_node,
                             text, key=None, expanded=expanded)
        # callable or a tuple/list of MfxTreeNodes
        self.select_func = select_func

    def drawSymbol(self, x, y, **kw):
        pass
        '''
        if self.tree.nodes.get(self.symbol_id) is not self:
            self.symbol_id = self.tree.canvas.create_image(x, y,
                image=self.tree.data.img[self.expanded], anchor="nw")
            self.tree.nodes[self.symbol_id] = self
        '''
    def getContents(self):
        # cached values
        if self.subnodes is not None:
            return self.subnodes
        # print self.whoami()
        if isinstance(self.select_func, (tuple, list)):
            return self.select_func
        return self._getContents()

    def _getContents(self):
        # subclass
        return []


# ************************************************************************
# * Tree database
# ************************************************************************


class SelectDialogTreeData():
    img = []  # loaded in Application.loadImages3

    def __init__(self):
        self.tree_xview = (0.0, 1.0)
        self.tree_yview = (0.0, 1.0)


# ************************************************************************
# * Canvas that shows the tree (left side)
# ************************************************************************


class SelectDialogTreeCanvas(MfxTreeInCanvas):
    def __init__(self, dialog, parent, key, default,
                 font=None, width=-1, height=-1, hbar=2, vbar=3):
        pass
    # not needed with kivy


'''
'''
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#

# Toolkit imports
from pysollib.kivy.tkwidget import MfxDialog

# ************************************************************************
# *
# ************************************************************************


class TimeoutsDialog(MfxDialog):
    def __init__(self, parent, title, app, **kw):
        pass
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#

# Toolkit imports
from pysollib.pysoltk import MfxDialog

# ************************************************************************
# *
# ************************************************************************


class ColorsDialog(MfxDialog):
    def __init__(self, parent, title, app, **kw):
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)
        # not used in kivy version.
        return


'''end of file'''
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#
# imports
# import os
# import time

# Kivy
# from LApp import *
from kivy.graphics import Color
from kivy.graphics import Line
from kivy.uix.label import Label
from kivy.uix.widget import Widget

# PySol imports
# Toolkit imports
# from pysollib.mfxutil import format_time
# from pysollib.mfxutil import kwdefault, KwStruct
# from pysollib.mygettext import _, n_
# from pysollib.pysoltk import MfxScrolledCanvas
# from pysollib.stats import PysolStatsFormatter, ProgressionFormatter
# from pysollib.util import *
# from tkutil import bind, unbind_destroy, loadImage
from pysollib.kivy.LApp import LImage
from pysollib.mfxutil import KwStruct
from pysollib.mygettext import _
from pysollib.pysoltk import MfxDialog, MfxMessageDialog
from pysollib.settings import TOP_TITLE

# FIXME - this file a quick hack and needs a rewrite

# Note almoust not used in the kivy implementation. Only a simple text
# is displayed, for single user Statisics. The code from tk implementation was
# kept as an examlple what could eventually be done once ....

# ************************************************************************
# *
# ************************************************************************


class LPieChart(Widget):
    def __init__(self, prnt, args, **kw):
        super(LPieChart, self).__init__(**kw)
        self.prnt = prnt

        # print('width   %s' % kw['width'])
        # print('outline %s' % kw['outline'])
        # print('fill    %s' % kw['fill'])

        # width = 10.0
        # if ('width' in kw):
        #     width = float(kw['width'])

        bcolor = '#ffa000a0'
        if ('outline') in kw:
            bcolor = kw['outline']
        if (not bcolor or len(bcolor) < 7):
            bcolor = '#ffa000a0'

        fcolor = '#00aaff20'
        if ('fill') in kw:
            fcolor = kw['fill']
        if (not fcolor or len(fcolor) < 7):
            fcolor = '#00aaff20'

        self.group = None
        if 'group' in kw:
            self.group = kw['group']

        self.center = (0.0, 0.0)
        if ('center') in kw:
            self.center = kw['center']

        self.radius = (0.0, 0.0)
        if ('radius') in kw:
            self.radius = kw['radius']

        self.fcolor = (0.9, 0.1, 0.3, 0.5)
        self.bind(size=self.updateCanvas)
        self.bind(pos=self.updateCanvas)

    def updateCanvas(self, instance, value):

        self.canvas.clear()
        with self.canvas:
            Color(self.fcolor[0], self.fcolor[1],
                  self.fcolor[2], self.fcolor[3])

            center = (self.pos[0] + self.size[0] / 2.0,
                      self.pos[1] + self.size[1] / 2.0)
            radius = (self.size[0] * 0.45)
            radius2 = (self.size[1] * 0.45)
            if (radius > radius2):
                radius = radius2

            # Rectangle(pos=pos, size=size)
            Line(circle=(center[0], center[1], radius), width=2.0, close=True)

            # kreis kann nicht gefüllt werden !!! - man sollte eine Funktion
            # haben die einen geschlossenen pfad füllt.
            # TBD.vertices/Mesh. versuchen, kreis annähern.

            # Color(self.bcolor[0], self.bcolor[1],
            #    self.bcolor[2], self.bcolor[3])
            # Line(points=poly, width=border)


# ************************************************************************
# *
# ************************************************************************

class SingleGame_StatsDialog(MfxDialog):
    def __init__(self, parent, title, app, player, gameid, **kw):
        kw['size_hint'] = (0.5, 1)
        self.app = app
        self.selected_game = None
        kw = self.initKw(kw)
        print('SingleGame_StatsDialog: p=%s, g=%s, kw=%s' %
              (player, gameid, kw))
        if isinstance(kw, KwStruct):
            print('kw=%s' % kw.getKw())

        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.top_frame = top_frame

#        self.createBitmaps(top_frame, kw)
        #
        self.player = player or _("Demo games")
        self.top.wm_minsize(200, 200)
        self.button = kw.default
        #
        # createChart = self.create3DBarChart
        # createChart = self.createPieChart
        # createChart = self.createSimpleChart
        #         if parent.winfo_screenwidth() < 800
        #            or parent.winfo_screenheight() < 600:
        #             createChart = self.createPieChart
        #             createChart = self.createSimpleChart
        #
        self.font = self.app.getFont("default")
#        self.tk_font = tkFont.Font(self.top, self.font)
#        self.font_metrics = self.tk_font.metrics()
        self._calc_tabs()

        if (kw.image):
            image = LImage(texture=kw.image.texture, size_hint=(1, 1))
            self.top.add_widget(image)

        #
        won, lost = app.stats.getStats(player, gameid)
        pwon, plost = self._getPwon(won, lost)

        print('Stats(p): won=%s, lost=%s' % (won, lost))

        text1 = _('Total:\n' +
                  '   won: %(won)s ... %(percentwon)s%%\n' +
                  '   lost: %(lost)s ... %(percentlost)s%%\n\n') % dict(
            won=won, percentwon=int(round(100.0 * pwon)),
            lost=lost, percentlost=int(round(100.0 * plost)))

#        createChart(app, won, lost, _("Total"))
        won, lost = app.stats.getSessionStats(player, gameid)
        pwon, plost = self._getPwon(won, lost)

        print('Stats(s): won=%s, lost=%s' % (won, lost))

        text2 = _('Current Session:\n' +
                  '   won: %(won)s ... %(percentwon)s%%\n' +
                  '   lost: %(lost)s ... %(percentlost)s%%\n') % dict(
            won=won, percentwon=(round(100.0 * pwon)),
            lost=lost, percentlost=int(round(100.0 * plost)))
        # text2 = 'Current Session:\n   won=%s, lost=%s\n' % (won, lost)

#        createChart(app, won, lost, _("Current session"))

        self.top.add_widget(Label(text=text1 + text2))

        # self.top.add_widget(Button(text='reset', size_hint=(1, 0.15)))
        #
#        focus = self.createButtons(bottom_frame, kw)
#        self.mainloop(focus, kw.timeout)

    #
    # helpers
    #

    def _calc_tabs(self):
        return

    def _getPwon(self, won, lost):
        pwon, plost = 0.0, 0.0
        if won + lost > 0:
            pwon = float(won) / float(won + lost)
            pwon = min(max(pwon, 0.00001), 0.99999)
            plost = 1.0 - float(pwon)
        return pwon, plost

    def _createChartTexts(self, tx, ty, won, lost):
        c, tfont, fg = self.canvas, self.font, self.fg
        pwon, plost = self._getPwon(won, lost)
        #
        x = tx[0]
        dy = int(self.font_metrics['ascent']) - 10
        dy = dy / 2
        c.create_text(x, ty[0] - dy, text=_("Won:"),
                      anchor="nw", font=tfont, fill=fg)
        c.create_text(x, ty[1] - dy, text=_("Lost:"),
                      anchor="nw", font=tfont, fill=fg)
        c.create_text(x, ty[2] - dy, text=_("Total:"),
                      anchor="nw", font=tfont, fill=fg)
        x = tx[1] - 16
        c.create_text(x, ty[0] - dy, text="%d" %
                      won, anchor="ne", font=tfont, fill=fg)
        c.create_text(x, ty[1] - dy, text="%d" %
                      lost, anchor="ne", font=tfont, fill=fg)
        c.create_text(x, ty[2] - dy, text="%d" %
                      (won + lost), anchor="ne", font=tfont, fill=fg)
        y = ty[2] - 11
        c.create_line(tx[0], y, x, y, fill=fg)
        if won + lost > 0:
            x = tx[2]
            pw = int(round(100.0 * pwon))
            c.create_text(x, ty[0] - dy, text="%d%%" %
                          pw, anchor="ne", font=tfont, fill=fg)
            c.create_text(x, ty[1] - dy, text="%d%%" %
                          (100 - pw), anchor="ne", font=tfont, fill=fg)

    #
    # charts
    #

    def initKw(self, kw):
        kw = KwStruct(kw,
                      strings=(_("&OK"),
                               (_("&All games..."), 102),
                               (TOP_TITLE + "...", 105),
                               (_("&Reset..."), 302)), default=0,
                      image=self.app.gimages.logos[5],
                      padx=10, pady=10,
                      )
        return MfxDialog.initKw(self, kw)

# ************************************************************************
# *
# ************************************************************************


class AllGames_StatsDialog(MfxDialog):

    YVIEW = 0
    FONT_TYPE = "default"

    def __init__(self, parent, title, app, player, **kw):
        self.status = 0
        print('AllGames_StatsDialog')
        pass

# ************************************************************************
# *
# ************************************************************************


class FullLog_StatsDialog(AllGames_StatsDialog):
    pass


class SessionLog_StatsDialog(FullLog_StatsDialog):
    pass

# ************************************************************************
# *
# ************************************************************************


class Status_StatsDialog(MfxMessageDialog):
    def __init__(self, parent, game):
        self.status = 0
        pass

# ************************************************************************
# *
# ************************************************************************


class Top_StatsDialog(MfxDialog):
    def __init__(self, parent, title, app, player, gameid, **kw):
        pass

# ************************************************************************
# *
# ************************************************************************


class ProgressionDialog(MfxDialog):
    def __init__(self, parent, title, app, player, gameid, **kw):
        pass
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#

import formatter
import os
import sys

from kivy.uix.boxlayout import BoxLayout
from kivy.uix.button import Button
from kivy.uix.label import Label

import pysollib.htmllib2 as htmllib
from pysollib.kivy.LApp import LPopCommander
from pysollib.kivy.LApp import LScrollView
from pysollib.kivy.LApp import LTopLevel
from pysollib.kivy.LApp import get_platform
from pysollib.mfxutil import Struct, openURL
from pysollib.mygettext import _
from pysollib.pysoltk import MfxMessageDialog
from pysollib.settings import TITLE

REMOTE_PROTOCOLS = ("ftp:", "gopher:", "http:", "mailto:", "news:", "telnet:")

# ************************************************************************
# *
# ************************************************************************


if get_platform() == 'android':
    from jnius import autoclass
    from jnius import cast

    def startAndroidBrowser(www):
        # init java classes
        PythonActivity = autoclass('org.kivy.android.PythonActivity')
        Intent = autoclass('android.content.Intent')
        Uri = autoclass('android.net.Uri')
        # String = autoclass('java.lang.String') # get the Java object

        # prepare activity
        # PythonActivity.mActivity is the instance of the current Activity
        # BUT, startActivity is a method from the Activity class, not from our
        # PythonActivity.
        # We need to cast our class into an activity and use it
        currentActivity = cast(
            'android.app.Activity', PythonActivity.mActivity)

        # create the intent
        intent = Intent()
        intent.setAction(Intent.ACTION_VIEW)
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
        intent.setDataAndType(Uri.parse(www), "application/xhtml+xml")

        # start activity
        currentActivity.startActivity(intent)

# ************************************************************************
# *
# ************************************************************************


def cmp2(a, b):
    """python 3 replacement for python 2 cmp function"""
    return (a > b) - (a < b)


class tkHTMLWriter(formatter.NullWriter):
    def __init__(self, text, viewer, app):
        formatter.NullWriter.__init__(self)

        self.text = text
        self.viewer = viewer

        #
        if app:
            font = app.getFont("sans")
            fixed = app.getFont("fixed")
        else:
            font = ('helvetica', 12)
            fixed = ('courier', 12)
        size = font[1]
        sign = 1
        if size < 0:
            sign = -1
        self.fontmap = {
            "h1": (font[0], size + 12 * sign, "bold"),
            "h2": (font[0], size + 8 * sign, "bold"),
            "h3": (font[0], size + 6 * sign, "bold"),
            "h4": (font[0], size + 4 * sign, "bold"),
            "h5": (font[0], size + 2 * sign, "bold"),
            "h6": (font[0], size + 1 * sign, "bold"),
            "bold": (font[0], size, "bold"),
            "italic": (font[0], size, "italic"),
            "pre": fixed,
        }

        self.text.config(cursor=self.viewer.defcursor, font=font)
        for f in self.fontmap.keys():
            self.text.tag_config(f, font=self.fontmap[f])

        self.anchor = None
        self.anchor_mark = None
        self.font = None
        self.font_mark = None
        self.indent = ""
        self.text.label.bind(on_ref_press=self.refpress)

    '''
    def createCallback(self, href):
        class Functor:
            def __init__(self, viewer, arg):
                self.viewer = viewer
                self.arg = arg

            def __call__(self, *args):
                self.viewer.updateHistoryXYView()
                return self.viewer.display(self.arg)
        return Functor(self.viewer, href)
    '''

    def write(self, data):
        # print('writer: write %s' % data)
        self.text.insert("insert", data)

    def anchor_bgn(self, href, name, type):
        # print('writer: anchor_bgn %s - %s' % (href, name))
        if href:
            # self.text.update_idletasks()   # update display during parsing
            self.anchor = (href, name, type)
            self.anchor_mark = self.text.index("insert")
            self.write('[ref=' + href + ']')

            url = self.anchor[0]
            fg = '0000cc'
            u = self.viewer.normurl(url, with_protocol=False)
            if u in self.viewer.visited_urls:
                fg = '660099'
            self.write('[color=' + fg + '][i]')
            # self.text.tag_config(tag, foreground=fg, underline=1)

    def refpress(self, instance, value):
        # print('writer: refpress %s, %s' % (instance, value))
        pass

    def anchor_end(self):
        # print('writer: anchor_end')
        if self.anchor:

            self.anchor = None
            self.write('[/i][/color]')
            self.write('[/ref]')

    def anchor_enter(self, url):
        url = self.viewer.normurl(url)
        self.viewer.statusbar.updateText(url=url)
        self.text.config(cursor=self.viewer.handcursor)

    def anchor_leave(self, *args):
        self.viewer.statusbar.updateText(url='')
        self.text.config(cursor=self.viewer.defcursor)

    def new_font(self, font):
        # print('writer: new_font %s' % str(font))
        # end the current font
        if self.font:
            # print "end_font(%s)" % `self.font`
            self.text.tag_add(self.font, self.font_mark, "insert")
            self.font = None
        # start the new font
        if font:
            # print "start_font(%s)" % `font`
            self.font_mark = self.text.index("insert")
            if font[0] in self.fontmap:
                self.font = font[0]
            elif font[3]:
                self.font = "pre"
            elif font[2]:
                self.font = "bold"
            elif font[1]:
                self.font = "italic"
            else:
                self.font = None

    def new_margin(self, margin, level):
        # print('writer: new_margin %s, %s' % (margin, level))
        self.indent = "    " * level

    def send_label_data(self, data):
        # print('writer: send_label_data %s' % (data))
        # self.write(self.indent + data + " ")
        self.write(self.indent)
        if data == '*':  # <li>
            img = self.viewer.symbols_img.get('disk')
            if img:
                self.text.image_create(index='insert', image=img,
                                       padx=0, pady=0)
            else:
                self.write('*')
        else:
            self.write(data)
        self.write(' ')

    def send_paragraph(self, blankline):
        # print('writer: send_paragraph %s' % (blankline))
        self.write('\n' * blankline)

    def send_line_break(self):
        # print('writer: send_break')
        self.write('\n')

    def send_hor_rule(self, *args):
        if (args):
            pass
            # print('writer: send_hor_rule %s' % (args))
        # width = int(int(self.text["width"]) * 0.9)
        width = 20
        self.write("_" * width)
        self.write("\n")

    def send_literal_data(self, data):
        # print('writer: send_literal_data %s' % (data))
        self.write(data)

    def send_flowing_data(self, data):
        # print('writer: send_flowing_data %s' % (data))
        self.write(data)

# ************************************************************************
# *
# ************************************************************************


class tkHTMLParser(htmllib.HTMLParser):
    def anchor_bgn(self, href, name, type):
        self.formatter.flush_softspace()
        htmllib.HTMLParser.anchor_bgn(self, href, name, type)
        self.formatter.writer.anchor_bgn(href, name, type)

    def close(self):
        # print('tkHTMLParser1: close()')
        self.formatter.writer.text.applyBuffer()
        # label = self.formatter.writer.text.label
        # print('tkHTMLParser: label.refs %s' % str(label.refs))
        # print ('tkHTMLParser: label.refs %s' % str(Label.refs))

        # print('tkHTMLParser2: close()')
        htmllib.HTMLParser.close(self)

    def anchor_end(self):
        if self.anchor:
            self.anchor = None
        self.formatter.writer.anchor_end()

    def do_dt(self, attrs):
        self.formatter.end_paragraph(1)
        self.ddpop()

    def handle_image(self, src, alt, ismap, align, width, height):
        self.formatter.writer.viewer.showImage(
            src, alt, ismap, align, width, height)

# ************************************************************************
# *
# ************************************************************************


class HTMLButton(Button):
    def __init__(self, **kw):
        super(HTMLButton, self).__init__(**kw)

    def config(self, **kw):
        pass


class HTMLLabel(Label):
    def __init__(self, **kw):
        super(HTMLLabel, self).__init__(**kw)

        self.bind(size=self.onUpdate)
        self.bind(pos=self.onUpdate)
        self.bind(text=self.onUpdate)

    def onUpdate(self, instance, size):
        self.size_hint_y = None
        self.text_size = self.width, None
        self.texture_update()
        self.height = self.texture_size[1]


class HTMLText(LScrollView, LPopCommander):
    def __init__(self, **kw):
        super(HTMLText, self).__init__(**kw)

        self.label = HTMLLabel(text='', markup=True)
        self.tags = {}
        self.textbuffer = ''
        self.add_widget(self.label)

    def applyBuffer(self):
        # print('applybuffer:')
        self.label.text = self.textbuffer

    def config(self, **kw):
        # print('config: %s' % kw)
        pass

    def update_idletasks(self):
        pass

    def delete(self, val, val1):
        pass

    def insert(self, cmd, data):
        # print('insert text: %s' % data)
        self.textbuffer = self.textbuffer + data
        # self.label.text = self.textbuffer
        pass

    def index(self, cmd):
        # print('index: %s' % cmd)
        # was sollen wir hier zuruckgeben ?
        return 0

    def tag_add(self, font, fontmark, cmd):
        # print('tag_add: %s, %s, %s' % (font, fontmark, cmd))
        pass

    def tag_config(self, tag, **kw):
        # print('tag_config: %s, %s' % (tag, kw))
        # self.tags[tag] = kw

        # for t, k in self.tags:
        #    print('tagslist: %s, %s' % (t, k))

        pass

    def xview_moveto(self, xview):
        # print('xview_moveto: %s' % xview)
        pass

    def yview_moveto(self, yview):
        # print('yview_moveto: %s' % yview)
        pass


class HTMLViewer:
    symbols_fn = {}  # filenames, loaded in Application.loadImages3
    symbols_img = {}

    def make_pop_command(self, parent, title):
        def pop_command(event):
            if self.history.index > 1:
                self.goBack(event)
                return None
            del self.history.list
            self.history.index = 0
            parent.popWork(title)
        return pop_command

    def make_close_command(self, parent, title):
        def close_command(event):
            del self.history.list
            self.history.index = 0
            parent.popWork(title)
        return close_command

    def refpress(self, instance, value):
        # print('writer: refpress %s, %s' % (instance, value))
        self.updateHistoryXYView()
        return self.display(value)

    def __init__(self, parent, app=None, home=None):
        self.parent = parent
        self.app = app
        self.home = home
        self.url = None
        self.history = Struct(
            list=[],
            index=0,
        )
        self.visited_urls = []
        self.images = {}
        # need to keep a reference because of garbage collection
        self.defcursor = "default"
        # self.defcursor = parent["cursor"]
        # self.defcursor = 'xterm'
        self.handcursor = "hand2"

        self.title = _("Browser")
        self.window = None
        self.running = False

        # prüfen ob noch aktiv.

        if parent.workStack.peek(self.title) is not None:
            parent.popWork(self.title)

        pc = self.make_pop_command(parent, self.title)
        cc = self.make_close_command(parent, self.title)

        # neuen Dialog aufbauen.

        window = LTopLevel(app.top, self.title, size_hint=(1.8, 1.0))
        window.titleline.bind(on_press=cc)
        self.parent.pushWork(self.title, window)
        self.window = window
        self.running = True

        content = BoxLayout(orientation='vertical')
        # buttonline =
        #   BoxLayout(orientation='horizontal', size_hint=(1.0, 0.1))

        # create buttons
        self.homeButton = HTMLButton(text=_("Index"), on_release=self.goHome)
        self.backButton = HTMLButton(text=_("Back"), on_release=self.goBack)
        self.forwardButton = HTMLButton(
            text=_("Forward"), on_release=self.goForward)
        self.closeButton = HTMLButton(text=_("Close"), on_release=self.goHome)

        '''
        buttonline.add_widget(self.homeButton)
        buttonline.add_widget(self.backButton)
        buttonline.add_widget(self.forwardButton)
        buttonline.add_widget(self.closeButton)
        content.add_widget(buttonline)
        '''

        '''
        self.homeButton = Tkinter.Button(parent, text=_("Index"),
                                         width=button_width,
                                         command=self.goHome)
        self.homeButton.grid(row=0, column=0, sticky='w')
        self.backButton = Tkinter.Button(parent, text=_("Back"),
                                         width=button_width,
                                         command=self.goBack)
        self.backButton.grid(row=0, column=1, sticky='w')
        self.forwardButton = Tkinter.Button(parent, text=_("Forward"),
                                            width=button_width,
                                            command=self.goForward)
        self.forwardButton.grid(row=0, column=2, sticky='w')
        self.closeButton = Tkinter.Button(parent, text=_("Close"),
                                          width=button_width,
                                          command=self.destroy)
        self.closeButton.grid(row=0, column=3, sticky='e')
        '''

        # create text widget

        self.text = HTMLText(
            pop_command=pc, text="hallo", size_hint=(1.0, 1.0))
        self.text.label.bind(on_ref_press=self.refpress)
        content.add_widget(self.text)
        '''
        text_frame = Tkinter.Frame(parent)
        text_frame.grid(row=1, column=0, columnspan=4, sticky='nsew')
        text_frame.grid_propagate(False)
        vbar = Tkinter.Scrollbar(text_frame)
        vbar.pack(side='right', fill='y')
        self.text = Tkinter.Text(text_frame,
                                 fg='black', bg='white',
                                 bd=1, relief='sunken',
                                 cursor=self.defcursor,
                                 wrap='word', padx=10)
        self.text.pack(side='left', fill='both', expand=True)
        self.text["yscrollcommand"] = vbar.set
        vbar["command"] = self.text.yview
        '''

        self.window.content.add_widget(content)

        # statusbar
        # self.statusbar = HtmlStatusbar(parent, row=2, column=0, columnspan=4)

        # parent.columnconfigure(2, weight=1)
        # parent.rowconfigure(1, weight=1)

        # load images
        for name, fn in self.symbols_fn.items():
            self.symbols_img[name] = self.getImage(fn)

    def _yview(self, *args):
        self.text.yview(*args)
        return 'break'

    def page_up(self, *event):
        return self._yview('scroll', -1, 'page')

    def page_down(self, *event):
        return self._yview('scroll', 1, 'page')

    def unit_up(self, *event):
        return self._yview('scroll', -1, 'unit')

    def unit_down(self, *event):
        return self._yview('scroll', 1, 'unit')

    def scroll_top(self, *event):
        return self._yview('moveto', 0)

    def scroll_bottom(self, *event):
        return self._yview('moveto', 1)

    # locate a file relative to the current self.url
    def basejoin(self, url, baseurl=None, relpath=1):
        if baseurl is None:
            baseurl = self.url
        if 0:
            import urllib
            url = urllib.pathname2url(url)
            if relpath and self.url:
                url = urllib.basejoin(baseurl, url)
        else:
            url = os.path.normpath(url)
            if relpath and baseurl and not os.path.isabs(url):
                h1, t1 = os.path.split(url)
                h2, t2 = os.path.split(baseurl)
                if cmp2(h1, h2) != 0:
                    url = os.path.join(h2, h1, t1)
                url = os.path.normpath(url)
        return url

    def normurl(self, url, with_protocol=True):
        for p in REMOTE_PROTOCOLS:
            if url.startswith(p):
                break
        else:
            url = self.basejoin(url)
            if with_protocol:
                if os.name == 'nt':
                    url = url.replace('\\', '/')
                url = 'file://' + url
        return url

    def openfile(self, url):
        if url[-1:] == "/" or os.path.isdir(url):
            url = os.path.join(url, "index.html")
        url = os.path.normpath(url)
        if sys.version_info > (3,):
            import codecs
            return codecs.open(url, encoding='utf-8'), url
        return open(url, "rb"), url

    def display(self, url, add=1, relpath=1, xview=0, yview=0):
        # for some reason we have to stop the PySol demo
        # (is this a multithread problem with Tkinter ?)
        if self.app and self.app.game:
            self.app.game.stopDemo()
            # self.app.game._cancelDrag()
            # pass

        # ftp: and http: would work if we use urllib, but this widget is
        # far too limited to display anything but our documentation...
        for p in REMOTE_PROTOCOLS:
            if url.startswith(p):
                plat = get_platform()
                if plat == 'android':
                    print("Open url: %s (TBD)" % url)
                    startAndroidBrowser(url)
                elif not openURL(url):
                    return

        # locate the file relative to the current url
        url = self.basejoin(url, relpath=relpath)

        # read the file
        try:
            file = None
            if 0:
                import urllib
                file = urllib.urlopen(url)
            else:
                file, url = self.openfile(url)
            data = file.read()
            file.close()
            file = None
        except Exception:
            print("Open url(1) - Exception: %s" % url)
            if file:
                file.close()

            '''
            self.errorDialog(_("Unable to service request:\n") + url)
            '''
            return

        self.url = url
        if self.home is None:
            self.home = self.url
        if add:
            self.addHistory(self.url, xview=xview, yview=yview)

        # print self.history.index, self.history.list
        if self.history.index > 1:
            self.backButton.config(state="normal")
        else:
            self.backButton.config(state="disabled")
        if self.history.index < len(self.history.list):
            self.forwardButton.config(state="normal")
        else:
            self.forwardButton.config(state="disabled")

        old_c1, old_c2 = self.defcursor, self.handcursor
        self.defcursor = self.handcursor = "watch"
        self.text.config(cursor=self.defcursor)
        self.text.update_idletasks()
        # self.frame.config(cursor=self.defcursor)
        # self.frame.update_idletasks()
        self.text.config(state="normal")
        self.text.delete("1.0", "end")
        # self.images = {}
        self.text.textbuffer = ''
        writer = tkHTMLWriter(self.text, self, self.app)
        fmt = formatter.AbstractFormatter(writer)
        parser = tkHTMLParser(fmt)
        parser.feed(data)
        parser.close()
        self.text.config(state="disabled")
        if 0.0 <= xview <= 1.0:
            self.text.xview_moveto(xview)
        if 0.0 <= yview <= 1.0:
            self.text.yview_moveto(yview)
        # self.parent.wm_title(parser.title)
        self.window.titleline.text = parser.title
        self.parent.wm_iconname(parser.title)
        self.defcursor, self.handcursor = old_c1, old_c2
        self.text.config(cursor=self.defcursor)
        # self.frame.config(cursor=self.defcursor)

    def addHistory(self, url, xview=0, yview=0):
        if url not in self.visited_urls:
            self.visited_urls.append(url)
        if self.history.index > 0:
            u, xv, yv = self.history.list[self.history.index - 1]
            if cmp2(u, url) == 0:
                self.updateHistoryXYView()
                return
        del self.history.list[self.history.index:]
        self.history.list.append((url, xview, yview))
        self.history.index = self.history.index + 1

    def updateHistoryXYView(self):
        if self.history.index > 0:
            url, xview, yview = self.history.list[self.history.index - 1]
            self.history.list[self.history.index - 1] = (url, xview, yview)

    def goBack(self, *event):
        if self.history.index > 1:
            self.updateHistoryXYView()
            self.history.index = self.history.index - 1
            url, xview, yview = self.history.list[self.history.index - 1]
            self.display(url, add=0, relpath=0, xview=xview, yview=yview)

    def goForward(self, *event):
        if self.history.index < len(self.history.list):
            self.updateHistoryXYView()
            url, xview, yview = self.history.list[self.history.index]
            self.history.index = self.history.index + 1
            self.display(url, add=0, relpath=0, xview=xview, yview=yview)

    def goHome(self, *event):
        if self.home and cmp2(self.home, self.url) != 0:
            self.updateHistoryXYView()
            self.display(self.home, relpath=0)

    def errorDialog(self, msg):
        MfxMessageDialog(self.parent,
                         title=_("%s HTML Problem") % TITLE,
                         text=msg,
                         # bitmap="warning"
                         # FIXME: this interp don't have images
                         strings=(_("&OK"), ), default=0)

    def getImage(self, fn):
        if fn in self.images:
            return self.images[fn]
        else:
            return None

    def showImage(self, src, alt, ismap, align, width, height):
        url = self.basejoin(src)
        img = self.getImage(url)
        if img:
            self.text.image_create(index="insert", image=img, padx=0, pady=0)


# ************************************************************************
# *
# ************************************************************************

''
#!/usr/bin/python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 2017 LB
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#

from __future__ import division

import logging
import math
import traceback

from kivy.animation import Animation
from kivy.app import App
from kivy.base import EventLoop
from kivy.base import stopTouchApp
from kivy.cache import Cache
from kivy.clock import Clock
from kivy.config import Config
from kivy.core.audio import SoundLoader
from kivy.core.window import Window
from kivy.graphics import Color
from kivy.graphics import Line
from kivy.graphics import Rectangle
from kivy.graphics import Triangle
from kivy.properties import StringProperty
from kivy.uix.actionbar import ActionButton
from kivy.uix.actionbar import ActionPrevious
from kivy.uix.actionbar import ActionView
from kivy.uix.behaviors import ButtonBehavior
from kivy.uix.boxlayout import BoxLayout
from kivy.uix.button import Button
from kivy.uix.image import Image as KivyImage
from kivy.uix.label import Label
from kivy.uix.scrollview import ScrollView
from kivy.uix.treeview import TreeView
from kivy.uix.treeview import TreeViewLabel
from kivy.uix.widget import Widget
from kivy.utils import platform

from pysollib.kivy.androidperms import requestStoragePerm

if platform != 'android':
    Config.set('input', 'mouse', 'mouse,multitouch_on_demand')

# =============================================================================


def get_platform():
    return platform

# =============================================================================


def get_screen_ori():
    if get_platform() == 'android':
        from jnius import autoclass
        from jnius import cast
    else:
        logging.info("LApp: ori = unknown")
        return None

    PythonActivity = autoclass('org.kivy.android.PythonActivity')
    currentActivity = cast('android.app.Activity', PythonActivity.mActivity)

    # Display = autoclass('android.view.Display')
    # WindowManager = autoclass('android.view.WindowManager')

    wm = currentActivity.getWindowManager()
    d = wm.getDefaultDisplay()

    so = None
    if d.getWidth() > d.getHeight():
        so = 'landscape'
    else:
        so = 'portrait'

    logging.info("LApp: ori = %s" % so)
    return so

# =============================================================================
# kivy EventDispatcher passes keywords, that to not correspond to properties
# to the base classes. Finally they will reach 'object'. With python3 (but not
# python2) 'object' throws an exception 'takes no parameters' in that a
# situation. We therefore underlay a base class (right outside), which
# swallows up remaining keywords. Thus the keywords do not reach 'object' any
# more.


class LBase(object):
    def __init__(self, **kw):
        super(LBase, self).__init__()

# =============================================================================


class LPopCommander(LBase):
    def __init__(self, **kw):
        super(LPopCommander, self).__init__()
        self.pop_command = kw['pop_command']

    def pop(self):
        if self.pop_command is not None:
            self.pop_command(0)
            return True
        return False

# =============================================================================


class LAnimationMgr(object):
    def __init__(self, **kw):
        super(LAnimationMgr, self).__init__()
        self.animations = []
        self.widgets = {}

    def animEnd(self, anim, widget):
        # print('LAnimationMgr: animEnd = %s.%s' % (anim, widget))

        self.widgets[widget] = self.widgets[widget][1:]
        self.animations.remove(anim)
        if len(self.widgets[widget]) > 0:
            # start next animation on widget
            nanim = self.widgets[widget][0]
            self.animations.append(nanim)
            print('LAnimationMgr: animEnd, append = %s' % (nanim))
            nanim.start(widget)
        else:
            # no further animations for widget so stop
            del self.widgets[widget]

    def makeAnimStart(self, anim, spos, widget):
        def animStart(dt):
            widget.pos = spos
            # print('LAnimationMgr: animStart = %s ... %s' % (anim, dt))
            anim.start(widget)
        return animStart

    def checkRunning(self):
        return len(self.animations) > 0

    def create(self, spos, widget, **kw):
        x = 0.0
        y = 0.0
        duration = 0.2
        transition = 'in_out_quad'
        if 'x' in kw:
            x = kw['x']
        if 'y' in kw:
            y = kw['y']
        if 'duration' in kw:
            duration = kw['duration']
        if 'transition' in kw:
            transition = kw['transition']

        anim = Animation(x=x, y=y, duration=duration, transition=transition)
        anim.bind(on_complete=self.animEnd)
        if 'bindE' in kw:
            anim.bind(on_complete=kw['bindE'])
        if 'bindS' in kw:
            anim.bind(on_start=kw['bindS'])

        offset = duration / 3.0
        # offset = duration*1.2
        timedelay = offset * len(self.animations)
        # print('offset = %s'% offset)
        print('LAnimationMgr: timedelay = %s' % timedelay)

        if widget in self.widgets:
            # append additional animation to widget
            self.widgets[widget].append(anim)
        else:
            # setup first animation for widget
            self.animations.append(anim)
            self.widgets[widget] = [anim]
            Clock.schedule_once(self.makeAnimStart(
                anim, spos, widget), timedelay)


LAnimationManager = LAnimationMgr()

# =============================================================================

LSoundLoader = SoundLoader

# =============================================================================


class LBoxLayout(BoxLayout, LBase):
    def __init__(self, **kw):
        super(LBoxLayout, self).__init__(**kw)

    def winfo_screenwidth(self):
        return self.size[0]

    def winfo_screenheight(self):
        return self.size[1]

# =============================================================================


class LImage(KivyImage, LBase):

    def __init__(self, **kwargs):
        super(LImage, self).__init__(**kwargs)
        self.size = self.texture.size
        self.silent = False
        self.allow_stretch = True
        # self.keep_ratio = 0
        # self.size_hint = (1.0/9.0, 1.0/4.0)
        self.size_hint = (1.0, 1.0)
        # self.mipmap = True     # funktioniert nicht.

        self.corePos = None
        self.coreSize = None

        # logging.info('LImage: __init__() %s' % kwargs)

    def getHeight(self):
        return self.size[1]

    def getWidth(self):
        return self.size[0]

    def subsample(self, r):
        ''
        return LImage(texture=self.texture)
        '''
        if (self.source!=None):
            # logging.info("LImage: subsample, %d, %s " % (r , self.source))
            return LImage(source=self.source)
        elif (self.texture!=None):
            # logging.info("LImage: subsample, %d (texture) " % r)
            return LImage(texture=self.texture)
        '''
        return self

    def on_touch_down(self, touch):
        if self.silent:
            return False

        # print('LImage: touch_down on %s' % str(touch.pos))
        if self.collide_point(*touch.pos):
            if (self.source is not None):
                print('LImage match %s' % self.source)
            else:
                print('LImage match with texture')
            return True
        return False

    def on_touch_up(self, touch):
        if self.silent:
            return False

        # print('LImage: touch_up on %s' % str(touch.pos))
        if self.collide_point(*touch.pos):
            if (self.source is not None):
                print('LImage match %s' % self.source)
            else:
                print('LImage match with texture')
            return True
        return False

# =============================================================================


def addAnchorOffset(pos, size, anchor):
    # print ('MfxCanvas: anchor=%s' % (anchor))
    x = pos[0]
    y = pos[1]
    xa = 0
    ya = 0
    if anchor == "n":
        ya = -1
    elif anchor == "w":
        xa = -1
    elif anchor == "s":
        ya = 1
    elif anchor == "e":
        xa = 1
    elif anchor == "ne":
        ya = -1
        xa = 1
    elif anchor == "nw":
        ya = -1
        xa = -1
    elif anchor == "se":
        ya = 1
        xa = 1
    elif anchor == "sw":
        ya = 1
        xa = -1

    if xa == 0:
        x = x - size[0] / 2.0
    elif xa == 1:
        x = x - size[0]
    if ya == 0:
        y = y - size[1] / 2.0
    elif ya == 1:
        y = y - size[1]
    return (x, y)

# =============================================================================


def LColorToKivy(outline):
    if (outline[0] == '#'):
        outline = outline[1:]
    ou0 = float(int(outline[0:2], 16)) / 256.0
    ou1 = float(int(outline[2:4], 16)) / 256.0
    ou2 = float(int(outline[4:6], 16)) / 256.0
    ou3 = 1.0
    if len(outline) >= 8:
        ou3 = float(int(outline[6:8], 16)) / 256.0
    return ou0, ou1, ou2, ou3

# =============================================================================


class LText(Widget, LBase):
    text = StringProperty('')

    def __init__(self, canvas, x, y, **kwargs):
        super(LText, self).__init__(**kwargs)
        # super(LText, self).__init__()

        if 'text' not in kwargs:
            kwargs['text'] = 'X'

        font = 'helvetica'
        fontsize = 18.0
        if 'font' in kwargs:
            font = kwargs['font'][0]
            fontsize = kwargs['font'][1]
            del kwargs['font']

        self.anchor = 'nw'
        if 'anchor' in kwargs:
            self.anchor = kwargs['anchor']

        self.text = kwargs['text']
        self.coreFontSize = fontsize
        self.coreFont = font

        # print('LText: font = %s, font_size = %s' % (font, fontsize))
        # print('LText: text = %s' % (self.text))

        kwargs['font'] = font
        kwargs['font_size'] = fontsize

        class MyLabel(Label, LBase):
            pass

        self.label = MyLabel(**kwargs)
        self.label.texture_update()
        self.coreSize = self.label.texture_size
        self.corePos = (x, y)
        self.prnt = canvas

        # print('LText: corePos = %s, coreSize = %s'
        # % (self.corePos, self.coreSize))

        self.size = self.label.texture_size

        self.bind(size=self.updateCanvas)
        self.bind(pos=self.updateCanvas)
        self.bind(text=self.updateCanvas)

    def updateCanvas(self, inst, val):
        self.label.text = self.text
        self.label.texture_update()

        self.coreSize = self.label.texture_size
        cp = addAnchorOffset(self.corePos, self.coreSize, self.anchor)
        cs = self.coreSize

        pos, size = self.prnt.CoreToKivy(cp, cs)
        # print('LText: pos = %s, size = %s' % (pos, size))

        color = LColorToKivy(self.prnt._text_color)
        # print('LText: color = %s' % str(color))
        self.canvas.clear()
        with self.canvas:
            Color(color[0], color[1], color[2], color[3])
            Rectangle(texture=self.label.texture, pos=pos, size=size)

# =============================================================================


class LEvent(object):
    def __init__(self):
        self.x = 0
        self.y = 0
        self.cardid = -1
        self.char = False
        pass

# =============================================================================


class LLine(Widget, LBase):
    def __init__(self, canvas, args, **kw):
        super(LLine, self).__init__(**kw)

        print('kw = %s%s' % (args, kw))

        lwidth = 10
        fill = '#ee3344'
        ashape = ()
        arrow = 'none'

        self.prnt = canvas
        xmin = 100000
        ymin = 100000
        xmax = -100000
        ymax = -100000
        self.corePoly = []
        if isinstance(args[0], list):
            kww = args[1]
            if ('width' in kww):
                lwidth = kww['width']
            self.lwidth = lwidth
            if ('fill' in kww):
                fill = kww['fill']
            self.fill = fill
            if ('arrowshape' in kw):
                ashape = kw['arrowshape']
            self.ashape = ashape
            if ('arrow' in kw):
                arrow = kw['arrow']
            self.arrow = arrow

            pts = args[0]
            ipts = iter(pts)
            for x, y in zip(ipts, ipts):
                print('%s.%s' % (x, y))
                self.corePoly.append(x)
                self.corePoly.append(y)
                if x < xmin:
                    xmin = x
                if x > xmax:
                    xmax = x
                if y < ymin:
                    ymin = y
                if y > ymax:
                    ymax = y
        else:
            if ('width' in kw):
                lwidth = kw['width']
            self.lwidth = lwidth
            if ('fill' in kw):
                fill = kw['fill']
            self.fill = fill
            if ('arrowshape' in kw):
                ashape = kw['arrowshape']
            self.ashape = ashape
            if ('arrow' in kw):
                arrow = kw['arrow']
            self.arrow = arrow

            for i in range(0, 2):
                x = args[2 * i]
                y = args[2 * i + 1]
                self.corePoly.append(x)
                self.corePoly.append(y)
                if x < xmin:
                    xmin = x
                if x > xmax:
                    xmax = x
                if y < ymin:
                    ymin = y
                if y > ymax:
                    ymax = y

        print('width = %s' % self.lwidth)
        print('color = %s' % self.fill)
        print('arrow = %s' % self.arrow)
        print('ashape = %s' % str(self.ashape))

        self.alist = []
        if self.arrow == 'last':
            self.alist.append(self.corePoly[-2])
            self.alist.append(self.corePoly[-1])
            self.alist.append(self.corePoly[-4])
            self.alist.append(self.corePoly[-3])
        elif self.arrow != 'none':
            self.alist.append(self.corePoly[0])
            self.alist.append(self.corePoly[1])
            self.alist.append(self.corePoly[2])
            self.alist.append(self.corePoly[3])

        self.corePos = (xmin, ymin)
        self.coreSize = (xmax - xmin, ymax - ymin)
        self.pos = self.corePos
        self.size = self.coreSize

        self.bcolor = LColorToKivy(self.fill)

        self.bind(size=self.updateCanvas)
        self.bind(pos=self.updateCanvas)

    def updateCanvas(self, instance, value):
        # size = self.size
        # pos = self.pos

        # Linie:
        poly = None
        poly = []
        dmy, sxy = self.prnt.CoreToKivy(
            (0.0, 0.0), (self.lwidth, self.lwidth))
        wpoly = sxy[1]
        ipts = iter(self.corePoly)
        for x, y in zip(ipts, ipts):
            print('%s.%s' % (x, y))
            xy, dmy = self.prnt.CoreToKivy((x, y))
            poly.append(xy[0])
            poly.append(xy[1])

        def rot(x, y, a):
            x1 = x * math.cos(a) + y * math.sin(a)
            y1 = y * math.cos(a) - x * math.sin(a)
            return (x1, y1)

        # Pfeil:
        PI = 3.1415926
        atrio = None
        atrio = []
        if (len(self.ashape) > 2):
            dx = (self.alist[0] - self.alist[2])
            dy = (self.alist[1] - self.alist[3])
            if (dx == 0.0):
                if (dy > 0.0):
                    ang = -PI / 2.0
                else:
                    ang = PI / 2.0
            else:
                ang = math.atan(dy / dx)
            if (dx > 0.0):
                ang = ang + PI

            # (kante, winkel?)
            x = self.ashape[0] * math.cos(self.ashape[1] * PI / 360.0)
            y = 2.0 * self.ashape[0] * math.sin(self.ashape[1] * PI / 360.0)
            # (länge, breite?)
            # x = self.ashape[0]
            # y = self.ashape[1]
            o = self.ashape[2]
            axy, dmy = self.prnt.CoreToKivy((self.alist[0], self.alist[1]))
            dmy, asxy = self.prnt.CoreToKivy((0, 0), (x, y))
            dmy, aoff = self.prnt.CoreToKivy((0, 0), (o, o))
            print('asxy=%s' % str(asxy))

            x1, y1 = rot(-aoff[0], 0.0, ang)
            atrio.append(x1 + axy[0])
            atrio.append(y1 + axy[1])
            x1, y1 = rot(asxy[0] - aoff[0], asxy[1], ang)
            atrio.append(x1 + axy[0])
            atrio.append(y1 + axy[1])
            x1, y1 = rot(asxy[0] - aoff[0], -asxy[1], ang)
            atrio.append(x1 + axy[0])
            atrio.append(y1 + axy[1])

        self.canvas.clear()
        with self.canvas:
            Color(self.bcolor[0], self.bcolor[1],
                  self.bcolor[2], self.bcolor[3])
            Line(points=poly, width=wpoly, cap='none', joint='bevel')
            if (len(atrio) > 2):
                Triangle(points=atrio)

# =============================================================================


class LRectangle(Widget, LBase):
    def __init__(self, prnt, args, **kw):
        super(LRectangle, self).__init__(**kw)
        self.prnt = prnt

        # print('width   %s' % kw['width'])
        # print('outline %s' % kw['outline'])
        # print('fill    %s' % kw['fill'])

        width = 10.0
        if ('width' in kw):
            width = float(kw['width'])

        bcolor = '#ffa000a0'
        if ('outline') in kw:
            bcolor = kw['outline']
        if (not bcolor or len(bcolor) < 7):
            bcolor = '#ffa000a0'

        fcolor = '#00aaff20'
        if ('fill') in kw:
            fcolor = kw['fill']
        if (not fcolor or len(fcolor) < 7):
            fcolor = '#00aaff20'

        self.group = None
        if 'group' in kw:
            self.group = kw['group']

        xmin = float(args[0])
        ymin = float(args[1])
        xmax = float(args[2])
        ymax = float(args[3])

        # print ('LRectangle: min = %s.%s' % (xmin, ymin))
        # print ('LRectangle: max = %s.%s' % (xmax, ymax))
        # print ('LRectangle: border = %s' % (width))

        self.border = width
        self.fcolor = LColorToKivy(fcolor)
        self.bcolor = LColorToKivy(bcolor)

        self.corePos = (xmin, ymin)
        self.coreSize = (xmax - xmin, ymax - ymin)
        self.pos = self.corePos
        self.size = self.coreSize
        self.topleft = (xmin + width / 2.0, ymin + width / 2.0)
        self.bottomright = (xmax - width / 2.0, ymax - width / 2.0)
        self.poly = None

        self.bind(size=self.updateCanvas)
        self.bind(pos=self.updateCanvas)

    def updateCanvas(self, instance, value):
        # print('LRectangle: updateCanvas')

        pos, size = self.prnt.CoreToKivy(self.corePos, self.coreSize)
        bpos, dmy = self.prnt.CoreToKivy(self.topleft)
        tpos, dmy = self.prnt.CoreToKivy(self.bottomright)

        poly = [bpos[0], bpos[1],
                tpos[0], bpos[1],
                tpos[0], tpos[1],
                bpos[0], tpos[1],
                bpos[0], bpos[1]]

        dmy, brd = self.prnt.CoreToKivy(
            (0.0, 0.0), (self.border, self.border))
        border = brd[1]

        self.canvas.clear()
        with self.canvas:
            Color(self.fcolor[0], self.fcolor[1],
                  self.fcolor[2], self.fcolor[3])
            Rectangle(pos=pos, size=size)
            Color(self.bcolor[0], self.bcolor[1],
                  self.bcolor[2], self.bcolor[3])
            Line(points=poly, width=border)

    def on_touch_down(self, touch):
        if self.collide_point(*touch.pos):
            if self.group is not None:
                logging.info('LRectangle: self=%s group=%s' %
                             (self, self.group))
                if '<1>' in self.group.bindings:
                    # logging.info('LRectangle: size=%s' % (self.size))
                    ppos, psize = self.group.canvas.KivyToCore(touch.pos)
                    event = LEvent()
                    event.x = ppos[0]
                    event.y = ppos[1]
                    if touch.is_double_tap:
                        self.group.bindings['<Double-1>'](event)
                    else:
                        self.group.bindings['<1>'](event)
                    return True
        return False

    def on_touch_up(self, touch):
        if self.collide_point(*touch.pos):
            if self.group is not None:
                logging.info('LRectangle: self=%s group=%s' %
                             (self, self.group))
                if '<ButtonRelease-1>' in self.group.bindings:
                    ppos, psize = self.group.canvas.KivyToCore(touch.pos)
                    event = LEvent()
                    event.x = ppos[0]
                    event.y = ppos[1]
                    self.group.bindings['<ButtonRelease-1>'](event)
                    return True
        return False

# =============================================================================


class LImageItem(BoxLayout, LBase):
    def __init__(self, **kw):
        super(LImageItem, self).__init__(**kw)
        self.game = None
        self.card = None
        self.group = None
        if 'game' in kw:
            self.game = kw['game']
        if 'card' in kw:
            self.card = kw['card']
        if 'group' in kw:
            self.group = kw['group']
        self.dragstart = None
        # ev. noch globales cache für stacks->game und cards->stack
        # einrichten. Aber: stacks hängt vom jeweiligen spiel ab.

    def send_event_pressed_n(self, event, n):
        if self.group and n in self.group.bindings:
            self.group.bindings[n](event)

    def send_event_pressed(self, touch, event):

        if touch.is_double_tap:
            self.send_event_pressed_n(event, '<Double-1>')
        else:
            button = 'left'
            if 'button' in touch.profile:
                button = touch.button
            if button == 'left':
                self.send_event_pressed_n(event, '<1>')
                return
            if button == 'middle':
                self.send_event_pressed_n(event, '<2>')
                return
            if button == 'right':
                self.send_event_pressed_n(event, '<3>')
                return

    def on_touch_down(self, touch):

        if self.collide_point(*touch.pos):

            for c in self.children:
                # print('child at %s' % c)
                if (c.on_touch_down(touch) and self.game):
                    for stack in self.game.allstacks:
                        for i in range(len(stack.cards)):
                            if stack.cards[i] == self.card:
                                print('LCardImage: stack = %s' % stack)
                                print('LCardImage: touch = %s' % str(touch))
                                print('grab')
                                # grab the touch!
                                touch.grab(self)
                                ppos, psize = self.game.canvas.KivyToCore(
                                    touch.pos, self.size)
                                event = LEvent()
                                event.x = ppos[0]
                                event.y = ppos[1]
                                self.dragstart = touch.pos
                                event.cardid = i
                                self.send_event_pressed(touch, event)
                                return True

            if self.group is not None:
                print('LCardImage: self=%s group=%s' % (self, self.group))
                if '<1>' in self.group.bindings:
                    ppos, psize = self.group.canvas.KivyToCore(
                        touch.pos, self.size)
                    event = LEvent()
                    event.x = ppos[0]
                    event.y = ppos[1]
                    self.group.bindings['<1>'](event)
                    return True

            if self.card is None:
                return False
            if self.game is None:
                return False

        # print('LCardImage: touch_down on %s' % str(touch.pos))
        return False

    def send_event_released_1(self, event):
        if self.group and '<ButtonRelease-1>' in self.group.bindings:
            self.group.bindings['<ButtonRelease-1>'](event)

    def on_touch_up(self, touch):
        if touch.grab_current is self:
            # release my grabbed touch!
            print('ungrab')
            touch.ungrab(self)
            return True

        if self.collide_point(*touch.pos):

            for c in self.children:
                # print('child at %s' % c)

                if (c.on_touch_up(touch) and self.game):
                    for stack in self.game.allstacks:
                        for i in range(len(stack.cards)):
                            if stack.cards[i] == self.card:
                                print('LCardImage: stack = %s' % stack)
                                ppos, psize = self.game.canvas.KivyToCore(
                                    touch.pos, self.size)
                                event = LEvent()
                                event.x = ppos[0]
                                event.y = ppos[1]
                                event.cardid = i
                                self.send_event_released_1(event)
                                return True

            if self.group is not None:
                print('LCardImage: self=%s group=%s' % (self, self.group))
                if '<ButtonRelease-1>' in self.group.bindings:
                    ppos, psize = self.group.canvas.KivyToCore(
                        touch.pos, self.size)
                    event = LEvent()
                    event.x = ppos[0]
                    event.y = ppos[1]
                    self.group.bindings['<ButtonRelease-1>'](event)
                    return True

            if self.card is None:
                return False
            if self.game is None:
                return False

        # print('LCardImage: touch_up on %s' % str(touch.pos))
        return False

    def on_touch_move(self, touch):
        # behandeln nur wenn grabbed
        if touch.grab_current is not self:
            return False
        if 'pos' not in touch.profile:
            return False

        print('LCardImage: touch_move on %s' % str(touch.pos))

        for stack in self.game.allstacks:
            for i in range(len(stack.cards)):
                if stack.cards[i] == self.card:
                    print('LCardImage: stack = %s/%s' % (stack, touch))
                    ppos, psize = self.game.canvas.KivyToCore(
                        touch.pos, self.size)
                    event = LEvent()
                    event.x = ppos[0]
                    event.y = ppos[1]
                    event.cardid = i
                    stack._motionEventHandler(event)
                    return True

        # print('LCardImage: touch_move on %s' % str(touch.pos))
        return False

# =============================================================================
# Treeview


class LTreeRoot(TreeView, LBase):
    def __init__(self, **kw):
        super(LTreeRoot, self).__init__(**kw)
        self.kw = kw

    def closeLastNode(self):
        ret = False
        lastopen = None
        for ti in reversed(self.children):
            if isinstance(ti, LTreeNode):
                if ti.is_open:
                    lastopen = ti

        if lastopen is not None:
            self.toggle_node(lastopen)
            self.select_node(lastopen)
            ret = True

        return ret


class LTreeNode(ButtonBehavior, TreeViewLabel, LBase):

    # def __init__(self, gameview, **kw):
    def __init__(self, **kw):
        self.command = None
        if 'command' in kw:
            self.command = kw['command']
        self.variable = None
        if 'variable' in kw:
            self.variable = kw['variable']
        if 'value' in kw:
            self.value = kw['value']
        if ('text' in kw):
            self.title = kw['text']

        super(LTreeNode, self).__init__(markup=True, **kw)

        if self.variable:
            self.variable.bind(value=self.onVarChange)
            self.onVarChange(self.variable, self.variable.get())

        # self.gameview = gameview
        self.coreFont = self.font_size
        # self.scaleFont(self.gameview.size[1])
        # self.gameview.bind(size=self.scaleFontCB)
        # nicht skalieren!

        self.bind(on_release=self.on_released)
        self.bind(is_selected=self.onSelect)
        self.bind(is_open=self.onOpen)

    def onVarChange(self, instance, value):
        # print('LTreeNode: onVarChange(%s, %s, %s)'
        # % (instance, value, type(value)))
        if type(value) is bool:
            self.setCheck(value)
        if type(value) is int:
            self.setVal(value)
        if type(value) is str:
            self.setVal(value)
        # if type(value) is unicode:
        #     self.setVal(value)

    def setCheck(self, value):
        # print('LTreeNode: setCheck(%s)' % value)
        if value:
            # self.text = '+ '+self.title
            self.text = '[b]+[/b] ' + self.title
        else:
            self.text = '- ' + self.title
        self.texture_update()

    def setVal(self, value):
        # print('LTreeNode: setVal(%s)' % value)
        if value == self.value:
            # fs = str(int(self.font_size+2))
            # print ('%s.%s' % (self.font_size, fs))
            # self.text = '[size='+fs+'][b]'+self.title+'[/b][/size]'
            # self.text = 'o '+self.title
            self.text = '[b]o[/b] ' + self.title
            # self.text = u'\u25cf '+self.title  # unicode filled circle
        else:
            self.text = self.title
            self.text = u'    ' + self.title
            # self.text = u'\u25cb  '+self.title # unicode open circle
        self.texture_update()

    # font skalierung.

    def scaleFont(self, value):
        self.font_size = int(self.coreFont * value / 550.0)

    def scaleFontCB(self, instance, value):
        self.scaleFont(value[1])

    # benutzer interaktion.

    def onSelect(self, instance, val):
        if val:
            print('select %s' % self.title)
        else:
            print('deselect %s' % self.title)
        pass

    def collapseChildren(self, deep=False):

        def cc(p, n):
            for c in n.nodes:
                if c.is_open:
                    cc(p, c)
                    p.toggle_node(c)

        p = self.parent
        if p and isinstance(p, LTreeRoot):
            for n in self.nodes:
                if n.is_open:
                    # n.collapseChildren()   # ginge nur mit LTreeNode!
                    if deep:
                        cc(p, n)            # geht mit allen TreeViewNode
                    p.toggle_node(n)

    def collapseSiblings(self, deep=True):

        def cc(p, n):
            for c in n.nodes:
                if c.is_open:
                    cc(p, c)
                    p.toggle_node(c)

        p = self.parent
        if p and isinstance(p, LTreeRoot):
            # print('expand: LTreeRoot')
            for n in p.root.nodes:
                # print('expand: -> check %s' % n.title)
                if n != self and n.is_open and n.level >= self.level:
                    # print('expand: -> close %s' % n.title)
                    if deep:
                        cc(p, n)
                    p.toggle_node(n)

            pn = self.parent_node
            if pn and isinstance(pn, LTreeNode):
                # print('expand: LTreeNode')
                for n in pn.nodes:
                    # print('expand: -> check %s' % n.title)
                    if n != self and n.is_open and n.level >= self.level:
                        # print('expand: -> close %s' % n.title)
                        if deep:
                            cc(p, n)
                        p.toggle_node(n)

    def onOpen(self, instance, val):
        if val:
            # print('expand %s, %s' % (self.level, self.title))
            self.collapseSiblings(deep=False)
        else:
            # print('collapse %s, %s' % (self.level, self.title))
            pass

    def on_released(self, v):
        if self.command:
            Clock.schedule_once(self.commandCB, 0.1)
        else:
            Clock.schedule_once(self.toggleCB, 0.1)

    def commandCB(self, d):
        self.command()

    def toggleCB(self, d):
        # hier könnte der knoten ev. auch neu aufgebaut werden ?!
        self.parent.toggle_node(self)

# =============================================================================


class LTopLevelContent(BoxLayout, LBase):
    def __init__(self, **kw):
        super(LTopLevelContent, self).__init__(**kw)

        # beispiel zu canvas (hintergrund)
        with self.canvas.before:
            Color(0.45, 0.5, 0.5, 1.0)
            self.rect = Rectangle(pos=self.pos, size=self.size)
        self.bind(pos=self.update_rect)
        self.bind(size=self.update_rect)

    def update_rect(self, *args):
        self.rect.pos = self.pos
        self.rect.size = self.size

    def wm_minsize(self, w, h):
        pass

# =============================================================================


class LTopLine(ButtonBehavior, Label, LBase):

    def __init__(self, **kw):
        super(LTopLine, self).__init__(**kw)
        with self.canvas.before:
            Color(0.45, 0.3, 0.3, 1.0)
            self.rect = Rectangle(pos=self.pos, size=self.size)
        self.bind(pos=self.update_rect)
        self.bind(size=self.update_rect)

    def update_rect(self, *args):
        self.rect.pos = self.pos
        self.rect.size = self.size

    def on_press(self):
        print('press')

    def on_release(self):
        print('release')

# =============================================================================


class LTopLevel0(BoxLayout, LBase):
    def __init__(self, top, title=None, **kw):
        self.main = top
        super(LTopLevel0, self).__init__(
            orientation="vertical", **kw)

        # self.canvas.add(Color(0, 1, 0, 0.4))
        # self.canvas.add(Rectangle(pos=(100, 100), size=(100, 100)))

        self.size_hint = (0.5, 1.0)
        '''
        self.titleline = BoxLayout(
            orientation="horizontal", size_hint=[1.0, 0.15], **kw)
        self.button = Button(text="X", size_hint=[0.15, 1.0], **kw)
        if not title:
            title = '<>'
        self.title = Label(text=title, **kw)
        self.titleline.add_widget(self.title)
        self.titleline.add_widget(self.button)
        '''
        self.titleline = LTopLine(text=title, size_hint=[1.0, 0.15])
        self.title = title

        # self.content = BoxLayout(orientation="vertical", **kw)
        self.content = LTopLevelContent(orientation="vertical", **kw)
        self.add_widget(self.titleline)
        self.add_widget(self.content)
        '''
        self.button.bind(on_press=self.onClick)
        '''
        self.titleline.bind(on_press=self.onClick)
        self.main.pushWork(self.title, self)

    def onClick(self, event):
        print('LTopLevel: onClick')
        self.main.popWork(self.title)

# =============================================================================


class LTopLevel(BoxLayout, LBase):
    def __init__(self, parent, title=None, **kw):
        self.mainwindow = parent
        super(LTopLevel, self).__init__(
            orientation="vertical", **kw)

        if ('size_hint' not in kw):
            self.size_hint = (0.5, 1.0)
        else:
            del kw['size_hint']
        self.titleline = LTopLine(text=title, size_hint=(1.0, 0.10))

        self.content = LTopLevelContent(orientation="vertical", **kw)
        self.add_widget(self.titleline)
        self.add_widget(self.content)

    def processAndroidBack(self):
        ret = False
        # try to collapse the last open tree node
        # the treeview will be located inside of a scrollview
        # (-> menubar.py)
        for c in self.content.children:
            # print("childitem: %s" % str(c))
            if isinstance(c, LScrollView):
                for t in reversed(c.children):
                    # print("  childitem: %s" % str(t))
                    if isinstance(t, LTreeRoot):
                        ret = t.closeLastNode()
            if isinstance(c, BoxLayout):
                for t in reversed(c.children):
                    # print("  childitem: %s" % str(t))
                    if isinstance(t, LPopCommander):
                        ret = t.pop()
                    pass
        return ret


# =============================================================================


class LMenuBar(BoxLayout, LBase):
    def __init__(self, **kw):
        super(LMenuBar, self).__init__(**kw)
        self.menu = None
        self.size_hint = (1.0, 0.08)

    def setMenu(self, menu):
        print('LMenuBar: setMenu %s, %s' % (self, menu))

        # Letztes Menu entfernen
        last = self.menu
        if (last is not None):
            self.remove_widget(last)
            self.menu = None

        # Neues Menu einfügen
        if (menu is not None):
            self.add_widget(menu)
            self.menu = menu
            menu.setBar(self)

    def getMenu(self):
        return self.menu

# =============================================================================


class LMenu(ActionView, LBase):
    def __init__(self, prev, **kw):
        super(LMenu, self).__init__(**kw)

        class MyActionPrev(ActionPrevious, LBase):
            pass

        kw['app_icon'] = 'data/images/icons/48x48/pysol.png'
        kw['with_previous'] = prev
        kw['size_hint'] = (.01, 1)
        self.ap = MyActionPrev(**kw)
        self.add_widget(self.ap)
        self.bar = None
        self.uppermenu = None

    def addItem(self, mi):
        # print ('LMenu: addItem '+str(mi)+' '+str(self.bar))
        mi.setBar(self.bar)
        self.add_widget(mi)

    def setBar(self, bar):
        # print ('LMenu: setBar %s, %s' % (self, bar))
        self.bar = bar

    def prev(self, menu):
        # print ('LMenu: prev = %s' % menu)
        self.uppermenu = menu
        self.ap.bind(on_release=self.upper)
        pass

    def upper(self, event):
        print('upper')
        self.bar.setMenu(self.uppermenu)

    def delete(self, pos, mode):
        # print ('LMenu(%s): delete(%s, %s)' % (self, pos, mode))

        items = []
        menues = []
        for c in self.children:
            if (type(c) is LMenuItem):
                # print ('LMenu: to delete child %s' % c)
                items.append(c)
            elif (type(c) is LMenu):
                # print ('LMenu: to delete child %s' % c)
                menues.append(c)
            else:
                # print ('LMenu: unknown child %s' % c)
                pass

        for c in items:
            # print ('LMenu: delete child %s' % c)
            self.clear_widgets([c])
        for c in menues:
            # print ('LMenu: delete child %s' % c)
            self.clear_widgets([c])
            c.delete(pos, mode)

    # def __str__(self):
    #   return hex(id(self))

# =============================================================================


class LMenuItem(ActionButton, LBase):

    def __init__(self, menu, **kw):
        super(LMenuItem, self).__init__(**kw)
        # super(LMenuItem, self).__init__()
        self.bar = None
        self.submenu = None
        self.menu = menu
        self.menu.addItem(self)
        self.minimum_width = '200sp'
        if 'command' in kw:
            self.setCommand(kw['command'])
        if 'submenu' in kw:
            self.setSubMenu(kw['submenu'])

    def setBar(self, bar):
        # print ('LMenuItem: setBar %s, %s' % (self, bar))
        self.bar = bar

    def onClick(self, event):
        # print('LMenuItem: onClick')
        # print('LMenuItem: submenu vorh: '+str(self.submenu))
        self.bar.setMenu(self.submenu)
        return True

    def setSubMenu(self, submenu):
        # print('LMenuItem: setSubMenu')
        self.submenu = submenu
        # print('LMenuItem: setSubMenu: '+str(self.submenu))
        self.submenu.prev(self.menu)
        self.submenu.setBar(self.bar)
        self.bind(on_release=self.onClick)
        pass

    def setCommand(self, cmd):
        # print('LMenuItem: setCommand')
        self.bind(on_release=cmd)

    # def __str__(self):
    #   return hex(id(self))

# =============================================================================


class LScrollView(ScrollView, LBase):
    def __init__(self, **kw):
        super(LScrollView, self).__init__(**kw)
        self.delayDown = False
        self.touch = None

    def delayReset(self, dt):
        if not self.delayDown:
            return
        self.delayDown = False
        ScrollView.on_touch_down(self, self.touch)

    # Scroll ist original viel zu flink auf den Touchgeräten.
    # Wir versuchen das hier etwas abzuschwächen.

    def on_touch_down(self, touch):
        self.delayDown = True
        self.touch = touch
        Clock.schedule_once(self.delayReset, 0.15)

    def on_touch_up(self, touch):
        if self.delayDown:
            ScrollView.on_touch_down(self, self.touch)
        self.delayDown = False
        return ScrollView.on_touch_up(self, touch)

    def on_touch_move(self, touch):
        return ScrollView.on_touch_move(self, touch)

# =============================================================================


class LWorkWindow(Widget):
    def __init__(self):
        super(LWorkWindow, self).__init__()

        # beispiel zu canvas (hintergrund)
        with self.canvas.before:
            Color(0, 1, 1, 0.4)
            self.rect = Rectangle(pos=self.pos, size=self.size)
        self.bind(pos=self.update_rect)
        self.bind(size=self.update_rect)

    def update_rect(self, *args):
        self.rect.pos = self.pos
        self.rect.size = self.size

    def on_touch_down(self, touch):
        print('LWorkWindow: touch_down on %s' % str(touch.pos))
        # return True

# =============================================================================


class LTkBase:
    # Tk Emulation needs.
    def __init__(self):
        self.title = "default title"
        self.icontitle = "default title"
        logging.info("LTkBase: __init__()")
        self.sleeping = False
        self.in_loop = False
        self.screenSize = (1000, 1000)

    def cget(self, strg):
        return False

    def wm_title(self, strg):
        self.title = strg
        logging.info("LTkBase: wm_title %s" % strg)
        if (self.app):
            # self.app.top.topLine.text = strg
            self.app.top.getMenu().ap.title = strg

    def wm_iconname(self, strg):
        self.icontitle = strg
        logging.info("LTkBase: wm_iconname %s" % strg)

    def eval_screen_dim(self, size):
        self.screenSize = size
        if get_platform() == 'android':
            from jnius import autoclass
            from jnius import cast
        else:
            return

        PythonActivity = autoclass('org.kivy.android.PythonActivity')
        currentActivity = cast(
            'android.app.Activity', PythonActivity.mActivity)
        wm = currentActivity.getWindowManager()
        d = wm.getDefaultDisplay()

        self.screenSize = (d.getWidth(), d.getHeight())

    def winfo_screenwidth(self):
        logging.info("LTkBase: winfo_screenwidth %s" % str(self.size[0]))
        return self.size[0]

    def winfo_screenheight(self):
        logging.info("LTkBase: winfo_screenheight %s" % str(self.size[1]))
        return self.size[1]

    def winfo_screendepth(self):
        return 32

    def wm_minsize(self, x, y):
        pass

    def option_add(self, a, b, c):
        pass

    def option_get(self, a, b):
        return 0

    def wm_withdraw(self):
        logging.info("LTkBase: wm_withdraw")
        pass

    def busyUpdate(self):
        print('LTkBase: busyUpdate()')
        pass

    def grid_columnconfigure(self, a, weight):
        pass

    def grid_rowconfigure(self, a, weight):
        pass

    def connectApp(self, app):
        logging.info("LTkBase: connectApp %s" % str(app))
        self.app = app
        pass

    def wm_geometry(self, val):
        logging.info("LTkBase: wm_geometry %s" % str(val))
        pass

    def update_idletasks(self):
        logging.info("LTkBase: update_idletasks")
        try:
            if len(EventLoop.event_listeners) > 0:
                self.in_loop = True
                EventLoop.idle()
                self.in_loop = False
            else:
                logging.info("LTkBase: update_idletasks: terminating")
        except Exception:
            self.in_loop = False
            logging.info("LTkBase: update_idletasks: exception")

    def wm_state(self):
        return ""

    def wm_deiconify(self):
        pass

    def mainloop(self):
        logging.info("LTkBase: mainloop")
        pass

    def quit(self):
        logging.info("LTkBase: quit")
        stopTouchApp()

    def interruptSleep(self):
        logging.info('LTkBase: interruptSleep')
        self.update_idletasks()
        # self.sleep_var = 1
        return

    def mainquit(self):
        logging.info('LTkBase: mainquit')
        lapp = App.get_running_app()
        lapp.mainloop.send(None)    # Spielprozess verlassen
        return

    def onWakeUp(self, dt):
        self.sleeping = False

    def sleep(self, seconds):
        logging.info('LTkBase: sleep %s seconds' % seconds)
        self.sleeping = True
        Clock.schedule_once(self.onWakeUp, seconds)
        while self.sleeping:
            # time.sleep(0.05)
            self.in_loop = True
            EventLoop.idle()
            self.in_loop = False

    def waitCondition(self, condition):
        logging.info('LTkBase: wait condition start')
        while condition():
            self.in_loop = True
            EventLoop.idle()
            self.in_loop = False
        logging.info('LTkBase: wait condition end')

    def waitAnimation(self):
        self.waitCondition(LAnimationManager.checkRunning)

    def tkraise(self):
        pass

    def winfo_ismapped(self):
        return True
        # ???

# =============================================================================


class LStack:
    def __init__(self):
        self.items = []

    def isEmpty(self):
        return self.items == []

    def push(self, key, item):
        self.items.append((key, item))

    def pop(self, key):
        for i in range(len(self.items)):
            t = self.items[i]
            if (t[0] == key):
                self.items.pop(i)
                return t[1]
        return None

    def peek(self, key):
        for i in range(len(self.items)):
            t = self.items[i]
            if (t[0] == key):
                return t
        return None

    def size(self):
        return len(self.items)

# =============================================================================


class LMainWindow(BoxLayout, LTkBase):
    def __init__(self, **kw):
        super(LMainWindow, self).__init__(orientation='vertical')
        LTkBase.__init__(self)
        self.menuArea = LMenuBar()
        self.workContainer = LBoxLayout(orientation='horizontal')
        self.workContainerO = LBoxLayout(orientation='horizontal')
        self.workArea = None
        self.toolBar = None
        self.toolBarPos = 0
        self.bindings = {}
        self._w = '.'
        self.topLine = Button(
            size_hint=(1.0, 0.01),
            background_down='atlas:'
                            '//data/images/defaulttheme/action_item_down',
            background_normal='atlas:'
                              '//data/images/defaulttheme/action_item',
            border=(0, 0, 0, 0))
        self.topLine1 = Label(size_hint=(1.0, 0.01))

        self.add_widget(self.topLine)
        self.add_widget(self.menuArea)
        self.add_widget(self.topLine1)
        self.add_widget(self.workContainerO)
        self.workContainerO.add_widget(self.workContainer)
        # self.add_widget(Button(size_hint = (1.0, 0.01)))

        self.workStack = LStack()
        self.app = None

        '''
        from kivy.graphics import opengl_utils
        print('OPENGL support:')
        print(opengl_utils.gl_get_extensions())
        '''

        # self.touches = []

        # beispiel zu canvas (hintergrund)
        # with self.canvas.before:
        #   Color(0, 1, 0.7, 0.5)
        #   self.rect = Rectangle(pos=self.pos, size=self.size)
        # self.bind(pos=self.update_rect)
        # self.bind(size=self.update_rect)

    # def update_rect(self, *args):
    #   self.rect.pos = self.pos
    #   self.rect.size = self.size

    def on_motion(self, m):
        print('on_motion', m)
        pass

    # Events.

    def on_touch_down(self, touch):
        ret = False

        # print(dir(touch))

        # multitouch detection
        '''
        #print("MainWindow touch_down",touch.ox,touch.oy)
        #print("MainWindow touch_down",touch.sx,touch.sy)
        #print("MainWindow touch_down",touch.px,touch.py)
        self.touches.append(touch)
        print("touches cnt = ",len(self.touches))
        '''
        # multiclick detection
        '''
        if touch.is_double_tap:
            # print('Touch is a double tap !')
            # print(' - interval is', touch.double_tap_time)
            # print(' - distance betw. previous is', touch.double_tap_distance)
            # test the functions of Android back key
            ret = self.processAndroidBack()
            if (ret):
                return ret
        '''
        '''
        if touch.is_triple_tap:
            print('Touch is a triple tap !')
            print(' - interval is', touch.triple_tap_time)
            print(' - distance between previous is', touch.triple_tap_distance)
        '''
        # (Eventloop reentrancy check)
        if self.in_loop:
            return ret

        # (demo mode stop - nur auf spielfläche)
        if '<KeyPress>' in self.bindings:
            pgs = self.workStack.peek('playground')
            if pgs:
                pg = pgs[1]
                if pg.collide_point(*touch.pos):
                    event = LEvent()
                    event.char = True
                    self.bindings['<KeyPress>'](event)

        # standard notifikation:
        for c in self.children:
            ret = c.on_touch_down(touch)
            if ret:
                break
        return ret

    def on_touch_up(self, touch):
        ret = False
        # standard notifikation:
        for c in self.children:
            ret = c.on_touch_up(touch)
            if ret:
                break

        # multitouch support
        '''
        self.touches = [xx for xx in self.touches if xx != touch]
        print("touches cnt = ",len(self.touches))
        '''
        return ret

    # Menubar:

    def setMenu(self, menu):
        self.menuArea.setMenu(menu)

    def getMenu(self):
        return self.menuArea.getMenu()

    # Toolbar:

    def setTool(self, toolbar, pos=0):
        if (toolbar is not None):
            self.toolBar = toolbar
        self.toolBarPos = pos
        self.rebuildContainer()

    # Workarea:

    def removeContainer(self):
        self.workContainer.clear_widgets()
        self.workContainerO.clear_widgets()

    def buildContainer(self):
        if self.toolBar is not None and self.toolBarPos == 3:
            self.workContainerO.add_widget(self.toolBar)
        self.workContainerO.add_widget(self.workContainer)
        if self.toolBar is not None and self.toolBarPos == 4:
            self.workContainerO.add_widget(self.toolBar)
        for w in self.workStack.items:
            self.workContainer.add_widget(w[1])

    def rebuildContainer(self):
        self.removeContainer()
        self.buildContainer()

    def pushWork(self, key, widget):
        if (widget):
            self.workStack.push(key, widget)
            self.rebuildContainer()

    def popWork(self, key):
        w = None
        if self.workStack.size() > 0:
            w = self.workStack.pop(key)
            self.rebuildContainer()
        return w

    def setWork(self, key, widget):
        self.pushWork(key, widget)

    def getWork(self, key):
        return self.workStack.peek(key)

    def processAndroidBack(self):
        ret = False
        # try to close currently open popup windows, one by one
        r = range(len(self.workStack.items))
        rr = reversed(r)
        for i in rr:
            t = self.workStack.items[i]
            # print("stackkey:  %s" % str(t[0]))
            # print("stackitem: %s" % str(t[1]))
            if t[0] == 'playground':
                pass
            else:
                if isinstance(t[1], LTopLevel):
                    ret = t[1].processAndroidBack()
                if not ret:
                    self.popWork(t[0])
                    ret = True
            if ret:
                break
        return ret

# =============================================================================


class LApp(App):

    # Handling of android return key
    def key_input(self, window, key, scancode, codepoint, modifier):
        if key == 27:
            # Back key of Android.
            lapp = App.get_running_app()
            app = lapp.app
            if app is None:
                return False  # delegate

            # redirect to mainwindow to close popups, tree nodes
            # and html pages.
            if (self.mainWindow.processAndroidBack()):
                return True  # consumed

            # redirect to game to undo last step
            app.menubar.mUndo()
            return True     # consumed
        else:
            return False    # delegate

    def __init__(self):
        super(LApp, self).__init__()

        # Config.set('input', 'multitouchscreen1', 'tuio,0.0.0.0:3333')

        self.mainWindow = LMainWindow()
        logging.info('top = %s' % str(self.mainWindow))
        Cache.register('LAppCache', limit=10)
        Cache.append('LAppCache', 'mainWindow', self.mainWindow, timeout=0)
        Cache.append('LAppCache', 'mainApp', self, timeout=0)
        self.startCode = 0

    # Es gibt hier offensichtlich nur einen Bilschirm mit Höhe und Breite.
    # Alles andere stellt das Betriebssystem zur Verfügung. Wir wissen auch
    # nicht, wie das Gerät gerade orientiert ist, ist nicht unsere Sache.
    # Alles was wir tun können ist Höhe und Breite zu verfolgen, sobald wir
    # dazu informiert werden. (Android informiert leider nicht immer, wenn
    # es nötig wäre).
    # Update:
    # Nachdem im Manifest nun steht 'configChange=...|screenSize' bekommen
    # wir auch nach dem on_resume ein Signal.

    def delayedRebuild(self, dt):
        logging.info("LApp: delayedRebuild")
        self.mainWindow.rebuildContainer()

    def makeDelayedRebuild(self):
        def delayedRebuild(dt):
            # Clock.schedule_once(self.delayedRebuild, 0.01)
            Clock.schedule_once(self.delayedRebuild, 0.5)
        return delayedRebuild

    def doSize(self, obj, val):
        mval = self.mainWindow.size
        if (val[0] != mval[0] and val[1] != mval[1]):
            logging.info("LApp: size changed %s - %s (%s)" % (obj, val, mval))
            Clock.schedule_once(self.makeDelayedRebuild(), 0.01)
        pass

    def on_start(self):
        logging.info('mw = %s,  w = %s' % (self.mainWindow, Window))

        Window.bind(on_keyboard=self.key_input)
        Window.bind(size=self.doSize)

        if self.startCode > 0:
            logging.info("LApp: on_start fails")
            return

        logging.info("LApp: on_start")
        self.mainloop = self.app.mainproc()  # Einrichten
        self.mainloop.send(None)                # Spielprozess starten
        logging.info("LApp: on_start processed")
        # Android: Request missing android permissions.
        requestStoragePerm()

    def on_stop(self):
        # Achtung wird u.U. 2 mal aufgerufen !!!
        logging.info("LApp: on_stop")
        if self.startCode > 0:
            return
        # lapp: erweiterte klasse dieser (mit pysolfc app members).
        lapp = App.get_running_app()
        lapp.app.menubar.mHoldAndQuit()

    def on_pause(self):
        logging.info("LApp: on_pause")
        # return True: wenn wir wirklich in pause gehen. Dann wird auch
        # resume aufgerufen falls die app wieder aktiviert wird.
        # return False: app wird gestoppt (on_stop wird aufgerufen)
        if self.startCode > 0:
            return False

        pauseSupport = True
        # True ist die bessere Variante.

        lapp = App.get_running_app()
        app = lapp.app
        if app is None:
            return

        logging.info("LApp: on_pause - pause on")
        # set pause
        if not app.game.pause:
            app.game.doPause()

        logging.info("LApp: on_pause - savegame")
        # save game
        try:
            app.game.gstats.holded = 1
            app.game._saveGame(app.fn.holdgame)
            app.opt.game_holded = app.game.id
            app.opt.last_gameid = app.game.id
        except Exception:
            traceback.print_exc()
            pass
        # save options
        try:
            app.saveOptions()
        except Exception:
            traceback.print_exc()
            pass
        # save statistics
        try:
            app.saveStatistics()
        except Exception:
            traceback.print_exc()
            pass
        logging.info("LApp: on_pause - gamesaved")

        logging.info("LApp: on_pause, Window.size=%s" % str(Window.size))

        return pauseSupport

    def on_resume(self):
        logging.info("LApp: on_resume")

        lapp = App.get_running_app()
        app = lapp.app
        if app is None:
            return

        so = get_screen_ori()
        go = so  # flake8: F841 nonsense!
        so = go
        logging.info("LApp: on_resume, Window.size=%s" % str(Window.size))
        # ANM:
        # kivy.core.window.Window hat hier u.U. eine falsche dimension
        # und unterscheidet sich vom display (-> in get_screen_ori).
        # Eine korrektur der Parameter von Window kann hier wie skizziert
        # durchgeführt werden und führt auch zu den korrekten 'on_size'
        # Notifikationen. Allerdings wird später (nach diesem Aufruf)
        # eine weitere Notifikation erhalten, welche das Fenster u.U.
        # wieder falsch aufstellt. (woher kommt die und warum ist sie
        # oft falsch ?)

        if app.game.pause:
            Clock.schedule_once(self.makeEndPauseCmd(app), 3.0)

    def makeEndPauseCmd(self, app):
        def endPauseCmd(dt):
            if app.game.pause:
                logging.info("LApp: on_resume - pause off")
                app.game.doPause()
        return endPauseCmd
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
# Copyright (C) 2017 LB
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#

import math
import os
import re

from kivy.event import EventDispatcher
from kivy.properties import BooleanProperty
from kivy.properties import NumericProperty
from kivy.properties import StringProperty

from pysollib.gamedb import GI
from pysollib.kivy.LApp import LMenu
from pysollib.kivy.LApp import LMenuItem
from pysollib.kivy.LApp import LScrollView
from pysollib.kivy.LApp import LTopLevel
from pysollib.kivy.LApp import LTreeNode
from pysollib.kivy.LApp import LTreeRoot
from pysollib.kivy.findcarddialog import destroy_find_card_dialog
from pysollib.kivy.selectcardset import SelectCardsetDialogWithPreview
from pysollib.kivy.selectgame import SelectGameDialog
from pysollib.kivy.solverdialog import connect_game_solver_dialog
from pysollib.kivy.tkconst import CURSOR_WATCH, EVENT_HANDLED, EVENT_PROPAGATE
from pysollib.kivy.tkconst import TOOLBAR_BUTTONS
from pysollib.kivy.tkutil import after_idle
from pysollib.kivy.tkutil import bind
from pysollib.mfxutil import Struct
from pysollib.mygettext import _
from pysollib.pysoltk import MfxMessageDialog
from pysollib.pysoltk import connect_game_find_card_dialog
from pysollib.settings import SELECT_GAME_MENU
from pysollib.settings import TITLE


# ************************************************************************
# * tk emuls:
# ************************************************************************


class TkVarObj(EventDispatcher):
    def __init(self):
        self.value = None

    def set(self, v):
        if v is None:
            if type(self.value) is str:
                v = ''
        self.value = v

    def get(self):
        return self.value


class BooleanVar(TkVarObj):
    value = BooleanProperty(False)


class IntVar(TkVarObj):
    value = NumericProperty(0)


class StringVar(TkVarObj):
    value = StringProperty('')

# ************************************************************************
# * Menu Dialogs
# ************************************************************************


class LMenuDialog(object):

    dialogCache = {}

    def make_pop_command(self, parent, title):
        def pop_command(event):
            print('event = %s' % event)
            parent.popWork(title)
        return pop_command

    def __init__(self, menubar, parent, title, app, **kw):
        super(LMenuDialog, self).__init__()

        self.menubar = menubar
        self.parent = parent
        self.app = app
        self.title = title
        self.window = None
        self.running = False
        self.persist = False
        if 'persist' in kw:
            self.persist = kw['persist']

        # prüfen ob noch aktiv - toggle.

        if parent.workStack.peek(title) is not None:
            parent.popWork(title)
            return

        if self.persist and title in self.dialogCache:
            parent.pushWork(title, self.dialogCache[title])
            return

        pc = self.closeWindow = self.make_pop_command(parent, title)

        # neuen Dialog aufbauen.

        window = LTopLevel(parent, title, **kw)
        window.titleline.bind(on_press=pc)
        self.parent.pushWork(title, window)
        self.window = window
        self.running = True

        if self.persist:
            self.dialogCache[title] = window

        # Tree skelett.

        tv = self.tvroot = LTreeRoot(root_options=dict(text='EditTree'))
        tv.hide_root = True
        tv.size_hint = 1, None
        tv.bind(minimum_height=tv.setter('height'))

        # menupunkte aufbauen.

        self.buildTree(tv, None)

        # tree in einem Scrollwindow präsentieren.

        root = LScrollView(pos=(0, 0))
        root.add_widget(tv)
        self.window.content.add_widget(root)

    def buildTree(self, tree, node):
        print('buildTree base')
        # to implement in dervied class
        pass

# ************************************************************************


class MainMenuDialog(LMenuDialog):

    def __init__(self, menubar, parent, title, app, **kw):
        kw['size_hint'] = (0.2, 1)
        kw['persist'] = True
        super(MainMenuDialog, self).__init__(
            menubar, parent, title, app, **kw)

    def make_game_command(self, command):
        def game_command():
            command()
            self.closeWindow(0)
        return game_command

    def buildTree(self, tv, node):
        rg = tv.add_node(
            LTreeNode(
                text=_("File"),
                command=self.make_game_command(self.menubar.mFileMenuDialog)))
        rg = tv.add_node(
            LTreeNode(
                text=_("Games"),
                command=self.make_game_command(
                    self.menubar.mSelectGameDialog)))
        rg = tv.add_node(
            LTreeNode(
                text=_("Tools"),
                command=self.make_game_command(self.menubar.mEditMenuDialog)))
        rg = tv.add_node(
            LTreeNode(
                text=_("Statistics"),
                command=self.make_game_command(self.menubar.mGameMenuDialog)))
        rg = tv.add_node(
            LTreeNode(
                text=_("Assist"),
                command=self.make_game_command(
                    self.menubar.mAssistMenuDialog)))
        rg = tv.add_node(
            LTreeNode(
                text=_("Options"),
                command=self.make_game_command(
                    self.menubar.mOptionsMenuDialog)))
        rg = tv.add_node(
            LTreeNode(
                text=_("Help"),
                command=self.make_game_command(self.menubar.mHelpMenuDialog)))
        del rg

# ************************************************************************


class FileMenuDialog(LMenuDialog):

    def __init__(self, menubar, parent, title, app, **kw):
        kw['size_hint'] = (0.3, 1)
        super(FileMenuDialog, self).__init__(
            menubar, parent, title, app, **kw)

    def make_game_command(self, key, command):
        def game_command():
            command(key)
        return game_command

    def buildTree(self, tv, node):
        rg = tv.add_node(
            LTreeNode(text=_('Recent games')))
        # Recent Liste
        recids = self.app.opt.recent_gameid
        # recgames = []
        for rid in recids:
            gi = self.app.getGameInfo(rid)
            if gi:
                command = self.make_game_command(
                    rid, self.menubar._mSelectGame)
                tv.add_node(
                    LTreeNode(text=gi.name, command=command), rg)

        rg = tv.add_node(
            LTreeNode(text=_('Favorite games')))
        if rg:
            tv.add_node(LTreeNode(
                text=_('<Add>'), command=self.menubar.mAddFavor), rg)
            tv.add_node(LTreeNode(
                text=_('<Remove>'), command=self.menubar.mDelFavor), rg)

            # Recent Liste
            favids = self.app.opt.favorite_gameid
            # favgames = []
            for fid in favids:
                gi = self.app.getGameInfo(fid)
                if gi:
                    command = self.make_game_command(
                        fid, self.menubar._mSelectGame)
                    tv.add_node(
                        LTreeNode(text=gi.name, command=command), rg)

        tv.add_node(LTreeNode(
            text=_('Load'), command=self.menubar.mOpen))
        tv.add_node(LTreeNode(
            text=_('Save'), command=self.menubar.mSaveAs))

        tv.add_node(LTreeNode(
            text=_('Quit'), command=self.menubar.mHoldAndQuit))

# ************************************************************************


class EditMenuDialog(LMenuDialog):  # Tools

    def __init__(self, menubar, parent, title, app, **kw):
        kw['size_hint'] = (0.2, 1)
        kw['persist'] = True
        super(EditMenuDialog, self).__init__(
            menubar, parent, title, app, **kw)

    def make_auto_command(self, variable, command):
        def auto_command():
            variable.set(not variable.get())
            command()
        return auto_command

    def addCheckNode(self, tv, rg, title, auto_var, auto_com):
        command = self.make_auto_command(auto_var, auto_com)
        rg1 = tv.add_node(
            LTreeNode(text=title, command=command, variable=auto_var), rg)
        return rg1

    def buildTree(self, tv, node):
        tv.add_node(LTreeNode(
            text=_('New game'), command=self.menubar.mNewGame))
        tv.add_node(LTreeNode(
            text=_('Restart game'), command=self.menubar.mRestart))

        tv.add_node(LTreeNode(
            text=_('Undo'), command=self.menubar.mUndo))
        tv.add_node(LTreeNode(
            text=_('Redo'), command=self.menubar.mRedo))
        tv.add_node(LTreeNode(
            text=_('Redo all'), command=self.menubar.mRedoAll))

        tv.add_node(LTreeNode(
            text=_('Auto drop'), command=self.menubar.mDrop))
        tv.add_node(LTreeNode(
            text=_('Shuffle tiles'), command=self.menubar.mShuffle))
        tv.add_node(LTreeNode(
            text=_('Deal cards'), command=self.menubar.mDeal))

        self.addCheckNode(tv, None,
                          _('Pause'),
                          self.menubar.tkopt.pause,
                          self.menubar.mPause)

        tv.add_node(LTreeNode(
            text=_('Load game'), command=self.menubar.mOpen))
        tv.add_node(LTreeNode(
            text=_('Save game'), command=self.menubar.mSaveAs))

        tv.add_node(LTreeNode(
            text=_('Help'), command=self.menubar.mHelpRules))

        # -------------------------------------------
        # TBD ?
        '''
        menu.add_separator()
        submenu = MfxMenu(menu, label=n_("&Set bookmark"))
        for i in range(9):
            label = _("Bookmark %d") % (i + 1)
            submenu.add_command(
                label=label, command=lambda i=i: self.mSetBookmark(i))
        submenu = MfxMenu(menu, label=n_("Go&to bookmark"))
        for i in range(9):
            label = _("Bookmark %d") % (i + 1)
            acc = m + "%d" % (i + 1)
            submenu.add_command(
                label=label,
                command=lambda i=i: self.mGotoBookmark(i),
                accelerator=acc)
        menu.add_command(
            label=n_("&Clear bookmarks"), command=self.mClearBookmarks)
        menu.add_separator()
        '''
        # und solitär wizard (-> custom games).
        '''
        tv.add_node(LTreeNode(
            text='Solitaire &Wizard', command=self.menubar.mWizard))
        tv.add_node(LTreeNode(
                text='Edit current game', command=self.menubar.mWizardEdit))
        '''

# ************************************************************************


class GameMenuDialog(LMenuDialog):

    def __init__(self, menubar, parent, title, app, **kw):
        kw['size_hint'] = (0.2, 1)
        kw['persist'] = True
        super(GameMenuDialog, self).__init__(
            menubar, parent, title, app, **kw)

    def make_command(self, key, command):
        def stats_command():
            kw = {}
            kw['mode'] = key
            command(**kw)
        return stats_command

    def buildTree(self, tv, node):
        tv.add_node(LTreeNode(
            text=_('Current game...'),
            command=self.make_command(101, self.menubar.mPlayerStats)), None)

        # tv.add_node(LTreeNode(
        #   text='All games ...',
        #   command=self.make_command(102, self.menubar.mPlayerStats)), None)

    # -------------------------------------------
    # TBD ? - just to remember original tk code.
    '''
        menu.add_command(
            label=n_("S&tatus..."),
            command=lambda x: self.mPlayerStats(mode=100), accelerator=m+"Y")
        menu.add_checkbutton(
            label=n_("&Comments..."), variable=self.tkopt.comment,
            command=self.mEditGameComment)
    '''
    '''
        menu.add_separator()
        submenu = MfxMenu(menu, label=n_("&Statistics"))
        submenu.add_command(
            label=n_("Current game..."),
            command=lambda x: self.mPlayerStats(mode=101))
        submenu.add_command(
            label=n_("All games..."),
            command=lambda x: self.mPlayerStats(mode=102))
        submenu.add_separator()
        submenu.add_command(
            label=n_("Session log..."),
            command=lambda x: self.mPlayerStats(mode=104))
        submenu.add_command(
            label=n_("Full log..."),
            command=lambda x: self.mPlayerStats(mode=103))
        submenu.add_separator()
        submenu.add_command(
            label=TOP_TITLE+"...",
            command=lambda x: self.mPlayerStats(mode=105),
            accelerator=m+"T")
        submenu.add_command(
            label=n_("Progression..."),
            command=lambda x: self.mPlayerStats(mode=107))
        submenu = MfxMenu(menu, label=n_("D&emo statistics"))
        submenu.add_command(
            label=n_("Current game..."),
            command=lambda x: self.mPlayerStats(mode=1101))
        submenu.add_command(
            label=n_("All games..."),
            command=lambda x: self.mPlayerStats(mode=1102))
    '''

# ************************************************************************


class AssistMenuDialog(LMenuDialog):

    def __init__(self, menubar, parent, title, app, **kw):
        kw['size_hint'] = (0.2, 1)
        kw['persist'] = True
        super(AssistMenuDialog, self).__init__(
            menubar, parent, title, app, **kw)

    def buildTree(self, tv, node):
        tv.add_node(LTreeNode(
            text=_('Hint'), command=self.menubar.mHint))

        tv.add_node(LTreeNode(
            text=_('Highlight piles'), command=self.menubar.mHighlightPiles))

        # tv.add_node(LTreeNode(
        #   text='Find Card', command=self.menubar.mFindCard))

        tv.add_node(LTreeNode(
            text=_('Demo'), command=self.menubar.mDemo))

        # -------------------------------------------
        # TBD. How ?

        '''
        menu.add_command(
            label=n_("Demo (&all games)"), command=self.mMixedDemo)
        if USE_FREECELL_SOLVER:
            menu.add_command(label=n_("&Solver"), command=self.mSolver)
        else:
            menu.add_command(label=n_("&Solver"), state='disabled')
        menu.add_separator()
        menu.add_command(
            label=n_("&Piles description"),
            command=self.mStackDesk, accelerator="F2")
        '''

# ************************************************************************


class OptionsMenuDialog(LMenuDialog):

    def __init__(self, menubar, parent, title, app, **kw):
        kw['size_hint'] = (0.5, 1)
        kw['persist'] = True
        super(OptionsMenuDialog, self).__init__(
            menubar, parent, title, app, **kw)

    def make_auto_command(self, variable, command):
        def auto_command():
            variable.set(not variable.get())
            command()
        return auto_command

    def addCheckNode(self, tv, rg, title, auto_var, auto_com):
        command = self.make_auto_command(auto_var, auto_com)
        rg1 = tv.add_node(
            LTreeNode(text=title, command=command, variable=auto_var), rg)
        return rg1

    def make_val_command(self, variable, value, command):
        def val_command():
            variable.set(value)
            command()
        return val_command

    def make_vars_command(self, command, key):
        def vars_command():
            command(key)
        return vars_command

    def addRadioNode(self, tv, rg, title, auto_var, auto_val, auto_com):
        command = self.make_val_command(auto_var, auto_val, auto_com)
        rg1 = tv.add_node(
            LTreeNode(text=title,
                      command=command,
                      variable=auto_var, value=auto_val), rg)
        return rg1

    def buildTree(self, tv, node):

        # -------------------------------------------
        # Automatic play settings

        rg = tv.add_node(
            LTreeNode(text=_('Automatic play')))
        if rg:
            self.addCheckNode(tv, rg,
                              _('Auto face up'),
                              self.menubar.tkopt.autofaceup,
                              self.menubar.mOptAutoFaceUp)

            self.addCheckNode(tv, rg,
                              _('Auto drop'),
                              self.menubar.tkopt.autodrop,
                              self.menubar.mOptAutoDrop)

            self.addCheckNode(tv, rg,
                              _('Auto deal'),
                              self.menubar.tkopt.autodeal,
                              self.menubar.mOptAutoDeal)

            # submenu.add_separator()

            self.addCheckNode(tv, rg,
                              _('Quick play'),
                              self.menubar.tkopt.quickplay,
                              self.menubar.mOptQuickPlay)

        # -------------------------------------------
        # Player assistance

        rg = tv.add_node(
            LTreeNode(text=_('Assist level')))
        if rg:
            self.addCheckNode(tv, rg,
                              _('Enable undo'),
                              self.menubar.tkopt.undo,
                              self.menubar.mOptEnableUndo)

            self.addCheckNode(tv, rg,
                              _('Enable bookmarks'),
                              self.menubar.tkopt.bookmarks,
                              self.menubar.mOptEnableBookmarks)

            self.addCheckNode(tv, rg,
                              _('Enable hint'),
                              self.menubar.tkopt.hint,
                              self.menubar.mOptEnableHint)

            self.addCheckNode(tv, rg,
                              _('Enable shuffle'),
                              self.menubar.tkopt.shuffle,
                              self.menubar.mOptEnableShuffle)

            self.addCheckNode(tv, rg,
                              _('Enable highlight piles'),
                              self.menubar.tkopt.highlight_piles,
                              self.menubar.mOptEnableHighlightPiles)

            self.addCheckNode(tv, rg,
                              _('Enable highlight cards'),
                              self.menubar.tkopt.highlight_cards,
                              self.menubar.mOptEnableHighlightCards)

            self.addCheckNode(tv, rg,
                              _('Enable highlight same rank'),
                              self.menubar.tkopt.highlight_samerank,
                              self.menubar.mOptEnableHighlightSameRank)

            self.addCheckNode(tv, rg,
                              _('Highlight no matching'),
                              self.menubar.tkopt.highlight_not_matching,
                              self.menubar.mOptEnableHighlightNotMatching)

            # submenu.add_separator()

            self.addCheckNode(tv, rg,
                              _('Show removed tiles (in Mahjongg games)'),
                              self.menubar.tkopt.mahjongg_show_removed,
                              self.menubar.mOptMahjonggShowRemoved)

            self.addCheckNode(tv, rg,
                              _('Show hint arrow (in Shisen-Sho games)'),
                              self.menubar.tkopt.shisen_show_hint,
                              self.menubar.mOptShisenShowHint)

            # submenu.add_separator()

        # -------------------------------------------
        # Language options

        rg = tv.add_node(
            LTreeNode(text=_('Language')))
        if rg:
            self.addRadioNode(tv, rg,
                              _('Default'),
                              self.menubar.tkopt.language, '',
                              self.menubar.mOptLanguage)
            self.addRadioNode(tv, rg,
                              _('English'),
                              self.menubar.tkopt.language, 'en',
                              self.menubar.mOptLanguage)
            self.addRadioNode(tv, rg,
                              _('German'),
                              self.menubar.tkopt.language, 'de',
                              self.menubar.mOptLanguage)
            self.addRadioNode(tv, rg,
                              _('Italian'),
                              self.menubar.tkopt.language, 'it',
                              self.menubar.mOptLanguage)
            self.addRadioNode(tv, rg,
                              _('Polish'),
                              self.menubar.tkopt.language, 'pl',
                              self.menubar.mOptLanguage)
            self.addRadioNode(tv, rg,
                              _('Russian'),
                              self.menubar.tkopt.language, 'ru',
                              self.menubar.mOptLanguage)

        # -------------------------------------------
        # Sound options

        rg = tv.add_node(
            LTreeNode(text=_('Sound')))
        if rg:
            self.addCheckNode(tv, rg,
                              _('Enable'),
                              self.menubar.tkopt.sound,
                              self.menubar.mOptSoundDialog)

            rg1 = tv.add_node(
                LTreeNode(text=_('Volume')), rg)
            if rg1:
                self.addRadioNode(tv, rg1,
                                  _('100%'),
                                  self.menubar.tkopt.sound_sample_volume, 100,
                                  self.menubar.mOptSoundSampleVol)
                self.addRadioNode(tv, rg1,
                                  _('75%'),
                                  self.menubar.tkopt.sound_sample_volume, 75,
                                  self.menubar.mOptSoundSampleVol)
                self.addRadioNode(tv, rg1,
                                  _('50%'),
                                  self.menubar.tkopt.sound_sample_volume, 50,
                                  self.menubar.mOptSoundSampleVol)
                self.addRadioNode(tv, rg1,
                                  _('25%'),
                                  self.menubar.tkopt.sound_sample_volume, 25,
                                  self.menubar.mOptSoundSampleVol)

            rg1 = tv.add_node(
                LTreeNode(text=_('Samples')), rg)
            if rg1:
                key = 'areyousure'
                self.addCheckNode(
                    tv, rg1,
                    _('are you sure'),
                    self.menubar.tkopt.sound_sample_vars[key],
                    self.make_vars_command(self.menubar.mOptSoundSample, key))
                key = 'autodrop'
                self.addCheckNode(
                    tv, rg1,
                    _('auto drop'),
                    self.menubar.tkopt.sound_sample_vars[key],
                    self.make_vars_command(self.menubar.mOptSoundSample, key))
                key = 'autoflip'
                self.addCheckNode(
                    tv, rg1,
                    _('auto flip'),
                    self.menubar.tkopt.sound_sample_vars[key],
                    self.make_vars_command(self.menubar.mOptSoundSample, key))
                key = 'autopilotlost'
                self.addCheckNode(
                    tv, rg1,
                    _('auto pilot lost'),
                    self.menubar.tkopt.sound_sample_vars[key],
                    self.make_vars_command(self.menubar.mOptSoundSample, key))
                key = 'autopilotwon'
                self.addCheckNode(
                    tv, rg1,
                    _('auto pilot won'),
                    self.menubar.tkopt.sound_sample_vars[key],
                    self.make_vars_command(self.menubar.mOptSoundSample, key))
                key = 'deal'
                self.addCheckNode(
                    tv, rg1,
                    _('deal'),
                    self.menubar.tkopt.sound_sample_vars[key],
                    self.make_vars_command(self.menubar.mOptSoundSample, key))
                key = 'dealwaste'
                self.addCheckNode(
                    tv, rg1,
                    _('deal waste'),
                    self.menubar.tkopt.sound_sample_vars[key],
                    self.make_vars_command(self.menubar.mOptSoundSample, key))
                key = 'droppair'
                self.addCheckNode(
                    tv, rg1,
                    _('drop pair'),
                    self.menubar.tkopt.sound_sample_vars[key],
                    self.make_vars_command(self.menubar.mOptSoundSample, key))
                key = 'drop'
                self.addCheckNode(
                    tv, rg1,
                    _('drop'),
                    self.menubar.tkopt.sound_sample_vars[key],
                    self.make_vars_command(self.menubar.mOptSoundSample, key))
                key = 'flip'
                self.addCheckNode(
                    tv, rg1,
                    _('flip'),
                    self.menubar.tkopt.sound_sample_vars[key],
                    self.make_vars_command(self.menubar.mOptSoundSample, key))
                key = 'move'
                self.addCheckNode(
                    tv, rg1,
                    _('move'),
                    self.menubar.tkopt.sound_sample_vars[key],
                    self.make_vars_command(self.menubar.mOptSoundSample, key))
                key = 'nomove'
                self.addCheckNode(
                    tv, rg1,
                    _('no move'),
                    self.menubar.tkopt.sound_sample_vars[key],
                    self.make_vars_command(self.menubar.mOptSoundSample, key))
                key = 'redo'
                self.addCheckNode(
                    tv, rg1,
                    _('redo'),
                    self.menubar.tkopt.sound_sample_vars[key],
                    self.make_vars_command(self.menubar.mOptSoundSample, key))
                key = 'startdrag'
                self.addCheckNode(
                    tv, rg1,
                    _('start drag'),
                    self.menubar.tkopt.sound_sample_vars[key],
                    self.make_vars_command(self.menubar.mOptSoundSample, key))
                key = 'turnwaste'
                self.addCheckNode(
                    tv, rg1,
                    _('turn waste'),
                    self.menubar.tkopt.sound_sample_vars[key],
                    self.make_vars_command(self.menubar.mOptSoundSample, key))
                key = 'undo'
                self.addCheckNode(
                    tv, rg1,
                    _('undo'),
                    self.menubar.tkopt.sound_sample_vars[key],
                    self.make_vars_command(self.menubar.mOptSoundSample, key))
                key = 'gamefinished'
                self.addCheckNode(
                    tv, rg1,
                    _('game finished'),
                    self.menubar.tkopt.sound_sample_vars[key],
                    self.make_vars_command(self.menubar.mOptSoundSample, key))
                key = 'gamelost'
                self.addCheckNode(
                    tv, rg1,
                    _('game lost'),
                    self.menubar.tkopt.sound_sample_vars[key],
                    self.make_vars_command(self.menubar.mOptSoundSample, key))
                key = 'gameperfect'
                self.addCheckNode(
                    tv, rg1,
                    _('game perfect'),
                    self.menubar.tkopt.sound_sample_vars[key],
                    self.make_vars_command(self.menubar.mOptSoundSample, key))
                key = 'gamewon'
                self.addCheckNode(
                    tv, rg1,
                    _('game won'),
                    self.menubar.tkopt.sound_sample_vars[key],
                    self.make_vars_command(self.menubar.mOptSoundSample, key))

        # -------------------------------------------
        # Cardsets and card backside options

        rg = tv.add_node(
            LTreeNode(text=_('Cardsets')))
        if rg:
            self.menubar.tkopt.cardset.set(self.app.cardset.index)

            csm = self.app.cardset_manager
            # cnt = csm.len()
            i = 0
            while 1:
                cs = csm.get(i)
                if cs is None:
                    break
                rg1 = self.addRadioNode(tv, rg,
                                        cs.name,
                                        self.menubar.tkopt.cardset, i,
                                        self.menubar.mOptCardset)
                if rg1:
                    cbs = cs.backnames
                    self.menubar.tkopt.cardbacks[i] = IntVar()
                    self.menubar.tkopt.cardbacks[i].set(cs.backindex)

                    bcnt = len(cbs)
                    bi = 0
                    while 1:
                        if bi == bcnt:
                            break
                        cb = cbs[bi]
                        self.addRadioNode(
                            tv, rg1,
                            cb,
                            self.menubar.tkopt.cardbacks[i], bi,
                            self.make_vars_command(
                                self.menubar.mOptSetCardback, i))
                        bi += 1

                i += 1

        # -------------------------------------------
        # Table background settings

        rg = tv.add_node(
            LTreeNode(text=_('Table')))
        if rg:
            rg1 = tv.add_node(
                LTreeNode(text=_('Solid colors')), rg)
            if rg1:
                key = 'table'
                self.addRadioNode(
                    tv, rg1,
                    _('Blue'),
                    self.menubar.tkopt.color_vars[key], '#0082df',
                    self.menubar.mOptTableColor)
                self.addRadioNode(
                    tv, rg1,
                    _('Green'),
                    self.menubar.tkopt.color_vars[key], '#008200',
                    self.menubar.mOptTableColor)
                self.addRadioNode(
                    tv, rg1,
                    _('Navy'),
                    self.menubar.tkopt.color_vars[key], '#000086',
                    self.menubar.mOptTableColor)
                self.addRadioNode(
                    tv, rg1,
                    _('Olive'),
                    self.menubar.tkopt.color_vars[key], '#868200',
                    self.menubar.mOptTableColor)
                self.addRadioNode(
                    tv, rg1,
                    _('Orange'),
                    self.menubar.tkopt.color_vars[key], '#f79600',
                    self.menubar.mOptTableColor)
                self.addRadioNode(
                    tv, rg1,
                    _('Teal'),
                    self.menubar.tkopt.color_vars[key], '#008286',
                    self.menubar.mOptTableColor)

            rg1 = tv.add_node(
                LTreeNode(text=_('Tiles and Images')), rg)

            if rg1:
                tm = self.app.tabletile_manager
                # cnt = tm.len()
                i = 1
                while True:
                    ti = tm.get(i)
                    if ti is None:
                        break
                    self.addRadioNode(tv, rg1,
                                      ti.name,
                                      self.menubar.tkopt.tabletile, i,
                                      self.menubar.mOptTileSet)
                    i += 1

        # -------------------------------------------
        # Card view options

        rg = tv.add_node(
            LTreeNode(text=_('Card view')))
        if rg:
            self.addCheckNode(tv, rg,
                              _('Card shadow'),
                              self.menubar.tkopt.shadow,
                              self.menubar.mOptShadow)

            self.addCheckNode(tv, rg,
                              _('Shade legal moves'),
                              self.menubar.tkopt.shade,
                              self.menubar.mOptShade)

            self.addCheckNode(tv, rg,
                              _('Negative cards bottom'),
                              self.menubar.tkopt.negative_bottom,
                              self.menubar.mOptNegativeBottom)

            self.addCheckNode(tv, rg,
                              _('Shrink face-down cards'),
                              self.menubar.tkopt.shrink_face_down,
                              self.menubar.mOptShrinkFaceDown)

            self.addCheckNode(tv, rg,
                              _('Shade filled stacks'),
                              self.menubar.tkopt.shade_filled_stacks,
                              self.menubar.mOptShadeFilledStacks)

        # -------------------------------------------
        # Animation settins

        rg = tv.add_node(
            LTreeNode(text=_('Animations')))
        if rg:
            self.addRadioNode(tv, rg,
                              _('None'),
                              self.menubar.tkopt.animations, 0,
                              self.menubar.mOptAnimations)

            self.addRadioNode(tv, rg,
                              _('Very fast'),
                              self.menubar.tkopt.animations, 1,
                              self.menubar.mOptAnimations)

            self.addRadioNode(tv, rg,
                              _('Fast'),
                              self.menubar.tkopt.animations, 2,
                              self.menubar.mOptAnimations)

            self.addRadioNode(tv, rg,
                              _('Medium'),
                              self.menubar.tkopt.animations, 3,
                              self.menubar.mOptAnimations)

            self.addRadioNode(tv, rg,
                              _('Slow'),
                              self.menubar.tkopt.animations, 4,
                              self.menubar.mOptAnimations)

            self.addRadioNode(tv, rg,
                              _('Very slow'),
                              self.menubar.tkopt.animations, 5,
                              self.menubar.mOptAnimations)

            # submenu.add_separator()

            self.addCheckNode(tv, rg,
                              _('Redeal animation'),
                              self.menubar.tkopt.redeal_animation,
                              self.menubar.mRedealAnimation)

            self.addCheckNode(tv, rg,
                              _('Winning animation'),
                              self.menubar.tkopt.win_animation,
                              self.menubar.mWinAnimation)

        # -------------------------------------------
        # Touch mode settings

        rg = tv.add_node(
            LTreeNode(text=_('Touch mode')))
        if rg:
            self.addRadioNode(tv, rg,
                              _('Drag-and-Drop'),
                              self.menubar.tkopt.mouse_type, 'drag-n-drop',
                              self.menubar.mOptMouseType)

            self.addRadioNode(tv, rg,
                              _('Point-and-Click'),
                              self.menubar.tkopt.mouse_type, 'point-n-click',
                              self.menubar.mOptMouseType)

            # sinnlos mit touch-device:
            # self.addRadioNode(tv, rg,
            #   'Sticky mouse',
            #   self.menubar.tkopt.mouse_type, u'sticky-mouse',
            #   self.menubar.mOptMouseType)

            # submenu.add_separator()

            # sinnlos mit touch-device:
            # self.addCheckNode(tv, rg,
            #   'Use mouse for undo/redo',
            #   self.menubar.tkopt.mouse_undo,
            #   self.menubar.mOptMouseUndo)

        # submenu.add_separator()

        # -------------------------------------------
        # TBD ?

        '''
        menu.add_command(label=n_("&Fonts..."), command=self.mOptFonts)
        menu.add_command(label=n_("&Colors..."), command=self.mOptColors)
        menu.add_command(label=n_("Time&outs..."), command=self.mOptTimeouts)
        menu.add_separator()
        '''

        # -------------------------------------------
        # Toolbar options

        rg = tv.add_node(
            LTreeNode(text=_('Toolbar')))
        if rg:
            self.addRadioNode(tv, rg,
                              _('Hide'),
                              self.menubar.tkopt.toolbar, 0,
                              self.menubar.mOptToolbar)

            # not supported: Top, Bottom
            # self.addRadioNode(tv, rg,
            #   'Top',
            #   self.menubar.tkopt.toolbar, 1,
            #   self.menubar.mOptToolbar)
            # self.addRadioNode(tv, rg,
            #   'Bottom',
            #   self.menubar.tkopt.toolbar, 2,
            #   self.menubar.mOptToolbar)

            self.addRadioNode(tv, rg,
                              _('Left'),
                              self.menubar.tkopt.toolbar, 3,
                              self.menubar.mOptToolbar)
            self.addRadioNode(tv, rg,
                              _('Right'),
                              self.menubar.tkopt.toolbar, 4,
                              self.menubar.mOptToolbar)

        # -------------------------------------------
        # Statusbar - not implemented

        '''
        submenu = MfxMenu(menu, label=n_("Stat&usbar"))
        submenu.add_checkbutton(
             label=n_("Show &statusbar"),
             variable=self.tkopt.statusbar,
             command=self.mOptStatusbar)
        submenu.add_checkbutton(
            label=n_("Show &number of cards"),
            variable=self.tkopt.num_cards,
            command=self.mOptNumCards)
        submenu.add_checkbutton(
            label=n_("Show &help bar"),
            variable=self.tkopt.helpbar,
            command=self.mOptHelpbar)
        '''

        # -------------------------------------------
        # general options

        # self.addCheckNode(tv, None,
        #   'Save games geometry',
        #   self.menubar.tkopt.save_games_geometry,
        #   self.menubar.mOptSaveGamesGeometry)

        # self.addCheckNode(tv, None,
        #   'Demo logo',
        #   self.menubar.tkopt.demo_logo,
        #   self.menubar.mOptDemoLogo)

        self.addCheckNode(tv, None,
                          _('Startup splash screen'),
                          self.menubar.tkopt.splashscreen,
                          self.menubar.mOptSplashscreen)

        self.addCheckNode(tv, None,
                          _('Winning splash'),
                          self.menubar.tkopt.display_win_message,
                          self.menubar.mWinDialog)


# ************************************************************************


class HelpMenuDialog(LMenuDialog):
    def __init__(self, menubar, parent, title, app, **kw):
        kw['size_hint'] = (0.3, 1)
        kw['persist'] = True
        super(HelpMenuDialog, self).__init__(menubar, parent, title, app, **kw)

    def make_help_command(self, command):
        def help_command():
            command()
            self.closeWindow(0)
        return help_command

    def buildTree(self, tv, node):
        tv.add_node(
            LTreeNode(
                text=_('Contents'),
                command=self.make_help_command(self.menubar.mHelp)))
        tv.add_node(
            LTreeNode(
                text=_('How to play'),
                command=self.make_help_command(self.menubar.mHelpHowToPlay)))
        tv.add_node(
            LTreeNode(
                text=_('Rules for this game'),
                command=self.make_help_command(self.menubar.mHelpRules)))
        tv.add_node(
            LTreeNode(
                text=_('License terms'),
                command=self.make_help_command(self.menubar.mHelpLicense)))
        tv.add_node(
            LTreeNode(
                text=_('About %s...') % TITLE,
                command=self.make_help_command(self.menubar.mHelpAbout)))

        # tv.add_node(LTreeNode(
        #   text='AboutKivy ...',
        #   command=self.makeHtmlCommand(self.menubar, "kivy.html")))

    def makeHtmlCommand(self, bar, htmlfile):
        def htmlCommand():
            bar.mHelpHtml(htmlfile)

        return htmlCommand


# ************************************************************************
# *
# ************************************************************************


class EmulTkMenu(object):

    def __init__(self, master, **kw):

        self.name = kw["name"]
        self.n = 0
        self._w = None
        if (self.name):
            if master._w == '.':
                self._w = '.' + self.name
            else:
                self._w = master._w + '.' + self.name
        else:
            self.name = "<>"

    def labeltoname(self, label):
        name = re.sub(r"[^0-9a-zA-Z]", "", label).lower()
        label = _(label)
        underline = label.find('&')
        if underline >= 0:
            label = label.replace('&', '')
        return name, label, underline

    def add_cascade(self, cnf={}, **kw):
        self.add('cascade', cnf or kw)
        pass

    def add(self, itemType, cnf={}):
        label = cnf.get("label")
        if label:
            name = cnf.get('name')
            if name:
                name, label, underline = self.labeltoname(label)
                cnf["underline"] = cnf.get("underline", underline)
                cnf["label"] = label
                if name and self.addPath:
                    path = str(self._w) + "." + name
                    self.addPath(path, self, self.n, cnf.get("menu"))

    def cget(self, key):
        return key

# ************************************************************************


class MfxMenubar(EmulTkMenu):
    addPath = None

    def __init__(self, master, **kw):
        super(MfxMenubar, self).__init__(master, **kw)
        topmenu = self.name == 'menubar'

        self.menu = LMenu(not topmenu, text=self.name)
        if topmenu:
            master.setMenu(self.menu)

# ************************************************************************
# * - create menubar
# * - update menubar
# * - menu actions
# ************************************************************************


class PysolMenubarTk:
    def __init__(self, app, top, progress=None):
        self._createTkOpt()
        self._setOptions()
        # init columnbreak
#        self.__cb_max = int(self.top.winfo_screenheight()/23)
        self.__cb_max = 8
#         sh = self.top.winfo_screenheight()
#         self.__cb_max = 22
#         if sh >= 600: self.__cb_max = 27
#         if sh >= 768: self.__cb_max = 32
#         if sh >= 1024: self.__cb_max = 40
        self.progress = progress
        # create menus
        self.__menubar = None
        self.__menupath = {}
        self.__keybindings = {}
        self._createMenubar()
        self.top = top

        if self.progress:
            self.progress.update(step=1)

        # set the menubar
        # self.updateBackgroundImagesMenu()
        # self.top.config(menu=self.__menubar)

    def _createTkOpt(self):
        # structure to convert menu-options to Toolkit variables
        self.tkopt = Struct(
            gameid=IntVar(),
            gameid_popular=IntVar(),
            comment=BooleanVar(),
            autofaceup=BooleanVar(),
            autodrop=BooleanVar(),
            autodeal=BooleanVar(),
            quickplay=BooleanVar(),
            undo=BooleanVar(),
            bookmarks=BooleanVar(),
            hint=BooleanVar(),
            shuffle=BooleanVar(),
            highlight_piles=BooleanVar(),
            highlight_cards=BooleanVar(),
            highlight_samerank=BooleanVar(),
            highlight_not_matching=BooleanVar(),
            mahjongg_show_removed=BooleanVar(),
            shisen_show_hint=BooleanVar(),
            sound=BooleanVar(),
            sound_sample_volume=IntVar(),
            sound_music_volume=IntVar(),
            cardback=IntVar(),
            tabletile=IntVar(),
            animations=IntVar(),
            redeal_animation=BooleanVar(),
            win_animation=BooleanVar(),
            shadow=BooleanVar(),
            shade=BooleanVar(),
            shade_filled_stacks=BooleanVar(),
            shrink_face_down=BooleanVar(),
            toolbar=IntVar(),
            toolbar_style=StringVar(),
            toolbar_relief=StringVar(),
            toolbar_compound=StringVar(),
            toolbar_size=IntVar(),
            statusbar=BooleanVar(),
            num_cards=BooleanVar(),
            helpbar=BooleanVar(),
            save_games_geometry=BooleanVar(),
            splashscreen=BooleanVar(),
            demo_logo=BooleanVar(),
            mouse_type=StringVar(),
            mouse_undo=BooleanVar(),
            negative_bottom=BooleanVar(),
            display_win_message=BooleanVar(),
            pause=BooleanVar(),
            cardset=IntVar(),
            cardbacks={},
            toolbar_vars={},
            sound_sample_vars={},
            color_vars={},
            language=StringVar(),
        )
        for w in TOOLBAR_BUTTONS:
            self.tkopt.toolbar_vars[w] = BooleanVar()
        for k in self.app.opt.sound_samples:
            self.tkopt.sound_sample_vars[k] = BooleanVar()
        for k in self.app.opt.colors:
            self.tkopt.color_vars[k] = StringVar()

    def _setOptions(self):
        tkopt, opt = self.tkopt, self.app.opt
        # set state of the menu items
        tkopt.autofaceup.set(opt.autofaceup)
        tkopt.autodrop.set(opt.autodrop)
        tkopt.autodeal.set(opt.autodeal)
        tkopt.quickplay.set(opt.quickplay)
        tkopt.undo.set(opt.undo)
        tkopt.hint.set(opt.hint)
        tkopt.shuffle.set(opt.shuffle)
        tkopt.bookmarks.set(opt.bookmarks)
        tkopt.highlight_piles.set(opt.highlight_piles)
        tkopt.highlight_cards.set(opt.highlight_cards)
        tkopt.highlight_samerank.set(opt.highlight_samerank)
        tkopt.highlight_not_matching.set(opt.highlight_not_matching)
        tkopt.shrink_face_down.set(opt.shrink_face_down)
        tkopt.shade_filled_stacks.set(opt.shade_filled_stacks)
        tkopt.mahjongg_show_removed.set(opt.mahjongg_show_removed)
        tkopt.shisen_show_hint.set(opt.shisen_show_hint)
        tkopt.sound.set(opt.sound)
        tkopt.sound_sample_volume.set(opt.sound_sample_volume)
        tkopt.sound_music_volume.set(opt.sound_music_volume)
        tkopt.cardback.set(self.app.cardset.backindex)
        tkopt.tabletile.set(self.app.tabletile_index)
        tkopt.animations.set(opt.animations)
        tkopt.redeal_animation.set(opt.redeal_animation)
        tkopt.win_animation.set(opt.win_animation)
        tkopt.shadow.set(opt.shadow)
        tkopt.shade.set(opt.shade)
        tkopt.toolbar.set(opt.toolbar)
        tkopt.toolbar_style.set(opt.toolbar_style)
        tkopt.toolbar_relief.set(opt.toolbar_relief)
        tkopt.toolbar_compound.set(opt.toolbar_compound)
        tkopt.toolbar_size.set(opt.toolbar_size)
        tkopt.toolbar_relief.set(opt.toolbar_relief)
        tkopt.statusbar.set(opt.statusbar)
        tkopt.num_cards.set(opt.num_cards)
        tkopt.helpbar.set(opt.helpbar)
        tkopt.save_games_geometry.set(opt.save_games_geometry)
        tkopt.demo_logo.set(opt.demo_logo)
        tkopt.splashscreen.set(opt.splashscreen)
        tkopt.mouse_type.set(opt.mouse_type)
        tkopt.mouse_undo.set(opt.mouse_undo)
        tkopt.negative_bottom.set(opt.negative_bottom)
        tkopt.display_win_message.set(opt.display_win_message)
        tkopt.cardset.set(self.app.cardset_manager.getSelected())
        tkopt.language.set(opt.language)

        for w in TOOLBAR_BUTTONS:
            tkopt.toolbar_vars[w].set(opt.toolbar_vars.get(w, False))
        for k in self.app.opt.sound_samples:
            self.tkopt.sound_sample_vars[k].set(
                opt.sound_samples.get(k, False))
        for k in self.app.opt.colors:
            self.tkopt.color_vars[k].set(opt.colors.get(k, '#000000'))

    def connectGame(self, game):
        self.game = game
        if game is None:
            return
        assert self.app is game.app
        tkopt = self.tkopt
        # opt = self.app.opt
        tkopt.gameid.set(game.id)
        tkopt.gameid_popular.set(game.id)
        tkopt.comment.set(bool(game.gsaveinfo.comment))
        tkopt.pause.set(self.game.pause)
        if game.canFindCard():
            connect_game_find_card_dialog(game)
        else:
            destroy_find_card_dialog()
        connect_game_solver_dialog(game)

    # create a GTK-like path
    def _addPath(self, path, menu, index, submenu):
        # print ('MfxMenubar: _addPath %s, %s' % (path, menu))
        # y = self.yy
        if path not in self.__menupath:
            # print path, menu, index, submenu
            self.__menupath[path] = (menu, index, submenu)

    def _getEnabledState(self, enabled):
        print('_getEnabledState: %s' % enabled)
        if enabled:
            return "normal"
        return "disabled"

    def updateProgress(self):
        if self.progress:
            self.progress.update(step=1)

    #
    # create the menubar
    #

    def _createMenubar(self):
        MfxMenubar.addPath = self._addPath
        kw = {"name": "menubar"}
        self.__menubar = MfxMenubar(self.top, **kw)

        # init keybindings
        bind(self.top, "<KeyPress>", self._keyPressHandler)

        # LMainMenuDialog()
        LMenuItem(self.__menubar.menu,
                  text=_("Menu"), command=self.mMainMenuDialog)

        MfxMenubar.addPath = None

    #
    # key binding utility
    #

    def _bindKey(self, modifier, key, func):
        #         if 0 and not modifier and len(key) == 1:
        #             self.__keybindings[key.lower()] = func
        #             self.__keybindings[key.upper()] = func
        #             return
        if not modifier and len(key) == 1:
            # ignore Ctrl/Shift/Alt
            # but don't ignore NumLock (state == 16)
            def lfunc(e, func=func):
                return e.state in (0, 16) and func(e)
            func = lfunc
            # func = lambda e, func=func: e.state in (0, 16) and func(e)
        sequence = "<" + modifier + "KeyPress-" + key + ">"
        bind(self.top, sequence, func)
        if len(key) == 1 and key != key.upper():
            key = key.upper()
            sequence = "<" + modifier + "KeyPress-" + key + ">"
            bind(self.top, sequence, func)

    def _keyPressHandler(self, event):
        r = EVENT_PROPAGATE
        if event and self.game:
            # print event.__dict__
            if self.game.demo:
                # stop the demo by setting self.game.demo.keypress
                if event.char:    # ignore Ctrl/Shift/etc.
                    self.game.demo.keypress = event.char
                    r = EVENT_HANDLED
#             func = self.__keybindings.get(event.char)
#             if func and (event.state & ~2) == 0:
#                 func(event)
#                 r = EVENT_HANDLED
        return r

    #
    # Select Game menu creation
    #
    '''
    def _addSelectGameMenu(self, menu):
        games = map(self.app.gdb.get, self.app.gdb.getGamesIdSortedByName())
        m = "Ctrl-"
        if sys.platform == "darwin":
            m = "Cmd-"
        menu.add_command(label=n_("All &games..."), accelerator=m + "W",
                         command=self.mSelectGameDialog)

    def _addSelectGameSubMenu(self, games, menu, select_data,
                              command, variable):
        # print select_data
        need_sep = 0
        for label, select_func in select_data:
            if label is None:
                need_sep = 1
                continue
            g = filter(select_func, games)
            if not g:
                continue
            if need_sep:
                menu.add_separator()
                need_sep = 0
            submenu = MfxMenu(menu, label=label)
            self._addSelectGameSubSubMenu(g, submenu, command, variable)

    def _getNumGames(self, games, select_data):
        ngames = 0
        for label, select_func in select_data:
            ngames += len(filter(select_func, games))
        return ngames

    def _addSelectMahjonggGameSubMenu(self, games, menu, command, variable):
        def select_func(gi): return gi.si.game_type == GI.GT_MAHJONGG
        mahjongg_games = filter(select_func, games)
        if len(mahjongg_games) == 0:
            return
        #
        menu = MfxMenu(menu, label=n_("&Mahjongg games"))

        def add_menu(games, c0, c1, menu=menu,
                     variable=variable, command=command):
            if not games:
                return
            label = c0 + ' - ' + c1
            if c0 == c1:
                label = c0
            submenu = MfxMenu(menu, label=label, name=None)
            self._addSelectGameSubSubMenu(games, submenu, command,
                                          variable, short_name=True)

        games = {}
        for gi in mahjongg_games:
            c = gi.short_name.strip()[0]
            if c in games:
                games[c].append(gi)
            else:
                games[c] = [gi]
        games = games.items()
        games.sort()
        g0 = []
        c0 = c1 = games[0][0]
        for c, g1 in games:
            if len(g0) + len(g1) >= self.__cb_max:
                add_menu(g0, c0, c1)
                g0 = g1
                c0 = c1 = c
            else:
                g0 += g1
                c1 = c
        add_menu(g0, c0, c1)

    def _addSelectPopularGameSubMenu(self, games, menu, command, variable):
        def select_func(gi): return gi.si.game_flags & GI.GT_POPULAR
        if len(filter(select_func, games)) == 0:
            return
        data = (n_("&Popular games"), select_func)
        self._addSelectGameSubMenu(games, menu, (data, ),
                                   self.mSelectGamePopular,
                                   self.tkopt.gameid_popular)

    def _addSelectFrenchGameSubMenu(self, games, menu, command, variable):
        if self._getNumGames(games, GI.SELECT_GAME_BY_TYPE) == 0:
            return
        submenu = MfxMenu(menu, label=n_("&French games"))
        self._addSelectGameSubMenu(games, submenu, GI.SELECT_GAME_BY_TYPE,
                                   self.mSelectGame, self.tkopt.gameid)

    def _addSelectOrientalGameSubMenu(self, games, menu, command, variable):
        if self._getNumGames(games, GI.SELECT_ORIENTAL_GAME_BY_TYPE) == 0:
            return
        submenu = MfxMenu(menu, label=n_("&Oriental games"))
        self._addSelectGameSubMenu(games, submenu,
                                   GI.SELECT_ORIENTAL_GAME_BY_TYPE,
                                   self.mSelectGame, self.tkopt.gameid)

    def _addSelectSpecialGameSubMenu(self, games, menu, command, variable):
        if self._getNumGames(games, GI.SELECT_ORIENTAL_GAME_BY_TYPE) == 0:
            return
        submenu = MfxMenu(menu, label=n_("&Special games"))
        self._addSelectGameSubMenu(games, submenu,
                                   GI.SELECT_SPECIAL_GAME_BY_TYPE,
                                   self.mSelectGame, self.tkopt.gameid)

    def _addSelectCustomGameSubMenu(self, games, menu, command, variable):
        submenu = MfxMenu(menu, label=n_("&Custom games"))

        def select_func(gi): return gi.si.game_type == GI.GT_CUSTOM
        games = filter(select_func, games)
        self.updateGamesMenu(submenu, games)
    '''

    def _addSelectAllGameSubMenu(self, games, menu, command, variable):
        # LB
        # herausgenommen: zu aufwendig !
        return
        '''
        menu = MfxMenu(menu, label=n_("&All games by name"))
        n, d = 0, self.__cb_max
        i = 0
        while True:
            if self.progress:
                self.progress.update(step=1)
            columnbreak = i > 0 and (i % d) == 0
            i += 1
            if not games[n:n + d]:
                break
            m = min(n + d - 1, len(games) - 1)
            label = games[n].name[:3] + ' - ' + games[m].name[:3]

            submenu = MfxMenu(menu, label=label, name=None)
            self._addSelectGameSubSubMenu(games[n:n + d], submenu,
                                          command, variable)
            n += d
            # if columnbreak:
            #    menu.entryconfigure(i, columnbreak=columnbreak)
        '''

    # Eine 'closure' in Python? - voila!
    def make_gamesetter(self, n, variable, command):
        def gamesetter(x):
            variable.set(n)
            command()
        return gamesetter

    def _addSelectGameSubSubMenu(self, games, menu, command, variable,
                                 short_name=False):

        # cb = self.__cb_max
        for i in range(len(games)):
            gi = games[i]
            # columnbreak = i > 0 and (i % cb) == 0
            if short_name:
                label = gi.short_name
            else:
                label = gi.name

            # optimized by inlining

            # geht nicht mehr 'optimiert' mit kivy
            # die Funktionalität des tk.calls kann mit hilfe
            # einer 'closure' rekonstruiert werden (s.o).
            # LB

            gsetter = self.make_gamesetter(gi.id, variable, command)
            menu.add_command(label=label, command=gsetter)

            # menu.tk.call((menu._w, 'add', 'radiobutton') +
            #             menu._options({'command': command,
            #                            'variable': variable,
            #                            'columnbreak': columnbreak,
            #                            'value': gi.id,
            #                            'label': label}))

    def updateGamesMenu(self, menu, games):

        def cmp2(a, b):
            """python 3 replacement for python 2 cmp function"""
            return (a > b) - (a < b)

        menu.delete(0, 'last')

        if len(games) == 0:
            menu.add_radiobutton(label=_('<none>'), name=None,
                                 state='disabled')
        elif len(games) > self.__cb_max * 4:
            games.sort(lambda a, b: cmp2(a.name, b.name))
            self._addSelectAllGameSubMenu(games, menu,
                                          command=self.mSelectGame,
                                          variable=self.tkopt.gameid)
        else:
            self._addSelectGameSubSubMenu(games, menu,
                                          command=self.mSelectGame,
                                          variable=self.tkopt.gameid)

    def mMainMenuDialog(self, *event):
        MainMenuDialog(self, self.top, title=_("Main Menu"), app=self.app)
        return EVENT_HANDLED

    def mFileMenuDialog(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.game.setCursor(cursor=CURSOR_WATCH)
        after_idle(self.top, self.__restoreCursor)
        FileMenuDialog(self, self.top, title=_("File Menu"), app=self.app)
        return EVENT_HANDLED

    def mEditMenuDialog(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.game.setCursor(cursor=CURSOR_WATCH)
        after_idle(self.top, self.__restoreCursor)
        EditMenuDialog(self, self.top, title=_("Tools"), app=self.app)
        return EVENT_HANDLED

    def mGameMenuDialog(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.game.setCursor(cursor=CURSOR_WATCH)
        after_idle(self.top, self.__restoreCursor)
        GameMenuDialog(self, self.top, title=_("Statistics"), app=self.app)
        return EVENT_HANDLED

    def mAssistMenuDialog(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.game.setCursor(cursor=CURSOR_WATCH)
        after_idle(self.top, self.__restoreCursor)
        AssistMenuDialog(self, self.top, title=_("Assists"), app=self.app)
        return EVENT_HANDLED

    def mOptionsMenuDialog(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.game.setCursor(cursor=CURSOR_WATCH)
        after_idle(self.top, self.__restoreCursor)
        OptionsMenuDialog(self, self.top, title=_("Options"), app=self.app)
        return EVENT_HANDLED

    def mHelpMenuDialog(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.game.setCursor(cursor=CURSOR_WATCH)
        after_idle(self.top, self.__restoreCursor)
        HelpMenuDialog(self, self.top, title=_("Help"), app=self.app)
        return EVENT_HANDLED
    #
    # Select Game menu actions
    #

    def mSelectGame(self, *args):
        print('mSelectGame %s' % self)
        self._mSelectGame(self.tkopt.gameid.get())

    def mSelectGamePopular(self, *args):
        self._mSelectGame(self.tkopt.gameid_popular.get())

    def _mSelectGameDialog(self, d):
        if d.gameid != self.game.id:
            self.tkopt.gameid.set(d.gameid)
            self.tkopt.gameid_popular.set(d.gameid)
            self._cancelDrag()
            self.game.endGame()
            self.game.quitGame(d.gameid, random=d.random)
        return EVENT_HANDLED

    def __restoreCursor(self, *event):
        self.game.setCursor(cursor=self.app.top_cursor)

    def mSelectGameDialog(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.game.setCursor(cursor=CURSOR_WATCH)
        after_idle(self.top, self.__restoreCursor)
        d = SelectGameDialog(self.top, title=_("Select game"),
                             app=self.app, gameid=self.game.id)
        return self._mSelectGameDialog(d)

    #
    # menubar overrides
    #

    def updateFavoriteGamesMenu(self):
        return

        # TBD ?
        '''
        gameids = self.app.opt.favorite_gameid

        print('favorite_gameids = %s' % gameids)

        submenu = self.__menupath[".menubar.file.favoritegames"][2]
        games = []
        for id in gameids:
            gi = self.app.getGameInfo(id)
            if gi:
                games.append(gi)
        self.updateGamesMenu(submenu, games)

        # das folgende ist nur das enable/disable des add/remove buttons.
        # geht mit kivy nicht so.

#        state = self._getEnabledState
#        in_favor = self.app.game.id in gameids

# menu, index, submenu = self.__menupath[".menubar.file.addtofavorites"]
# menu.entryconfig(index, state=state(not in_favor))

# menu, index, submenu = self.__menupath[".menubar.file.removefromfavorites"]
# menu.entryconfig(index, state=state(in_favor))
        '''

    def updateRecentGamesMenu(self, gameids):
        return

        # TBD ?
        '''
        submenu = self.__menupath[".menubar.file.recentgames"][2]
        games = []
        for id in gameids:
            gi = self.app.getGameInfo(id)
            if gi:
                games.append(gi)
        self.updateGamesMenu(submenu, games)
        '''

    def updateBookmarkMenuState(self):
        # LB:
        print('updateBookmarkMenuState - fake')
        return

        state = self._getEnabledState
        mp1 = self.__menupath.get(".menubar.edit.setbookmark")
        mp2 = self.__menupath.get(".menubar.edit.gotobookmark")
        mp3 = self.__menupath.get(".menubar.edit.clearbookmarks")
        if mp1 is None or mp2 is None or mp3 is None:
            return
        x = self.app.opt.bookmarks and self.game.canSetBookmark()
        #
        menu, index, submenu = mp1
        for i in range(9):
            submenu.entryconfig(i, state=state(x))
        menu.entryconfig(index, state=state(x))
        #
        menu, index, submenu = mp2
        ms = 0
        for i in range(9):
            s = self.game.gsaveinfo.bookmarks.get(i) is not None
            submenu.entryconfig(i, state=state(s and x))
            ms = ms or s
        menu.entryconfig(index, state=state(ms and x))
        #
        menu, index, submenu = mp3
        menu.entryconfig(index, state=state(ms and x))

    def updateBackgroundImagesMenu(self):
        # LB:
        print('updateBackgroundImagesMenu - fake')
        return

        mp = self.__menupath.get(".menubar.options.cardbackground")
        # delete all entries
        submenu = mp[2]
        submenu.delete(0, "last")
        # insert new cardbacks
        mbacks = self.app.images.getCardbacks()
        cb = int(math.ceil(math.sqrt(len(mbacks))))
        for i in range(len(mbacks)):
            columnbreak = i > 0 and (i % cb) == 0
            submenu.add_radiobutton(
                    label=mbacks[i].name,
                    image=mbacks[i].menu_image,
                    variable=self.tkopt.cardback,
                    value=i,
                    command=self.mOptCardback,
                    columnbreak=columnbreak,
                    indicatoron=0,
                    hidemargin=0)
    #
    # menu updates
    #

    def setMenuState(self, state, path):
        # LB: not used
        return

    def setToolbarState(self, state, path):
        # LB: not used
        return

    def _setCommentMenu(self, v):
        self.tkopt.comment.set(v)

    def _setPauseMenu(self, v):
        self.tkopt.pause.set(v)

    #
    # menu actions
    #

    DEFAULTEXTENSION = ".pso"
    # TRANSLATORS: Usually, 'PySol files'
    FILETYPES = ((_("%s files") % TITLE, "*" + DEFAULTEXTENSION),
                 (_("All files"), "*"))

    def mAddFavor(self, *event):
        gameid = self.app.game.id
        if gameid not in self.app.opt.favorite_gameid:
            self.app.opt.favorite_gameid.append(gameid)
            self.updateFavoriteGamesMenu()

    def mDelFavor(self, *event):
        gameid = self.app.game.id
        if gameid in self.app.opt.favorite_gameid:
            self.app.opt.favorite_gameid.remove(gameid)
            self.updateFavoriteGamesMenu()

    def mOpen(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        # filename = self.game.filename
        filename = "lastgame.pso"
        if filename:
            idir, ifile = os.path.split(os.path.normpath(filename))
        else:
            idir, ifile = "", ""
        if not idir:
            idir = self.app.dn.savegames
#        d = tkFileDialog.Open()
#        filename = d.show(filetypes=self.FILETYPES,
#                          defaultextension=self.DEFAULTEXTENSION,
#                          initialdir=idir, initialfile=ifile)
        filename = idir + "/" + ifile

        print('filename = %s' % filename)
        if filename:
            filename = os.path.normpath(filename)
            # filename = os.path.normcase(filename)
            if os.path.isfile(filename):
                self.game.loadGame(filename)

    def mSaveAs(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        if not self.menustate.save_as:
            return
        # filename = self.game.filename
        filename = "lastgame.pso"
        if not filename:
            filename = self.app.getGameSaveName(self.game.id)
            if os.name == "posix":
                filename = filename + "-" + self.game.getGameNumber(format=0)
            elif os.path.supports_unicode_filenames:  # new in python 2.3
                filename = filename + "-" + self.game.getGameNumber(format=0)
            else:
                filename = filename + "-01"
            filename = filename + self.DEFAULTEXTENSION
        idir, ifile = os.path.split(os.path.normpath(filename))
        if not idir:
            idir = self.app.dn.savegames
        # print self.game.filename, ifile
        # d = tkFileDialog.SaveAs()
        # filename = d.show(filetypes=self.FILETYPES,
        #                  defaultextension=self.DEFAULTEXTENSION,
        #                  initialdir=idir, initialfile=ifile)
        filename = idir + "/" + ifile
        if filename:
            filename = os.path.normpath(filename)
            # filename = os.path.normcase(filename)
            self.game.saveGame(filename)
            self.updateMenus()

    def mPause(self, *args):
        if not self.game:
            return
        if not self.game.pause:
            if self._cancelDrag():
                return
        self.game.doPause()
        self.tkopt.pause.set(self.game.pause)

    def mOptLanguage(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.language = self.tkopt.language.get()
        MfxMessageDialog(
           self.app.top, title=_("Note"),
           text=_("""\
These settings will take effect
the next time you restart the %(app)s""") % {'app': TITLE})

    def mOptSoundDialog(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.sound = self.tkopt.sound.get()

    def mOptSoundSampleVol(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.sound_sample_volume = self.tkopt.sound_sample_volume.get()

    def mOptSoundMusicVol(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.sound_music_volume = self.tkopt.sound_music_volume.get()

    def mOptSoundSample(self, key, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.sound_samples[key] = \
            self.tkopt.sound_sample_vars[key].get()

    def mOptTableColor(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        nv = self.tkopt.color_vars['table'].get()
        ov = self.app.opt.colors['table']
        self.app.opt.colors['table'] = nv
        if ov != nv:
            self.app.top_bg = nv
            self.app.tabletile_index = 0
            self.app.setTile(0, force=True)
            self.tkopt.tabletile.set(0)

    def mOptTileSet(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        idx = self.tkopt.tabletile.get()
        if idx > 0 and idx != self.app.tabletile_index:
            self.app.setTile(idx)
            self.tkopt.color_vars['table'].set('#008285')

    def mOptAutoFaceUp(self, *args):
        if self._cancelDrag():
            return
        self.app.opt.autofaceup = self.tkopt.autofaceup.get()
        if self.app.opt.autofaceup:
            self.game.autoPlay()

    def mOptAutoDrop(self, *args):
        if self._cancelDrag():
            return
        self.app.opt.autodrop = self.tkopt.autodrop.get()
        if self.app.opt.autodrop:
            self.game.autoPlay()

    def mOptAutoDeal(self, *args):
        if self._cancelDrag():
            return
        self.app.opt.autodeal = self.tkopt.autodeal.get()
        if self.app.opt.autodeal:
            self.game.autoPlay()

    def mOptQuickPlay(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.quickplay = self.tkopt.quickplay.get()

    def mOptEnableUndo(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.undo = self.tkopt.undo.get()
        self.game.updateMenus()

    def mOptEnableBookmarks(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.bookmarks = self.tkopt.bookmarks.get()
        self.game.updateMenus()

    def mOptEnableHint(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.hint = self.tkopt.hint.get()
        self.game.updateMenus()

    def mOptEnableShuffle(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.shuffle = self.tkopt.shuffle.get()
        self.game.updateMenus()

    def mOptEnableHighlightPiles(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.highlight_piles = self.tkopt.highlight_piles.get()
        self.game.updateMenus()

    def mOptEnableHighlightCards(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.highlight_cards = self.tkopt.highlight_cards.get()
        self.game.updateMenus()

    def mOptEnableHighlightSameRank(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.highlight_samerank = self.tkopt.highlight_samerank.get()
        # self.game.updateMenus()

    def mOptEnableHighlightNotMatching(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.highlight_not_matching = \
            self.tkopt.highlight_not_matching.get()
        # self.game.updateMenus()

    def mOptAnimations(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.animations = self.tkopt.animations.get()

    def mRedealAnimation(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.redeal_animation = self.tkopt.redeal_animation.get()

    def mWinAnimation(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.win_animation = self.tkopt.win_animation.get()

    def mWinDialog(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.display_win_message = self.tkopt.display_win_message.get()

    def mOptShadow(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.shadow = self.tkopt.shadow.get()

    def mOptShade(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.shade = self.tkopt.shade.get()

    def mOptShrinkFaceDown(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.shrink_face_down = self.tkopt.shrink_face_down.get()
        self.game.endGame(bookmark=1)
        self.game.quitGame(bookmark=1)

    def mOptShadeFilledStacks(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.shade_filled_stacks = self.tkopt.shade_filled_stacks.get()
        self.game.endGame(bookmark=1)
        self.game.quitGame(bookmark=1)

    def mOptMahjonggShowRemoved(self, *args):
        if self._cancelDrag():
            return
        self.app.opt.mahjongg_show_removed = \
            self.tkopt.mahjongg_show_removed.get()
        # self.game.updateMenus()
        self.game.endGame(bookmark=1)
        self.game.quitGame(bookmark=1)

    def mOptShisenShowHint(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.shisen_show_hint = self.tkopt.shisen_show_hint.get()
        # self.game.updateMenus()

    def mOptCardset(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        idx = self.tkopt.cardset.get()
        cs = self.app.cardset_manager.get(idx)
        if cs is None or idx == self.app.cardset.index:
            return
        if idx >= 0:
            self.app.nextgame.cardset = cs
            self._cancelDrag()
            self.game.endGame(bookmark=1)
            self.game.quitGame(bookmark=1)

    def mSelectCardsetDialog(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        # strings, default = ("&OK", "&Load", "&Cancel"), 0
        strings, default = (None, _("&Load"), _("&Cancel"), ), 1
        # if os.name == "posix":
        strings, default = (None, _("&Load"), _(
            "&Cancel"), _("&Info..."), ), 1
        key = self.app.nextgame.cardset.index
        d = SelectCardsetDialogWithPreview(
                self.top, title=_("Select cardset"),
                app=self.app, manager=self.app.cardset_manager, key=key,
                strings=strings, default=default)

        cs = self.app.cardset_manager.get(d.key)
        if cs is None or d.key == self.app.cardset.index:
            return
        if d.status == 0 and d.button in (0, 1) and d.key >= 0:
            self.app.nextgame.cardset = cs
            if d.button == 1:
                self._cancelDrag()
                self.game.endGame(bookmark=1)
                self.game.quitGame(bookmark=1)

    def mOptSetCardback(self, key, *event):
        val = self.tkopt.cardbacks[key].get()
        cs = self.app.cardset_manager.get(key)
        cs.updateCardback(backindex=val)
        # ANM: wir können den Background nur für das aktuell
        # selektierte Cardset wirklich ändern. Nur dieses wird
        # wird in den Optionen gespeichert.
        if (cs == self.app.cardset):
            self.app.updateCardset(self.game.id)
            self.app.cardset.backindex = val
            image = self.app.images.getBack(update=True)
            for card in self.game.cards:
                card.updateCardBackground(image=image)
            self.app.canvas.update_idletasks()

    def _mOptCardback(self, index):
        if self._cancelDrag(break_pause=False):
            return
        cs = self.app.cardset
        old_index = cs.backindex
        cs.updateCardback(backindex=index)
        if cs.backindex == old_index:
            return
        self.app.updateCardset(self.game.id)
        image = self.app.images.getBack(update=True)
        for card in self.game.cards:
            card.updateCardBackground(image=image)
        self.app.canvas.update_idletasks()
        self.tkopt.cardback.set(cs.backindex)

    def mOptCardback(self, *event):
        self._mOptCardback(self.tkopt.cardback.get())

    def mOptChangeCardback(self, *event):
        self._mOptCardback(self.app.cardset.backindex + 1)

    def mOptToolbar(self, *event):
        # if self._cancelDrag(break_pause=False): return
        self.setToolbarSide(self.tkopt.toolbar.get())

    def mOptToolbarStyle(self, *event):
        # if self._cancelDrag(break_pause=False): return
        self.setToolbarStyle(self.tkopt.toolbar_style.get())

    def mOptToolbarCompound(self, *event):
        # if self._cancelDrag(break_pause=False): return
        self.setToolbarCompound(self.tkopt.toolbar_compound.get())

    def mOptToolbarSize(self, *event):
        # if self._cancelDrag(break_pause=False): return
        self.setToolbarSize(self.tkopt.toolbar_size.get())

    def mOptToolbarRelief(self, *event):
        # if self._cancelDrag(break_pause=False): return
        self.setToolbarRelief(self.tkopt.toolbar_relief.get())

    def mOptToolbarConfig(self, w):
        self.toolbarConfig(w, self.tkopt.toolbar_vars[w].get())

    def mOptStatusbar(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        if not self.app.statusbar:
            return
        side = self.tkopt.statusbar.get()
        self.app.opt.statusbar = side
        resize = not self.app.opt.save_games_geometry
        if self.app.statusbar.show(side, resize=resize):
            self.top.update_idletasks()

    def mOptNumCards(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.num_cards = self.tkopt.num_cards.get()

    def mOptHelpbar(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        if not self.app.helpbar:
            return
        show = self.tkopt.helpbar.get()
        self.app.opt.helpbar = show
        resize = not self.app.opt.save_games_geometry
        if self.app.helpbar.show(show, resize=resize):
            self.top.update_idletasks()

    def mOptSaveGamesGeometry(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.save_games_geometry = self.tkopt.save_games_geometry.get()

    def mOptDemoLogo(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.demo_logo = self.tkopt.demo_logo.get()

    def mOptSplashscreen(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.splashscreen = self.tkopt.splashscreen.get()

    def mOptMouseType(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.mouse_type = self.tkopt.mouse_type.get()

    def mOptMouseUndo(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.mouse_undo = self.tkopt.mouse_undo.get()

    def mOptNegativeBottom(self, *event):
        if self._cancelDrag():
            return
        self.app.opt.negative_bottom = self.tkopt.negative_bottom.get()
        self.app.updateCardset()
        self.game.endGame(bookmark=1)
        self.game.quitGame(bookmark=1)

    #
    # toolbar support
    #

    def setToolbarSide(self, side):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.toolbar = side
        self.tkopt.toolbar.set(side)                    # update radiobutton
        resize = not self.app.opt.save_games_geometry
        if self.app.toolbar.show(side, resize=resize):
            self.top.update_idletasks()

    def setToolbarSize(self, size):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.toolbar_size = size
        self.tkopt.toolbar_size.set(size)                # update radiobutton
        dir = self.app.getToolbarImagesDir()
        if self.app.toolbar.updateImages(dir, size):
            self.game.updateStatus(player=self.app.opt.player)
            self.top.update_idletasks()

    def setToolbarStyle(self, style):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.toolbar_style = style
        # update radiobutton
        self.tkopt.toolbar_style.set(style)
        dir = self.app.getToolbarImagesDir()
        size = self.app.opt.toolbar_size
        if self.app.toolbar.updateImages(dir, size):
            # self.game.updateStatus(player=self.app.opt.player)
            self.top.update_idletasks()

    def setToolbarCompound(self, compound):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.toolbar_compound = compound
        self.tkopt.toolbar_compound.set(
            compound)          # update radiobutton
        if self.app.toolbar.setCompound(compound):
            self.game.updateStatus(player=self.app.opt.player)
            self.top.update_idletasks()

    def setToolbarRelief(self, relief):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.toolbar_relief = relief
        self.tkopt.toolbar_relief.set(relief)           # update radiobutton
        self.app.toolbar.setRelief(relief)
        self.top.update_idletasks()

    def toolbarConfig(self, w, v):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.toolbar_vars[w] = v
        self.app.toolbar.config(w, v)
        self.top.update_idletasks()

    #
    # stacks descriptions
    #

    def mStackDesk(self, *event):
        if self.game.stackdesc_list:
            self.game.deleteStackDesc()
        else:
            if self._cancelDrag(break_pause=True):
                return
            self.game.showStackDesc()

    def wizardDialog(self, edit=False):
        from pysollib.wizardutil import write_game, reset_wizard
        from wizarddialog import WizardDialog

        if edit:
            reset_wizard(self.game)
        else:
            reset_wizard(None)
        d = WizardDialog(self.top, _('Solitaire Wizard'), self.app)
        if d.status == 0 and d.button == 0:
            try:
                if edit:
                    gameid = write_game(self.app, game=self.game)
                else:
                    gameid = write_game(self.app)
            except Exception:
                return
            if SELECT_GAME_MENU:
                menu = self.__menupath[".menubar.select.customgames"][2]

                def select_func(gi): return gi.si.game_type == GI.GT_CUSTOM
                games = map(self.app.gdb.get,
                            self.app.gdb.getGamesIdSortedByName())
                games = filter(select_func, games)
                self.updateGamesMenu(menu, games)

            self.tkopt.gameid.set(gameid)
            self._mSelectGame(gameid, force=True)

    def mWizard(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.wizardDialog()

    def mWizardEdit(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.wizardDialog(edit=True)


'''
'''
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#

# imports
# import os

# Toolkit imports
from pysollib.pysoltk import MfxScrolledCanvas


# ************************************************************************
# *
# ************************************************************************


class MfxTreeBaseNode:
    def __init__(self, tree, parent_node, text, key):
        self.tree = tree
        self.parent_node = parent_node
        self.text = text
        self.key = key
        # state
        self.selected = 0
        self.subnodes = None
        # canvas item ids
        self.symbol_id = None
        self.text_id = None
        self.textrect_id = None

    def registerKey(self):
        if self.key is not None:
            lk = self.tree.keys.get(self.key, [])
            lk.append(self)
            self.tree.keys[self.key] = lk

    def whoami(self):
        if self.parent_node is None:
            return (self.text, )
        else:
            return self.parent_node.whoami() + (self.text, )

    # drawing functions not used with kivy.
    '''
    def draw(self, x, y, lastx=None, lasty=None):
        canvas, style = self.tree.canvas, self.tree.style
        topleftx = x + style.distx
        toplefty = y - style.height / 2  # +++
        # draw the horizontal line
        if lastx is not None:
            canvas.create_line(x, y, topleftx, y,
                               stipple=style.linestyle, fill=style.linecolor)
        # draw myself - ugly, ugly...
        self.selected = 0
        self.symbol_id = -1
        self.drawSymbol(topleftx, toplefty)
        linestart = style.distx + style.width + 5
        self.text_id = -1
        self.drawText(x + linestart, y)
        return x, y, x, y + style.disty

    #
    #
    #

    def drawText(self, x, y):
        canvas, style = self.tree.canvas, self.tree.style
        if self.selected:
            fg, bg = style.text_selected_fg, style.text_selected_bg
        else:
            fg, bg = style.text_normal_fg, style.text_normal_bg
        #
        if self.tree.nodes.get(self.text_id) is self:
            canvas.itemconfig(self.text_id, fill=fg)
        else:
            # note: I don't use Label + canvas.create_window here
            #   because it doesn't propagate events to the canvas
            #   and has some other re-display annoyances
            # print 'style.font:', style.font
            self.text_id = canvas.create_text(x + 1, y, text=self.text,
                                              anchor="w", justify="left",
                                              font=style.font,
                                              fill=fg)
            self.tree.nodes[self.text_id] = self
        #
        if self.tree.nodes.get(self.textrect_id) is self:
            try:
                # _tkinter.TclError: unknown option "-fill" ???
                canvas.itemconfig(self.textrect_id, fill=bg)
            except Tkinter.TclError:
                pass
        elif self.selected:
            b = canvas.bbox(self.text_id)
            self.textrect_id = canvas.create_rectangle(
                b[0] - 1, b[1] - 1, b[2] + 1, b[3] + 1, fill=bg, outline="")
            canvas.tag_lower(self.textrect_id, self.text_id)
            self.tree.nodes[self.textrect_id] = self

    def updateText(self):
        if self.tree.nodes.get(self.text_id) is self:
            self.drawText(-1, -1)

    #
    #
    #

    def drawSymbol(self, x, y, **kw):
        canvas, style = self.tree.canvas, self.tree.style
        color = kw.get("color")
        if color is None:
            if self.selected:
                color = "darkgreen"
            else:
                color = "green"
        # note: rectangle outline is one pixel
        if self.tree.nodes.get(self.symbol_id) is self:
            canvas.itemconfig(self.symbol_id, fill=color)
        else:
            self.symbol_id = canvas.create_rectangle(
                x + 1, y + 1, x + style.width, y + style.height, fill=color)
            self.tree.nodes[self.symbol_id] = self

    def updateSymbol(self):
        if self.tree.nodes.get(self.symbol_id) is self:
            self.drawSymbol(-1, -1)
    '''

# ************************************************************************
# * Terminal and non-terminal nodes
# ************************************************************************


class MfxTreeLeaf(MfxTreeBaseNode):
    def drawText(self, x, y):
        if self.text_id < 0:
            self.registerKey()
        MfxTreeBaseNode.drawText(self, x, y)


class MfxTreeNode(MfxTreeBaseNode):
    def __init__(self, tree, parent_node, text, key, expanded=0):
        MfxTreeBaseNode.__init__(self, tree, parent_node, text, key)
        self.expanded = expanded

    def drawChildren(self, x, y, lastx, lasty):
        # get subnodes
        self.subnodes = self.tree.getContents(self)
        # draw subnodes
        lx, ly = lastx, lasty
        nx, ny = x, y
        for node in self.subnodes:
            # update tree
            node.tree = self.tree
            # draw node
            lx, ly, nx, ny = node.draw(nx, ny, lx, ly)
        # draw the vertical line
        if self.subnodes:
            style = self.tree.style
            dy = (style.disty - style.width) / 2
            y = y - style.disty / 2 - dy
            self.tree.canvas.create_line(x, y, nx, ly,
                                         stipple=style.linestyle,
                                         fill=style.linecolor)
        return ny

    def draw(self, x, y, ilastx=None, ilasty=None):
        # draw myself
        lx, ly, nx, ny = MfxTreeBaseNode.draw(self, x, y, ilastx, ilasty)
        if self.expanded:
            style = self.tree.style
            childx = nx + style.distx + style.width / 2
            childy = ny
            clastx = nx + style.distx + style.width / 2
            clasty = ly + style.height / 2
            ny = self.drawChildren(childx, childy, clastx, clasty)
        return lx, ly, x, ny

    #
    #
    #

    def drawSymbol(self, x, y, **kw):
        color = kw.get("color")
        if color is None:
            if self.expanded:
                color = "red"
            else:
                color = "pink"
        MfxTreeBaseNode.drawSymbol(self, x, y, color=color)


# ************************************************************************
# *
# ************************************************************************

class MfxTreeInCanvas(MfxScrolledCanvas):
    pass
    '''
    class Style:
        def __init__(self):
            self.distx = 16
            self.disty = 18
            self.width = 16         # width of symbol
            self.height = 16        # height of symbol
            self.originx = 0
            self.originy = 0
            self.text_normal_fg = "black"
            self.text_normal_bg = "white"
            self.text_selected_fg = "white"
            self.text_selected_bg = "#00008b"       # "darkblue"
            self.font = None
            self.linestyle = "gray50"
            self.linecolor = "black"

    def __init__(self, parent, rootnodes, **kw):
        # LB bg = kw["bg"] = kw.get("bg") or parent.cget("bg")
        kw['bd'] = 0
        MfxScrolledCanvas.__init__(self, parent, **kw)
        #
        self.rootnodes = rootnodes
        self.updateNodesWithTree(self.rootnodes, self)
        self.selection_key = None
        self.nodes = {}
        self.keys = {}
        #
        self.style = self.Style()
        # self.style.text_normal_fg = self.canvas.cget("insertbackground")
        self.style.text_normal_fg = self.canvas.option_get(
            'foreground', '') or self.canvas.cget("insertbackground")
        self.style.text_normal_bg = bg
        #
        bind(self.canvas, "<ButtonPress-1>", self.singleClick)
        bind(self.canvas, "<Double-Button-1>", self.doubleClick)
        # bind(self.canvas, "<ButtonRelease-1>", xxx)
        self.pack(fill='both', expand=True)

    def destroy(self):
        for node in self.keys.get(self.selection_key, []):
            node.selected = 0
        MfxScrolledCanvas.destroy(self)

    def findNode(self, event=None):
        id = self.canvas.find_withtag('current')
        if id:
            return self.nodes.get(id[0])
        return None

    #
    # draw nodes
    #

    def draw(self):
        nx, ny = self.style.originx, self.style.originy
        # Account for initial offsets, see topleft[xy] in BaseNode.draw().
        # We do this so that our bounding box always starts at (0, 0)
        # and the yscrollincrement works nicely.
        nx = nx - self.style.distx
        ny = ny + self.style.height / 2
        for node in self.rootnodes:
            # update tree
            node.tree = self
            # draw
            try:
                lx, ly, nx, ny = node.draw(nx, ny, None, None)
            except Tkinter.TclError:
                # FIXME: Tk bug ???
                raise
        # set scroll region
        bbox = self.canvas.bbox("all")
        # self.canvas.config(scrollregion=bbox)
        self.canvas.config(scrollregion=(0, 0, bbox[2], bbox[3]))
        self.canvas.config(yscrollincrement=self.style.disty)

    def clear(self):
        self.nodes = {}
        self.keys = {}
        self.canvas.delete("all")

    def redraw(self):
        oldcur = self.canvas["cursor"]
        self.canvas["cursor"] = "watch"
        self.canvas.update_idletasks()
        self.clear()
        self.draw()
        self.updateSelection(self.selection_key)
        self.canvas["cursor"] = oldcur

    #
    #
    #

    def getContents(self, node):
        # Overload this, supposed to return a list of subnodes of node.
        pass

    def singleClick(self, event=None):
        # Overload this if you want to know when a node is clicked on.
        pass

    def doubleClick(self, event=None):
        # Overload this if you want to know when a node is d-clicked on.
        self.singleClick(event)

    #
    #
    #

    def updateSelection(self, key):
        l1 = self.keys.get(self.selection_key, [])
        l2 = self.keys.get(key, [])
        for node in l1:
            if node.selected and node not in l2:
                node.selected = 0
                node.updateSymbol()
                node.updateText()
        for node in l2:
            if not node.selected:
                node.selected = 1
                node.updateSymbol()
                node.updateText()
        self.selection_key = key

    def updateNodesWithTree(self, nodes, tree):
        for node in nodes:
            node.tree = tree
            if node.subnodes:
                self.updateNodesWithTree(node.subnodes, tree)
    '''

# ************************************************************************
# *
# ************************************************************************


'''
class DirectoryBrowser(MfxTreeInCanvas):
    def __init__(self, parent, dirs):
        nodes = []
        if isinstance(dirs, str):
            dirs = (dirs, )
        for dir in dirs:
            self.addNode(nodes, None, dir, dir)
        # note: best results if height is a multiple of style.disty
        MfxTreeInCanvas.__init__(self, parent, nodes, height=25 * 18)
        self.draw()

    def addNode(self, list, node, filename, text):
        try:
            if os.path.isdir(filename):
                list.append(MfxTreeNode(self, node, text, key=filename))
            else:
                list.append(MfxTreeLeaf(self, node, text, key=filename))
        except EnvironmentError:
            pass

    def getContents(self, node):
        # use cached values
        if node.subnodes is not None:
            return node.subnodes
        #
        dir = node.key
        print "Getting %s" % dir
        try:
            filenames = os.listdir(dir)
            filenames.sort()
        except EnvironmentError:
            return ()
        contents = []
        for filename in filenames:
            self.addNode(contents, node, os.path.join(
                dir, filename), filename)
        # print "gotten"
        return contents

    def singleClick(self, event=None):
        node = self.findNode(event)
        if not node:
            return
        print "Clicked node %s %s" % (node.text, node.key)
        if isinstance(node, MfxTreeLeaf):
            self.updateSelection(key=node.key)
        elif isinstance(node, MfxTreeNode):
            node.expanded = not node.expanded
            self.redraw()
        return "break"
'''

if __name__ == "__main__":
    '''
    tk = Tkinter.Tk()
    if os.name == "nt":
        app = DirectoryBrowser(tk, ("c:\\", "c:\\windows"))
    else:
        app = DirectoryBrowser(tk, ("/", "/home"))
    tk.mainloop()
    '''
    pass
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#

# imports
# import os
# import traceback

# PySol imports

# Toolkit imports
# from tkutil import after, after_cancel
# from tkutil import bind, unbind_destroy, makeImage
# from tkcanvas import MfxCanvas, MfxCanvasGroup
# from tkcanvas import MfxCanvasImage, MfxCanvasRectangle

# from pysollib.settings import TITLE

# ************************************************************************
# *
# ************************************************************************

LARGE_EMBLEMS_SIZE = (38, 34)
SMALL_EMBLEMS_SIZE = (31, 21)


find_card_dialog = None


def create_find_card_dialog(parent, game, dir):
    pass
    '''
    global find_card_dialog
    try:
        find_card_dialog.wm_deiconify()
        find_card_dialog.tkraise()
    except:
        # traceback.print_exc()
        find_card_dialog = FindCardDialog(parent, game, dir)
    '''


def connect_game_find_card_dialog(game):
    pass
    '''
    try:
        find_card_dialog.connectGame(game)
    except:
        pass
    '''


def destroy_find_card_dialog():
    pass
    '''
    global find_card_dialog
    try:
        find_card_dialog.destroy()
    except:
        # traceback.print_exc()
        pass
    find_card_dialog = None
    '''


'''
'''
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#

# Toolkit imports
from pysollib.pysoltk import MfxDialog

# ************************************************************************
# *
# ************************************************************************
# not supported.


class FontsDialog(MfxDialog):
    def __init__(self, parent, title, app, **kw):
        pass
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#

from pysollib.acard import AbstractCard
from pysollib.kivy.LApp import LImage
from pysollib.kivy.LApp import LImageItem
from pysollib.kivy.tkcanvas import MfxCanvasGroup, MfxCanvasImage


class _HideableCard(AbstractCard):
    def hide(self, stack):
        if stack is self.hide_stack:
            return
        self.item.config(state="hidden")
        self.hide_stack = stack
        # print "hide:", self.id, self.item.coords()

    def unhide(self):
        if self.hide_stack is None:
            return 0
        # print "unhide:", self.id, self.item.coords()
        self.item.config(state="normal")
        self.hide_stack = None
        return 1

    # moveBy aus Basisklasse überschreiben.
    def moveBy(self, dx, dy):
        # wir verwenden direkt den float Wert.
        if dx or dy:
            self.x = self.x + dx
            self.y = self.y + dy
            self.item.move(dx, dy)


# ************************************************************************
# * New implemetation since 2.10
# *
# * We use a single CanvasImage and call CanvasImage.config() to
# * turn the card.
# * This makes turning cards a little bit slower, but dragging cards
# * around is noticeable faster as the total number of images is
# * reduced by half.
# ************************************************************************
# * Kivy Implementation
# * Wir verwenden ein BoxLayout und installieren je nach Status das
# * face oder das back Image.
# ************************************************************************


class _OneImageCard(_HideableCard):
    def __init__(self, id, deck, suit, rank, game, x=0, y=0):
        _HideableCard.__init__(self, id, deck, suit, rank, game, x=x, y=y)

        fimage = game.getCardFaceImage(deck, suit, rank)
        bimage = game.getCardBackImage(deck, suit, rank)

        self._face_image = LImage(texture=fimage.texture)
        self._back_image = LImage(texture=bimage.texture)
        # self._face_image = Image(source=fimage.source)
        # self._back_image = Image(source=bimage.source)
        self._shade_image = game.getCardShadeImage()

        aimage = LImageItem(
            pos=(x, -y), size=self._face_image.size, game=game, card=self)
        aimage.add_widget(self._back_image)
        self._active_image = aimage

        self.item = MfxCanvasImage(
            game.canvas, self.x, self.y, image=aimage, anchor="nw")
        self.shade_item = None

        # print ('card: face = %s xy=%s/%s' % (self._face_image.source, x, y))
        # print ('card: back = %s xy=%s/%s' % (self._back_image.source, x, y))
        # y = self.yy

    def _setImage(self, image):
        self._active_image.clear_widgets()
        self._active_image.add_widget(image)

    def showFace(self, unhide=1):
        # print ('card: showFace = %s' % self._face_image.source)
        if not self.face_up:
            self._setImage(image=self._face_image)
            self.tkraise(unhide)
            self.face_up = 1

    def showBack(self, unhide=1):
        # print ('card: showBack = %s' % self._back_image.source)
        if self.face_up:
            self._setImage(image=self._back_image)
            self.tkraise(unhide)
            self.face_up = 0

    def updateCardBackground(self, image):
        print('card: updateCardBackground = %s' % image.source)
        self._back_image = LImage(texture=image.texture)
        if not self.face_up:
            self._setImage(image=self._back_image)

    def setSelected(self, s, group=None):
        print('card: setselected(%s, %s)' % (s, group))
        # wird nicht bedient.
        pass

    def animatedMove(self, dx, dy, duration=0.2):
        self.item.animatedMove(dx, dy, duration)

# ************************************************************************
# * New idea since 3.00
# *
# * Hide a card by configuring the canvas image to None.
# ************************************************************************


class _OneImageCardWithHideByConfig(_OneImageCard):
    def hide(self, stack):
        if stack is self.hide_stack:
            return
        self._setImage(image=None)
        self.hide_stack = stack

    def unhide(self):
        if self.hide_stack is None:
            return 0
        if self.face_up:
            self._setImage(image=self._face_image)
        else:
            self._setImage(image=self._back_image)
        self.hide_stack = None
        return 1

    #
    # much like in _OneImageCard
    #

    def showFace(self, unhide=1):
        if not self.face_up:
            if unhide:
                self._setImage(image=self._face_image)
            self.item.tkraise()
            self.face_up = 1

    def showBack(self, unhide=1):
        if self.face_up:
            if unhide:
                self._setImage(image=self._back_image)
            self.item.tkraise()
            self.face_up = 0

    def updateCardBackground(self, image):
        self._back_image = image
        if not self.face_up and not self.hide_stack:
            self._setImage(image=image)


# ************************************************************************
# * Old implemetation prior to 2.10
# *
# * The card consists of two CanvasImages. To show the card face up,
# * the face item is placed in front of the back. To show it face
# * down, this is reversed.
# ************************************************************************


class _TwoImageCard(_HideableCard):
    # Private instance variables:
    #   __face, __back -- the canvas items making up the card
    def __init__(self, id, deck, suit, rank, game, x=0, y=0):
        _HideableCard.__init__(self, id, deck, suit, rank, game, x=x, y=y)
        self.item = MfxCanvasGroup(game.canvas)
        self.__face = MfxCanvasImage(
            game.canvas, self.x, self.y,
            image=game.getCardFaceImage(deck, suit, rank), anchor="nw")
        self.__back = MfxCanvasImage(
            game.canvas, self.x, self.y,
            image=game.getCardBackImage(deck, suit, rank), anchor="nw")
        self.__face.addtag(self.item)
        self.__back.addtag(self.item)

    def showFace(self, unhide=1):
        if not self.face_up:
            self.__face.tkraise()
            self.tkraise(unhide)
            self.face_up = 1

    def showBack(self, unhide=1):
        if self.face_up:
            self.__back.tkraise()
            self.tkraise(unhide)
            self.face_up = 0

    def updateCardBackground(self, image):
        self.__back.config(image=image)


# ************************************************************************
# * New idea since 2.90
# *
# * The card consists of two CanvasImages. Instead of raising
# * one image above the other we move the inactive image out
# * of the visible canvas.
# ************************************************************************


class _TwoImageCardWithHideItem(_HideableCard):
    # Private instance variables:
    #   __face, __back -- the canvas items making up the card
    def __init__(self, id, deck, suit, rank, game, x=0, y=0):
        _HideableCard.__init__(self, id, deck, suit, rank, game, x=x, y=y)
        self.item = MfxCanvasGroup(game.canvas)
        self.__face = MfxCanvasImage(
            game.canvas, self.x, self.y + 11000,
            image=game.getCardFaceImage(deck, suit, rank), anchor="nw")
        self.__back = MfxCanvasImage(
            game.canvas, self.x, self.y,
            image=game.getCardBackImage(deck, suit, rank), anchor="nw")
        self.__face.addtag(self.item)
        self.__back.addtag(self.item)

    def showFace(self, unhide=1):
        if not self.face_up:
            self.__back.move(0, 10000)
            # self.__face.tkraise()
            self.__face.move(0, -11000)
            self.tkraise(unhide)
            self.face_up = 1

    def showBack(self, unhide=1):
        if self.face_up:
            self.__face.move(0, 11000)
            # self.__back.tkraise()
            self.__back.move(0, -10000)
            self.tkraise(unhide)
            self.face_up = 0

    def updateCardBackground(self, image):
        self.__back.config(image=image)


# choose the implementation
# Card = _TwoImageCardWithHideItem
# Card = _TwoImageCard
# Card = _OneImageCardWithHideByConfig
Card = _OneImageCard


'''end of file'''
import logging
try:
    import jnius
except ImportError:
    jnius = None

# link address of related support library:
# https://maven.google.com/com/android/support/support-v4/24.1.1/support-v4-24.1.1.aar

# inspired by stackoverflow.com/questions/47510030/
# as functools (reduce,partial,map) do not seem to work in python3 on android,
# implemented in a classic functional way.
# LB190927.
# wait loop removed. (Implement it in external code if needed.)
# LB191011.


class AndroidPerms(object):
    def __init__(self):
        if jnius is None:
            return
        self.PythonActivity = jnius.autoclass(
            'org.kivy.android.PythonActivity')
        self.Compat = jnius.autoclass(
            'android.support.v4.content.ContextCompat')
        self.currentActivity = jnius.cast(
            'android.app.Activity', self.PythonActivity.mActivity)

    def getPerm(self, permission):
        if jnius is None:
            return True
        p = self.Compat.checkSelfPermission(self.currentActivity, permission)
        return p == 0

    # check actual permissions
    def getPerms(self, permissions):
        if jnius is None:
            return True
        haveperms = True
        for perm in permissions:
            haveperms = haveperms and self.getPerm(perm)
        return haveperms

    # invoke the permissions dialog
    def requestPerms(self, permissions):
        if jnius is None:
            return True
        logging.info("androidperms: invoke permission dialog")
        self.currentActivity.requestPermissions(permissions, 0)
        return


def getStoragePerm():
    ap = AndroidPerms()
    return ap.getPerms(
        ["android.permission.WRITE_EXTERNAL_STORAGE"])


def requestStoragePerm():
    ap = AndroidPerms()
    # ap.requestPerms(
    #    ["android.permission.READ_EXTERNAL_STORAGE","android.permission.WRITE_EXTERNAL_STORAGE"])
    ap.requestPerms(
        ["android.permission.WRITE_EXTERNAL_STORAGE"])
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#

from kivy.uix.popup import Popup

# ************************************************************************
# * a simple progress bar
# ************************************************************************
# not really supportable with kivy. dummy def.


class PysolProgressBar(Popup):
    def __init__(self, app, parent, title=None, images=None, color="blue",
                 width=300, height=25, show_text=1, norm=1):
        self.percent = 100
        return

    def update(self, **kw):
        return

    def destroy(self):
        return

    def reset(self, percent=0):
        return
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
# Copyright (C) 2017 LB
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#
# Note:
# Many classes or some methods of classes are dead code resulting from the tk
# implementation. If executed it would throw exceptions.
#
# Kivy Implementation used: MfxScrolledCanvas, MfxDialog (partly)

from __future__ import division

import logging

from kivy.clock import Clock
from kivy.uix.anchorlayout import AnchorLayout
from kivy.uix.boxlayout import BoxLayout
from kivy.uix.label import Label

from pysollib.kivy.LApp import LBoxLayout
from pysollib.kivy.LApp import LImage
from pysollib.kivy.LApp import LScrollView
from pysollib.kivy.LApp import LTopLevel
from pysollib.kivy.tkcanvas import MfxCanvas
from pysollib.kivy.tkutil import bind, unbind_destroy
from pysollib.kivy.tkutil import makeToplevel
from pysollib.mfxutil import KwStruct, kwdefault
from pysollib.mygettext import _
from pysollib.settings import WIN_SYSTEM

# ************************************************************************
# * abstract base class for the dialogs in this module
# ************************************************************************


class MfxDialog:  # ex. _ToplevelDialog
    img = {}
    button_img = {}

    def __init__(self, parent, title="", resizable=False, default=-1):
        self.parent = parent
        self.status = 0
        self.button = default
        self.timer = None
        self.buttons = []
        self.accel_keys = {}
        self.top = makeToplevel(parent, title=title)

    def wmDeleteWindow(self, *event):
        self.status = 1
        raise SystemExit
        # return EVENT_HANDLED

    def mCancel(self, *event):
        self.status = 1
        raise SystemExit

    def mTimeout(self, *event):
        self.status = 2
        raise SystemExit

    def mDone(self, button):
        self.button = button
        raise SystemExit

    def altKeyEvent(self, event):
        key = event.char
        # key = unicode(key, 'utf-8')
        key = key.lower()
        button = self.accel_keys.get(key)
        if button is not None:
            self.mDone(button)

    def initKw(self, kw):
        kw = KwStruct(kw,
                      timeout=0, resizable=False,
                      text="", justify="center",
                      strings=(_("&OK"), ),
                      default=0,
                      width=0,
                      padx=20, pady=20,
                      bitmap=None, bitmap_side="left",
                      bitmap_padx=10, bitmap_pady=20,
                      image=None, image_side="left",
                      image_padx=10, image_pady=20,
                      )
        # default to separator if more than one button
        sep = len(kw.strings) > 1
        kwdefault(kw.__dict__, separator=sep)
        return kw

    def createFrames(self, kw):
        a = LBoxLayout(orientation="vertical")
        b = LBoxLayout(orientation="vertical")
        return a, b


# ************************************************************************
# Needed Labels.

class MfxSimpleEntry:
    pass


class MfxToolTip:
    pass

# ************************************************************************
# * replacement for the tk_dialog script
# ************************************************************************
# Kivy implementation helpers.


class FLabel(Label):
    def __init__(self, **kw):
        super(FLabel, self).__init__(**kw)

        self.bind(size=self.onUpdate)
        self.bind(pos=self.onUpdate)
        self.bind(text=self.onUpdate)

    def onUpdate(self, instance, size):
        self.size_hint_y = None
        self.text_size = self.width, None
        self.texture_update()
        self.height = self.texture_size[1]


class FText(LScrollView):
    def __init__(self, **kw):
        super(FText, self).__init__(**kw)

        self.label = FLabel(**kw)
        self.add_widget(self.label)


class MfxMessageDialog(MfxDialog):
    def __init__(self, parent, title, **kw):
        kw = self.initKw(kw)
        MfxDialog.__init__(self, parent, title, kw.resizable, kw.default)

        if (kw.image):
            image = LImage(texture=kw.image.texture, size_hint=(1, 1))
            self.top.add_widget(image)

        label = FText(text=kw.text, halign='center')
        self.top.add_widget(label)

        # LB
        # nicht automatisch ein neues spiel laden.
        if (title == _("Game won")):
            self.status = 1
            # self.button = 0
        if (title == _("Game finished")):
            self.status = 1
            # self.button =

# ************************************************************************
# *
# ************************************************************************


class MfxExceptionDialog(MfxMessageDialog):
    def __init__(self, parent, ex, title=_("Error"), **kw):
        kw = KwStruct(kw, bitmap="error")
        text = kw.get("text", "")
        if not text.endswith("\n"):
            text = text + "\n"
        text = text + "\n"
        if isinstance(ex, EnvironmentError) and ex.filename is not None:
            t = "[Errno %s] %s:\n%s" % (
                ex.errno, ex.strerror, repr(ex.filename))
        else:
            t = str(ex)
        kw.text = text + t
        MfxMessageDialog.__init__(self, parent, title, **kw.getKw())


# ************************************************************************
# *
# ************************************************************************

class PysolAboutDialog(object):

    # Die einzige Instanz.
    AboutDialog = None

    def onClick(self, event):
        print('LTopLevel: onClick')
        PysolAboutDialog.AboutDialog.parent.popWork('AboutDialog')
        PysolAboutDialog.AboutDialog.running = False

    def __init__(self, app, parent, title, **kw):
        logging.info('PysolAboutDialog:')
        super(PysolAboutDialog, self).__init__()

        self._url = kw['url']
        logging.info('PysolAboutDialog: txt=%s' % title)

        text = kw['text']
        text = text + '\n' + self._url
        logging.info('PysolAboutDialog: txt=%s' % text)

        text = text + '\n\n' + 'Adaptation to Kivy/Android\n' + \
            ' Copyright (C) (2016-19) LB'

        self.parent = parent
        self.app = app
        self.window = None
        self.running = False
        self.status = 1  # -> von help.py so benötigt
        self.button = 0  # -> von help.py so benötigt

        # bestehenden Dialog rezyklieren.

        logging.info('PysolAboutDialog: 1')
        onlyone = PysolAboutDialog.AboutDialog
        if (onlyone and onlyone.running):
            return
        if (onlyone):
            onlyone.parent.pushWork('AboutDialog', onlyone.window)
            onlyone.running = True
            return

        # neuen Dialog aufbauen.

        window = LTopLevel(parent, title, size_hint=(1.0, 1.0))
        window.titleline.bind(on_press=self.onClick)
        self.parent.pushWork('AboutDialog', window)
        self.window = window
        self.running = True
        PysolAboutDialog.AboutDialog = self

        if kw['image']:
            image = LImage(texture=kw['image'].texture)
            image.size_hint = (1, 0.8)
            al = AnchorLayout()
            al.add_widget(image)
            al.size_hint = (1, 0.3)
            window.content.add_widget(al)

        label = FText(text=text, halign='center', size_hint=(1, 1))
        window.content.add_widget(label)


# ************************************************************************
# * a simple tooltip
# ************************************************************************
# ToolTip - not used in Kivy - would not run without adaptations.


'''
class MfxTooltip:
    last_leave_time = 0

    def __init__(self, widget):
        # private vars
        self.widget = widget
        self.text = None
        self.timer = None
        self.cancel_timer = None
        self.tooltip = None
        self.label = None
        self.bindings = []
        self.bindings.append(self.widget.bind("<Enter>", self._enter))
        self.bindings.append(self.widget.bind("<Leave>", self._leave))
        self.bindings.append(self.widget.bind("<ButtonPress>", self._leave))
        # user overrideable settings
        self.timeout = 800                    # milliseconds
        self.cancel_timeout = 5000
        self.leave_timeout = 400
        self.relief = 'solid'
        self.justify = 'left'
        self.fg = "#000000"
        self.bg = "#ffffe0"
        self.xoffset = 0
        self.yoffset = 4

    def setText(self, text):
        self.text = text

    def _unbind(self):
        if self.bindings and self.widget:
            self.widget.unbind("<Enter>", self.bindings[0])
            self.widget.unbind("<Leave>", self.bindings[1])
            self.widget.unbind("<ButtonPress>", self.bindings[2])
            self.bindings = []

    def destroy(self):
        self._unbind()
        self._leave()

    def _enter(self, *event):
        after_cancel(self.timer)
        after_cancel(self.cancel_timer)
        self.cancel_timer = None
        timediff = time.time() - MfxTooltip.last_leave_time
        if timediff < self.leave_timeout / 1000.:
            self._showTip()
        else:
            self.timer = after(self.widget, self.timeout, self._showTip)

    def _leave(self, *event):
        after_cancel(self.timer)
        after_cancel(self.cancel_timer)
        self.timer = self.cancel_timer = None
        if self.tooltip:
            self.label.destroy()
            destruct(self.label)
            self.label = None
            self.tooltip.destroy()
            destruct(self.tooltip)
            self.tooltip = None
            MfxTooltip.last_leave_time = time.time()

    def _showTip(self):
        self.timer = None
        if self.tooltip or not self.text:
            return
#         if isinstance(self.widget, (Tkinter.Button, Tkinter.Checkbutton)):
#             if self.widget["state"] == 'disabled':
#                 return
        # x = self.widget.winfo_rootx()
        x = self.widget.winfo_pointerx()
        y = self.widget.winfo_rooty() + self.widget.winfo_height()
        x += self.xoffset
        y += self.yoffset
        self.tooltip = Tkinter.Toplevel()
        self.tooltip.wm_iconify()
        self.tooltip.wm_overrideredirect(1)
        self.tooltip.wm_protocol("WM_DELETE_WINDOW", self.destroy)
        self.label = Tkinter.Label(self.tooltip, text=self.text,
                                   relief=self.relief, justify=self.justify,
                                   fg=self.fg, bg=self.bg, bd=1, takefocus=0)
        self.label.pack(ipadx=1, ipady=1)
        self.tooltip.wm_geometry("%+d%+d" % (x, y))
        self.tooltip.wm_deiconify()
        self.cancel_timer = after(
            self.widget, self.cancel_timeout, self._leave)
        # self.tooltip.tkraise()
'''

# ************************************************************************
# * A canvas widget with scrollbars and some useful bindings.
# ************************************************************************
# Kivy implementation of MfxScrolledCanvas.


class LScrollFrame(BoxLayout):
    def __init__(self, **kw):
        super(LScrollFrame, self).__init__(orientation="vertical", **kw)


class MfxScrolledCanvas(object):
    def __init__(self, parent, hbar=True, vbar=True, propagate=False, **kw):
        kwdefault(kw, highlightthickness=0, bd=1, relief='sunken')
        self.parent = parent

        # workarea = parent.getWork()
        print('MfxScrolledCanvas: parent=%s' % (parent))

        super(MfxScrolledCanvas, self).__init__()
        self.createFrame(kw)
        self.canvas = None
        # do_scroll_x = None
        # do_scroll_y = None
        # self.hbar = None
        # self.vbar = None
        self.hbar_show = False
        self.vbar_show = False
        self.createCanvas(kw)
        # self.frame.grid_rowconfigure(0, weight=1)
        # self.frame.grid_columnconfigure(0, weight=1)
        # self.frame.grid_propagate(propagate)
        if hbar:
            self.createHbar()
            self.bindHbar()
        if vbar:
            self.createVbar()
            self.bindVbar()
        # self.canvas.focus_set()

    def destroy(self):
        logging.info('MfxRoot: destroy')
        self.unbind_all()
        self.canvas.destroy()
        self.frame.destroy()

    def pack(self, **kw):
        pass
        # self.frame.pack(**kw)

    def grid(self, **kw):
        pass
        # self.frame.grid(**kw)

    #
    #
    #

    def setTile(self, app, i, force=False):
        logging.info('MfxRoot: setTitle app=%s' % app)

        tile = app.tabletile_manager.get(i)

        print('setTile: (tile) %s, index=%s' % (tile, i))

        if tile is None or tile.error:
            return False

        # print i, tile
        if i == 0:
            assert tile.color
            assert tile.filename is None
        else:
            assert tile.color is None
            assert tile.filename
            assert tile.basename
        if not force:
            if (i == app.tabletile_index and
                    tile.color == app.opt.colors['table']):
                return False
        #
        print('setTile2: %s' % (tile.filename))

        if not self.canvas.setTile(
                tile.filename, tile.stretch, tile.save_aspect):
            tile.error = True
            return False

        print(
            'MfxScrolledCanvas: tile.color, app.top_bg %s, %s'
            % (tile.color, app.top_bg))
        if i == 0:
            if force:
                tile.color = app.opt.colors['table']
            self.canvas.config(bg=tile.color)
        else:
            if type(app.top_bg) is str:
                self.canvas.config(bg=app.top_bg)

        self.canvas.setTextColor(app.opt.colors['text'])
        return True
    #
    #
    #

    def deleteAllItems(self):
        logging.info('MfxRoot: deleteAllItems')
        # self.parent.getWork()
        # self.parent.popWork()
        # self.frame.clear_widgets()
        self.canvas.clear_widgets()

    def update_idletasks(self):
        logging.info('MfxRoot: update_idletasks')
        Clock.schedule_once(lambda x: self.canvas.canvas.ask_update)

    def unbind_all(self):
        unbind_destroy(self.hbar)
        unbind_destroy(self.vbar)
        unbind_destroy(self.canvas)
        unbind_destroy(self.frame)

    def createFrame(self, kw):
        logging.info('MfxRoot: createFrame')
        # width = kw.get("width")
        # height = kw.get("height")
        print('createFrame: kw=%s' % kw)
        # self.frame = Tkinter.Frame(self.parent, width=width, height=height)

        self.frame = LScrollFrame(size_hint=(1, 1))

        print("createFrame: self.parent %s" % str(self.frame))

    def createCanvas(self, kw):
        logging.info('MfxRoot: createCanvas')
        # bd = kw['bd']
        kw['bd'] = 0
        # relief = kw['relief']
        del kw['relief']
        # frame = Tkinter.Frame(self.frame, bd=bd, relief=relief)
        # frame.grid(row=0, column=0, sticky="news")
        '''
        self.canvas = MfxCanvas(self.frame, **kw)
        self.frame.add_widget(self.canvas)
        self.parent.pushWork(self.frame)
        '''
        self.canvas = MfxCanvas(self.parent, **kw)
        self.frame = self.canvas
        self.parent.pushWork('playground', self.frame)
        ''
        # self.canvas.pack(expand=True, fill='both')

    def createHbar(self):
        pass
        '''
        self.hbar = Tkinter.Scrollbar(self.frame, takefocus=0,
                                      orient="horizontal")
        self.canvas["xscrollcommand"] = self._setHbar
        self.hbar["command"] = self.canvas.xview
        self.hbar.grid(row=1, column=0, sticky="we")
        self.hbar.grid_remove()
        '''

    def createVbar(self):
        pass
        '''
        self.vbar = Tkinter.Scrollbar(self.frame, takefocus=0)
        self.canvas["yscrollcommand"] = self._setVbar
        self.vbar["command"] = self.canvas.yview
        self.vbar.grid(row=0, column=1, sticky="ns")
        self.vbar.grid_remove()
        '''

    def bindHbar(self, w=None):
        if w is None:
            w = self.canvas
        bind(w, "<KeyPress-Left>", self.unit_left)
        bind(w, "<KeyPress-Right>", self.unit_right)

    def bindVbar(self, w=None):
        if w is None:
            w = self.canvas
        bind(w, "<KeyPress-Prior>", self.page_up)
        bind(w, "<KeyPress-Next>", self.page_down)
        bind(w, "<KeyPress-Up>", self.unit_up)
        bind(w, "<KeyPress-Down>", self.unit_down)
        bind(w, "<KeyPress-Begin>", self.scroll_top)
        bind(w, "<KeyPress-Home>", self.scroll_top)
        bind(w, "<KeyPress-End>", self.scroll_bottom)
        # mousewheel support
        if WIN_SYSTEM == 'x11':
            bind(w, '<4>', self.mouse_wheel_up)
            bind(w, '<5>', self.mouse_wheel_down)
        # don't work on Linux
        # bind(w, '<MouseWheel>', self.mouse_wheel)

    def mouse_wheel(self, *args):
        pass

    def _setHbar(self, first, last):
        if self.canvas.busy:
            return
        sb = self.hbar
        if float(first) <= 0 and float(last) >= 1:
            sb.grid_remove()
            self.hbar_show = False
        else:
            if self.canvas.winfo_ismapped():
                sb.grid()
                self.hbar_show = True
        sb.set(first, last)

    def _setVbar(self, first, last):
        if self.canvas.busy:
            return
        sb = self.vbar
        if float(first) <= 0 and float(last) >= 1:
            sb.grid_remove()
            self.vbar_show = False
        else:
            if self.canvas.winfo_ismapped():
                sb.grid()
                self.vbar_show = True
        sb.set(first, last)

    def _xview(self, *args):
        if self.hbar_show:
            self.canvas.xview(*args)
        return 'break'

    def _yview(self, *args):
        if self.vbar_show:
            self.canvas.yview(*args)
        return 'break'

    def page_up(self, *event):
        return self._yview('scroll', -1, 'page')

    def page_down(self, *event):
        return self._yview('scroll', 1, 'page')

    def unit_up(self, *event):
        return self._yview('scroll', -1, 'unit')

    def unit_down(self, *event):
        return self._yview('scroll', 1, 'unit')

    def mouse_wheel_up(self, *event):
        return self._yview('scroll', -5, 'unit')

    def mouse_wheel_down(self, *event):
        return self._yview('scroll', 5, 'unit')

    def page_left(self, *event):
        return self._xview('scroll', -1, 'page')

    def page_right(self, *event):
        return self._xview('scroll', 1, 'page')

    def unit_left(self, *event):
        return self._xview('scroll', -1, 'unit')

    def unit_right(self, *event):
        return self._xview('scroll', 1, 'unit')

    def scroll_top(self, *event):
        return self._yview('moveto', 0)

    def scroll_bottom(self, *event):
        return self._yview('moveto', 1)


# ************************************************************************
# *
# ************************************************************************
# not used witch kivy. would not nun as it refers TkInter.
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#


# PySol imports
# from pysollib.mfxutil import KwStruct
# from pysollib.gamedb import GI

# Toolkit imports
from pysollib.pysoltk import MfxDialog

__all__ = ['GameInfoDialog']

# ************************************************************************
# *
# ************************************************************************


class GameInfoDialog(MfxDialog):
    def __init__(self, parent, title, app, **kw):
        pass


'''
'''
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#

# Toolkit imports
from pysollib.pysoltk import MfxDialog

# ************************************************************************
# *
# ************************************************************************


class EditTextDialog(MfxDialog):

    def __init__(self, parent, title, text, **kw):
        # not used with kivy.
        pass

    def initKw(self, kw):
        pass

    def destroy(self):
        pass

    def wmDeleteWindow(self, *event):   # ignore
        pass

    def mCancel(self, *event):          # ignore <Escape>
        pass


'''end of file'''
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#

import logging

from kivy.cache import Cache

TclError = 0


def MfxRoot(**kw):
    mainWindow = Cache.get('LAppCache', 'mainWindow')
    logging.info('tkwrap: top = %s' % str(mainWindow))
    return mainWindow
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#

from pysollib.mfxutil import kwdefault
from pysollib.mygettext import _
from pysollib.pysoltk import MfxDialog

# ************************************************************************
# * Dialog
# ************************************************************************
# not used with kivy. dummy def.


class SelectCardsetDialogWithPreview(MfxDialog):
    _cardset_store = None

    def __init__(self, parent, title, app, manager, key=None, **kw):
        if key is None:
            key = 1
        self.status = -1
        self.key = key
        self.app = app
        self.manager = manager
        return

    def getSelected(self):
        return None

    def showSelected(self, w):
        pass

    def updatePreview(self, key):
        pass

    def initKw(self, kw):
        kwdefault(kw,
                  strings=(_("&Load"), _("&Cancel"), _("&Info..."), ),
                  default=1,
                  resizable=1,
                  padx=10, pady=10,
                  width=600, height=400,
                  )
        return MfxDialog.initKw(self, kw)

    def createInfo(self):
        pass

    def done(self, button):
        pass
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ************************************************************************
# * constants
# ************************************************************************

EVENT_HANDLED = "break"
EVENT_PROPAGATE = None

CURSOR_DRAG = "hand1"
CURSOR_WATCH = "watch"
CURSOR_DOWN_ARROW = 'sb_down_arrow'

ANCHOR_CENTER = 'center'
ANCHOR_N = 'n'
ANCHOR_NW = 'nw'
ANCHOR_NE = 'ne'
ANCHOR_S = 's'
ANCHOR_SW = 'sw'
ANCHOR_SE = 'se'
ANCHOR_W = 'w'
ANCHOR_E = 'e'
'''
COMPOUNDS = (
    # (Tkinter.BOTTOM,  'bottom'),
    # (Tkinter.CENTER,  'center'),
    # (Tkinter.RIGHT,    'right'),
    (Tkinter.NONE,   n_('Icons only')),
    (Tkinter.TOP,    n_('Text below icons')),
    (Tkinter.LEFT,   n_('Text beside icons')),
    ('text',         n_('Text only')),
    )
'''
TOOLBAR_BUTTONS = (
    "new",
    "restart",
    "open",
    "save",
    "undo",
    "redo",
    "autodrop",
    "shuffle",
    "pause",
    "statistics",
    "rules",
    "quit",
    "player",
)
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#

# kivy implementation:
# most of the code will not be used, but some important function have been
# emulated.

from __future__ import division

import logging
import os
from array import array

from kivy.clock import Clock
from kivy.core.image import Image as CoreImage
from kivy.core.text import Label as CoreLabel
from kivy.graphics.texture import Texture

from pysollib.kivy.LApp import LImage
from pysollib.kivy.LApp import LTopLevel0

# ************************************************************************
# * window manager util
# ************************************************************************


def wm_withdraw(window):
    window.wm_withdraw()


def wm_map(window, maximized=0):
    return


# ************************************************************************
# * window util
# ************************************************************************


def setTransient(window, parent, relx=None, rely=None, expose=1):
    # Make an existing toplevel window transient for a parent.
    #
    # The window must exist but should not yet have been placed; in
    # other words, this should be called after creating all the
    # subwidget but before letting the user interact.

    # not used in kivy (highly tk specific).
    return


def makeToplevel(parent, title=None):
    print('tkutil: makeTopLevel')

    # Create a Toplevel window.
    #
    window = LTopLevel0(parent, title)
    # window = LTopLevelPopup(parent, title)
    return window.content


def make_help_toplevel(app, title=None):
    # Create an independent Toplevel window.

    window = app.top

    # from pysollib.winsystems import init_root_window
    # window = Tkinter.Tk(className=TITLE)
    # init_root_window(window, app)
    return window


# ************************************************************************
# * bind wrapper - Tkinter doesn't properly delete all bindings
# ************************************************************************

__mfx_bindings = {}
__mfx_wm_protocols = ("WM_DELETE_WINDOW", "WM_TAKE_FOCUS", "WM_SAVE_YOURSELF")


def bind(widget, sequence, func, add=None):

    # logging.info('tkutil: bind  %s %s %s %s '
    #              % (widget, sequence, func, add))

    # logging.info('tkutil: bind canvas = ' % str(widget.canvas))

    if hasattr(widget, 'bindings'):
        # logging.info('tkutil: bind  %s %s %s %s '
        #              % (sequence, widget, func, add))
        widget.bindings[sequence] = func
    else:
        # logging.info('tkutil: bind failed %s %s' % (sequence, widget))
        pass

    if (sequence == '<KeyPress-Left>'):
        return
    if (sequence == '<KeyPress-Right>'):
        return
    if (sequence == '<KeyPress-Prior>'):
        return
    if (sequence == '<KeyPress-Next>'):
        return
    if (sequence == '<KeyPress-Up>'):
        return
    if (sequence == '<KeyPress-Down>'):
        return
    if (sequence == '<KeyPress-Begin>'):
        return
    if (sequence == '<KeyPress-Home>'):
        return
    if (sequence == '<KeyPress-End>'):
        return
    if (sequence == '<KeyPress-Down>'):
        return

    if (sequence == '<4>'):
        return
    if (sequence == '<5>'):
        return

    if (sequence == '<1>'):
        return
    if (sequence == '<Motion>'):
        return
    if (sequence == '<ButtonRelease-1>'):
        return
    if (sequence == '<Control-1>'):
        return
    if (sequence == '<Shift-1>'):
        return
    if (sequence == '<Double-1>'):
        return
    if (sequence == '<3>'):
        return
    if (sequence == '<2>'):
        return
    if (sequence == '<Control-3>'):
        return
    if (sequence == '<Enter>'):
        return
    if (sequence == '<Leave>'):
        return
    if (sequence == '<Unmap>'):
        return
    if (sequence == '<Configure>'):
        return
    pass


def unbind_destroy(widget):
    # logging.info('tkutil: unbind  %s' % (widget))
    widget.bindings = []
    pass


# ************************************************************************
# * timer wrapper - Tkinter doesn't properly delete all commands
# ************************************************************************


def after(widget, ms, func, *args):
    print('tkutil: after(%s, %s, %s, %s)' % (widget, ms, func, args))
    if (ms == 'idle'):
        print('demo use')
        Clock.schedule_once(lambda dt: func(), 1.0)
    elif (isinstance(ms, int)):
        # print('ms: play timer (accounting)')
        # Clock.schedule_once(lambda dt: func(), float(ms)/1000.0)
        # makes not sense, drains battery!
        pass


def after_idle(widget, func, *args):
    print('tkutil: after_idle()')
    return after(widget, "idle", func, *args)


def after_cancel(t):
    print('tkutil: after_cancel()')
    pass


# ************************************************************************
# * image handling
# ************************************************************************


def makeImage(file=None, data=None, dither=None, alpha=None):
    kw = {}
    if data is None:
        assert file is not None
        kw["source"] = file
        # print('makeImage: source = %s' % file)
        # if (file=='/home/lb/PRG/Python/Kivy/pysolfc/data/images/redeal.gif'):
        #    y = self.yy
    else:
        assert data is not None
        kw["texture"] = data
        # ob das geht ?? - kommt das vor ?
        # yy = self.yy
    '''
    if 'source' in kw:
        logging.info ("makeImage: " + kw["source"])
    if 'texture' in kw:
        logging.info ("makeImage: " + str(kw["texture"]))
    '''

    return LImage(**kw)


loadImage = makeImage


def copyImage(image, x, y, width, height):

    # return Image(source=image.source)
    # return Image(texture=image.texture)
    return image


def fillTexture(texture, fill, outline=None, owidth=1):

    # logging.info("fillImage: t=%s, f=%s o=%s, w=%s" %
    #              (texture, fill, outline, owidth))
    # O.K. Kivy

    if not fill and not outline:
        return

    width = texture.width
    height = texture.height

    ox = round(owidth)
    ow = int(ox)  # muss int sein!
    if width <= 2 * ow or height <= 2 * ow:
        fill = fill or outline
        outline = None

    if not fill:
        fi0 = 0
        fi1 = 0
        fi2 = 0
        fi3 = 0
    else:
        # wir erwarten Werte als '#xxxxxx' (color Werte in Tk notation)
        # (optional mit transparenz)
        if (fill[0] == '#'):
            fill = fill[1:]
        fi0 = int(fill[0:2], 16)
        fi1 = int(fill[2:4], 16)
        fi2 = int(fill[4:6], 16)
        fi3 = 255
        if len(fill) >= 8:
            fi3 = int(fill[6:8], 16)

    if not outline:
        f = (fi0, fi1, fi2, fi3) * width
        f = (f, ) * height
        assert len(f) == height
        f = sum(f, ())
        assert len(f) == height * width * 4
        arr = array('B', f)
        texture.blit_buffer(arr, colorfmt='rgba', bufferfmt='ubyte')
    else:
        if (outline[0] == '#'):
            outline = outline[1:]
        ou0 = int(outline[0:2], 16)
        ou1 = int(outline[2:4], 16)
        ou2 = int(outline[4:6], 16)
        ou3 = 255
        if len(outline) >= 8:
            ou3 = int(outline[6:8], 16)

        l1 = (
            ou0,
            ou1,
            ou2,
            ou3,
        ) * width
        l2 = (ou0, ou1, ou2, ou3, ) * ow + (fi0, fi1, fi2, fi3, ) * \
            (width - 2 * ow) + (ou0, ou1, ou2, ou3, ) * ow
        f = (l1, ) * ow + (l2, ) * (height - 2 * ow) + (l1, ) * ow
        assert len(f) == height
        f = sum(f, ())
        assert len(f) == height * width * 4
        arr = array('B', f)
        texture.blit_buffer(arr, colorfmt='rgba', bufferfmt='ubyte')


def createImage(width, height, fill, outline=None, outwidth=1):

    logging.info("createImage: w=%s, h=%s, f=%s, o=%s, ow=%s" %
                 (width, height, fill, outline, outwidth))

    # test stellungen:
    # if (fill==None):
    #   fill = '#00cc00'
    # if (outline==None):
    #   outline = '#ff00ff'

    # if (fill is None and (outline is None or outline == '')):
    #     outline = '#fff000'
    #     outwidth = 1

    texture = Texture.create(size=(width, height), colorfmt='rgba')
    fillTexture(texture, fill, outline, outwidth)
    image = LImage(texture=texture)
    # logging.info("createImage: LImage create %s" % image)
    return image


def shadowImage(image, color='#3896f8', factor=0.3):

    logging.info("shadowImage: ")
    # TBD.
    return None
    # Kivy nicht benötigt. aber - was tut das ?
    # wurde aufgerufen, als der erste König auf die Foundation
    # gezogen wurde. (möglicherweise eine Gewonnen! - Markierung).


def markImage(image):
    logging.info("markImage: ")
    return None


def _createImageMask(texture, color):

    col = 0
    if (color == 'black'):
        col = 0
    if (color == 'white'):
        col = 255

    g = texture.pixels
    arr = array('B', g)

    for mx in range(int(len(arr) / 4)):
        m = 4 * mx
        if arr[m + 3] < 128:
            arr[m + 3] = 0
            arr[m] = arr[m + 1] = arr[m + 2] = 0
        else:
            arr[m + 3] = 32
            arr[m] = arr[m + 1] = arr[m + 2] = col

    mask = Texture.create(size=texture.size, colorfmt='rgba')
    mask.blit_buffer(arr, colorfmt='rgba', bufferfmt='ubyte')
    return mask


def _scaleTextureToSize(texture, size):

    width = size[0]
    height = size[1]

    g = texture.pixels
    ag = array('B', g)
    gw, gh = texture.size

    # print('size:',width,height)
    # print('texture size:',gw,gh)

    bb = array('B', [0 for x in range(width * height * 4)])
    # print ('bb length: ',len(bb))
    # print ('gg length: ',gw*gh*4)

    scalex = width / gw
    scaley = height / gh

    # scale, x und y offset bestimmen.

    scale = scaley
    if (scalex < scaley):
        scale = scalex

    offx = (width - gw * scale) / 2
    offy = (height - gh * scale) / 2

    # print ('scale: ',scalex,'/',scaley,' -> ',scale)
    # print ('offs: ',offx,'/',offy)

    for bi in range(height):
        bline = bi * width
        if (bi >= offy) and (bi < (height - offy)):
            # transfer
            ai = gh - int((bi - offy) / scale) - 1
            aline = ai * gw
            for bk in range(width):
                bpos = (bline + bk) * 4
                if (bk >= offx) and (bk < (width - offx)):
                    # transfer
                    ak = int((bk - offx) / scale)
                    apos = (aline + ak) * 4
                    bb[bpos] = ag[apos]
                    bb[bpos + 1] = ag[apos + 1]
                    bb[bpos + 2] = ag[apos + 2]
                    bb[bpos + 3] = ag[apos + 3]
                else:
                    # transparent
                    bb[bpos + 3] = 0
        else:
            # transparent
            for bk in range(width):
                bb[(bline + bk) * 4 + 3] = 0

    stext = Texture.create(size=(width, height), colorfmt='rgba')
    stext.blit_buffer(bb, colorfmt='rgba', bufferfmt='ubyte')
    return stext


def _pasteTextureTo(texture, totexture):

    g = texture.pixels
    ag = array('B', g)
    gw, gh = texture.size

    t = totexture.pixels
    at = array('B', t)
    tw, th = totexture.size

    if (tw != gw) or (th != gh):
        return

    for i in range(int(len(ag) / 4)):
        i4 = i * 4
        if ag[i4 + 3] > 128:
            at[i4] = ag[i4]
            at[i4 + 1] = ag[i4 + 1]
            at[i4 + 2] = ag[i4 + 2]
            at[i4 + 3] = ag[i4 + 3]

    stext = Texture.create(size=(tw, th), colorfmt='rgba')
    stext.blit_buffer(at, colorfmt='rgba', bufferfmt='ubyte')
    return stext


def createBottom(image, color='white', backfile=None):

    backfilebase = None
    if backfile is not None:
        backfilebase = os.path.basename(backfile)

    logging.info("createBottom: %s | %s" % (color, backfilebase))
    # print('createBottom:',image)

    # th = 1                              # thickness
    # size = (w - th * 2, h - th * 2)
    # original: zeichnet noch eine outline um die karte - können wir nicht.

    tmp0 = _createImageMask(image.texture, color)
    if backfile:
        tmp1 = CoreImage(backfile)
        txtre = _scaleTextureToSize(tmp1.texture, image.texture.size)
        tmp = _pasteTextureTo(txtre, tmp0)
    else:
        tmp = tmp0

    img = LImage(texture=tmp)
    img.size[0] = image.getWidth()
    img.size[1] = image.getHeight()
    return img
    '''
    im = image._pil_image
    th = 1                              # thickness
    sh = Image.new('RGBA', im.size, color)
    out = Image.composite(sh, im, im)
    w, h = im.size
    size = (w - th * 2, h - th * 2)
    tmp = Image.new('RGBA', size, color)
    tmp.putalpha(60)
    mask = out.resize(size, Image.ANTIALIAS)
    out.paste(tmp, (th, th), mask)
    if backfile:
        back = Image.open(backfile).convert('RGBA')
        w0, h0 = back.size
        w1, h1 = im.size
        a = min(float(w1) / w0, float(h1) / h0)
        a = a * 0.9
        w0, h0 = int(w0 * a), int(h0 * a)
        back = back.resize((w0, h0), Image.ANTIALIAS)
        x, y = (w1 - w0) / 2, (h1 - h0) / 2
        out.paste(back, (x, y), back)
    return PIL_Image(image=out)
    '''


# ************************************************************************
# * font utils
# ************************************************************************


def get_text_width(text, font, root=None):

    logging.info("get_text_width: %s  %s" % (text, font))

    label = CoreLabel()
    label.text = text
    label.refresh()
    return label.content_width
    # return Font(root=root, font=font).measure(text)
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
# Copyright (C) 2017 LB
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#

from __future__ import division

import logging

from kivy.clock import Clock
from kivy.graphics import Color
from kivy.graphics import Rectangle
from kivy.uix.anchorlayout import AnchorLayout
from kivy.uix.widget import Widget

from pysollib.kivy.LApp import LAnimationManager
from pysollib.kivy.LApp import LColorToKivy
from pysollib.kivy.LApp import LImage
from pysollib.kivy.LApp import LImage as Image
from pysollib.kivy.LApp import LImageItem
from pysollib.kivy.LApp import LLine
from pysollib.kivy.LApp import LRectangle
from pysollib.kivy.LApp import LText

# ************************************************************************
# * canvas items helpers
# ************************************************************************


def addAnchorOffset(pos, anchor, size):
    # print ('MfxCanvas: anchor=%s' % (anchor))
    x = pos[0]
    y = pos[1]
    xa = 0
    ya = 0
    if anchor == "n":
        ya = -1
    elif anchor == "w":
        xa = -1
    elif anchor == "s":
        ya = 1
    elif anchor == "e":
        xa = 1
    elif anchor == "ne":
        ya = -1
        xa = 1
    elif anchor == "nw":
        ya = -1
        xa = -1
    elif anchor == "se":
        ya = 1
        xa = 1
    elif anchor == "sw":
        ya = 1
        xa = -1

    if xa == 0:
        x = x - size[0] / 2.0
    elif xa == 1:
        x = x - size[0]
    if ya == 0:
        y = y - size[1] / 2.0
    elif ya == 1:
        y = y - size[1]
    return (x, y)


def subAnchorOffset(pos, anchor, size):
    # print ('MfxCanvas: anchor=%s' % (anchor))
    x = pos[0]
    y = pos[1]
    xa = 0
    ya = 0
    if anchor == "n":
        ya = -1
    elif anchor == "w":
        xa = -1
    elif anchor == "s":
        ya = 1
    elif anchor == "e":
        xa = 1
    elif anchor == "ne":
        ya = -1
        xa = 1
    elif anchor == "nw":
        ya = -1
        xa = -1
    elif anchor == "se":
        ya = 1
        xa = 1
    elif anchor == "sw":
        ya = 1
        xa = -1

    if xa == 0:
        x = x + size[0] / 2.0
    elif xa == 1:
        x = x + size[0]
    if ya == 0:
        y = y + size[1] / 2.0
    elif ya == 1:
        y = y + size[1]
    return (x, y)

# ************************************************************************
# * canvas items
# ************************************************************************


class MfxCanvasGroup():
    def __init__(self, canvas, tag=None):
        # logging.info('MfxCanvasGroup: __init__() %s - %s' %
        #  (str(canvas), str(tag)))
        self.canvas = canvas
        self.bindings = {}
        self.stack = None

    def tkraise(self):
        pass

    def addtag(self, tag, option="withtag"):
        # logging.info('MfxCanvasGroup: addtag(%s, %s)' % (tag, option))
        # self.canvas.addtag(tag, option, self.id)
        pass

    def delete(self):
        # logging.info('MfxCanvasGroup: delete()')
        # del self.canvas.items[self.id]
        pass

    def gettags(self):
        # logging.info('MfxCanvasGroup: gettags()')
        # return self.canvas.tk.splitlist(self._do("gettags"))
        return None


class MfxCanvasImage(object):
    def __init__(self, canvas, *args, **kwargs):

        # print ('MfxCanvasImage: %s | %s | %s' % (canvas, args, kwargs))

        group = None
        if 'group' in kwargs:
            group = kwargs['group']
            del kwargs['group']
        self._image = None
        if 'image' in kwargs:
            self._image = kwargs['image']
        self._anchor = None
        if 'anchor' in kwargs:
            self._anchor = kwargs['anchor']

        super(MfxCanvasImage, self).__init__()
        self.canvas = canvas
        self.animation = None

        ed = kwargs['image']
        size = ed.size

        if type(ed) is LImageItem:
            aimage = ed
        else:
            if (ed.source is None):
                image = LImage(texture=ed.texture)
                image.size = [ed.getWidth(), ed.getHeight()]
                aimage = LImageItem(size=image.size, group=group)
                aimage.add_widget(image)
                size = image.size
            else:
                image = LImage(texture=ed.texture)
                # image = LImage(source=ed.source)
                image.size = [ed.getWidth(), ed.getHeight()]
                aimage = LImageItem(size=ed.size, group=group)
                aimage.add_widget(image)
                size = image.size

        xy = addAnchorOffset(args, self._anchor, size)

        aimage.coreSize = (aimage.size[0], aimage.size[1])
        aimage.corePos = (xy[0], xy[1])

        aimage.pos, aimage.size = canvas.CoreToKivy(xy, aimage.size)
        self.canvas.add_widget(aimage)
        self.image = aimage
        self.widget = aimage

        if group:
            self.addtag(group)

    def __del__(self):
        print('MfxCanvasImage: __del__(%s)' % self.image)
        self.canvas.clear_widgets([self.image])

    def config(self, **kw):
        pass

    def tkraise(self, aboveThis=None):
        # print('MfxCanvasImage: tkraise')
        abitm = None
        if aboveThis:
            abitm = aboveThis.widget
        if not self.animation:
            self.canvas.tag_raise(self.image, abitm)
        pass

    def addtag(self, tag):
        # print('MfxCanvasImage: addtag %s' % tag)
        self.group = tag
        if (self.image):
            self.image.group = tag
        pass

    def dtag(self, tag):
        # print('MfxCanvasImage: remtag %s' % tag)
        self.group = None
        if (self.image):
            self.image.group = None
        pass

    def delete(self):
        # print('MfxCanvasImage: delete()')
        self.canvas.clear_widgets([self.image])

    def move(self, dx, dy):
        # print ('MfxCanvasImage: move %s, %s' % (dx, dy))
        image = self.image
        dsize = image.coreSize
        dpos = (image.corePos[0] + dx, image.corePos[1] + dy)
        image.corePos = dpos
        if not self.animation:
            image.pos, image.size = self.canvas.CoreToKivy(dpos, dsize)

    def makeAnimStart(self):
        def animStart(anim, widget):
            # print('MfxCanvasImage: animStart')
            image = self.image
            self.canvas.tag_raise(image, None)
            pass
        return animStart

    def makeAnimEnd(self, dpos, dsize):
        def animEnd(anim, widget):
            # print('MfxCanvasImage: animEnd %s' % self)
            self.animation = False
            image = self.image
            image.pos, image.size = self.canvas.CoreToKivy(dpos, dsize)
            pass
        return animEnd

    def animatedMove(self, dx, dy, duration=0.2):
        # print ('MfxCanvasImage: animatedMove %s, %s' % (dx, dy))

        image = self.image
        dsize = image.coreSize
        dpos = (image.corePos[0] + dx, image.corePos[1] + dy)
        pos, size = self.canvas.CoreToKivy(dpos, dsize)
        transition1 = 'out_expo'
        # transition2 = 'out_cubic'
        # transition3 = 'out_quad'
        # transition4 = 'out_quint'
        # transition5 = 'out_sine'
        transition6 = 'in_out_quad'
        # transition7 = 'in_bounce'
        # transition8 = 'in_elastic'
        transition = transition6
        if self.canvas.wmain.app.game.demo:
            transition = transition1

        self.animation = True
        ssize = image.coreSize
        spos = (image.corePos[0], image.corePos[1])
        spos, ssize = self.canvas.CoreToKivy(spos, ssize)
        LAnimationManager.create(
            spos,
            image,
            x=pos[0], y=pos[1],
            duration=duration, transition=transition,
            bindS=self.makeAnimStart(),
            bindE=self.makeAnimEnd(dpos, dsize))

    # def moveTo(self, x, y):
    #    c = self.coords()
    #    self.move(x - int(c[0]), y - int(c[1]))

    def show(self):
        self.config(state='normal')

    def hide(self):
        self.config(state='hidden')


class MfxCanvasLine(object):
    def __init__(self, canvas, *args, **kwargs):
        print('MfxCanvasLine: %s %s' % (args, kwargs))

        self.canvas = canvas
        line = LLine(canvas, args, **kwargs)
        line.pos, line.size = canvas.CoreToKivy(line.corePos, line.coreSize)
        canvas.add_widget(line)
        self.canvas = canvas
        self.line = line
        self.widget = line

    def delete_deferred(self, seconds):
        print('MfxCanvasLine: delete_deferred(%s)' % seconds)
        Clock.schedule_once(lambda dt: self.delete(), seconds)

    def delete(self):
        print('MfxCanvasLine: delete()')
        self.canvas.clear_widgets([self.line])


class MfxCanvasRectangle(object):
    def __init__(self, canvas, *args, **kwargs):

        # logging.info('MfxCanvasRectangle: %s %s' % (args, kwargs))

        rect = LRectangle(canvas, args, **kwargs)
        rect.pos, rect.size = canvas.CoreToKivy(rect.corePos, rect.coreSize)
        canvas.add_widget(rect)
        self.canvas = canvas
        self.rect = rect
        self.widget = rect

    def delete(self):
        # print('MfxCanvasRectangle: delete()')
        self.canvas.clear_widgets([self.rect])

    def __del__(self):
        # print('MfxCanvasRectangle: __del__()')
        self.delete()

    def delete_deferred_step(self, seconds):
        # print ('MfxCanvasRectangle: delete_deferred_step(%s)' % seconds)
        Clock.schedule_once(lambda dt: self.delete(), seconds)

    def delete_deferred(self, seconds):
        # self.canvas.canvas.ask_update()
        # print ('MfxCanvasRectangle: delete_deferred(%s)' % seconds)
        Clock.schedule_once(
            lambda dt: self.delete_deferred_step(seconds), 0.05)

    def addtag(self, tag):
        logging.info('MfxCanvasRectangle: addtag(%s) - fake' % tag)
        pass

    def tkraise(self, aboveThis=None):
        # logging.info('MfxCanvasRectangle: tkraise(%s) - fake' % item)
        abitm = None
        if aboveThis:
            abitm = aboveThis.widget
        self.canvas.tag_raise(self.rect, abitm)
        pass


class MfxCanvasText(object):
    def __init__(self, canvas, x, y, preview=-1, **kwargs):

        print(
            'MfxCanvasText: %s | %s, %s, %s | %s'
            % (canvas, x, y, preview, kwargs))

        if preview < 0:
            preview = canvas.preview
        if preview > 1:
            return
        if "fill" not in kwargs:
            kwargs["fill"] = canvas._text_color
        if 'group' in kwargs:
            del kwargs['group']

        super(MfxCanvasText, self).__init__()

        label = LText(canvas, x, y, **kwargs)
        label.pos, label.size = canvas.CoreToKivy(
            label.corePos, label.coreSize)
        canvas.add_widget(label)
        self.canvas = canvas
        self.label = label
        self.widget = label

    def config(self, **kw):
        print('MfxCanvasText: config %s' % kw)
        if ('text' in kw):
            self.label.text = kw['text']

    def tkraise(self, aboveThis=None):
        abitm = None
        if aboveThis:
            abitm = aboveThis.widget
        self.canvas.tag_raise(self.label, abitm)
        pass

    def bbox(self):
        # Dimensionen als 2x2 array zurückgeben.
        # (aufruf z.B. bei games/special/poker.py und bei Memory!)
        label = self.label
        canvas = self.canvas
        pos = label.pos
        size = label.size
        pos, size = canvas.KivyToCore(pos, size)
        ret = [[pos[0], pos[1]], [pos[0] + size[0], pos[1] + size[1]]]
        return ret

    def addtag(self, tag):
        pass

# ************************************************************************
# * canvas
# ************************************************************************


class MfxCanvas(Widget):

    def __init__(self, wmain, *args, **kw):
        # super(MfxCanvas, self).__init__(**kw)
        super(MfxCanvas, self).__init__()

        # self.tags = {}   # bei basisklasse widget (ev. nur vorläufig)

        self.wmain = wmain
        print('MfxCanvas: wmain = %s' % self.wmain)

        # Tkinter.Canvas.__init__(self, *args, **kw)
        self.preview = 0
        self.busy = False
        self._text_color = '#000000'
        self._bg_color = '#00ffff'
        self._stretch_bg_image = 0
        self._save_aspect_bg_image = 0
        #
        self.xmargin, self.ymargin = 0.0, 0.0
        self.topImage = None

        # Skalierung
        # self.lastsize = (self.size[0], self.size[1])
        # self.lastpos = (self.pos[0], self.pos[1])

        self.scale = 1.2
        self.r_width = None
        self.r_height = None

        self.bindings = {}
        self.bind(pos=self.pos_update_widget)
        self.bind(size=self.size_update_widget)

    def KivyToCoreP(self, pos, size, scale):
        cpos = pos
        cpos = (cpos[0] - self.pos[0], self.pos[1] +
                self.size[1] - cpos[1] - size[1])
        cpos = (1.0 * cpos[0] / scale, 1.0 * cpos[1] / scale)
        csize = (1.0 * size[0] / scale, 1.0 * size[1] / scale)
        return cpos, csize

    def CoreToKivyP(self, cpos, csize, scale):
        size = (1.0 * csize[0] * scale, 1.0 * csize[1] * scale)
        pos = (1.0 * cpos[0] * scale, 1.0 * cpos[1] * scale)
        pos = (self.pos[0] + pos[0], self.pos[1] +
               self.size[1] - pos[1] - size[1])
        return pos, size

    def KivyToCore(self, pos, size=(0.0, 0.0)):
        return self.KivyToCoreP(pos, size, self.scale)

    def CoreToKivy(self, cpos, csize=(0.0, 0.0)):
        return self.CoreToKivyP(cpos, csize, self.scale)

    def move(self, itm, dx, dy):
        # print ('MfxCanvas: move %s %s %s' % (itm, dx, dy))
        scale = self.scale
        dx = scale * dx
        dy = scale * dy
        itm.pos = (itm.pos[0] + dx, itm.pos[1] - dy)

    def scalefactor(self):
        if self.r_width is None:
            return self.scale
        if self.r_height is None:
            return self.scale

        # TBD (idee).
        # Hier ev. einen 2ten Modus zulassen, welche das Spielfeld
        # knapp auf die vorhandenen Karten/Anzeigeelemente bemisst.
        # Zur Optimierung der Sichtbarkeit auf kleinen Geräten.
        # Könnte z.B. über Doppelklick umgeschaltet werden. (Die
        # Skalierung müsste dann allerding nach jedem Zug dem ev.
        # veränderten Feld angepasst werden.)

        wid = self.size[0]
        hei = self.size[1]
        scfx = wid / self.r_width
        scfy = hei / self.r_height

        scf = scfx
        if (scfx < scfy):
            # print('scale factor by x = %s' % (scfx))
            scf = scfx
        else:
            # print('scale factor by y = %s' % (scfy))
            scf = scfy

        return scf

    def pos_update_widget(self, posorobj, size):
        # print('MfxCanvas: pos_update_widget size=(%s, %s)' %
        #       (self.size[0], self.size[1]))
        self.update_widget(posorobj, size)

    def size_update_widget(self, posorobj, size):
        # print('MfxCanvas: size_update_widget size=(%s, %s)' %
        #       (self.size[0], self.size[1]))
        self.update_widget(posorobj, size)

    def update_widget(self, posorobj, size):

        # print('MfxCanvas: update_widget size=(%s, %s)' %
        #       (self.size[0], self.size[1]))

        # Update Skalierungsparameter

        oldscale = self.scale
        newscale = self.scalefactor()
        print('MfxCanvas: scale factor old= %s, new=%s' %
              (oldscale, newscale))
        self.scale = newscale

        # Anpassung Skalierung.

        for c in self.children:
            if not hasattr(c, 'corePos'):
                continue
            if not hasattr(c, 'coreSize'):
                continue

            bpos = c.corePos
            bsiz = c.coreSize
            if bpos and bsiz:
                npos, nsiz = self.CoreToKivy(bpos, bsiz)
                c.pos = npos
                c.size = nsiz

        # Hintergrund update.

        self.canvas.before.clear()
        texture = None
        if self._bg_img:
            texture = self._bg_img.texture

            # Color only: Nur eine Hintergrundfarbe wird installiert.
        if texture is None:
            kc = LColorToKivy(self._bg_color)
            self.canvas.before.add(
                Color(kc[0], kc[1], kc[2], kc[3]))
            self.canvas.before.add(
                Rectangle(pos=self.pos, size=self.size))
            return

        # Image: Das Bild wird im Fenster expandiert.
        if self._stretch_bg_image:
            if self._save_aspect_bg_image == 0:
                self.canvas.before.add(
                    Rectangle(texture=texture, pos=self.pos, size=self.size))
            else:
                # TBD: gesucht: aspect erhaltende skalierung
                self.canvas.before.add(
                    Rectangle(texture=texture, pos=self.pos, size=self.size))
            return

            # Tiles: Die Kacheln werden im Fenster ausgelegt und minim
        # skaliert, damit sie genau passen.
        else:
            print('tiles !')
            stsize = (texture.size[0] * self.scale,
                      texture.size[1] * self.scale)
            stepsy = int(self.size[1] / stsize[1]) + 1
            stepsx = int(self.size[0] / stsize[0]) + 1

            scaley = 1.0 * self.size[1] / (stepsy * stsize[1])
            sy = scaley * stsize[1]
            scalex = 1.0 * self.size[0] / (stepsx * stsize[0])
            sx = scalex * stsize[0]
            tsize = (sx, sy)

            # print ('self.size = %s, %s' % (self.size[0], self.size[1]))
            # print ('sx, sy = %s, %s' % (stepsx, stepsy))
            for y in range(0, stepsy):
                py = y * sy
                for x in range(0, stepsx):
                    px = x * sx
                    tpos = (self.pos[0] + px, self.pos[1] + py)
                    self.canvas.before.add(
                        Rectangle(texture=texture, pos=tpos, size=tsize))

    def setBackgroundImage(self, event=None):

        print('setBackgroundImage', self._bg_img)

        if not self._bg_img:  # solid color
            return
        return 1

    # Funktionen, welche vom Core aufgerufen werden.

    def winfo_width(self):
        # return self.r_width
        cpos, csize = self.KivyToCoreP(self.pos, self.size, self.scale)
        print('MfxCanvas: winfo_width %s' % (csize[0]))
        return csize[0]

    def winfo_height(self):
        # return self.r_height
        cpos, csize = self.KivyToCoreP(self.pos, self.size, self.scale)
        print('MfxCanvas: winfo_height %s' % (csize[1]))
        return csize[1]

    def cget(self, f):
        print('MfxCanvas: cget %s -> %s, %s' % (f, self.pos, self.size))
        cpos, csize = self.KivyToCoreP(self.pos, self.size, self.scale)
        if f == 'width':
            print('MfxCanvas: cget %s -> x=%s' % (f, cpos[0]))
            return cpos[0]
        if f == 'height':
            print('MfxCanvas: cget %s -> y=%s' % (f, cpos[1]))
            return cpos[1]
        # if f=='bg':
        #    return background-color
        print('MfxCanvas: cget unsupported token')
        return 1

    def xview(self):
        print('MfxCanvas: xview')
        return [1, 1]
        pass

    def yview(self):
        print('MfxCanvas: yview')
        return [1, 1]
        pass

    #
    # top-image support
    #

    def tag_raise(self, itm, abitm=None):
        # print('MfxCanvas: tag_raise, itm=%s, aboveThis=%s' % (itm, abitm))
        if (itm is not None):
            if (abitm is None):
                # print('MfxCanvas: tag_raise: to top')
                self.clear_widgets([itm])
                self.add_widget(itm)
            else:
                print('MfxCanvas: tag_raise: to specified position')
                ws = []
                for c in reversed(self.children):   # reversed!
                    if c != itm and c != abitm:
                        ws.append(c)
                    if c == itm:
                        ws.append(abitm)
                        ws.append(itm)    # (~shadow image!)
                self.clear_widgets()
                for w in ws:
                    self.add_widget(w)

    def tag_lower(self, id, belowThis=None):
        print('MfxCanvas: tag_lower(%s, %s)' % (id, belowThis))
        # y = self.yy  # kommt das vor ?
        pass

    #
    #
    #
    def setInitialSize(self, width, height):
        print('MfxCanvas: setInitialSize request %s/%s' % (width, height))
        print(
            'MfxCanvas: setInitialSize actual  %s/%s'
            % (self.size[0], self.size[1]))
        self.r_width = width
        self.r_height = height

        # ev. update anstossen
        self.update_widget(self.pos, self.size)

        # self.size[0] = width
        # self.size[1] = height
        return

    # delete all CanvasItems, but keep the background and top tiles
    def deleteAllItems(self):
        print('MfxCanvas: deleteAllItems')
        self.clear_widgets()
        pass

    def findCard(self, stack, event):
        print('MfxCanvas: findCard(%s, %s)' % (stack, event))
        if (event.cardid > -1):
            return event.cardid

        print('MfxCanvas: findCard no cardid')
        return -1

    def setTextColor(self, color):
        print('MfxCanvas: setTextColor1 %s' % color)
        if color is None:
            c = self.cget("bg")
            if not isinstance(c, str) or c[0] != "#" or len(c) != 7:
                return
            v = []
            for i in (1, 3, 5):
                v.append(int(c[i:i + 2], 16))
            luminance = (0.212671 * v[0] + 0.715160 *
                         v[1] + 0.072169 * v[2]) / 255
            # print c, ":", v, "luminance", luminance
            color = ("#000000", "#ffffff")[luminance < 0.3]

        print('MfxCanvas: setTextColor2 %s' % color)
        if self._text_color != color:
            self._text_color = color

            # falls wir das wollen in kivy:
            # -> text_color als property deklarieren, und a.a.O binden.
            # for item in self._text_items:
            #    item.config(fill=self._text_color)

    def setTile(self, image, stretch=0, save_aspect=0):

        print('setTile: %s, %s' % (image, stretch))
        if image:
            try:
                # print ('setTile: image.open %s, %s' % (image, Image))
                bs = False
                if stretch > 0:
                    bs = True
                self._bg_img = Image(source=image, allow_stretch=bs)

                self._stretch_bg_image = stretch
                self._save_aspect_bg_image = save_aspect
                self.setBackgroundImage()
                self.update_widget(self.pos, self.size)
            except Exception:
                return 0
        else:
            # print ('setTile: no image!')
            self._bg_img = None
            self.update_widget(self.pos, self.size)
        return 1

    def setTopImage(self, image, cw=0, ch=0):
        print('MfxCanvas: setTopImage %s' % image)

        if self.topImage:
            self.clear_widgets([self.topImage])
            self.topImage = None

        if image:
            tex = LImage(texture=image.texture)
            tex.size_hint = (0.4, 0.4)
            lay = AnchorLayout(anchor_y='bottom')
            lay.size = self.size
            lay.add_widget(tex)

            self.topImage = lay
            self.add_widget(self.topImage)

        return 1
    #
    # Pause support
    #

    def hideAllItems(self):
        print('MfxCanvas: hideAllItems')
        # TBD
        # Wir lassen das. Das TopImage deckt alles ab. Spielen ist
        # nicht möglich.
        pass

    def showAllItems(self):
        print('MfxCanvas: showAllItems')
        # TBD
        pass

    # Erweiterungen fuer Tk Canvas (prüfen was noch nötig!!).

    def itemconfig(self, tagOrId, cnf=None, **kw):
        """Configure resources of an item TAGORID.

        The values for resources are specified as keyword
        arguments. To get an overview about
        the allowed keyword arguments call the method without arguments.
        """
        print(
            'MfxCanvas: itemconfigure tagOrId=%s, cnf=%s, kw=%s'
            % (tagOrId, cnf, kw))

        if 'image' in cnf:
            # tagOrId ist ein Image oder ein CardImage
            # self.clear_widgets([cnf['image']])
            # self.add_widget(cnf['image'])
            # y = self.yy
            pass
        if 'text' in cnf:
            # tagOrId ist das Label.
            tagOrId.text = cnf['text']
            pass

    def config(self, cnf={}, **kw):
        print('MfxCanvas: config %s %s' % (cnf, kw))
        if ('cursor' in kw):
            pass
        if ('width' in kw):
            self.size[0] = kw['width']
        if ('height' in kw):
            self.size[1] = kw['height']
        if ('bg' in kw):
            self._bg_color = kw['bg']
            self.update_widget(self.pos, self.size)

    def dtag(self, tag, b=None):
        # print ('Canvas: dtag %s %s' % (tag, b))
        # if (tag in self.tags):
        #  if (self.tags[tag]==b):
        #    del self.tags[tag]
        pass

    def addtag(self, tag, b, c):
        # print ('Canvas: addtag %s %s %s' % (tag, b, c))
        # self.tags[c] = tag
        # self.tags.append(tag)
        pass

    def delete(self, tag):
        # print ('MfxCanvas: delete tag=%s' % tag)
        # y = self.yy
        pass

    def update_idletasks(self):
        print('MfxCanvas: update_idletasks')
        self.wmain.update_idletasks()
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------#
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------#

from kivy.clock import Clock

from pysollib.gamedb import GI
from pysollib.kivy.LApp import LScrollView
from pysollib.kivy.LApp import LTopLevel
from pysollib.kivy.LApp import LTreeNode
from pysollib.kivy.LApp import LTreeRoot
from pysollib.kivy.selecttree import SelectDialogTreeData
from pysollib.kivy.selecttree import SelectDialogTreeLeaf, SelectDialogTreeNode
from pysollib.mygettext import _

from six.moves import UserList


# ************************************************************************
# * Nodes
# ************************************************************************


class SelectGameLeaf(SelectDialogTreeLeaf):
    def getContents(self):
        return None


class SelectGameNode(SelectDialogTreeNode):
    def _getContents(self):
        contents = []
        if isinstance(self.select_func, UserList):
            # key/value pairs
            for id, name in self.select_func:
                if id and name:
                    node = SelectGameLeaf(self.tree, self, name, key=id)
                    contents.append(node)
        else:
            for gi in self.tree.all_games_gi:
                if gi and self.select_func is None:
                    # All games
                    # name = '%s (%s)' % (gi.name, CSI.TYPE_NAME[gi.category])
                    name = gi.name
                    node = SelectGameLeaf(self.tree, self, name, key=gi.id)
                    contents.append(node)
                elif gi and self.select_func(gi):
                    name = gi.name
                    node = SelectGameLeaf(self.tree, self, name, key=gi.id)
                    contents.append(node)
        return contents or self.tree.no_games


# ************************************************************************
# * Tree database
# ************************************************************************

class SelectGameData(SelectDialogTreeData):
    def __init__(self, app):
        SelectDialogTreeData.__init__(self)

        # originale.
        self.all_games_gi = list(
            map(app.gdb.get, app.gdb.getGamesIdSortedByName()))
        self.no_games = [SelectGameLeaf(None, None, _("(no games)"), None), ]
        #
        s_by_type = s_oriental = s_special = None
        s_original = s_contrib = s_mahjongg = None
        g = []
        for data in (GI.SELECT_GAME_BY_TYPE,
                     GI.SELECT_ORIENTAL_GAME_BY_TYPE,
                     GI.SELECT_SPECIAL_GAME_BY_TYPE,
                     GI.SELECT_ORIGINAL_GAME_BY_TYPE,
                     GI.SELECT_CONTRIB_GAME_BY_TYPE,
                     ):
            gg = []
            for name, select_func in data:
                if name is None or not filter(select_func, self.all_games_gi):
                    continue
                gg.append(SelectGameNode(None, _(name), select_func))
            g.append(gg)

        def select_mahjongg_game(gi): return gi.si.game_type == GI.GT_MAHJONGG
        gg = None
        if filter(select_mahjongg_game, self.all_games_gi):
            gg = SelectGameNode(None, _("Mahjongg Games"),
                                select_mahjongg_game)
        g.append(gg)
        if g[0]:
            s_by_type = SelectGameNode(None, _("French games"),
                                       tuple(g[0]), expanded=1)
        if g[1]:
            s_oriental = SelectGameNode(None, _("Oriental Games"),
                                        tuple(g[1]))
        if g[2]:
            s_special = SelectGameNode(None, _("Special Games"),
                                       tuple(g[2]))
        if g[3]:
            s_original = SelectGameNode(None, _("Original Games"),
                                        tuple(g[3]))
#         if g[4]:
#           s_contrib = SelectGameNode(None, "Contributed Games", tuple(g[4]))
        if g[5]:
            s_mahjongg = g[5]
        #
        # all games sorted (in pieces).
        s_all_games, gg = None, []
        agames = self.all_games_gi
        n, d = 0, 17
        i = 0
        while True:
            # columnbreak = i > 0 and (i % d) == 0
            i += 1
            if not agames[n:n + d]:
                break
            m = min(n + d - 1, len(agames) - 1)
            label = agames[n].name[:4] + ' - ' + agames[m].name[:4]
            # print('label = %s' % label)

            ggg = []
            for ag in agames[n:n + d]:
                # print('game, id = %s, %s' % (ag.name, ag.id))
                ggg.append((ag.id, ag.name + ' (' + str(ag.id) + ')'))

            gg.append(SelectGameNode(None, label, UserList(ggg)))
            n += d
        if 1 and gg:
            s_all_games = SelectGameNode(None, _("All Games"), tuple(gg))
        #
        s_by_compatibility, gg = None, []
        for name, games in GI.GAMES_BY_COMPATIBILITY:
            def select_func(gi, games=games):
                return gi.id in games
            if name is None or not list(filter(
                    select_func, self.all_games_gi)):
                continue
            gg.append(SelectGameNode(None, name, select_func))
        if 1 and gg:
            s_by_compatibility = SelectGameNode(None, _("by Compatibility"),
                                                tuple(gg))
            pass
        #
        s_by_pysol_version, gg = None, []
        for name, games in GI.GAMES_BY_PYSOL_VERSION:
            def select_func(gi, games=games):
                return gi.id in games
            if name is None or not list(filter(
                    select_func, self.all_games_gi)):
                continue
            name = _("New games in v. %(version)s") % {'version': name}
            gg.append(SelectGameNode(None, name, select_func))
        if 1 and gg:
            s_by_pysol_version = SelectGameNode(None, _("by PySol version"),
                                                tuple(gg))
        #
        s_by_inventors, gg = None, []
        for name, games in GI.GAMES_BY_INVENTORS:
            def select_func(gi, games=games):
                return gi.id in games
            if name is None or not list(filter(
                    select_func, self.all_games_gi)):
                continue
            gg.append(SelectGameNode(None, name, select_func))
        if 1 and gg:
            s_by_inventors = SelectGameNode(None, _("by Inventors"),
                                            tuple(gg))
        #
        ul_alternate_names = UserList(
            list(app.gdb.getGamesTuplesSortedByAlternateName()))
        #
        self.rootnodes = [_f for _f in (
            # SelectGameNode(None, _("All Games"), None),
            SelectGameNode(None, _("Popular Games"),
                           lambda gi: gi.si.game_flags & GI.GT_POPULAR),
            s_mahjongg,
            s_oriental,
            s_special,
            # SelectGameNode(None, _("Custom Games"),
            #               lambda gi: gi.si.game_type == GI.GT_CUSTOM),
            SelectGameNode(None, _("Alternate Names"), ul_alternate_names),
            s_by_type,
            s_all_games,
            SelectGameNode(None, _('by Skill Level'), (
                SelectGameNode(None, _('Luck only'),
                           lambda gi: gi.skill_level == GI.SL_LUCK),
                SelectGameNode(None, _('Mostly luck'),
                           lambda gi: gi.skill_level == GI.SL_MOSTLY_LUCK),
                SelectGameNode(None, _('Balanced'),
                           lambda gi: gi.skill_level == GI.SL_BALANCED),
                SelectGameNode(None, _('Mostly skill'),
                           lambda gi: gi.skill_level == GI.SL_MOSTLY_SKILL),
                SelectGameNode(None, _('Skill only'),
                           lambda gi: gi.skill_level == GI.SL_SKILL),
            )),
            SelectGameNode(None, _("by Game Feature"), (
                SelectGameNode(None, _("by Number of Cards"), (
                    SelectGameNode(None, _("32 cards"),
                                   lambda gi: gi.si.ncards == 32),
                    SelectGameNode(None, _("48 cards"),
                                   lambda gi: gi.si.ncards == 48),
                    SelectGameNode(None, _("52 cards"),
                                   lambda gi: gi.si.ncards == 52),
                    SelectGameNode(None, _("64 cards"),
                                   lambda gi: gi.si.ncards == 64),
                    SelectGameNode(None, _("78 cards"),
                                   lambda gi: gi.si.ncards == 78),
                    SelectGameNode(None, _("104 cards"),
                                   lambda gi: gi.si.ncards == 104),
                    SelectGameNode(None, _("144 cards"),
                                   lambda gi: gi.si.ncards == 144),
                    SelectGameNode(None, _("Other number"),
                                   lambda gi: gi.si.ncards not in
                                   (32, 48, 52, 64, 78, 104, 144)),
                )),
                SelectGameNode(None, _("by Number of Decks"), (
                    SelectGameNode(None, _("1 deck games"),
                                   lambda gi: gi.si.decks == 1),
                    SelectGameNode(None, _("2 deck games"),
                                   lambda gi: gi.si.decks == 2),
                    SelectGameNode(None, _("3 deck games"),
                                   lambda gi: gi.si.decks == 3),
                    SelectGameNode(None, _("4 deck games"),
                                   lambda gi: gi.si.decks == 4),
                )),
                SelectGameNode(None, _("by Number of Redeals"), (
                    SelectGameNode(None, _("No redeal"),
                               lambda gi: gi.si.redeals == 0),
                    SelectGameNode(None, _("1 redeal"),
                               lambda gi: gi.si.redeals == 1),
                    SelectGameNode(None, _("2 redeals"),
                               lambda gi: gi.si.redeals == 2),
                    SelectGameNode(None, _("3 redeals"),
                               lambda gi: gi.si.redeals == 3),
                    SelectGameNode(None, _("Unlimited redeals"),
                               lambda gi: gi.si.redeals == -1),
                    SelectGameNode(None, "Variable redeals",
                               lambda gi: gi.si.redeals == -2),
                    SelectGameNode(None, _("Other number of redeals"),
                               lambda gi: gi.si.redeals not in
                               (-1, 0, 1, 2, 3)),
                )),
                s_by_compatibility,
            )),
            s_by_pysol_version,
            s_by_inventors,
            SelectGameNode(None, _("Other Categories"), (
                SelectGameNode(None, _("Games for Children (very easy)"),
                               lambda gi: gi.si.game_flags & GI.GT_CHILDREN),
                SelectGameNode(None, _("Games with Scoring"),
                               lambda gi: gi.si.game_flags & GI.GT_SCORE),
                SelectGameNode(None, _("Games with Separate Decks"),
                           lambda gi: gi.si.game_flags & GI.GT_SEPARATE_DECKS),
                SelectGameNode(None, _("Open Games (all cards visible)"),
                               lambda gi: gi.si.game_flags & GI.GT_OPEN),
                SelectGameNode(None, _("Relaxed Variants"),
                               lambda gi: gi.si.game_flags & GI.GT_RELAXED),
            )),
            s_original,
            s_contrib,
        ) if _f]


# ************************************************************************
# * Canvas that shows the tree
# ************************************************************************
'''
class SelectGameTreeWithPreview(SelectDialogTreeCanvas):
    data = None


class SelectGameTree(SelectGameTreeWithPreview):
    def singleClick(self, event=None):
        self.doubleClick(event)
'''
# ************************************************************************
# * Kivy support
# ************************************************************************


class LGameRoot(LTreeRoot):
    def __init__(self, gametree, gameview, **kw):
        super(LGameRoot, self).__init__(**kw)
        self.gametree = gametree
        self.gameview = gameview
        self.kw = kw


class LGameNode(LTreeNode):
    def __init__(self, gamenode, gameview, **kw):

        self.lastpos = None
        self.gamenode = gamenode
        self.gameview = gameview
        super(LGameNode, self).__init__(**kw)

        self.coreFont = self.font_size
        # self.scaleFont(self.gameview.size[1])
        # self.gameview.bind(size=self.scaleFontCB)

        self.command = None
        if 'command' in kw:
            self.command = kw['command']
        self.bind(on_release=self.on_released)

    # font skalierung.

    def scaleFont(self, value):
        self.font_size = int(self.coreFont * value / 550.0)

    def scaleFontCB(self, instance, value):
        self.scaleFont(value[1])

    # benutzer interaktion.

    def on_released(self, v):
        if self.gamenode.key:
            if self.command:
                # print('game number = %s' % self.gamenode.key)
                Clock.schedule_once(self.commandCB, 0.1)
        else:
            # verzögert aufrufen, wegen user feedback.
            Clock.schedule_once(self.toggleCB, 0.1)
    '''
    def on_touch_move(self, touch):
        if self.collide_point(*touch.pos):
            if self.lastpos==None:
                self.lastpos = touch.pos
                print('touch.pos %s' % str(touch.pos))
                return

            print ('touch move on %s - %s' % (self.text, touch.profile))
            print('touch.pos(2) %s' % str(touch.pos))
            # tbd: nur wenn horizontal move !
            if (touch.pos[0]+2) < self.lastpos[0]:
                Clock.schedule_once(self.collapseParentCB, 0.1)
        pass
    '''

    def commandCB(self, d):
        self.command(self.gamenode.key)

    def toggleCB(self, d):
        self.parent.toggle_node(self)

    '''
    def collapseParentCB(self, d):
        if self.parent:
            if self.parent_node.is_open:
                self.parent.toggle_node(self.parent_node)
            self.lastpos = None
    '''
# ************************************************************************
# * Dialog
# ************************************************************************


class SelectGameDialog(object):

    # Dialog, einmal erzeugt, wird rezykliert.
    SingleInstance = None

    def onClick(self, event):
        print('LTopLevel: onClick')
        SelectGameDialog.SingleInstance.parent.popWork('SelectGame')
        SelectGameDialog.SingleInstance.running = False

    def selectCmd(self, gameid):
        self.app.menubar._mSelectGame(gameid)

    def __init__(self, parent, title, app, gameid, **kw):
        super(SelectGameDialog, self).__init__()

        self.parent = parent
        self.app = app
        self.gameid = gameid
        self.random = None
        self.running = False
        self.window = None

        # bestehenden Dialog rezyklieren.

        si = SelectGameDialog.SingleInstance
        # if (si and si.running): return
        if (si and si.running):
            si.parent.popWork('SelectGame')
            si.running = False
            return
        if (si):
            si.parent.pushWork('SelectGame', si.window)
            si.running = True
            return

        # neuen Dialog aufbauen.

        window = LTopLevel(parent, title)
        window.titleline.bind(on_press=self.onClick)
        self.parent.pushWork('SelectGame', window)
        self.window = window
        self.running = True
        SelectGameDialog.SingleInstance = self

        # Asynchron laden.

        def loaderCB(treeview, node):

            # Beispielcode aus doku:
            #
            # for name in ('Item 1', 'Item 2'):
            #   yield TreeViewLabel(text=name, parent=node)
            #
            # LGameNode ist ein Button. Es stellt sich heraus, dass
            # wir (ev. darum) parent=node NICHT setzen dürfen, da das
            # sonst zum versuchten doppelten einfügen des gleichen
            # widget im tree führt.

            if node:
                if not hasattr(node, "gamenode"):
                    # (das löst ein problem mit dem root knoten),
                    return

            v = treeview.gameview
            if node:
                n = node.gamenode
                n.tree = treeview.gametree

                nodes = n.getContents()
                if type(nodes) is list:
                    # Blaetter
                    for l in nodes:
                        # print ('**game=%s' % l.text)
                        yield LGameNode(
                            l, v, text=l.text,
                            is_leaf=True,
                            command=self.selectCmd)

                if type(nodes) is tuple:
                    # Knoten
                    for nn in nodes:
                        # print ('**node=%s' % nn.text)
                        newnode = LGameNode(
                            nn, v, text=nn.text, is_leaf=False)
                        yield newnode

                    print('all nodes done')
            else:
                # Knoten
                nodes = treeview.gametree.rootnodes[:]
                for n in nodes:
                    newnode = LGameNode(n, v, text=n.text, is_leaf=False)
                    # print ('**node=%s' % newnode)
                    yield newnode

        # treeview aufsetzen.

        tree = SelectGameData(app)
        tv = self.tvroot = LGameRoot(
            tree,
            self.app.canvas,
            root_options=dict(text='Tree One'))
        tv.size_hint = 1, None
        tv.hide_root = True
        tv.load_func = loaderCB
        tv.bind(minimum_height=tv.setter('height'))

        # tree in einem Scrollwindow präsentieren.

        root = LScrollView(pos=(0, 0))
        root.add_widget(tv)
        window.content.add_widget(root)

# ************************************************************************
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##
from pysollib.mygettext import _
from pysollib.settings import TITLE
from pysollib.ui.tktile.tkconst import EVENT_HANDLED

from six.moves import tkinter


class BaseSolverDialog:
    def _ToggleShowProgressButton(self, *args):
        self.app.opt.solver_show_progress = self.progress_var.get()

    def _getMaxIters(self):
        try:
            i = self.max_iters_var.get()
        except Exception:
            i = 100000
        return i

    def _OnAssignToMaxIters(self, *args):
        self.app.opt.solver_max_iterations = self._getMaxIters()

    def _OnAssignToPreset(self, *args):
        self.app.opt.solver_preset = self.preset_var.get()

    def __init__(self, parent, app, **kw):
        self.parent = parent
        self.app = app
        title = _('%(app)s - FreeCell Solver') % {'app': TITLE}
        kw = self.initKw(kw)
        self._calc_MfxDialog().__init__(
            self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.createBitmaps(top_frame, kw)
        self.games = {}                 # key: gamename; value: gameid

        #
        frame = self._calcToolkit().Frame(top_frame)
        frame.pack(expand=True, fill='both', padx=4, pady=4)
        frame.columnconfigure(1, weight=1)

        #
        row = 0
        self._calcToolkit().Label(
            frame, text=_('Game:'), anchor='w').grid(
            row=row, column=0, sticky='ew', padx=2, pady=2)
        games = app.getGamesForSolver()
        gamenames = ['']
        for id in games:
            name = app.getGameTitleName(id)
            gamenames.append(name)
            self.games[name] = id
        gamenames.sort()
        self.gamenames = gamenames
        self.games_var = self._createGamesVar(frame, row)

        #
        row += 1
        self._calcToolkit().Label(
            frame, text=_('Preset:'), anchor='w').grid(
            row=row, column=0, sticky='ew', padx=2, pady=2)
        presets = app.opt.solver_presets
        self.presets = presets
        self.preset_var = self._createPresetVar(frame, row)
        self.preset_var.set(self.app.opt.solver_preset)

        #
        row += 1
        self.max_iters_var = tkinter.IntVar()
        self.max_iters_var.set(self.app.opt.solver_max_iterations)
        self._calcToolkit().Label(
            frame, text=_('Max iterations:'), anchor='w').grid(
            row=row, column=0, sticky='ew', padx=2, pady=2)
        spin = tkinter.Spinbox(frame, bg='white', from_=1000, to=10e6,
                               increment=1000, textvariable=self.max_iters_var)
        self.max_iters_var.trace('w', self._OnAssignToMaxIters)
        spin.grid(row=row, column=1, sticky='w', padx=2, pady=2)

        #
        row += 1
        self.progress_var = tkinter.BooleanVar()
        self.progress_var.set(self.app.opt.solver_show_progress)
        w = self._createShowProgressButton(frame)
        w.grid(row=row, column=0, columnspan=2, sticky='ew', padx=2, pady=2)
        w.config(command=self._ToggleShowProgressButton)

        #
        label_frame = self._calcToolkit().LabelFrame(
            top_frame, text=_('Progress'))
        label_frame.pack(expand=True, fill='both', padx=6, pady=2)
        # label_frame.columnconfigure(0, weight=1)
        label_frame.columnconfigure(1, weight=1)

        #
        frow = 0
        self._calcToolkit().Label(
            label_frame, text=_('Iteration:'), anchor='w').grid(
            row=frow, column=0, sticky='ew', padx=4, pady=2)
        lb = self._calcToolkit().Label(label_frame, anchor='w')
        lb.grid(row=frow, column=1, sticky='ew', padx=4, pady=2)
        self.iter_label = lb
        frow += 1
        self._calcToolkit().Label(
            label_frame, text=_('Depth:'), anchor='w').grid(
            row=frow, column=0, sticky='ew', padx=4, pady=2)
        lb = self._calcToolkit().Label(label_frame, anchor='w')
        lb.grid(row=frow, column=1, sticky='ew', padx=4, pady=2)
        self.depth_label = lb
        frow += 1
        self._calcToolkit().Label(
            label_frame, text=_('Stored-States:'), anchor='w').grid(
            row=frow, column=0, sticky='ew', padx=4, pady=2)
        lb = self._calcToolkit().Label(label_frame, anchor='w')
        lb.grid(row=frow, column=1, sticky='ew', padx=4, pady=2)
        self.states_label = lb

        #
        lb = self._calcToolkit().Label(top_frame, anchor='w')
        lb.pack(expand=True, fill='x', padx=6, pady=4)
        self.result_label = lb

        #
        focus = self.createButtons(bottom_frame, kw)
        self.start_button = self.buttons[0]
        self.play_button = self.buttons[1]
        self._reset()
        self.connectGame(self.app.game)
        self.mainloop(focus, kw.timeout, transient=False)

    def mDone(self, button):
        if button == 0:
            self.startSolving()
        elif button == 1:
            self.startPlay()
        elif button == 2:
            self.app.menubar.mNewGame()
        elif button == 3:
            global solver_dialog
            solver_dialog = None
            self.destroy()
        return EVENT_HANDLED

    def mCancel(self, *event):
        return self.mDone(3)

    def wmDeleteWindow(self, *event):
        return self.mDone(3)

    def gameSelected(self, *event):
        name = self.games_var.get()
        if not name:
            return
        id = self.games[name]
        self.app.menubar._mSelectGame(id)

    def _reset(self):
        self.play_button.config(state='disabled')
        self.setText(iter='', depth='', states='')
        self.result_label['text'] = ''
        self.top.update_idletasks()

    def reset(self):
        self.play_button.config(state='disabled')

    def startSolving(self):
        from pysollib.mygettext import ungettext

        self._reset()
        game = self.app.game
        solver = game.Solver_Class(game, self)  # create solver instance
        game.solver = solver
        preset = self.preset_var.get()
        max_iters = self._getMaxIters()
        progress = self.app.opt.solver_show_progress
        iters_step = self.app.opt.solver_iterations_output_step
        solver.config(preset=preset, max_iters=max_iters, progress=progress,
                      iters_step=iters_step)
        try:
            solver.computeHints()
        except RuntimeError:
            self.result_label['text'] = _('Solver not found in the PATH')
            return
        hints_len = len(solver.hints)-1
        if hints_len > 0:
            if solver.solver_state == 'intractable':
                t = ungettext('This game can be hinted in %d move.',
                              'This game can be hinted in %d moves.',
                              hints_len)
            else:
                t = ungettext('This game is solvable in %d move.',
                              'This game is solvable in %d moves.',
                              hints_len)
            t = t % hints_len
            self.result_label['text'] = t
            self.play_button.config(state='normal')
        else:
            self.result_label['text'] = \
                (_('I could not solve this game.')
                 if solver.solver_state == 'unsolved'
                 else _('Iterations count exceeded (Intractable)'))
            self.play_button.config(state='disabled')

    def startPlay(self):
        self.play_button.config(state='disabled')
        self.start_button.focus()
        if self.app.game.pause:
            self.app.menubar.mPause()
        self.app.top.tkraise()
        self.app.top.update_idletasks()
        self.app.top.update()
        self.app.top.after(200)
        self.app.game.startDemo(level=3)

    def setText(self, **kw):
        if 'iter' in kw:
            self.iter_label['text'] = kw['iter']
        if 'depth' in kw:
            self.depth_label['text'] = kw['depth']
        if 'states' in kw:
            self.states_label['text'] = kw['states']
        self.top.update_idletasks()


solver_dialog = None


def connect_game_solver_dialog(game):
    try:
        solver_dialog.connectGame(game)
    except Exception:
        pass


def destroy_solver_dialog():
    global solver_dialog
    try:
        solver_dialog.destroy()
    except Exception:
        # traceback.print_exc()
        pass
    solver_dialog = None


def reset_solver_dialog():
    if solver_dialog:
        try:
            solver_dialog.reset()
        except Exception:
            # traceback.print_exc()
            pass
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

# ************************************************************************
# * Nodes
# ************************************************************************

# imports
from six.moves import tkinter_font


class BaseSelectDialogTreeLeaf:
    def drawSymbol(self, x, y, **kw):
        if self.tree.nodes.get(self.symbol_id) is not self:
            self.symbol_id = self.tree.canvas.create_image(
                x, y,
                image=self.tree.data.img[2+(self.key is None)], anchor="nw")
            self.tree.nodes[self.symbol_id] = self


class BaseSelectDialogTreeNode:
    def __init__(self, tree, text, select_func, expanded=0, parent_node=None):
        self._calc_MfxTreeNode().__init__(
            self, tree, parent_node, text, key=None, expanded=expanded)
        # callable or a tuple/list of MfxTreeNodes
        self.select_func = select_func

    def drawSymbol(self, x, y, **kw):
        if self.tree.nodes.get(self.symbol_id) is not self:
            self.symbol_id = self.tree.canvas.create_image(
                x, y,
                image=self.tree.data.img[self.expanded], anchor="nw")
            self.tree.nodes[self.symbol_id] = self

    def getContents(self):
        # cached values
        if self.subnodes is not None:
            return self.subnodes
        # print self.whoami()
        if isinstance(self.select_func, (tuple, list)):
            return self.select_func
        return self._getContents()

    def _getContents(self):
        # subclass
        return []


# ************************************************************************
# * Tree database
# ************************************************************************

class SelectDialogTreeData:
    img = []  # loaded in Application.loadImages3

    def __init__(self):
        self.tree_xview = (0.0, 1.0)
        self.tree_yview = (0.0, 1.0)


# ************************************************************************
# * Canvas that shows the tree (left side)
# ************************************************************************

class BaseSelectDialogTreeCanvas:
    def __init__(self, dialog, parent, key, default,
                 font=None, width=-1, height=-1, hbar=2, vbar=3):
        self.dialog = dialog
        self.default = default
        self.n_selections = 0
        self.n_expansions = 0
        #
        disty = 16
        if width < 0:
            width = 400
        if height < 0:
            height = 20 * disty
            if parent and parent.winfo_screenheight() >= 600:
                height = 25 * disty
            if parent and parent.winfo_screenheight() >= 800:
                height = 30 * disty
        self.lines = height // disty
        self._calc_MfxTreeInCanvas().__init__(
                self, parent, self.data.rootnodes,
                width=width, height=height,
                hbar=hbar, vbar=vbar)
        self.style.distx = 20
        self.style.disty = disty
        self.style.width = 16     # width of symbol
        self.style.height = 14    # height of symbol
        if font:
            self.style.font = font
            f = tkinter_font.Font(parent, font)
            h = f.metrics()["linespace"]
            self.style.disty = max(self.style.width, h)

        self.draw()
        self.updateSelection(key)
        if self.hbar:
            # print self.data.tree_yview
            # print self.canvas.xview()
            self.canvas.xview_moveto(self.data.tree_xview[0])
        if self.vbar:
            # print self.data.tree_yview
            # print self.canvas.yview()
            self.canvas.yview_moveto(self.data.tree_yview[0])

    def destroy(self):
        if self.n_expansions > 0:   # must save updated xyview
            self.data.tree_xview = self.canvas.xview()
            self.data.tree_yview = self.canvas.yview()
        self._calc_MfxTreeInCanvas().destroy(self)

    def getContents(self, node):
        return node.getContents()

    def singleClick(self, event=None):
        node = self.findNode()
        if isinstance(node, self._calc_MfxTreeLeaf()):
            if not node.selected and node.key is not None:
                oldcur = self.canvas["cursor"]
                self.canvas["cursor"] = "watch"
                self.canvas.update_idletasks()
                self.n_selections = self.n_selections + 1
                self.updateSelection(node.key)
                self.dialog.updatePreview(self.selection_key)
                self.canvas["cursor"] = oldcur
        elif isinstance(node, self._calc_MfxTreeNode()):
            self.n_expansions = self.n_expansions + 1
            node.expanded = not node.expanded
            self.redraw()
        return "break"

    def doubleClick(self, event=None):
        node = self.findNode()
        if isinstance(node, self._calc_MfxTreeLeaf()):
            if node.key is not None:
                self.n_selections = self.n_selections + 1
                self.updateSelection(node.key)
                self.dialog.mDone(self.default)
        elif isinstance(node, self._calc_MfxTreeNode()):
            self.n_expansions = self.n_expansions + 1
            node.expanded = not node.expanded
            self.redraw()
        return "break"
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

from pysollib.mfxutil import KwStruct
from pysollib.mygettext import _

from six.moves import tkinter
from six.moves.tkinter_colorchooser import askcolor


class BaseColorsDialog:
    def _calcFrame(self):
        return self._calcToolkit().Frame

    def _calcLabel(self):
        return self._calcToolkit().Label

    def _calcButton(self):
        return self._calcToolkit().Button

    def __init__(self, parent, title, app, **kw):
        kw = self.initKw(kw)
        self._calc_MfxDialog().__init__(
            self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.createBitmaps(top_frame, kw)

        frame = self._calcFrame()(top_frame)
        frame.pack(expand=True, fill='both', padx=5, pady=10)
        frame.columnconfigure(0, weight=1)

        self.text_var = tkinter.StringVar()
        self.text_var.set(app.opt.colors['text'])
        self.piles_var = tkinter.StringVar()
        self.piles_var.set(app.opt.colors['piles'])
        self.cards_1_var = tkinter.StringVar()
        self.cards_1_var.set(app.opt.colors['cards_1'])
        self.cards_2_var = tkinter.StringVar()
        self.cards_2_var.set(app.opt.colors['cards_2'])
        self.samerank_1_var = tkinter.StringVar()
        self.samerank_1_var.set(app.opt.colors['samerank_1'])
        self.samerank_2_var = tkinter.StringVar()
        self.samerank_2_var.set(app.opt.colors['samerank_2'])
        self.hintarrow_var = tkinter.StringVar()
        self.hintarrow_var.set(app.opt.colors['hintarrow'])
        self.not_matching_var = tkinter.StringVar()
        self.not_matching_var.set(app.opt.colors['not_matching'])
        #
        row = 0
        for title, var in (
            (_('Text foreground:'),        self.text_var),
            (_('Highlight piles:'),        self.piles_var),
            (_('Highlight cards 1:'),      self.cards_1_var),
            (_('Highlight cards 2:'),      self.cards_2_var),
            (_('Highlight same rank 1:'),  self.samerank_1_var),
            (_('Highlight same rank 2:'),  self.samerank_2_var),
            (_('Hint arrow:'),             self.hintarrow_var),
            (_('Highlight not matching:'), self.not_matching_var),
                ):
            self._calcLabel()(
                frame, text=title, anchor='w',).grid(
                row=row, column=0, sticky='we')
            label = tkinter.Label(frame, width=10, height=2,
                                  bg=var.get(), textvariable=var)
            label.grid(row=row, column=1, padx=5)
            b = self._calcButton()(
                frame, text=_('Change...'), width=10,
                command=lambda label=label: self.selectColor(label))
            b.grid(row=row, column=2)
            row += 1
        #
        focus = self.createButtons(bottom_frame, kw)
        self.mainloop(focus, kw.timeout)
        #
        self.text_color = self.text_var.get()
        self.piles_color = self.piles_var.get()
        self.cards_1_color = self.cards_1_var.get()
        self.cards_2_color = self.cards_2_var.get()
        self.samerank_1_color = self.samerank_1_var.get()
        self.samerank_2_color = self.samerank_2_var.get()
        self.hintarrow_color = self.hintarrow_var.get()
        self.not_matching_color = self.not_matching_var.get()

    def selectColor(self, label):
        try:
            c = askcolor(parent=self.top, initialcolor=label.cget('bg'),
                         title=_("Select color"))
        except Exception:
            pass
        else:
            if c and c[1]:
                label.configure(bg=c[1])
                # label.configure(text=c[1]) # don't work
                label.setvar(label.cget('textvariable'), c[1])

    def initKw(self, kw):
        kw = KwStruct(kw,
                      strings=(_("&OK"), _("&Cancel")),
                      default=0,
                      )
        return self._calc_MfxDialog().initKw(self, kw)
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

import formatter
import os
import sys

import pysollib.htmllib2 as htmllib
from pysollib.mfxutil import openURL
from pysollib.mygettext import _
from pysollib.settings import TITLE
from pysollib.ui.tktile.tkutil import bind, unbind_destroy

from six.moves import tkinter

REMOTE_PROTOCOLS = ("ftp:", "gopher:", "http:", "mailto:", "news:", "telnet:")

# ************************************************************************
# *
# ************************************************************************


class tkHTMLWriter(formatter.NullWriter):
    def __init__(self, text, viewer, app):
        formatter.NullWriter.__init__(self)

        self.text = text
        self.viewer = viewer

        if app:
            font = app.getFont("sans")
            fixed = app.getFont("fixed")
        else:
            font = ('helvetica', 12)
            fixed = ('courier', 12)
        size = font[1]
        sign = 1
        if size < 0:
            sign = -1
        self.fontmap = {
            "h1": (font[0], size + 12*sign, "bold"),
            "h2": (font[0], size + 8*sign, "bold"),
            "h3": (font[0], size + 6*sign, "bold"),
            "h4": (font[0], size + 4*sign, "bold"),
            "h5": (font[0], size + 2*sign, "bold"),
            "h6": (font[0], size + 1*sign, "bold"),
            "bold": (font[0], size, "bold"),
            "italic": (font[0], size, "italic"),
            "pre": fixed,
        }

        self.text.config(cursor=self.viewer.defcursor, font=font)
        for f in self.fontmap.keys():
            self.text.tag_config(f, font=self.fontmap[f])

        self.anchor = None
        self.anchor_mark = None
        self.font = None
        self.font_mark = None
        self.indent = ""

    def createCallback(self, href):
        class Functor:
            def __init__(self, viewer, arg):
                self.viewer = viewer
                self.arg = arg

            def __call__(self, *args):
                self.viewer.updateHistoryXYView()
                return self.viewer.display(self.arg)
        return Functor(self.viewer, href)

    def write(self, data):
        self.text.insert("insert", str(data))

    def anchor_bgn(self, href, name, type):
        if href:
            # self.text.update_idletasks()   # update display during parsing
            self.anchor = (href, name, type)
            self.anchor_mark = self.text.index("insert")

    def anchor_end(self):
        if self.anchor:
            url = self.anchor[0]
            tag = "href_" + url
            self.text.tag_add(tag, self.anchor_mark, "insert")
            self.text.tag_bind(tag, "<1>", self.createCallback(url))
            self.text.tag_bind(
                tag, "<Enter>", lambda e: self.anchor_enter(url))
            self.text.tag_bind(tag, "<Leave>", self.anchor_leave)
            fg = 'blue'
            u = self.viewer.normurl(url, with_protocol=False)
            if u in self.viewer.visited_urls:
                fg = '#660099'
            self.text.tag_config(tag, foreground=fg, underline=1)
            self.anchor = None

    def anchor_enter(self, url):
        url = self.viewer.normurl(url)
        self.viewer.statusbar.updateText(url=url)
        self.text.config(cursor=self.viewer.handcursor)

    def anchor_leave(self, *args):
        self.viewer.statusbar.updateText(url='')
        self.text.config(cursor=self.viewer.defcursor)

    def new_font(self, font):
        # end the current font
        if self.font:
            # print "end_font(%s)" % `self.font`
            self.text.tag_add(self.font, self.font_mark, "insert")
            self.font = None
        # start the new font
        if font:
            # print "start_font(%s)" % `font`
            self.font_mark = self.text.index("insert")
            if font[0] in self.fontmap:
                self.font = font[0]
            elif font[3]:
                self.font = "pre"
            elif font[2]:
                self.font = "bold"
            elif font[1]:
                self.font = "italic"
            else:
                self.font = None

    def new_margin(self, margin, level):
        self.indent = "    " * level

    def send_label_data(self, data):
        # self.write(self.indent + data + " ")
        self.write(self.indent)
        if data == '*':  # <li>
            img = self.viewer.symbols_img.get('disk')
            if img:
                self.text.image_create(index='insert', image=img,
                                       padx=0, pady=0)
            else:
                self.write('*')
        else:
            self.write(data)
        self.write(' ')

    def send_paragraph(self, blankline):
        self.write("\n" * blankline)

    def send_line_break(self):
        self.write("\n")

    def send_hor_rule(self, *args):
        width = int(int(self.text["width"]) * 0.9)
        self.write("_" * width)
        self.write("\n")

    def send_literal_data(self, data):
        self.write(data)

    def send_flowing_data(self, data):
        self.write(data)


# ************************************************************************
# *
# ************************************************************************

class tkHTMLParser(htmllib.HTMLParser):
    def anchor_bgn(self, href, name, type):
        self.formatter.flush_softspace()
        htmllib.HTMLParser.anchor_bgn(self, href, name, type)
        self.formatter.writer.anchor_bgn(href, name, type)

    def anchor_end(self):
        if self.anchor:
            self.anchor = None
        self.formatter.writer.anchor_end()

    def do_dt(self, attrs):
        self.formatter.end_paragraph(1)
        self.ddpop()

    def handle_image(self, src, alt, ismap, align, width, height):
        self.formatter.writer.viewer.showImage(
            src, alt, ismap, align, width, height)


class Base_HTMLViewer:
    def initBindings(self):
        w = self.parent
        bind(w, "WM_DELETE_WINDOW", self.destroy)
        bind(w, "<Escape>", self.destroy)
        bind(w, "<KeyPress-Prior>", self.page_up)
        bind(w, "<KeyPress-Next>", self.page_down)
        bind(w, "<KeyPress-Up>", self.unit_up)
        bind(w, "<KeyPress-Down>", self.unit_down)
        bind(w, "<KeyPress-Begin>", self.scroll_top)
        bind(w, "<KeyPress-Home>", self.scroll_top)
        bind(w, "<KeyPress-End>", self.scroll_bottom)
        bind(w, "<KeyPress-BackSpace>", self.goBack)

    def destroy(self, *event):
        unbind_destroy(self.parent)
        try:
            self.parent.wm_withdraw()
        except Exception:
            pass
        try:
            self.parent.destroy()
        except Exception:
            pass
        self.parent = None

    def _yview(self, *args):
        self.text.yview(*args)
        return 'break'

    def page_up(self, *event):
        return self._yview('scroll', -1, 'page')

    def page_down(self, *event):
        return self._yview('scroll', 1, 'page')

    def unit_up(self, *event):
        return self._yview('scroll', -1, 'unit')

    def unit_down(self, *event):
        return self._yview('scroll', 1, 'unit')

    def scroll_top(self, *event):
        return self._yview('moveto', 0)

    def scroll_bottom(self, *event):
        return self._yview('moveto', 1)

    # locate a file relative to the current self.url
    def basejoin(self, url, baseurl=None, relpath=1):
        if baseurl is None:
            baseurl = self.url
        if 0:
            import urllib.request
            import urllib.parse
            import urllib.error
            url = urllib.request.pathname2url(url)
            if relpath and self.url:
                url = urllib.basejoin(baseurl, url)
        else:
            url = os.path.normpath(url)
            if relpath and baseurl and not os.path.isabs(url):
                h1, t1 = os.path.split(url)
                h2, t2 = os.path.split(baseurl)
                if h1 != h2:
                    url = os.path.join(h2, h1, t1)
                url = os.path.normpath(url)
        return url

    def normurl(self, url, with_protocol=True):
        for p in REMOTE_PROTOCOLS:
            if url.startswith(p):
                break
        else:
            url = self.basejoin(url)
            if with_protocol:
                if os.name == 'nt':
                    url = url.replace('\\', '/')
                url = 'file://'+url
        return url

    def openfile(self, url):
        if url[-1:] == "/" or os.path.isdir(url):
            url = os.path.join(url, "index.html")
        url = os.path.normpath(url)

        def my_open(url):
            if sys.version_info > (3,):
                import codecs
                return codecs.open(url, encoding='utf-8')
            else:
                return open(url, "rb")
        return my_open(url), url

    def display(self, url, add=1, relpath=1, xview=0, yview=0):
        # for some reason we have to stop the PySol demo
        # (is this a multithread problem with tkinter ?)
        if self.app and self.app.game:
            self.app.game.stopDemo()
            # self.app.game._cancelDrag()
            # pass

        # ftp: and http: would work if we use urllib, but this widget is
        # far too limited to display anything but our documentation...
        for p in REMOTE_PROTOCOLS:
            if url.startswith(p):
                if not openURL(url):
                    self.errorDialog(_('''%(app)s HTML limitation:
The %(protocol)s protocol is not supported yet.

Please use your standard web browser
to open the following URL:
%(url)s
''') % {'app': TITLE, 'protocol': p, 'url': url})
                return

        # locate the file relative to the current url
        url = self.basejoin(url, relpath=relpath)

        # read the file
        try:
            file = None
            if 0:
                import urllib.request
                import urllib.parse
                import urllib.error
                file = urllib.request.urlopen(url)
            else:
                file, url = self.openfile(url)
            data = file.read()
            file.close()
            file = None
        except Exception as ex:
            if file:
                file.close()
            self.errorDialog(_("Unable to service request:\n") + url +
                             "\n\n" + str(ex))
            return
        except Exception:
            if file:
                file.close()
            self.errorDialog(_("Unable to service request:\n") + url)
            return

        self.url = url
        if self.home is None:
            self.home = self.url
        if add:
            self.addHistory(self.url, xview=xview, yview=yview)

        # print self.history.index, self.history.list
        if self.history.index > 1:
            self.backButton.config(state="normal")
        else:
            self.backButton.config(state="disabled")
        if self.history.index < len(self.history.list):
            self.forwardButton.config(state="normal")
        else:
            self.forwardButton.config(state="disabled")

        old_c1, old_c2 = self.defcursor, self.handcursor
        self.defcursor = self.handcursor = "watch"
        self.text.config(cursor=self.defcursor)
        self.text.update_idletasks()
        # self.frame.config(cursor=self.defcursor)
        # self.frame.update_idletasks()
        self.text.config(state="normal")
        self.text.delete("1.0", "end")
        # self.images = {}
        writer = tkHTMLWriter(self.text, self, self.app)
        fmt = formatter.AbstractFormatter(writer)
        parser = tkHTMLParser(fmt)
        parser.feed(data)
        parser.close()
        self.text.config(state="disabled")
        if 0.0 <= xview <= 1.0:
            self.text.xview_moveto(xview)
        if 0.0 <= yview <= 1.0:
            self.text.yview_moveto(yview)
        self.parent.wm_title(parser.title)
        self.parent.wm_iconname(parser.title)
        self.defcursor, self.handcursor = old_c1, old_c2
        self.text.config(cursor=self.defcursor)
        # self.frame.config(cursor=self.defcursor)

    def addHistory(self, url, xview=0, yview=0):
        if url not in self.visited_urls:
            self.visited_urls.append(url)
        if self.history.index > 0:
            u, xv, yv = self.history.list[self.history.index-1]
            if u == url:
                self.updateHistoryXYView()
                return
        del self.history.list[self.history.index:]
        self.history.list.append((url, xview, yview))
        self.history.index = self.history.index + 1

    def updateHistoryXYView(self):
        if self.history.index > 0:
            url, xview, yview = self.history.list[self.history.index-1]
            xview = self.text.xview()[0]
            yview = self.text.yview()[0]
            self.history.list[self.history.index-1] = (url, xview, yview)

    def goBack(self, *event):
        if self.history.index > 1:
            self.updateHistoryXYView()
            self.history.index = self.history.index - 1
            url, xview, yview = self.history.list[self.history.index-1]
            self.display(url, add=0, relpath=0, xview=xview, yview=yview)

    def goForward(self, *event):
        if self.history.index < len(self.history.list):
            self.updateHistoryXYView()
            url, xview, yview = self.history.list[self.history.index]
            self.history.index = self.history.index + 1
            self.display(url, add=0, relpath=0, xview=xview, yview=yview)

    def goHome(self, *event):
        if self.home and self.home != self.url:
            self.updateHistoryXYView()
            self.display(self.home, relpath=0)

    def errorDialog(self, msg):
        self._calc_MfxMessageDialog()(
            self.parent, title="%(app)s HTML Problem" % {'app': TITLE},
            text=msg,
            # bitmap="warning", # FIXME: this interp don't have images
            strings=(_("&OK"),), default=0)

    def getImage(self, fn):
        if fn in self.images:
            return self.images[fn]
        try:
            img = tkinter.PhotoImage(master=self.parent, file=fn)
        except Exception:
            img = None
        self.images[fn] = img
        return img

    def showImage(self, src, alt, ismap, align, width, height):
        url = self.basejoin(src)
        img = self.getImage(url)
        if img:
            self.text.image_create(index="insert", image=img, padx=0, pady=0)
import math
import os
import re
import sys

from pysollib.gamedb import GI
from pysollib.hint import PySolHintLayoutImportError
from pysollib.mfxutil import Image, USE_PIL
from pysollib.mfxutil import Struct, kwdefault
from pysollib.mygettext import _, n_
from pysollib.settings import SELECT_GAME_MENU
from pysollib.settings import TITLE, WIN_SYSTEM
from pysollib.settings import USE_FREECELL_SOLVER
from pysollib.ui.tktile.tkconst import COMPOUNDS, CURSOR_WATCH, EVENT_HANDLED
from pysollib.ui.tktile.tkconst import EVENT_PROPAGATE
from pysollib.ui.tktile.tkconst import TOOLBAR_BUTTONS
from pysollib.ui.tktile.tkutil import after_idle, bind

from six.moves import tkinter
from six.moves import tkinter_tkfiledialog


def createToolbarMenu(menubar, menu):
    tearoff = menu.cget('tearoff')
#     data_dir = os.path.join(menubar.app.dataloader.dir, 'images', 'toolbar')
#     submenu = MfxMenu(menu, label=n_('Style'), tearoff=tearoff)
#     for f in os.listdir(data_dir):
#         d = os.path.join(data_dir, f)
#         if os.path.isdir(d) and os.path.exists(os.path.join(d, 'small')):
#             name = f.replace('_', ' ').capitalize()
#             submenu.add_radiobutton(
#               label=name,
#               variable=menubar.tkopt.toolbar_style,
#               value=f, command=menubar.mOptToolbarStyle)
    submenu = MfxMenu(menu, label=n_('Compound'), tearoff=tearoff)
    for comp, label in COMPOUNDS:
        submenu.add_radiobutton(
            label=label, variable=menubar.tkopt.toolbar_compound,
            value=comp, command=menubar.mOptToolbarCompound)
    menu.add_separator()
    menu.add_radiobutton(label=n_("Hide"),
                         variable=menubar.tkopt.toolbar, value=0,
                         command=menubar.mOptToolbar)
    menu.add_radiobutton(label=n_("Top"),
                         variable=menubar.tkopt.toolbar, value=1,
                         command=menubar.mOptToolbar)
    menu.add_radiobutton(label=n_("Bottom"),
                         variable=menubar.tkopt.toolbar, value=2,
                         command=menubar.mOptToolbar)
    menu.add_radiobutton(label=n_("Left"),
                         variable=menubar.tkopt.toolbar, value=3,
                         command=menubar.mOptToolbar)
    menu.add_radiobutton(label=n_("Right"),
                         variable=menubar.tkopt.toolbar, value=4,
                         command=menubar.mOptToolbar)
    #  menu.add_separator()
    #  menu.add_radiobutton(label=n_("Small icons"),
    #                       variable=menubar.tkopt.toolbar_size, value=0,
    #                       command=menubar.mOptToolbarSize)
    #  menu.add_radiobutton(label=n_("Large icons"),
    #                       variable=menubar.tkopt.toolbar_size, value=1,
    #                       command=menubar.mOptToolbarSize)
    menu.add_separator()
    submenu = MfxMenu(menu, label=n_('Visible buttons'), tearoff=tearoff)
    for w in TOOLBAR_BUTTONS:
        submenu.add_checkbutton(
            label=_(w.capitalize()),
            variable=menubar.tkopt.toolbar_vars[w],
            command=lambda m=menubar, w=w: m.mOptToolbarConfig(w))


# ************************************************************************
# *
# ************************************************************************

class MfxMenubar(tkinter.Menu):
    addPath = None

    def __init__(self, master, **kw):
        self.name = kw["name"]
        tearoff = 0
        self.n = kw["tearoff"] = int(kw.get("tearoff", tearoff))
        tkinter.Menu.__init__(self, master, **kw)

    def labeltoname(self, label):
        # print label, type(label)
        name = re.sub(r"[^0-9a-zA-Z]", "", label).lower()
        label = _(label)
        underline = label.find('&')
        if underline >= 0:
            label = label.replace('&', '')
        return name, label, underline

    def add(self, itemType, cnf={}):
        label = cnf.get("label")
        if label:
            name = cnf.get('name')
            if name:
                del cnf['name']  # TclError: unknown option "-name"
            else:
                name, label, underline = self.labeltoname(label)
                cnf["underline"] = cnf.get("underline", underline)
            cnf["label"] = label
            if name and self.addPath:
                path = str(self._w) + "." + name
                self.addPath(path, self, self.n, cnf.get("menu"))
        tkinter.Menu.add(self, itemType, cnf)
        self.n = self.n + 1


class MfxMenu(MfxMenubar):
    def __init__(self, master, label, underline=None, **kw):
        if 'name' in kw:
            name, label_underline = kw['name'], -1
        else:
            name, label, label_underline = self.labeltoname(label)
        kwdefault(kw, name=name)
        MfxMenubar.__init__(self, master, **kw)
        if underline is None:
            underline = label_underline
        if master:
            master.add_cascade(
                menu=self, name=name, label=label, underline=underline)


class PysolMenubarTkCommon:
    def __init__(self, app, top, progress=None):
        self._createTkOpt()
        self._setOptions()
        # init columnbreak
        self.cb_max = int(self.top.winfo_screenheight()//23)
        #  sh = self.top.winfo_screenheight()
        #  self.cb_max = 22
        #  if sh >= 600: self.cb_max = 27
        #  if sh >= 768: self.cb_max = 32
        #  if sh >= 1024: self.cb_max = 40
        self.progress = progress
        # create menus
        self.menubar = None
        self.menupath = {}
        self.keybindings = {}
        self._createMenubar()
        self.top = top

        if self.progress:
            self.progress.update(step=1)

        # set the menubar
        self.updateBackgroundImagesMenu()
        self.top.config(menu=self.menubar)

    def _createTkOpt(self):
        # structure to convert menu-options to Toolkit variables
        self.tkopt = Struct(
            gameid=tkinter.IntVar(),
            gameid_popular=tkinter.IntVar(),
            comment=tkinter.BooleanVar(),
            autofaceup=tkinter.BooleanVar(),
            autodrop=tkinter.BooleanVar(),
            autodeal=tkinter.BooleanVar(),
            quickplay=tkinter.BooleanVar(),
            undo=tkinter.BooleanVar(),
            bookmarks=tkinter.BooleanVar(),
            hint=tkinter.BooleanVar(),
            shuffle=tkinter.BooleanVar(),
            highlight_piles=tkinter.BooleanVar(),
            highlight_cards=tkinter.BooleanVar(),
            highlight_samerank=tkinter.BooleanVar(),
            highlight_not_matching=tkinter.BooleanVar(),
            mahjongg_show_removed=tkinter.BooleanVar(),
            shisen_show_hint=tkinter.BooleanVar(),
            sound=tkinter.BooleanVar(),
            auto_scale=tkinter.BooleanVar(),
            cardback=tkinter.IntVar(),
            tabletile=tkinter.IntVar(),
            animations=tkinter.IntVar(),
            redeal_animation=tkinter.BooleanVar(),
            win_animation=tkinter.BooleanVar(),
            shadow=tkinter.BooleanVar(),
            shade=tkinter.BooleanVar(),
            shade_filled_stacks=tkinter.BooleanVar(),
            shrink_face_down=tkinter.BooleanVar(),
            toolbar=tkinter.IntVar(),
            toolbar_style=tkinter.StringVar(),
            toolbar_relief=tkinter.StringVar(),
            toolbar_compound=tkinter.StringVar(),
            toolbar_size=tkinter.IntVar(),
            statusbar=tkinter.BooleanVar(),
            num_cards=tkinter.BooleanVar(),
            helpbar=tkinter.BooleanVar(),
            save_games_geometry=tkinter.BooleanVar(),
            splashscreen=tkinter.BooleanVar(),
            demo_logo=tkinter.BooleanVar(),
            mouse_type=tkinter.StringVar(),
            mouse_undo=tkinter.BooleanVar(),
            negative_bottom=tkinter.BooleanVar(),
            pause=tkinter.BooleanVar(),
            theme=tkinter.StringVar(),
            toolbar_vars={},
        )
        for w in TOOLBAR_BUTTONS:
            self.tkopt.toolbar_vars[w] = tkinter.BooleanVar()

    def _setOptions(self):
        tkopt, opt = self.tkopt, self.app.opt
        # set state of the menu items
        tkopt.autofaceup.set(opt.autofaceup)
        tkopt.autodrop.set(opt.autodrop)
        tkopt.autodeal.set(opt.autodeal)
        tkopt.quickplay.set(opt.quickplay)
        tkopt.undo.set(opt.undo)
        tkopt.hint.set(opt.hint)
        tkopt.shuffle.set(opt.shuffle)
        tkopt.bookmarks.set(opt.bookmarks)
        tkopt.highlight_piles.set(opt.highlight_piles)
        tkopt.highlight_cards.set(opt.highlight_cards)
        tkopt.highlight_samerank.set(opt.highlight_samerank)
        tkopt.highlight_not_matching.set(opt.highlight_not_matching)
        tkopt.shrink_face_down.set(opt.shrink_face_down)
        tkopt.shade_filled_stacks.set(opt.shade_filled_stacks)
        tkopt.mahjongg_show_removed.set(opt.mahjongg_show_removed)
        tkopt.shisen_show_hint.set(opt.shisen_show_hint)
        tkopt.sound.set(opt.sound)
        tkopt.auto_scale.set(opt.auto_scale)
        tkopt.cardback.set(self.app.cardset.backindex)
        tkopt.tabletile.set(self.app.tabletile_index)
        tkopt.animations.set(opt.animations)
        tkopt.redeal_animation.set(opt.redeal_animation)
        tkopt.win_animation.set(opt.win_animation)
        tkopt.shadow.set(opt.shadow)
        tkopt.shade.set(opt.shade)
        tkopt.toolbar.set(opt.toolbar)
        tkopt.toolbar_style.set(opt.toolbar_style)
        tkopt.toolbar_relief.set(opt.toolbar_relief)
        tkopt.toolbar_compound.set(opt.toolbar_compound)
        tkopt.toolbar_size.set(opt.toolbar_size)
        tkopt.toolbar_relief.set(opt.toolbar_relief)
        tkopt.statusbar.set(opt.statusbar)
        tkopt.num_cards.set(opt.num_cards)
        tkopt.helpbar.set(opt.helpbar)
        tkopt.save_games_geometry.set(opt.save_games_geometry)
        tkopt.demo_logo.set(opt.demo_logo)
        tkopt.splashscreen.set(opt.splashscreen)
        tkopt.mouse_type.set(opt.mouse_type)
        tkopt.mouse_undo.set(opt.mouse_undo)
        tkopt.negative_bottom.set(opt.negative_bottom)
        for w in TOOLBAR_BUTTONS:
            tkopt.toolbar_vars[w].set(opt.toolbar_vars.get(w, False))

    def connectGame(self, game):
        self.game = game
        if game is None:
            return
        assert self.app is game.app
        tkopt = self.tkopt
        tkopt.gameid.set(game.id)
        tkopt.gameid_popular.set(game.id)
        tkopt.comment.set(bool(game.gsaveinfo.comment))
        tkopt.pause.set(self.game.pause)
        if game.canFindCard():
            self._connect_game_find_card_dialog(game)
        else:
            self._destroy_find_card_dialog()
        self._connect_game_solver_dialog(game)

    # create a GTK-like path
    def _addPath(self, path, menu, index, submenu):
        if path not in self.menupath:
            # print path, menu, index, submenu
            self.menupath[path] = (menu, index, submenu)

    def _getEnabledState(self, enabled):
        if enabled:
            return "normal"
        return "disabled"

    def updateProgress(self):
        if self.progress:
            self.progress.update(step=1)

    def _createMenubar(self):
        MfxMenubar.addPath = self._addPath
        kw = {"name": "menubar"}
        self.menubar = MfxMenubar(self.top, **kw)

        # init keybindings
        bind(self.top, "<KeyPress>", self._keyPressHandler)

        m = "Ctrl-"
        if sys.platform == "darwin":
            m = "Cmd-"

        if WIN_SYSTEM == "aqua":
            applemenu = MfxMenu(self.menubar, "apple")
            applemenu.add_command(
                label=_("&About %s") % TITLE, command=self.mHelpAbout)

        menu = MfxMenu(self.menubar, n_("&File"))
        menu.add_command(
            label=n_("&New game"), command=self.mNewGame, accelerator="N")
        submenu = MfxMenu(menu, label=n_("R&ecent games"))
        # menu.add_command(label=n_("Select &random game"),
        #   command=self.mSelectRandomGame, accelerator=m+"R")
        submenu = MfxMenu(menu, label=n_("Select &random game"))
        submenu.add_command(
            label=n_("&All games"), command=lambda:
            self.mSelectRandomGame('all'), accelerator=m+"R")
        submenu.add_command(
            label=n_("Games played and &won"),
            command=lambda: self.mSelectRandomGame('won'))
        submenu.add_command(
            label=n_("Games played and &not won"),
            command=lambda: self.mSelectRandomGame('not won'))
        submenu.add_command(
            label=n_("Games not &played"),
            command=lambda: self.mSelectRandomGame('not played'))
        menu.add_command(
            label=n_("Select game by nu&mber..."),
            command=self.mSelectGameById, accelerator=m+"M")
        menu.add_separator()
        submenu = MfxMenu(menu, label=n_("Fa&vorite games"))
        menu.add_command(label=n_("A&dd to favorites"), command=self.mAddFavor)
        menu.add_command(
            label=n_("Remove &from favorites"),
            command=self.mDelFavor)
        menu.add_separator()
        menu.add_command(
            label=n_("&Open..."),
            command=self.mOpen, accelerator=m+"O")
        menu.add_command(
            label=n_("&Save"),
            command=self.mSave, accelerator=m+"S")
        menu.add_command(label=n_("Save &as..."), command=self.mSaveAs)
        menu.add_command(
            label=n_("E&xport current layout..."),
            command=self.mExportCurrentLayout)
        menu.add_command(
            label=n_("&Import starting layout..."),
            command=self.mImportStartingLayout)
        menu.add_separator()
        menu.add_command(
            label=n_("&Hold and quit"),
            command=self.mHoldAndQuit, accelerator=m+"X")
        if WIN_SYSTEM != "aqua":
            menu.add_command(
                label=n_("&Quit"),
                command=self.mQuit, accelerator=m+"Q")

        if self.progress:
            self.progress.update(step=1)

        menu = MfxMenu(self.menubar, label=n_("&Select"))
        self._addSelectGameMenu(menu)

        if self.progress:
            self.progress.update(step=1)

        menu = MfxMenu(self.menubar, label=n_("&Edit"))
        menu.add_command(
            label=n_("&Undo"),
            command=self.mUndo, accelerator="Z")
        menu.add_command(
            label=n_("&Redo"),
            command=self.mRedo, accelerator="R")
        menu.add_command(label=n_("Redo &all"), command=self.mRedoAll)

        menu.add_separator()
        submenu = MfxMenu(menu, label=n_("&Set bookmark"))
        for i in range(9):
            label = _("Bookmark %d") % (i + 1)
            submenu.add_command(
                label=label,
                command=lambda i=i: self.mSetBookmark(i))
        submenu = MfxMenu(menu, label=n_("Go&to bookmark"))
        for i in range(9):
            label = _("Bookmark %d") % (i + 1)
            acc = m + "%d" % (i + 1)
            submenu.add_command(
                label=label,
                command=lambda i=i: self.mGotoBookmark(i), accelerator=acc)
        menu.add_command(
            label=n_("&Clear bookmarks"),
            command=self.mClearBookmarks)
        menu.add_separator()

        menu.add_command(
            label=n_("Restart"),
            command=self.mRestart, accelerator=m+"G")

        menu.add_separator()
        menu.add_command(label=n_("Solitaire &Wizard"), command=self.mWizard)
        menu.add_command(
            label=n_("&Edit current game"),
            command=self.mWizardEdit)

        menu = MfxMenu(self.menubar, label=n_("&Game"))
        menu.add_command(
            label=n_("&Deal cards"),
            command=self.mDeal, accelerator="D")
        menu.add_command(
            label=n_("&Auto drop"),
            command=self.mDrop, accelerator="A")
        menu.add_command(
            label=n_("Shu&ffle tiles"),
            command=self.mShuffle, accelerator="F")
        menu.add_checkbutton(
            label=n_("&Pause"), variable=self.tkopt.pause,
            command=self.mPause, accelerator="P")
        # menu.add_command(
        #    label=n_("&Pause"), command=self.mPause, accelerator="P")
        menu.add_separator()
        menu.add_command(
            label=n_("S&tatus..."),
            command=lambda: self.mPlayerStats(mode=100), accelerator=m+"Y")
        menu.add_checkbutton(
            label=n_("&Comments..."), variable=self.tkopt.comment,
            command=self.mEditGameComment)
        menu.add_separator()
        menu.add_command(
            label=n_("&Statistics..."),
            command=self.mPlayerStats, accelerator=m+"T")
        menu.add_command(
            label=n_("Log..."),
            command=lambda: self.mPlayerStats(mode=103))
        menu.add_separator()
        menu.add_command(
            label=n_("D&emo statistics"),
            command=lambda: self.mPlayerStats(mode=1101))

        menu = MfxMenu(self.menubar, label=n_("&Assist"))
        menu.add_command(
            label=n_("&Hint"),
            command=self.mHint, accelerator="H")
        menu.add_command(
            label=n_("Highlight p&iles"),
            command=self.mHighlightPiles, accelerator="I")
        menu.add_command(
            label=n_("&Find card"),
            command=self.mFindCard, accelerator="F3")
        menu.add_separator()
        menu.add_command(
            label=n_("&Demo"),
            command=self.mDemo, accelerator=m+"D")
        menu.add_command(
            label=n_("Demo (&all games)"),
            command=self.mMixedDemo)
        if USE_FREECELL_SOLVER:
            menu.add_command(label=n_("&Solver"), command=self.mSolver)
        else:
            menu.add_command(label=n_("&Solver"), state='disabled')
        menu.add_separator()
        menu.add_command(
            label=n_("&Piles description"),
            command=self.mStackDesk, accelerator="F2")

        if self.progress:
            self.progress.update(step=1)

        menu = MfxMenu(self.menubar, label=n_("&Options"))
        menu.add_command(
            label=n_("&Player options..."),
            command=self.mOptPlayerOptions)
        submenu = MfxMenu(menu, label=n_("&Automatic play"))
        submenu.add_checkbutton(
            label=n_("Auto &face up"), variable=self.tkopt.autofaceup,
            command=self.mOptAutoFaceUp)
        submenu.add_checkbutton(
            label=n_("A&uto drop"), variable=self.tkopt.autodrop,
            command=self.mOptAutoDrop)
        submenu.add_checkbutton(
            label=n_("Auto &deal"), variable=self.tkopt.autodeal,
            command=self.mOptAutoDeal)
        submenu.add_separator()
        submenu.add_checkbutton(
            label=n_("&Quick play"), variable=self.tkopt.quickplay,
            command=self.mOptQuickPlay)
        submenu = MfxMenu(menu, label=n_("Assist &level"))
        submenu.add_checkbutton(
            label=n_("Enable &undo"), variable=self.tkopt.undo,
            command=self.mOptEnableUndo)
        submenu.add_checkbutton(
            label=n_("Enable &bookmarks"), variable=self.tkopt.bookmarks,
            command=self.mOptEnableBookmarks)
        submenu.add_checkbutton(
            label=n_("Enable &hint"), variable=self.tkopt.hint,
            command=self.mOptEnableHint)
        submenu.add_checkbutton(
            label=n_("Enable shu&ffle"), variable=self.tkopt.shuffle,
            command=self.mOptEnableShuffle)
        submenu.add_checkbutton(
            label=n_("Enable highlight p&iles"),
            variable=self.tkopt.highlight_piles,
            command=self.mOptEnableHighlightPiles)
        submenu.add_checkbutton(
            label=n_("Enable highlight &cards"),
            variable=self.tkopt.highlight_cards,
            command=self.mOptEnableHighlightCards)
        submenu.add_checkbutton(
            label=n_("Enable highlight same &rank"),
            variable=self.tkopt.highlight_samerank,
            command=self.mOptEnableHighlightSameRank)
        submenu.add_checkbutton(
            label=n_("Highlight &no matching"),
            variable=self.tkopt.highlight_not_matching,
            command=self.mOptEnableHighlightNotMatching)
        submenu.add_separator()
        submenu.add_checkbutton(
            label=n_("&Show removed tiles (in Mahjongg games)"),
            variable=self.tkopt.mahjongg_show_removed,
            command=self.mOptMahjonggShowRemoved)
        submenu.add_checkbutton(
            label=n_("Show hint &arrow (in Shisen-Sho games)"),
            variable=self.tkopt.shisen_show_hint,
            command=self.mOptShisenShowHint)
        menu.add_separator()
        label = n_("&Sound...")
        if not self.app.audio.CAN_PLAY_SOUND:
            menu.add_checkbutton(
                label=label, variable=self.tkopt.sound,
                command=self.mOptSoundDialog, state='disabled')
        else:
            menu.add_checkbutton(
                label=label, variable=self.tkopt.sound,
                command=self.mOptSoundDialog)
        # cardsets
        if USE_PIL:
            submenu = MfxMenu(menu, label=n_("Card si&ze"))
            submenu.add_command(
                label=n_("&Increase the card size"),
                command=self.mIncreaseCardset, accelerator=m+"+")
            submenu.add_command(
                label=n_("&Decrease the card size"),
                command=self.mDecreaseCardset, accelerator=m+"-")
            submenu.add_checkbutton(
                label=n_("&Auto scaling"), variable=self.tkopt.auto_scale,
                command=self.mOptAutoScale, accelerator=m+'0')
        # manager = self.app.cardset_manager
        # n = manager.len()
        menu.add_command(
            label=n_("Cards&et..."),
            command=self.mSelectCardsetDialog, accelerator=m+"E")
        menu.add_command(
            label=n_("Table t&ile..."),
            command=self.mSelectTileDialog)
        # this submenu will get set by updateBackgroundImagesMenu()
        submenu = MfxMenu(menu, label=n_("Card &background"))
        submenu = MfxMenu(menu, label=n_("Card &view"))
        submenu.add_checkbutton(
            label=n_("Card shado&w"), variable=self.tkopt.shadow,
            command=self.mOptShadow)
        submenu.add_checkbutton(
            label=n_("Shade &legal moves"), variable=self.tkopt.shade,
            command=self.mOptShade)
        submenu.add_checkbutton(
            label=n_("&Negative cards bottom"),
            variable=self.tkopt.negative_bottom,
            command=self.mOptNegativeBottom)
        submenu.add_checkbutton(
            label=n_("Shrink face-down cards"),
            variable=self.tkopt.shrink_face_down,
            command=self.mOptShrinkFaceDown)
        submenu.add_checkbutton(
            label=n_("Shade &filled stacks"),
            variable=self.tkopt.shade_filled_stacks,
            command=self.mOptShadeFilledStacks)
        submenu = MfxMenu(menu, label=n_("A&nimations"))
        submenu.add_radiobutton(
            label=n_("&None"), variable=self.tkopt.animations, value=0,
            command=self.mOptAnimations)
        submenu.add_radiobutton(
            label=n_("&Very fast"), variable=self.tkopt.animations, value=1,
            command=self.mOptAnimations)
        submenu.add_radiobutton(
            label=n_("&Fast"), variable=self.tkopt.animations, value=2,
            command=self.mOptAnimations)
        submenu.add_radiobutton(
            label=n_("&Medium"), variable=self.tkopt.animations, value=3,
            command=self.mOptAnimations)
        submenu.add_radiobutton(
            label=n_("&Slow"), variable=self.tkopt.animations, value=4,
            command=self.mOptAnimations)
        submenu.add_radiobutton(
            label=n_("V&ery slow"), variable=self.tkopt.animations, value=5,
            command=self.mOptAnimations)
        submenu.add_separator()
        submenu.add_checkbutton(
            label=n_("&Redeal animation"),
            variable=self.tkopt.redeal_animation,
            command=self.mRedealAnimation)
        if Image:
            submenu.add_checkbutton(
                label=n_("&Winning animation"),
                variable=self.tkopt.win_animation,
                command=self.mWinAnimation)
        submenu = MfxMenu(menu, label=n_("&Mouse"))
        submenu.add_radiobutton(
            label=n_("&Drag-and-Drop"), variable=self.tkopt.mouse_type,
            value='drag-n-drop',
            command=self.mOptMouseType)
        submenu.add_radiobutton(
            label=n_("&Point-and-Click"), variable=self.tkopt.mouse_type,
            value='point-n-click',
            command=self.mOptMouseType)
        submenu.add_radiobutton(
            label=n_("&Sticky mouse"), variable=self.tkopt.mouse_type,
            value='sticky-mouse',
            command=self.mOptMouseType)
        submenu.add_separator()
        submenu.add_checkbutton(
            label=n_("Use mouse for undo/redo"),
            variable=self.tkopt.mouse_undo,
            command=self.mOptMouseUndo)
        menu.add_separator()
        menu.add_command(label=n_("&Fonts..."), command=self.mOptFonts)
        menu.add_command(label=n_("&Colors..."), command=self.mOptColors)
        menu.add_command(label=n_("Time&outs..."), command=self.mOptTimeouts)
        menu.add_separator()
        self.createThemesMenu(menu)
        submenu = MfxMenu(menu, label=n_("&Toolbar"))
        createToolbarMenu(self, submenu)
        submenu = MfxMenu(menu, label=n_("Stat&usbar"))
        submenu.add_checkbutton(
            label=n_("Show &statusbar"), variable=self.tkopt.statusbar,
            command=self.mOptStatusbar)
        submenu.add_checkbutton(
            label=n_("Show &number of cards"), variable=self.tkopt.num_cards,
            command=self.mOptNumCards)
        submenu.add_checkbutton(
            label=n_("Show &help bar"), variable=self.tkopt.helpbar,
            command=self.mOptHelpbar)
        # if not USE_PIL:
        menu.add_checkbutton(
            label=n_("Save games &geometry"),
            variable=self.tkopt.save_games_geometry,
            command=self.mOptSaveGamesGeometry)
        menu.add_checkbutton(
            label=n_("&Demo logo"), variable=self.tkopt.demo_logo,
            command=self.mOptDemoLogo)
        menu.add_checkbutton(
            label=n_("Startup splash sc&reen"),
            variable=self.tkopt.splashscreen,
            command=self.mOptSplashscreen)
        #  menu.add_separator()
        #  menu.add_command(label="Save options", command=self.mOptSave)

        if self.progress:
            self.progress.update(step=1)

        menu = MfxMenu(self.menubar, label=n_("&Help"))
        menu.add_command(
            label=n_("&Contents"),
            command=self.mHelp, accelerator=m+"F1")
        menu.add_command(
            label=n_("&How to play"),
            command=self.mHelpHowToPlay)
        menu.add_command(
            label=n_("&Rules for this game"),
            command=self.mHelpRules, accelerator="F1")
        menu.add_command(
            label=n_("&License terms"),
            command=self.mHelpLicense)
        # menu.add_command(label=n_("What's &new ?"), command=self.mHelpNews)
        if WIN_SYSTEM != "aqua":
            menu.add_separator()
            menu.add_command(
                label=_("&About %s...") % TITLE,
                command=self.mHelpAbout)

        MfxMenubar.addPath = None

        # FIXME: all key bindings should be *added* to keyPressHandler
        ctrl = "Control-"
        if sys.platform == "darwin":
            ctrl = "Command-"
        self._bindKey("",   "n", self.mNewGame)
        self._bindKey(ctrl, "w", self.mSelectGameDialog)
        self._bindKey(ctrl, "v", self.mSelectGameDialogWithPreview)
        self._bindKey(ctrl, "r", lambda e: self.mSelectRandomGame())
        self._bindKey(ctrl, "m", self.mSelectGameById)
        self._bindKey(ctrl, "n", self.mNewGameWithNextId)
        self._bindKey(ctrl, "o", self.mOpen)
        self._bindKey(ctrl, "s", self.mSave)
        self._bindKey(ctrl, "x", self.mHoldAndQuit)
        self._bindKey(ctrl, "q", self.mQuit)
        self._bindKey(ctrl, "z", self.mUndo)
        self._bindKey("",   "z", self.mUndo)
        self._bindKey("",   "BackSpace", self.mUndo)    # undocumented
        self._bindKey("",   "KP_Enter", self.mUndo)     # undocumented
        self._bindKey("",   "r", self.mRedo)
        self._bindKey(ctrl, "g", self.mRestart)
        self._bindKey("",   "space", self.mDeal)        # undocumented
        self._bindKey(ctrl, "y", lambda e: self.mPlayerStats(mode=100))
        self._bindKey(ctrl, "t", lambda e: self.mPlayerStats(mode=105))
        self._bindKey("",   "h", self.mHint)
        self._bindKey(ctrl, "h", self.mHint1)           # undocumented
        # self._bindKey("",   "Shift_L", self.mHighlightPiles)
        # self._bindKey("",   "Shift_R", self.mHighlightPiles)
        self._bindKey("",   "i", self.mHighlightPiles)
        self._bindKey("",   "F3", self.mFindCard)
        self._bindKey(ctrl, "d", self.mDemo)
        self._bindKey(ctrl, "e", self.mSelectCardsetDialog)
        if USE_PIL:
            self._bindKey(ctrl, "plus", self.mIncreaseCardset)
            self._bindKey(ctrl, "equal", self.mIncreaseCardset)
            self._bindKey(ctrl, "minus", self.mDecreaseCardset)
            self._bindKey(ctrl, "0", self.mOptAutoScale)
        self._bindKey(ctrl, "b", self.mOptChangeCardback)  # undocumented
        self._bindKey(ctrl, "i", self.mOptChangeTableTile)  # undocumented
        self._bindKey(ctrl, "p", self.mOptPlayerOptions)   # undocumented
        self._bindKey(ctrl, "F1", self.mHelp)
        self._bindKey("",   "F1", self.mHelpRules)
        self._bindKey("",   "Print", self.mScreenshot)
        self._bindKey(ctrl, "u", self.mPlayNextMusic)   # undocumented
        self._bindKey("",   "p", self.mPause)
        self._bindKey("",   "Pause", self.mPause)       # undocumented
        self._bindKey("",   "Escape", self.mIconify)    # undocumented
        # ASD and LKJ
        self._bindKey("",   "a", self.mDrop)
        self._bindKey(ctrl, "a", self.mDrop1)
        self._bindKey("",   "s", self.mUndo)
        self._bindKey("",   "d", self.mDeal)
        self._bindKey("",   "l", self.mDrop)
        self._bindKey(ctrl, "l", self.mDrop1)
        self._bindKey("",   "k", self.mUndo)
        self._bindKey("",   "j", self.mDeal)

        self._bindKey("",   "F2", self.mStackDesk)
        #
        # undocumented, devel
        self._bindKey("", "slash", lambda e: self.mPlayerStats(mode=106))
        #
        self._bindKey("",   "f", self.mShuffle)

        for i in range(9):
            self._bindKey(
                ctrl, str(i+1),
                lambda e, i=i: self.mGotoBookmark(i, confirm=0))

        # undocumented, devel
        self._bindKey(ctrl, "End", self.mPlayNextMusic)
        self._bindKey(ctrl, "Prior", self.mSelectPrevGameByName)
        self._bindKey(ctrl, "Next", self.mSelectNextGameByName)
        self._bindKey(ctrl, "Up", self.mSelectPrevGameById)
        self._bindKey(ctrl, "Down", self.mSelectNextGameById)

    #
    # key binding utility
    #

    def _bindKey(self, modifier, key, func):
        #  if 0 and not modifier and len(key) == 1:
        #      self.keybindings[key.lower()] = func
        #      self.keybindings[key.upper()] = func
        #      return
        if not modifier and len(key) == 1:
            # ignore Ctrl/Shift/Alt
            # but don't ignore NumLock (state == 16)
            def func(e, f2=func):
                return e.state in (0, 16) and f2(e)
        sequence = "<" + modifier + "KeyPress-" + key + ">"
        bind(self.top, sequence, func)
        if len(key) == 1 and key != key.upper():
            key = key.upper()
            sequence = "<" + modifier + "KeyPress-" + key + ">"
            bind(self.top, sequence, func)

    def _keyPressHandler(self, event):
        r = EVENT_PROPAGATE
        if event and self.game:
            # print event.__dict__
            if self.game.demo:
                # stop the demo by setting self.game.demo.keypress
                if event.char:    # ignore Ctrl/Shift/etc.
                    self.game.demo.keypress = event.char
                    r = EVENT_HANDLED
                # func = self.keybindings.get(event.char)
                # if func and (event.state & ~2) == 0:
                #    func(event)
                #    r = EVENT_HANDLED
        return r

    #
    # Select Game menu creation
    #

    def _addSelectGameMenu(self, menu):
        # games = map(self.app.gdb.get,
        #   self.app.gdb.getGamesIdSortedByShortName())
        games = list(map(
            self.app.gdb.get, self.app.gdb.getGamesIdSortedByName()))
        # games = tuple(games)
        # menu = MfxMenu(menu, label="Select &game")
        m = "Ctrl-"
        if sys.platform == "darwin":
            m = "Cmd-"
        menu.add_command(label=n_("All &games..."), accelerator=m+"W",
                         command=self.mSelectGameDialog)
        menu.add_command(label=n_("Playable pre&view..."), accelerator=m+"V",
                         command=self.mSelectGameDialogWithPreview)
        if not SELECT_GAME_MENU:
            return
        menu.add_separator()
        self._addSelectPopularGameSubMenu(games, menu, self.mSelectGame,
                                          self.tkopt.gameid)
        self._addSelectFrenchGameSubMenu(games, menu, self.mSelectGame,
                                         self.tkopt.gameid)
        if self.progress:
            self.progress.update(step=1)
        self._addSelectMahjonggGameSubMenu(games, menu, self.mSelectGame,
                                           self.tkopt.gameid)
        self._addSelectOrientalGameSubMenu(games, menu, self.mSelectGame,
                                           self.tkopt.gameid)
        self._addSelectSpecialGameSubMenu(games, menu, self.mSelectGame,
                                          self.tkopt.gameid)
        self._addSelectCustomGameSubMenu(games, menu, self.mSelectGame,
                                         self.tkopt.gameid)
        menu.add_separator()
        if self.progress:
            self.progress.update(step=1)
        self._addSelectAllGameSubMenu(games, menu, self.mSelectGame,
                                      self.tkopt.gameid)

    def _addSelectGameSubMenu(self, games, menu, select_data,
                              command, variable):
        # print select_data
        need_sep = 0
        for label, select_func in select_data:
            if label is None:
                need_sep = 1
                continue
            g = list(filter(select_func, games))
            if not g:
                continue
            if need_sep:
                menu.add_separator()
                need_sep = 0
            submenu = MfxMenu(menu, label=label)
            self._addSelectGameSubSubMenu(g, submenu, command, variable)

    def _getNumGames(self, games, select_data):
        ngames = 0
        for label, select_func in select_data:
            ngames += len(list(filter(select_func, games)))
        return ngames

    def _addSelectMahjonggGameSubMenu(self, games, menu, command, variable):
        def select_func(gi):
            return gi.si.game_type == GI.GT_MAHJONGG
        mahjongg_games = list(filter(select_func, games))
        if len(mahjongg_games) == 0:
            return
        #
        menu = MfxMenu(menu, label=n_("&Mahjongg games"))

        def add_menu(games, c0, c1, menu=menu,
                     variable=variable, command=command):
            if not games:
                return
            label = c0 + ' - ' + c1
            if c0 == c1:
                label = c0
            submenu = MfxMenu(menu, label=label, name=None)
            self._addSelectGameSubSubMenu(games, submenu, command,
                                          variable, short_name=True)

        games = {}
        for gi in mahjongg_games:
            c = gi.short_name.strip()[0]
            if c in games:
                games[c].append(gi)
            else:
                games[c] = [gi]
        games = list(games.items())
        games.sort()
        g0 = []
        c0 = c1 = games[0][0]
        for c, g1 in games:
            if len(g0)+len(g1) >= self.cb_max:
                add_menu(g0, c0, c1)
                g0 = g1
                c0 = c1 = c
            else:
                g0 += g1
                c1 = c
        add_menu(g0, c0, c1)

    def _addSelectPopularGameSubMenu(self, games, menu, command, variable):
        def select_func(gi):
            return gi.si.game_flags & GI.GT_POPULAR
        if len(list(filter(select_func, games))) == 0:
            return
        data = (n_("&Popular games"), select_func)
        self._addSelectGameSubMenu(games, menu, (data, ),
                                   self.mSelectGamePopular,
                                   self.tkopt.gameid_popular)

    def _addSelectFrenchGameSubMenu(self, games, menu, command, variable):
        if self._getNumGames(games, GI.SELECT_GAME_BY_TYPE) == 0:
            return
        submenu = MfxMenu(menu, label=n_("&French games"))
        self._addSelectGameSubMenu(games, submenu, GI.SELECT_GAME_BY_TYPE,
                                   self.mSelectGame, self.tkopt.gameid)

    def _addSelectOrientalGameSubMenu(self, games, menu, command, variable):
        if self._getNumGames(games, GI.SELECT_ORIENTAL_GAME_BY_TYPE) == 0:
            return
        submenu = MfxMenu(menu, label=n_("&Oriental games"))
        self._addSelectGameSubMenu(games, submenu,
                                   GI.SELECT_ORIENTAL_GAME_BY_TYPE,
                                   self.mSelectGame, self.tkopt.gameid)

    def _addSelectSpecialGameSubMenu(self, games, menu, command, variable):
        if self._getNumGames(games, GI.SELECT_ORIENTAL_GAME_BY_TYPE) == 0:
            return
        submenu = MfxMenu(menu, label=n_("&Special games"))
        self._addSelectGameSubMenu(games, submenu,
                                   GI.SELECT_SPECIAL_GAME_BY_TYPE,
                                   self.mSelectGame, self.tkopt.gameid)

    def _addSelectCustomGameSubMenu(self, games, menu, command, variable):
        submenu = MfxMenu(menu, label=n_("&Custom games"))

        def select_func(gi):
            return gi.si.game_type == GI.GT_CUSTOM
        games = list(filter(select_func, games))
        self.updateGamesMenu(submenu, games)

    def _addSelectAllGameSubMenu(self, games, menu, command, variable):
        menu = MfxMenu(menu, label=n_("&All games by name"))
        n, d = 0, self.cb_max
        i = 0
        while True:
            if self.progress:
                self.progress.update(step=1)
            columnbreak = i > 0 and (i % d) == 0
            i += 1
            if not games[n:n+d]:
                break
            m = min(n+d-1, len(games)-1)
            label = games[n].name[:3] + ' - ' + games[m].name[:3]
            submenu = MfxMenu(menu, label=label, name=None)
            self._addSelectGameSubSubMenu(games[n:n+d], submenu,
                                          command, variable)
            n += d
            if columnbreak:
                menu.entryconfigure(i, columnbreak=columnbreak)

    def _addSelectGameSubSubMenu(self, games, menu, command, variable,
                                 short_name=False):
        # cb = (25, self.cb_max) [ len(g) > 4 * 25 ]
        # cb = min(cb, self.cb_max)
        cb = self.cb_max
        for i in range(len(games)):
            gi = games[i]
            columnbreak = i > 0 and (i % cb) == 0
            if short_name:
                label = gi.short_name
            else:
                label = gi.name
            # optimized by inlining
            menu.tk.call((menu._w, 'add', 'radiobutton') +
                         menu._options({'command': command,
                                        'variable': variable,
                                        'columnbreak': columnbreak,
                                        'value': gi.id,
                                        'label': label}))

    def updateGamesMenu(self, menu, games):
        menu.delete(0, 'last')
        if len(games) == 0:
            menu.add_radiobutton(label=_('<none>'), name=None,
                                 state='disabled')
        elif len(games) > self.cb_max*4:
            games.sort(key=lambda x: x.name)
            self._addSelectAllGameSubMenu(games, menu,
                                          command=self.mSelectGame,
                                          variable=self.tkopt.gameid)
        else:
            self._addSelectGameSubSubMenu(games, menu,
                                          command=self.mSelectGame,
                                          variable=self.tkopt.gameid)

    #
    # Select Game menu actions
    #

    def mSelectGame(self, *args):
        self._mSelectGame(self.tkopt.gameid.get())

    def mSelectGamePopular(self, *args):
        self._mSelectGame(self.tkopt.gameid_popular.get())

    def _mSelectGameDialog(self, d):
        if d.status == 0 and d.button == 0 and d.gameid != self.game.id:
            self.tkopt.gameid.set(d.gameid)
            self.tkopt.gameid_popular.set(d.gameid)
            if 0:
                self._mSelectGame(d.gameid, random=d.random)
            else:
                # don't ask areYouSure()
                self._cancelDrag()
                self.game.endGame()
                self.game.quitGame(d.gameid, random=d.random)
        return EVENT_HANDLED

    def __restoreCursor(self, *event):
        self.game.setCursor(cursor=self.app.top_cursor)

    def mSelectGameDialog(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.game.setCursor(cursor=CURSOR_WATCH)
        after_idle(self.top, self.__restoreCursor)
        d = self._calcSelectGameDialog()(
            self.top, title=_("Select game"),
            app=self.app, gameid=self.game.id)
        return self._mSelectGameDialog(d)

    def mSelectGameDialogWithPreview(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.game.setCursor(cursor=CURSOR_WATCH)
        bookmark = None
        if 0:
            # use a bookmark for our preview game
            if self.game.setBookmark(-2, confirm=0):
                bookmark = self.game.gsaveinfo.bookmarks[-2][0]
                del self.game.gsaveinfo.bookmarks[-2]
        after_idle(self.top, self.__restoreCursor)
        d = self._calcSelectGameDialogWithPreview()(
            self.top, title=_("Select game"),
            app=self.app, gameid=self.game.id,
            bookmark=bookmark)
        return self._mSelectGameDialog(d)

    #
    # menubar overrides
    #

    def updateFavoriteGamesMenu(self):
        gameids = self.app.opt.favorite_gameid
        submenu = self.menupath[".menubar.file.favoritegames"][2]
        games = []
        for id in gameids:
            gi = self.app.getGameInfo(id)
            if gi:
                games.append(gi)
        self.updateGamesMenu(submenu, games)
        state = self._getEnabledState
        in_favor = self.app.game.id in gameids
        menu, index, submenu = self.menupath[".menubar.file.addtofavorites"]
        menu.entryconfig(index, state=state(not in_favor))
        menu, index, submenu = \
            self.menupath[".menubar.file.removefromfavorites"]
        menu.entryconfig(index, state=state(in_favor))

    def updateRecentGamesMenu(self, gameids):
        submenu = self.menupath[".menubar.file.recentgames"][2]
        games = []
        for id in gameids:
            gi = self.app.getGameInfo(id)
            if gi:
                games.append(gi)
        self.updateGamesMenu(submenu, games)

    def updateBookmarkMenuState(self):
        state = self._getEnabledState
        mp1 = self.menupath.get(".menubar.edit.setbookmark")
        mp2 = self.menupath.get(".menubar.edit.gotobookmark")
        mp3 = self.menupath.get(".menubar.edit.clearbookmarks")
        if mp1 is None or mp2 is None or mp3 is None:
            return
        x = self.app.opt.bookmarks and self.game.canSetBookmark()
        #
        menu, index, submenu = mp1
        for i in range(9):
            submenu.entryconfig(i, state=state(x))
        menu.entryconfig(index, state=state(x))
        #
        menu, index, submenu = mp2
        ms = 0
        for i in range(9):
            s = self.game.gsaveinfo.bookmarks.get(i) is not None
            submenu.entryconfig(i, state=state(s and x))
            ms = ms or s
        menu.entryconfig(index, state=state(ms and x))
        #
        menu, index, submenu = mp3
        menu.entryconfig(index, state=state(ms and x))

    def updateBackgroundImagesMenu(self):
        mp = self.menupath.get(".menubar.options.cardbackground")
        # delete all entries
        submenu = mp[2]
        submenu.delete(0, "last")
        # insert new cardbacks
        mbacks = self.app.images.getCardbacks()
        cb = int(math.ceil(math.sqrt(len(mbacks))))
        for i in range(len(mbacks)):
            columnbreak = i > 0 and (i % cb) == 0
            submenu.add_radiobutton(
                label=mbacks[i].name, image=mbacks[i].menu_image,
                variable=self.tkopt.cardback, value=i,
                command=self.mOptCardback, columnbreak=columnbreak,
                indicatoron=0, hidemargin=0)

    #
    # menu updates
    #

    def setMenuState(self, state, path):
        # print state, path
        path = ".menubar." + path
        mp = self.menupath.get(path)
        menu, index, submenu = mp
        s = self._getEnabledState(state)
        menu.entryconfig(index, state=s)

    def setToolbarState(self, state, path):
        # print state, path
        s = self._getEnabledState(state)
        w = getattr(self.app.toolbar, path + "_button")
        w["state"] = s

    def _setCommentMenu(self, v):
        self.tkopt.comment.set(v)

    def _setPauseMenu(self, v):
        self.tkopt.pause.set(v)

    #
    # menu actions
    #

    DEFAULTEXTENSION = ".pso"
    FILETYPES = ((_("%s files") % TITLE, "*" + DEFAULTEXTENSION),
                 (_("All files"), "*"))

    def mAddFavor(self, *event):
        gameid = self.app.game.id
        if gameid not in self.app.opt.favorite_gameid:
            self.app.opt.favorite_gameid.append(gameid)
            self.updateFavoriteGamesMenu()

    def mDelFavor(self, *event):
        gameid = self.app.game.id
        if gameid in self.app.opt.favorite_gameid:
            self.app.opt.favorite_gameid.remove(gameid)
            self.updateFavoriteGamesMenu()

    def mOpen(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        filename = self.game.filename
        if filename:
            idir, ifile = os.path.split(os.path.normpath(filename))
        else:
            idir, ifile = "", ""
        if not idir:
            idir = self.app.dn.savegames
        d = tkinter_tkfiledialog.Open()
        filename = d.show(filetypes=self.FILETYPES,
                          defaultextension=self.DEFAULTEXTENSION,
                          initialdir=idir, initialfile=ifile)
        if filename:
            filename = os.path.normpath(filename)
            # filename = os.path.normcase(filename)
            if os.path.isfile(filename):
                self.game.loadGame(filename)

    def mExportCurrentLayout(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        game = self.game
        if not self.menustate.save_as:
            return
        if not game.Solver_Class:
            d = self._calc_MfxMessageDialog()(
                self.top, title=_('Export game error'),
                text=_('''
Unsupported game for export.
'''),
                bitmap='error')
            return

        filename = game.filename
        if not filename:
            filename = self.app.getGameSaveName(self.game.id)
            if os.name == "posix" or os.path.supports_unicode_filenames:
                filename += "-" + self.game.getGameNumber(format=0)
            else:
                filename += "-01"
            filename += ".board"
        idir, ifile = os.path.split(os.path.normpath(filename))
        if not idir:
            idir = self.app.dn.savegames
        # print self.game.filename, ifile
        d = tkinter_tkfiledialog.SaveAs()
        filename = d.show(filetypes=self.FILETYPES,
                          defaultextension=self.DEFAULTEXTENSION,
                          initialdir=idir, initialfile=ifile)
        if filename:
            filename = os.path.normpath(filename)
            # filename = os.path.normcase(filename)
            with open(filename, 'w') as fh:
                game = self.game
                fh.write(game.Solver_Class(game, self).calcBoardString())
            self.updateMenus()

    def mImportStartingLayout(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        game = self.game
        if not game.Solver_Class:
            d = self._calc_MfxMessageDialog()(
                self.top, title=_('Import game error'),
                text=_('''
Unsupported game for import.
'''),
                bitmap='error')
            return

        filename = self.game.filename
        if filename:
            idir, ifile = os.path.split(os.path.normpath(filename))
        else:
            idir, ifile = "", ""
        if not idir:
            idir = self.app.dn.savegames
        d = tkinter_tkfiledialog.Open()
        key = 'PYSOL_DEBUG_IMPORT'
        if key not in os.environ:
            filename = d.show(filetypes=self.FILETYPES,
                              defaultextension=self.DEFAULTEXTENSION,
                              initialdir=idir, initialfile=ifile)
        else:
            filename = os.environ[key]
        if filename:
            filename = os.path.normpath(filename)
            # filename = os.path.normcase(filename)
            if os.path.isfile(filename):
                with open(filename, 'r+b') as fh:
                    game = self.game
                    try:
                        game.Solver_Class(game, self).importFile(
                            fh, game, self)
                    except PySolHintLayoutImportError as err:
                        self._calc_MfxMessageDialog()(
                            self.top,
                            title=_('Import game error'),
                            text=err.format(),
                            bitmap='error'
                        )
                        game.busy = False
                        game.endGame()
                        game.newGame()

    def mSaveAs(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        if not self.menustate.save_as:
            return
        filename = self.game.filename
        if not filename:
            filename = self.app.getGameSaveName(self.game.id)
            if os.name == "posix":
                filename = filename + "-" + self.game.getGameNumber(format=0)
            elif os.path.supports_unicode_filenames:  # new in python 2.3
                filename = filename + "-" + self.game.getGameNumber(format=0)
            else:
                filename = filename + "-01"
            filename = filename + self.DEFAULTEXTENSION
        idir, ifile = os.path.split(os.path.normpath(filename))
        if not idir:
            idir = self.app.dn.savegames
        # print self.game.filename, ifile
        d = tkinter_tkfiledialog.SaveAs()
        filename = d.show(filetypes=self.FILETYPES,
                          defaultextension=self.DEFAULTEXTENSION,
                          initialdir=idir, initialfile=ifile)
        if filename:
            filename = os.path.normpath(filename)
            # filename = os.path.normcase(filename)
            self.game.saveGame(filename)
            self.updateMenus()

    def mPause(self, *args):
        if not self.game:
            return
        if not self.game.pause:
            if self._cancelDrag():
                return
        self.game.doPause()
        self.tkopt.pause.set(self.game.pause)

    def mOptSoundDialog(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self._calcSoundOptionsDialog()(
            self.top, _("Sound settings"), self.app)
        self.tkopt.sound.set(self.app.opt.sound)

    def mOptAutoFaceUp(self, *args):
        if self._cancelDrag():
            return
        self.app.opt.autofaceup = self.tkopt.autofaceup.get()
        if self.app.opt.autofaceup:
            self.game.autoPlay()

    def mOptAutoDrop(self, *args):
        if self._cancelDrag():
            return
        self.app.opt.autodrop = self.tkopt.autodrop.get()
        if self.app.opt.autodrop:
            self.game.autoPlay()

    def mOptAutoDeal(self, *args):
        if self._cancelDrag():
            return
        self.app.opt.autodeal = self.tkopt.autodeal.get()
        if self.app.opt.autodeal:
            self.game.autoPlay()

    def mOptQuickPlay(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.quickplay = self.tkopt.quickplay.get()

    def mOptEnableUndo(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.undo = self.tkopt.undo.get()
        self.game.updateMenus()

    def mOptEnableBookmarks(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.bookmarks = self.tkopt.bookmarks.get()
        self.game.updateMenus()

    def mOptEnableHint(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.hint = self.tkopt.hint.get()
        self.game.updateMenus()

    def mOptEnableShuffle(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.shuffle = self.tkopt.shuffle.get()
        self.game.updateMenus()

    def mOptEnableHighlightPiles(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.highlight_piles = self.tkopt.highlight_piles.get()
        self.game.updateMenus()

    def mOptEnableHighlightCards(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.highlight_cards = self.tkopt.highlight_cards.get()
        self.game.updateMenus()

    def mOptEnableHighlightSameRank(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.highlight_samerank = self.tkopt.highlight_samerank.get()
        # self.game.updateMenus()

    def mOptEnableHighlightNotMatching(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.highlight_not_matching = \
            self.tkopt.highlight_not_matching.get()
        # self.game.updateMenus()

    def mOptAnimations(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.animations = self.tkopt.animations.get()

    def mRedealAnimation(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.redeal_animation = self.tkopt.redeal_animation.get()

    def mWinAnimation(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.win_animation = self.tkopt.win_animation.get()

    def mOptShadow(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.shadow = self.tkopt.shadow.get()

    def mOptShade(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.shade = self.tkopt.shade.get()

    def mOptShrinkFaceDown(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.shrink_face_down = self.tkopt.shrink_face_down.get()
        self.game.endGame(bookmark=1)
        self.game.quitGame(bookmark=1)

    def mOptShadeFilledStacks(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.shade_filled_stacks = self.tkopt.shade_filled_stacks.get()
        self.game.endGame(bookmark=1)
        self.game.quitGame(bookmark=1)

    def mOptMahjonggShowRemoved(self, *args):
        if self._cancelDrag():
            return
        self.app.opt.mahjongg_show_removed = \
            self.tkopt.mahjongg_show_removed.get()
        # self.game.updateMenus()
        self.game.endGame(bookmark=1)
        self.game.quitGame(bookmark=1)

    def mOptShisenShowHint(self, *args):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.shisen_show_hint = self.tkopt.shisen_show_hint.get()
        # self.game.updateMenus()

    def _updateCardSize(self):
        geom = (self.app.canvas.winfo_width(),
                self.app.canvas.winfo_height())
        self.app.opt.game_geometry = geom
        self.app.game.resizeGame()
        if self.app.opt.auto_scale:
            w, h = self.app.opt.game_geometry
            self.app.canvas.setInitialSize(w, h, scrollregion=False)
        else:
            w = int(round(self.app.game.width * self.app.opt.scale_x))
            h = int(round(self.app.game.height * self.app.opt.scale_y))
            self.app.canvas.setInitialSize(w, h)
            self.app.top.wm_geometry("")    # cancel user-specified geometry
        # self.app.top.update_idletasks()

    def mIncreaseCardset(self, *event):
        if self._cancelDrag(break_pause=True):
            return
        if self.app.opt.scale_x < 4:
            self.app.opt.scale_x += 0.1
        else:
            return
        if self.app.opt.scale_y < 4:
            self.app.opt.scale_y += 0.1
        else:
            return
        self.app.opt.auto_scale = False
        self.tkopt.auto_scale.set(False)
        self._updateCardSize()

    def mDecreaseCardset(self, *event):
        if self._cancelDrag(break_pause=True):
            return
        if self.app.opt.scale_x > 0.5:
            self.app.opt.scale_x -= 0.1
        else:
            return
        if self.app.opt.scale_y > 0.5:
            self.app.opt.scale_y -= 0.1
        else:
            return
        self.app.opt.auto_scale = False
        self.tkopt.auto_scale.set(False)
        self._updateCardSize()

    def mOptAutoScale(self, *event):
        if self._cancelDrag(break_pause=True):
            return
        auto_scale = not self.app.opt.auto_scale
        self.app.opt.auto_scale = auto_scale
        self.tkopt.auto_scale.set(auto_scale)
        self._updateCardSize()

    def _mOptCardback(self, index):
        if self._cancelDrag(break_pause=False):
            return
        cs = self.app.cardset
        old_index = cs.backindex
        cs.updateCardback(backindex=index)
        if cs.backindex == old_index:
            return
        self.app.updateCardset(self.game.id)
        image = self.app.images.getBack(update=True)
        for card in self.game.cards:
            card.updateCardBackground(image=image)
        self.app.canvas.update_idletasks()
        self.tkopt.cardback.set(cs.backindex)

    def mOptCardback(self, *event):
        self._mOptCardback(self.tkopt.cardback.get())

    def mOptChangeCardback(self, *event):
        self._mOptCardback(self.app.cardset.backindex + 1)

    def mOptChangeTableTile(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        n = self.app.tabletile_manager.len()
        if n >= 2:
            i = (self.tkopt.tabletile.get() + 1) % n
            if self.app.setTile(i):
                self.tkopt.tabletile.set(i)

    def mSelectTileDialog(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        key = self.app.tabletile_index
        if key <= 0:
            key = self.app.opt.colors['table']  # .lower()
        d = self._calcSelectTileDialogWithPreview()(
            self.top, app=self.app,
            title=_("Select table background"),
            manager=self.app.tabletile_manager,
            key=key)
        if d.status == 0 and d.button == 0:
            if isinstance(d.key, str):
                tile = self.app.tabletile_manager.get(0)
                tile.color = d.key
                if self.app.setTile(0):
                    self.tkopt.tabletile.set(0)
            elif d.key > 0 and d.key != self.app.tabletile_index:
                if self.app.setTile(d.key):
                    self.tkopt.tabletile.set(d.key)

    def mOptToolbar(self, *event):
        # if self._cancelDrag(break_pause=False): return
        self.setToolbarSide(self.tkopt.toolbar.get())

    def mOptToolbarStyle(self, *event):
        # if self._cancelDrag(break_pause=False): return
        self.setToolbarStyle(self.tkopt.toolbar_style.get())

    def mOptToolbarCompound(self, *event):
        # if self._cancelDrag(break_pause=False): return
        self.setToolbarCompound(self.tkopt.toolbar_compound.get())

    def mOptToolbarSize(self, *event):
        # if self._cancelDrag(break_pause=False): return
        self.setToolbarSize(self.tkopt.toolbar_size.get())

    def mOptToolbarConfig(self, w):
        self.toolbarConfig(w, self.tkopt.toolbar_vars[w].get())

    def mOptStatusbar(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        if not self.app.statusbar:
            return
        side = self.tkopt.statusbar.get()
        self.app.opt.statusbar = side
        resize = not self.app.opt.save_games_geometry
        if self.app.statusbar.show(side, resize=resize):
            self.top.update_idletasks()

    def mOptNumCards(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.num_cards = self.tkopt.num_cards.get()

    def mOptHelpbar(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        if not self.app.helpbar:
            return
        show = self.tkopt.helpbar.get()
        self.app.opt.helpbar = show
        resize = not self.app.opt.save_games_geometry
        if self.app.helpbar.show(show, resize=resize):
            self.top.update_idletasks()

    def mOptSaveGamesGeometry(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.save_games_geometry = self.tkopt.save_games_geometry.get()

    def mOptDemoLogo(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.demo_logo = self.tkopt.demo_logo.get()

    def mOptSplashscreen(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.splashscreen = self.tkopt.splashscreen.get()

    def mOptMouseType(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.mouse_type = self.tkopt.mouse_type.get()

    def mOptMouseUndo(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.mouse_undo = self.tkopt.mouse_undo.get()

    def mOptNegativeBottom(self, *event):
        if self._cancelDrag():
            return
        self.app.opt.negative_bottom = self.tkopt.negative_bottom.get()
        self.app.updateCardset()
        self.game.endGame(bookmark=1)
        self.game.quitGame(bookmark=1)

    #
    # toolbar support
    #

    def setToolbarSide(self, side):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.toolbar = side
        self.tkopt.toolbar.set(side)                    # update radiobutton
        resize = not self.app.opt.save_games_geometry
        if self.app.toolbar.show(side, resize=resize):
            self.top.update_idletasks()

    def setToolbarSize(self, size):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.toolbar_size = size
        self.tkopt.toolbar_size.set(size)                # update radiobutton
        dir = self.app.getToolbarImagesDir()
        if self.app.toolbar.updateImages(dir, size):
            self.game.updateStatus(player=self.app.opt.player)
            self.top.update_idletasks()

    def setToolbarStyle(self, style):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.toolbar_style = style
        self.tkopt.toolbar_style.set(style)                # update radiobutton
        dir = self.app.getToolbarImagesDir()
        size = self.app.opt.toolbar_size
        if self.app.toolbar.updateImages(dir, size):
            # self.game.updateStatus(player=self.app.opt.player)
            self.top.update_idletasks()

    def setToolbarCompound(self, compound):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.toolbar_compound = compound
        self.tkopt.toolbar_compound.set(compound)          # update radiobutton
        if self.app.toolbar.setCompound(compound):
            self.game.updateStatus(player=self.app.opt.player)
            self.top.update_idletasks()

    def wizardDialog(self, edit=False):
        from pysollib.wizardutil import write_game, reset_wizard
        WizardDialog = self._calcWizardDialog()

        if edit:
            reset_wizard(self.game)
        else:
            reset_wizard(None)
        d = WizardDialog(self.top, _('Solitaire Wizard'), self.app)
        if d.status == 0 and d.button == 0:
            try:
                if edit:
                    gameid = write_game(self.app, game=self.game)
                else:
                    gameid = write_game(self.app)
            except Exception as err:
                # if False:
                #    traceback.print_exc()
                self._calc_MfxMessageDialog()(
                    self.top, title=_('Save game error'),
                    text=_('''
Error while saving game.

%s
''') % str(err),
                    bitmap='error')
                return

            if SELECT_GAME_MENU:
                menu = self.menupath[".menubar.select.customgames"][2]

                def select_func(gi):
                    return gi.si.game_type == GI.GT_CUSTOM
                games = list(map(self.app.gdb.get,
                                 self.app.gdb.getGamesIdSortedByName()))
                games = list(filter(select_func, games))
                self.updateGamesMenu(menu, games)

            self.tkopt.gameid.set(gameid)
            self._mSelectGame(gameid, force=True)

    def mWizard(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.wizardDialog()

    def mWizardEdit(self, *event):
        if self._cancelDrag(break_pause=False):
            return
        self.wizardDialog(edit=True)

    def toolbarConfig(self, w, v):
        if self._cancelDrag(break_pause=False):
            return
        self.app.opt.toolbar_vars[w] = v
        self.app.toolbar.config(w, v)
        self.top.update_idletasks()

    #
    # stacks descriptions
    #

    def mStackDesk(self, *event):
        if self.game.stackdesc_list:
            self.game.deleteStackDesc()
        else:
            if self._cancelDrag(break_pause=True):
                return
            self.game.showStackDesc()
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

import os

from pysollib.mygettext import _
from pysollib.settings import TITLE
from pysollib.ui.tktile.tkcanvas import MfxCanvas, MfxCanvasGroup
from pysollib.ui.tktile.tkcanvas import MfxCanvasImage, MfxCanvasRectangle
from pysollib.ui.tktile.tkutil import after, after_cancel
from pysollib.ui.tktile.tkutil import bind, makeImage, unbind_destroy

from six.moves import tkinter


LARGE_EMBLEMS_SIZE = (38, 34)
SMALL_EMBLEMS_SIZE = (31, 21)


class FindCardDialog(tkinter.Toplevel):
    CARD_IMAGES = {}  # key: (rank, suit)

    def __init__(self, parent, game, dir, size='large'):
        tkinter.Toplevel.__init__(self)
        title = TITLE + ' - ' + _('Find card')
        self.title(title)
        self.wm_resizable(False, False)
        #
        # self.images_dir = dir
        if size == 'large':
            self.images_dir = os.path.join(dir, 'large')
            self.label_width, self.label_height = LARGE_EMBLEMS_SIZE
        else:
            self.images_dir = os.path.join(dir, 'small')
            self.label_width, self.label_height = SMALL_EMBLEMS_SIZE
        self.canvas = MfxCanvas(self, bg='white')
        # self.canvas = MfxCanvas(self, bg='black')
        self.canvas.pack(expand=True, fill='both')
        #
        self.groups = []
        self.highlight_items = None
        self.busy = False
        self.connectGame(game)
        #
        bind(self, "WM_DELETE_WINDOW", self.destroy)
        bind(self, "<Escape>", self.destroy)
        #
        # self.normal_timeout = 400    # in milliseconds
        self.normal_timeout = int(
            1000*game.app.opt.timeouts['highlight_samerank'])
        self.hidden_timeout = 200
        self.timer = None

    def createCardLabel(self, suit, rank, x0, y0):
        dx, dy = self.label_width, self.label_height
        dir = self.images_dir
        canvas = self.canvas
        group = MfxCanvasGroup(canvas)
        #
        im = FindCardDialog.CARD_IMAGES.get((rank, suit))
        if im is None:
            r = '%02d' % (rank+1)
            s = 'cshd'[suit]
            fn = os.path.join(dir, r+s+'.gif')
            im = makeImage(file=fn)
            FindCardDialog.CARD_IMAGES[(rank, suit)] = im
        cim = MfxCanvasImage(canvas, x0, y0, image=im, anchor='nw')
        cim.addtag(group)
        cim.lower()
        #
        rect_width = 4
        x1, y1 = x0+dx, y0+dy
        rect = MfxCanvasRectangle(self.canvas, x0+1, y0+1, x1-1, y1-1,
                                  width=rect_width,
                                  fill=None,
                                  outline='red',
                                  state='hidden'
                                  )
        rect.addtag(group)
        #
        bind(group, '<Enter>',
             lambda e, suit=suit, rank=rank, rect=rect:
                 self.enterEvent(suit, rank, rect, group))
        bind(group, '<Leave>',
             lambda e, suit=suit, rank=rank, rect=rect:
                 self.leaveEvent(suit, rank, rect, group))
        self.groups.append(group)

    def connectGame(self, game):
        self.canvas.delete('all')
        self.game = game
        suits = game.gameinfo.suits
        ranks = game.gameinfo.ranks
        dx, dy = self.label_width, self.label_height
        uniq_suits = []
        i = 0
        for suit in suits:
            if suit in uniq_suits:
                continue
            uniq_suits.append(suit)
            j = 0
            for rank in ranks:
                x, y = dx*j+2, dy*i+2
                self.createCardLabel(suit=suit, rank=rank, x0=x, y0=y)
                j += 1
            i += 1
        w, h = dx*j+2, dy*i+2
        self.canvas.config(width=w, height=h)
        self.wm_iconname(TITLE + " - " + game.getTitleName())
        self.wm_geometry('')            # cancel user-specified geometry

    def enterEvent(self, suit, rank, rect, group):
        # print 'enterEvent', suit, rank, self.busy
        if self.busy:
            return
        if self.game.demo:
            return
        self.busy = True
        self.highlight_items = self.game.highlightCard(suit, rank)
        if not self.highlight_items:
            self.highlight_items = []
        if self.highlight_items:
            self.timer = after(self, self.normal_timeout, self.timeoutEvent)
        rect.config(state='normal')
        self.canvas.update_idletasks()
        self.busy = False

    def leaveEvent(self, suit, rank, rect, group):
        # print 'leaveEvent', suit, rank, self.busy
        if self.busy:
            return
        self.busy = True
        if self.highlight_items:
            for i in self.highlight_items:
                i.delete()
            self.highlight_items = []
        if self.timer:
            after_cancel(self.timer)
            self.timer = None
        rect.config(state='hidden')
        if self.game.canvas:
            self.game.canvas.update_idletasks()
        self.canvas.update_idletasks()
        self.busy = False

    def timeoutEvent(self, *event):
        if self.highlight_items:
            state = self.highlight_items[0].cget('state')
            if state in ('', 'normal'):
                state = 'hidden'
                self.timer = after(self, self.hidden_timeout,
                                   self.timeoutEvent)
            else:
                state = 'normal'
                self.timer = after(self, self.normal_timeout,
                                   self.timeoutEvent)
            for item in self.highlight_items:
                item.config(state=state)

    def destroy(self, *args):
        for l in self.groups:
            unbind_destroy(l)
        unbind_destroy(self)
        if self.timer:
            after_cancel(self.timer)
            self.timer = None
        self.wm_withdraw()
        if self.highlight_items:
            for i in self.highlight_items:
                i.delete()
        tkinter.Toplevel.destroy(self)


find_card_dialog = None


def create_find_card_dialog(parent, game, dir):
    global find_card_dialog
    try:
        find_card_dialog.wm_deiconify()
        find_card_dialog.tkraise()
    except Exception:
        # traceback.print_exc()
        find_card_dialog = FindCardDialog(parent, game, dir)


def connect_game_find_card_dialog(game):
    try:
        find_card_dialog.connectGame(game)
    except Exception:
        pass


def destroy_find_card_dialog():
    global find_card_dialog
    try:
        find_card_dialog.destroy()
    except Exception:
        # traceback.print_exc()
        pass
    find_card_dialog = None
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

from pysollib.acard import AbstractCard
from pysollib.ui.tktile.tkcanvas import MfxCanvasGroup, MfxCanvasImage


# ************************************************************************
# *
# ************************************************************************

class _HideableCard(AbstractCard):
    def hide(self, stack):
        if stack is self.hide_stack:
            return
        self.item.config(state="hidden")
        self.hide_stack = stack
        # print "hide:", self.id, self.item.coords()

    def unhide(self):
        if self.hide_stack is None:
            return 0
        # print "unhide:", self.id, self.item.coords()
        self.item.config(state="normal")
        self.hide_stack = None
        return 1


# ************************************************************************
# * New implementation since 2.10
# *
# * We use a single CanvasImage and call CanvasImage.config() to
# * turn the card.
# * This makes turning cards a little bit slower, but dragging cards
# * around is noticeable faster as the total number of images is
# * reduced by half.
# ************************************************************************

class _OneImageCard(_HideableCard):
    def __init__(self, id, deck, suit, rank, game, x=0, y=0):
        _HideableCard.__init__(self, id, deck, suit, rank, game, x=x, y=y)
        self._face_image = game.getCardFaceImage(deck, suit, rank)
        self._back_image = game.getCardBackImage(deck, suit, rank)
        self._shade_image = game.getCardShadeImage()
        self._active_image = self._back_image
        self.item = MfxCanvasImage(
            game.canvas, self.x, self.y, image=self._active_image, anchor="nw")
        self.shade_item = None
        # self._setImage = self.item.config

    def _setImage(self, image):
        if image is not self._active_image:
            self.item.config(image=image)
            self._active_image = image

    def showFace(self, unhide=1):
        if not self.face_up:
            self._setImage(image=self._face_image)
            self.tkraise(unhide)
            self.face_up = 1

    def showBack(self, unhide=1):
        if self.face_up:
            self._setImage(image=self._back_image)
            self.tkraise(unhide)
            self.face_up = 0

    def updateCardBackground(self, image):
        self._back_image = image
        if not self.face_up:
            self._setImage(image=image)

    #
    # optimized by inlining
    #

    def moveBy(self, dx, dy):
        dx, dy = int(dx), int(dy)
        self.x = self.x + dx
        self.y = self.y + dy
        item = self.item
        item.canvas.tk.call(item.canvas._w, "move", item.id, dx, dy)

    # for resize
    def update(self, id, deck, suit, rank, game):
        self._face_image = game.getCardFaceImage(deck, suit, rank)
        self._back_image = game.getCardBackImage(deck, suit, rank)
        self._shade_image = game.getCardShadeImage()
        if self.face_up:
            img = self._face_image
        else:
            img = self._back_image
        self.item.config(image=img)
        self._active_image = img


# ************************************************************************
# * New idea since 3.00
# *
# * Hide a card by configuring the canvas image to None.
# ************************************************************************

class _OneImageCardWithHideByConfig(_OneImageCard):
    def hide(self, stack):
        if stack is self.hide_stack:
            return
        self._setImage(image=None)
        self.hide_stack = stack

    def unhide(self):
        if self.hide_stack is None:
            return 0
        if self.face_up:
            self._setImage(image=self._face_image)
        else:
            self._setImage(image=self._back_image)
        self.hide_stack = None
        return 1

    #
    # much like in _OneImageCard
    #

    def showFace(self, unhide=1):
        if not self.face_up:
            if unhide:
                self._setImage(image=self._face_image)
            self.item.tkraise()
            self.face_up = 1

    def showBack(self, unhide=1):
        if self.face_up:
            if unhide:
                self._setImage(image=self._back_image)
            self.item.tkraise()
            self.face_up = 0

    def updateCardBackground(self, image):
        self._back_image = image
        if not self.face_up and not self.hide_stack:
            self._setImage(image=image)


# ************************************************************************
# * Old implementation prior to 2.10
# *
# * The card consists of two CanvasImages. To show the card face up,
# * the face item is placed in front of the back. To show it face
# * down, this is reversed.
# ************************************************************************

class _TwoImageCard(_HideableCard):
    # Private instance variables:
    #   __face, __back -- the canvas items making up the card
    def __init__(self, id, deck, suit, rank, game, x=0, y=0):
        _HideableCard.__init__(self, id, deck, suit, rank, game, x=x, y=y)
        self.item = MfxCanvasGroup(game.canvas)
        self.__face = MfxCanvasImage(
            game.canvas, self.x, self.y, image=game.getCardFaceImage(
                deck, suit, rank), anchor="nw")
        self.__back = MfxCanvasImage(
            game.canvas, self.x, self.y, image=game.getCardBackImage(
                deck, suit, rank), anchor="nw")
        self.__face.addtag(self.item)
        self.__back.addtag(self.item)

    def showFace(self, unhide=1):
        if not self.face_up:
            self.__face.tkraise()
            self.tkraise(unhide)
            self.face_up = 1

    def showBack(self, unhide=1):
        if self.face_up:
            self.__back.tkraise()
            self.tkraise(unhide)
            self.face_up = 0

    def updateCardBackground(self, image):
        self.__back.config(image=image)


# ************************************************************************
# * New idea since 2.90
# *
# * The card consists of two CanvasImages. Instead of raising
# * one image above the other we move the inactive image out
# * of the visible canvas.
# ************************************************************************

class _TwoImageCardWithHideItem(_HideableCard):
    # Private instance variables:
    #   __face, __back -- the canvas items making up the card
    def __init__(self, id, deck, suit, rank, game, x=0, y=0):
        _HideableCard.__init__(self, id, deck, suit, rank, game, x=x, y=y)
        self.item = MfxCanvasGroup(game.canvas)
        self.__face = MfxCanvasImage(
            game.canvas, self.x, self.y + 11000, image=game.getCardFaceImage(
                deck, suit, rank), anchor="nw")
        self.__back = MfxCanvasImage(
            game.canvas, self.x, self.y, image=game.getCardBackImage(
                deck, suit, rank), anchor="nw")
        self.__face.addtag(self.item)
        self.__back.addtag(self.item)

    def showFace(self, unhide=1):
        if not self.face_up:
            self.__back.move(0, 10000)
            # self.__face.tkraise()
            self.__face.move(0, -11000)
            self.tkraise(unhide)
            self.face_up = 1

    def showBack(self, unhide=1):
        if self.face_up:
            self.__face.move(0, 11000)
            # self.__back.tkraise()
            self.__back.move(0, -10000)
            self.tkraise(unhide)
            self.face_up = 0

    def updateCardBackground(self, image):
        self.__back.config(image=image)


# choose the implementation
Card = _TwoImageCardWithHideItem
Card = _TwoImageCard
Card = _OneImageCardWithHideByConfig
Card = _OneImageCard
# This module exports classes for the various canvas item types

# NOTE: This module was an experiment and is now obsolete.
# It's best to use the Tkinter.Canvas class directly.

from six.moves.tkinter import Canvas, _cnfmerge, _flatten  # noqa: F401


class CanvasItem:
    def __init__(self, canvas, itemType, *args, **kw):
        self.canvas = canvas
        self.id = canvas._create(itemType, args, kw)
        if not hasattr(canvas, 'items'):
            canvas.items = {}
        canvas.items[self.id] = self

    def __str__(self):
        return str(self.id)

    def __repr__(self):
        return '<%s, id=%d>' % (self.__class__.__name__, self.id)

    def delete(self):
        del self.canvas.items[self.id]
        self.canvas.delete(self.id)

    def __getitem__(self, key):
        v = self.canvas.tk.split(self.canvas.tk.call(
                self.canvas._w, 'itemconfigure',
                self.id, '-' + key))
        return v[4]
    cget = __getitem__

    def __setitem__(self, key, value):
        self.canvas.itemconfig(self.id, {key: value})

    def keys(self):
        if not hasattr(self, '_keys'):
            self._keys = map(lambda x, tk=self.canvas.tk:
                             tk.splitlist(x)[0][1:],
                             self.canvas.tk.splitlist(
                                     self.canvas._do(
                                             'itemconfigure',
                                             (self.id,))))
        return self._keys

    def has_key(self, key):
        return key in self.keys()

    def __contains__(self, key):
        return key in self.keys()

    def addtag(self, tag, option='withtag'):
        self.canvas.addtag(tag, option, self.id)

    def bbox(self):
        x1, y1, x2, y2 = self.canvas.bbox(self.id)
        return (x1, y1), (x2, y2)

    def bind(self, sequence=None, command=None, add=None):
        return self.canvas.tag_bind(self.id, sequence, command, add)

    def unbind(self, sequence, funcid=None):
        self.canvas.tag_unbind(self.id, sequence, funcid)

    def config(self, cnf={}, **kw):
        return self.canvas.itemconfig(self.id, _cnfmerge((cnf, kw)))

    def coords(self, pts=()):
        flat = ()
        for x, y in pts:
            flat += (x, y)
        return self.canvas.coords(self.id, *flat)

    def dchars(self, first, last=None):
        self.canvas.dchars(self.id, first, last)

    def dtag(self, ttd):
        self.canvas.dtag(self.id, ttd)

    def focus(self):
        self.canvas.focus(self.id)

    def gettags(self):
        return self.canvas.gettags(self.id)

    def icursor(self, index):
        self.canvas.icursor(self.id, index)

    def index(self, index):
        return self.canvas.index(self.id, index)

    def insert(self, beforethis, string):
        self.canvas.insert(self.id, beforethis, string)

    def lower(self, belowthis=None):
        self.canvas.tag_lower(self.id, belowthis)

    def move(self, xamount, yamount):
        self.canvas.move(self.id, xamount, yamount)

    def tkraise(self, abovethis=None):
        self.canvas.tag_raise(self.id, abovethis)
    raise_ = tkraise  # BW compat

    def scale(self, xorigin, yorigin, xscale, yscale):
        self.canvas.scale(self.id, xorigin, yorigin, xscale, yscale)

    def type(self):
        return self.canvas.type(self.id)


class Arc(CanvasItem):
    def __init__(self, canvas, *args, **kw):
        CanvasItem.__init__(self, canvas, 'arc', *args, **kw)


class Bitmap(CanvasItem):
    def __init__(self, canvas, *args, **kw):
        CanvasItem.__init__(self, canvas, 'bitmap', *args, **kw)


class ImageItem(CanvasItem):
    def __init__(self, canvas, *args, **kw):
        CanvasItem.__init__(self, canvas, 'image', *args, **kw)


class Line(CanvasItem):
    def __init__(self, canvas, *args, **kw):
        CanvasItem.__init__(self, canvas, 'line', *args, **kw)


class Oval(CanvasItem):
    def __init__(self, canvas, *args, **kw):
        CanvasItem.__init__(self, canvas, 'oval', *args, **kw)


class Polygon(CanvasItem):
    def __init__(self, canvas, *args, **kw):
        CanvasItem.__init__(self, canvas, 'polygon', *args, **kw)


class Rectangle(CanvasItem):
    def __init__(self, canvas, *args, **kw):
        CanvasItem.__init__(self, canvas, 'rectangle', *args, **kw)


# XXX "Text" is taken by the Text widget...
class CanvasText(CanvasItem):
    def __init__(self, canvas, *args, **kw):
        CanvasItem.__init__(self, canvas, 'text', *args, **kw)


class Window(CanvasItem):
    def __init__(self, canvas, *args, **kw):
        CanvasItem.__init__(self, canvas, 'window', *args, **kw)


class Group:
    def __init__(self, canvas, tag=None):
        if not tag:
            tag = 'Group%d' % id(self)
        self.tag = self.id = tag
        self.canvas = canvas
        self.canvas.dtag(self.tag)

    def str(self):
        return self.tag
    __str__ = str

    def _do(self, cmd, *args):
        return self.canvas._do(cmd, (self.tag,) + _flatten(args))

    def addtag_above(self, tagOrId):
        self._do('addtag', 'above', tagOrId)

    def addtag_all(self):
        self._do('addtag', 'all')

    def addtag_below(self, tagOrId):
        self._do('addtag', 'below', tagOrId)

    def addtag_closest(self, x, y, halo=None, start=None):
        self._do('addtag', 'closest', x, y, halo, start)

    def addtag_enclosed(self, x1, y1, x2, y2):
        self._do('addtag', 'enclosed', x1, y1, x2, y2)

    def addtag_overlapping(self, x1, y1, x2, y2):
        self._do('addtag', 'overlapping', x1, y1, x2, y2)

    def addtag_withtag(self, tagOrId):
        self._do('addtag', 'withtag', tagOrId)

    def bbox(self):
        return self.canvas._getints(self._do('bbox'))

    def bind(self, sequence=None, command=None, add=None):
        return self.canvas.tag_bind(self.id, sequence, command, add)

    def unbind(self, sequence, funcid=None):
        self.canvas.tag_unbind(self.id, sequence, funcid)

    def coords(self, *pts):
        return self._do('coords', pts)

    def dchars(self, first, last=None):
        self._do('dchars', first, last)

    def delete(self):
        self._do('delete')

    def dtag(self, tagToDelete=None):
        self._do('dtag', tagToDelete)

    def focus(self):
        self._do('focus')

    def gettags(self):
        return self.canvas.tk.splitlist(self._do('gettags', self.tag))

    def icursor(self, index):
        return self._do('icursor', index)

    def index(self, index):
        return self.canvas.tk.getint(self._do('index', index))

    def insert(self, beforeThis, string):
        self._do('insert', beforeThis, string)

    def config(self, cnf={}, **kw):
        return self.canvas.itemconfigure(self.tag, _cnfmerge((cnf, kw)))

    def lower(self, belowThis=None):
        self._do('lower', belowThis)

    def move(self, xAmount, yAmount):
        self._do('move', xAmount, yAmount)

    def tkraise(self, aboveThis=None):
        self._do('raise', aboveThis)
    lift = tkraise

    def scale(self, xOrigin, yOrigin, xScale, yScale):
        self._do('scale', xOrigin, yOrigin, xScale, yScale)

    def select_adjust(self, index):
        self.canvas._do('select', ('adjust', self.tag, index))

    def select_from(self, index):
        self.canvas._do('select', ('from', self.tag, index))

    def select_to(self, index):
        self.canvas._do('select', ('to', self.tag, index))

    def type(self):
        return self._do('type')
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

from pysollib.gamedb import GI
from pysollib.mfxutil import KwStruct
from pysollib.mygettext import _


class BaseGameInfoDialog:
    def __init__(self, parent, title, app, **kw):
        kw = self.initKw(kw)
        self._calc_MfxDialog().__init__(
            self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.createBitmaps(top_frame, kw)

        frame = self._calcToolkit().Frame(top_frame)
        frame.pack(expand=True, fill='both', padx=5, pady=10)
        frame.columnconfigure(0, weight=1)

        game = app.game
        gi = game.gameinfo

        #
        if gi.redeals == -2:
            redeals = 'VARIABLE'
        elif gi.redeals == -1:
            redeals = 'UNLIMITED'
        else:
            redeals = str(gi.redeals)
        cat = '<none>'
        type = '<none>'
        flags = []
        for attr in dir(GI):
            if attr.startswith('GC_'):
                c = getattr(GI, attr)
                if gi.category == c:
                    cat = attr
            elif attr.startswith('GT_'):
                t = getattr(GI, attr)
                if t < (1 << 12)-1:
                    if gi.si.game_type == t:
                        type = attr
                else:
                    if gi.si.game_flags & t:
                        flags.append(attr)
        #
        version = None
        for t in GI.GAMES_BY_PYSOL_VERSION:
            if gi.id in t[1]:
                version = t[0]
                break
        sl = {
            1: 'SL_LUCK',
            2: 'SL_MOSTLY_LUCK',
            3: 'SL_BALANCED',
            4: 'SL_MOSTLY_SKILL',
            5: 'SL_SKILL',
            }
        skill_level = sl.get(gi.skill_level)
        if game.Hint_Class is None:
            hint = None
        else:
            hint = game.Hint_Class.__name__
        row = 0
        for n, t in (('Name:', gi.name),
                     ('Short name:', gi.short_name),
                     ('ID:', gi.id),
                     ('Alt names:', '\n'.join(gi.altnames)),
                     ('PySol version:', version),
                     ('Decks:', gi.decks),
                     ('Cards:', gi.ncards),
                     ('Redeals:', redeals),
                     ('Category:', cat),
                     ('Type:', type),
                     ('Flags:', '\n'.join(flags)),
                     ('Skill level:', skill_level),
                     ('Rules filename:', gi.rules_filename),
                     ('Module:', game.__module__),
                     ('Class:', game.__class__.__name__),
                     ('Hint:', hint),
                     ):
            if t:
                self._calcToolkit().Label(
                    frame, text=n, anchor='w').grid(
                    row=row, column=0, sticky='nw')
                self._calcToolkit().Label(
                    frame, text=t, anchor='w', justify='left').grid(
                    row=row, column=1, sticky='nw')
                row += 1

        if game.s.talon:
            self.showStacks(frame, row, 'Talon:', game.s.talon)
            row += 1
        if game.s.waste:
            self.showStacks(frame, row, 'Waste:', game.s.waste)
            row += 1
        for t, s in (
            ('Foundations:', game.s.foundations,),
            ('Rows:',        game.s.rows,),
            ('Reserves:',    game.s.reserves,),
                ):
            if s:
                self.showStacks(frame, row, t, s)
                row += 1

        #
        focus = self.createButtons(bottom_frame, kw)
        self.mainloop(focus, kw.timeout)

    def showStacks(self, frame, row, title, stacks):
        self._calcToolkit().Label(
            frame, text=title, anchor='w').grid(
            row=row, column=0, sticky='nw')
        if isinstance(stacks, (list, tuple)):
            fs = {}
            for f in stacks:
                cn = f.__class__.__name__
                if cn in fs:
                    fs[cn] += 1
                else:
                    fs[cn] = 1
            t = '\n'.join(['%s (%d)' % (i[0], i[1]) for i in list(fs.items())])
        else:
            t = stacks.__class__.__name__
        self._calcToolkit().Label(
            frame, text=t, anchor='w', justify='left').grid(
            row=row, column=1, sticky='nw')

    def initKw(self, kw):
        kw = KwStruct(kw,
                      strings=(_("&OK"),),
                      default=0,
                      separator=True,
                      )
        return self._calc_MfxDialog().initKw(self, kw)

    # Requires implementing self._calcToolkit() self._calc_MfxDialog()
from pysollib.mfxutil import KwStruct
from pysollib.mygettext import _

from six.moves import tkinter


class BaseEditTextDialog:
    def __init__(self, parent, title, text, **kw):
        kw = self.initKw(kw)
        self._calc_MfxDialog().__init__(
            self, parent, title, kw.resizable, kw.default)
        top_frame, bottom_frame = self.createFrames(kw)
        self.createBitmaps(top_frame, kw)
        #
        self.text_w = tkinter.Text(top_frame, bd=1, relief="sunken",
                                   wrap="word", width=64, height=16)
        self.text_w.pack(side='left', fill="both", expand=True)
        # self.text_w.pack(side='top', padx=kw.padx, pady=kw.pady)
        vbar = self._calcToolkit().Scrollbar(top_frame)
        vbar.pack(side='right', fill='y')
        self.text_w["yscrollcommand"] = vbar.set
        vbar["command"] = self.text_w.yview
        #
        self.text = ""
        if text:
            self.text = text
            old_state = self.text_w["state"]
            self.text_w.config(state="normal")
            self.text_w.insert("insert", self.text)
            self.text_w.config(state=old_state)
        #
        focus = self.createButtons(bottom_frame, kw)
        focus = self.text_w
        self.mainloop(focus, kw.timeout)

    def initKw(self, kw):
        kw = KwStruct(kw,
                      strings=(_("&OK"), _("&Cancel")),
                      default=-1,
                      resizable=self._calc_Resizable(),
                      separator=False,
                      )
        return self._calc_MfxDialog().initKw(self, kw)

    def destroy(self):
        self.text = self.text_w.get("1.0", "end")
        self._calc_MfxDialog().destroy(self)

    def wmDeleteWindow(self, *event):   # ignore
        pass

    def mCancel(self, *event):          # ignore <Escape>
        pass
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

from pysollib.ui.tktile.tkconst import EVENT_PROPAGATE

from six.moves import tkinter
TclError = tkinter.TclError


# ************************************************************************
# * Wrapper class for Tk.
# * Required so that a Game will get properly destroyed.
# ************************************************************************

class MfxRoot(tkinter.Tk):
    def __init__(self, **kw):
        tkinter.Tk.__init__(self, **kw)
        self.app = None
        self.wm_protocol('WM_DELETE_WINDOW', self.wmDeleteWindow)
        # for interruptible sleep
        # self.sleep_var = tkinter.IntVar(self)
        # self.sleep_var.set(0)
        self.sleep_var = 0
        self.after_id = None
        # self.bind('<ButtonPress>', self._sleepEvent, add=True)

    def connectApp(self, app):
        self.app = app

    # sometimes an update() is needed under Windows, whereas
    # under Unix an update_idletasks() would be enough...
    def busyUpdate(self):
        game = None
        if self.app:
            game = self.app.game
        if not game:
            self.update()
        else:
            old_busy = game.busy
            game.busy = 1
            if game.canvas:
                game.canvas.update()
            self.update()
            game.busy = old_busy

    def mainquit(self):
        self.after_idle(self.quit)

    def screenshot(self, filename):
        # print 'MfxRoot.screenshot not yet implemented'
        pass

    def setCursor(self, cursor):
        if 0:
            # FIXME: this causes ugly resizes !
            tkinter.Tk.config(self, cursor=cursor)
        elif 0:
            # and this is even worse
            # print self.children
            for v in self.children.values():
                v.config(cursor=cursor)
        else:
            pass

    #
    # sleep
    #

    def sleep(self, seconds):
        # time.sleep(seconds)
        self.after(int(seconds*1000))
        return
        print('sleep', seconds)
        timeout = int(seconds*1000)
        self.sleep_var = 0
        while timeout > 0:
            self.update()
            self.update_idletasks()
            if self.sleep_var:
                break
            self.after(100)
            timeout -= 100
        print('finish sleep')
        return
        if self.after_id:
            self.after_cancel(self.after_id)
        self.after_id = self.after(int(seconds*1000), self._sleepEvent)
        self.sleep_var.set(1)
        self.update()
        self.wait_variable(self.sleep_var)
        if self.after_id:
            self.after_cancel(self.after_id)
            self.after_id = None
        print('finish sleep')

    def _sleepEvent(self, *args):
        return
        print('_sleepEvent', args)
        self.interruptSleep()
        return EVENT_PROPAGATE

    def interruptSleep(self):
        return
        print('interruptSleep')
        self.update()
        self.update_idletasks()
        self.sleep_var = 1
        # self.sleep_var.set(0)
        # self.after_idle(self.sleep_var.set, 0)

    #
    #
    #

    def update(self):
        tkinter.Tk.update(self)

    def wmDeleteWindow(self):
        if self.app and self.app.menubar:
            self.app.menubar.mQuit()
        else:
            # self.after_idle(self.quit)
            pass
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------##
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------##

from pysollib.mygettext import n_

from six.moves import tkinter

# ************************************************************************
# * constants
# ************************************************************************

EVENT_HANDLED = "break"
EVENT_PROPAGATE = None

CURSOR_DRAG = "hand1"
CURSOR_WATCH = "watch"
CURSOR_DOWN_ARROW = 'sb_down_arrow'

ANCHOR_CENTER = tkinter.CENTER
ANCHOR_N = tkinter.N
ANCHOR_NW = tkinter.NW
ANCHOR_NE = tkinter.NE
ANCHOR_S = tkinter.S
ANCHOR_SW = tkinter.SW
ANCHOR_SE = tkinter.SE
ANCHOR_W = tkinter.W
ANCHOR_E = tkinter.E

COMPOUNDS = (
    # (tkinter.BOTTOM,  'bottom'),
    # (tkinter.CENTER,  'center'),
    # (tkinter.RIGHT,    'right'),
    (tkinter.NONE,   n_('Icons only')),
    (tkinter.TOP,    n_('Text below icons')),
    (tkinter.LEFT,   n_('Text beside icons')),
    ('text',         n_('Text only')),
    )

TOOLBAR_BUTTONS = (
    "new",
    "restart",
    "open",
    "save",
    "undo",
    "redo",
    "autodrop",
    "shuffle",
    "pause",
    "statistics",
    "rules",
    "quit",
    "player",
    )
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

import re

from pysollib.mfxutil import Image, ImageOps, ImageTk
from pysollib.settings import TITLE, WIN_SYSTEM

from six.moves import tkinter
from six.moves import tkinter_font


# ************************************************************************
# * window manager util
# ************************************************************************

def wm_withdraw(window):
    window.wm_withdraw()


def wm_deiconify(window):
    window.wm_deiconify()


def wm_map(window, maximized=0):
    if window.wm_state() != "iconic":
        if maximized and WIN_SYSTEM == "win32":
            window.wm_state("zoomed")
        else:
            wm_deiconify(window)


__wm_get_geometry_re = re.compile(r"^(\d+)x(\d+)\+([\-]?\d+)\+([\-]?\d+)$")


def wm_get_geometry(window):
    g = window.wm_geometry()
    m = __wm_get_geometry_re.search(g)
    if not m:
        raise tkinter.TclError("invalid geometry "+str(g))
    lst = list(map(int, m.groups()))
    if window.wm_state() == "zoomed":
        # workaround as Tk returns the "unzoomed" origin
        lst[2] = lst[3] = 0
    return lst


# ************************************************************************
# * window util
# ************************************************************************

def setTransient(window, parent, relx=None, rely=None, expose=1):
    # Make an existing toplevel window transient for a parent.
    #
    # The window must exist but should not yet have been placed; in
    # other words, this should be called after creating all the
    # subwidget but before letting the user interact.

    # remain invisible while we figure out the geometry
    window.wm_withdraw()
    window.wm_group(parent)
    if parent and parent.wm_state() != "withdrawn":
        window.wm_transient(parent)
    # actualize geometry information
    window.update_idletasks()
    # show
    x, y = __getWidgetXY(window, parent, relx=relx, rely=rely)
    window.wm_geometry("+%d+%d" % (x, y))
    if expose:
        window.wm_deiconify()


def makeToplevel(parent, title=None):
    # Create a Toplevel window.
    #
    # This is a shortcut for a Toplevel() instantiation plus calls to
    # set the title and icon name of the window.
    window = tkinter.Toplevel(parent)  # , class_=TITLE)
    # window.wm_group(parent)
    # window.wm_command("")
    if WIN_SYSTEM == "x11":
        window.wm_command("/bin/true")
    # window.wm_protocol("WM_SAVE_YOURSELF", None)
    if title:
        window.wm_title(title)
        window.wm_iconname(title)
    return window


def make_help_toplevel(app, title=None):
    # Create an independent Toplevel window.
    from pysollib.winsystems import init_root_window
    window = tkinter.Toplevel(class_=TITLE)
    init_root_window(window, app)
    return window


def __getWidgetXY(widget, parent, relx=None, rely=None,
                  w_width=None, w_height=None):
    if w_width is None:
        w_width = widget.winfo_reqwidth()
    if w_height is None:
        w_height = widget.winfo_reqheight()
    s_width = widget.winfo_screenwidth()
    s_height = widget.winfo_screenheight()
    m_x = m_y = 0
    m_width, m_height = s_width, s_height
    if parent and parent.winfo_ismapped():
        # print parent.wm_geometry()
        # print parent.winfo_geometry(), parent.winfo_x(), parent.winfo_y(), \
        #   parent.winfo_rootx(), parent.winfo_rooty(), parent.winfo_vrootx(),\
        #   parent.winfo_vrooty()
        m_x = m_y = None
        if WIN_SYSTEM == "win32":
            try:
                m_width, m_height, m_x, m_y = wm_get_geometry(parent)
            except Exception:
                pass
        if m_x is None:
            m_x = parent.winfo_x()
            m_y = parent.winfo_y()
            m_width = parent.winfo_width()
            m_height = parent.winfo_height()
            if relx is None:
                relx = 0.5
            if rely is None:
                rely = 0.3
        else:
            if relx is None:
                relx = 0.5
            if rely is None:
                rely = 0.5
        m_x = max(m_x, 0)
        m_y = max(m_y, 0)
    else:
        if relx is None:
            relx = 0.5
        if rely is None:
            rely = 0.3
    x = m_x + int((m_width - w_width) * relx)
    y = m_y + int((m_height - w_height) * rely)
    # print x, y, w_width, w_height, m_x, m_y, m_width, m_height
    # make sure the widget is fully on screen
    if x < 0:
        x = 0
    elif x + w_width + 32 > s_width:
        x = max(0, (s_width - w_width) // 2)
    if y < 0:
        y = 0
    elif y + w_height + 32 > s_height:
        y = max(0, (s_height - w_height) // 2)
    return x, y


# ************************************************************************
# * bind wrapper - tkinter doesn't properly delete all bindings
# ************************************************************************

__mfx_bindings = {}
__mfx_wm_protocols = ("WM_DELETE_WINDOW", "WM_TAKE_FOCUS", "WM_SAVE_YOURSELF")


def bind(widget, sequence, func, add=None):
    # assert callable(func) # XXX: removed in py3k
    if sequence in __mfx_wm_protocols:
        funcid = widget._register(func)
        widget.tk.call("wm", "protocol", widget._w, sequence, funcid)
    elif add is None:
        funcid = widget.bind(sequence, func)
    else:
        # add = add and "+" or ""
        funcid = widget.bind(sequence, func, add)
    k = id(widget)
    if k in __mfx_bindings:
        __mfx_bindings[k].append((sequence, funcid))
    else:
        __mfx_bindings[k] = [(sequence, funcid)]


def unbind_destroy(widget):
    if widget is None:
        return
    k = id(widget)
    if k in __mfx_bindings:
        for sequence, funcid in __mfx_bindings[k]:
            # print widget, sequence, funcid
            try:
                if sequence in __mfx_wm_protocols:
                    widget.tk.call("wm", "protocol", widget._w, sequence, "")
                    # widget.deletecommand(funcid)
                else:
                    widget.unbind(sequence, funcid)
            except tkinter.TclError:
                pass
        del __mfx_bindings[k]
    # for k in __mfx_bindings.keys(): print __mfx_bindings[k]
    # print len(__mfx_bindings.keys())


# ************************************************************************
# * timer wrapper - tkinter doesn't properly delete all commands
# ************************************************************************

def after(widget, ms, func, *args):
    timer = widget.after(ms, func, *args)
    command = widget._tclCommands[-1]
    return (timer, command, widget)


def after_idle(widget, func, *args):
    return after(widget, "idle", func, *args)


def after_cancel(t):
    if t is not None:
        t[2].after_cancel(t[0])
        try:
            t[2].deletecommand(t[1])
        except tkinter.TclError:
            pass


# ************************************************************************
# * image handling
# ************************************************************************

if Image:
    class PIL_Image(ImageTk.PhotoImage):
        def __init__(self, file=None, image=None, pil_image_orig=None):
            if file:
                image = Image.open(file).convert('RGBA')
            ImageTk.PhotoImage.__init__(self, image)
            self._pil_image = image
            if pil_image_orig:
                self._pil_image_orig = pil_image_orig
            else:
                self._pil_image_orig = image

        def subsample(self, r):
            im = self._pil_image
            w, h = im.size
            w, h = int(float(w)/r), int(float(h)/r)
            im = im.resize((w, h))
            im = PIL_Image(image=im)
            return im

        def resize(self, xf, yf):
            w, h = self._pil_image_orig.size
            w0, h0 = int(w*xf), int(h*yf)
            im = self._pil_image_orig.resize((w0, h0), Image.ANTIALIAS)
            return PIL_Image(image=im, pil_image_orig=self._pil_image_orig)


def makeImage(file=None, data=None, dither=None, alpha=None):
    kw = {}
    if data is None:
        assert file is not None
        kw["file"] = file
    else:
        # assert data is not None
        kw["data"] = data
    if Image:
        # use PIL
        if file:
            im = PIL_Image(file)
            return im
        # fromstring(mode, size, data, decoder_name='raw', *args)
        else:
            return tkinter.PhotoImage(data=data)
    return tkinter.PhotoImage(**kw)


loadImage = makeImage


def copyImage(image, x, y, width, height):
    if Image:
        if isinstance(image, PIL_Image):
            return ImageTk.PhotoImage(
                image._pil_image.crop((x, y, x+width, y+height)))
    dest = tkinter.PhotoImage(width=width, height=height)
    assert dest.width() == width
    assert dest.height() == height
    dest.blank()
    image.tk.call(dest, "copy", image.name, "-from", x, y, x+width, y+height)
    assert dest.width() == width
    assert dest.height() == height
    return dest


def fillImage(image, fill, outline=None):
    if not fill and not outline:
        return
    width = image.width()
    height = image.height()
    ow = 1                              # outline width
    if width <= 2*ow or height <= 2*ow:
        fill = fill or outline
        outline = None
    if not outline:
        f = (fill,) * width
        f = (f,) * height
        assert len(f) == height
        image.put(f)
    elif not fill:
        l1 = ((outline,) * width,)
        for y in range(0, ow):
            image.put(l1, (0, y))
        for y in range(height-ow, height):
            image.put(l1, (0, y))
        p = ((outline,) * ow,)
        for y in range(ow, height-ow):
            image.put(p, (0, y))
            image.put(p, (width-ow, y))
    else:
        l1 = (outline,) * width
        l2 = (outline,) * ow + (fill,) * (width-2*ow) + (outline,) * ow
        f = (l1,) * ow + (l2,) * (height-2*ow) + (l1,) * ow
        assert len(f) == height
        image.put(f)


def createImage(width, height, fill, outline=None):
    image = tkinter.PhotoImage(width=width, height=height)
    assert image.width() == width
    assert image.height() == height
    image.blank()
    fillImage(image, fill, outline)
    return image


def shadowImage(image, color='#3896f8', factor=0.3):
    if not hasattr(image, '_pil_image'):
        return None
    im = image._pil_image
    # use an alpha image
    sh = Image.new('RGBA', im.size, color)
    sh.putalpha(100)
    out = Image.composite(sh, im, im)
    return PIL_Image(image=out)


def markImage(image):
    assert Image
    if 1:                               # shadow
        color, factor = '#6ae400', 0.3
        sh = Image.new('RGBA', image.size, color)
        tmp = Image.blend(image, sh, factor)
    else:                               # negate
        tmp = ImageOps.invert(image.convert('RGB'))
    out = Image.composite(tmp, image, image)
    return out


def _createBottomImage(image, color='white', backfile=None):
    th = 1                              # thickness
    sh = Image.new('RGBA', image.size, color)
    out = Image.composite(sh, image, image)
    w, h = image.size
    size = (w-th*2, h-th*2)
    tmp = Image.new('RGBA', size, color)
    tmp.putalpha(60)
    mask = out.resize(size, Image.ANTIALIAS)
    out.paste(tmp, (th, th), mask)
    if backfile:
        back = Image.open(backfile).convert('RGBA')
        w0, h0 = back.size
        w1, h1 = w, h
        a = min(float(w1)/w0, float(h1)/h0)
        a = a*0.9
        w0, h0 = int(w0*a), int(h0*a)
        back = back.resize((w0, h0), Image.ANTIALIAS)
        x, y = (w1 - w0) // 2, (h1 - h0) // 2
        out.paste(back, (x, y), back)
    return out


def createBottom(maskimage, color='white', backfile=None):
    if not hasattr(maskimage, '_pil_image'):
        return None
    maskimage = maskimage._pil_image
    out = _createBottomImage(maskimage, color, backfile)
    return PIL_Image(image=out)


def resizeBottom(image, maskimage, color='white', backfile=None):
    maskimage = maskimage._pil_image
    out = _createBottomImage(maskimage, color, backfile)
    image['image'] = out


# ************************************************************************
# * font utils
# ************************************************************************

def get_text_width(text, font, root=None):
    return tkinter_font.Font(root=root, font=font).measure(text)
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-
# ---------------------------------------------------------------------------
#
# Copyright (C) 1998-2003 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 2003 Mt. Hood Playing Card Co.
# Copyright (C) 2005-2009 Skomoroh
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# ---------------------------------------------------------------------------

from pysollib.mfxutil import Image, ImageTk
from pysollib.ui.tktile.Canvas2 import CanvasText, Group, Line, Rectangle
from pysollib.ui.tktile.Canvas2 import ImageItem as ImageItem2
from pysollib.ui.tktile.tkutil import loadImage, unbind_destroy

from six.moves import tkinter


# ************************************************************************
# * canvas items
# ************************************************************************

class MfxCanvasGroup(Group):
    def __init__(self, canvas, tag=None):
        Group.__init__(self, canvas=canvas, tag=tag)
        # register ourself so that we can unbind from the canvas
        assert self.id not in self.canvas.items
        self.canvas.items[self.id] = self

    def addtag(self, tag, option="withtag"):
        self.canvas.addtag(tag, option, self.id)

    def delete(self):
        del self.canvas.items[self.id]
        Group.delete(self)

    def gettags(self):
        return self.canvas.tk.splitlist(self._do("gettags"))


class MfxCanvasImage(ImageItem2):
    def __init__(self, canvas, x, y, **kwargs):
        self.init_coord = x, y
        group = None
        if 'group' in kwargs:
            group = kwargs['group']
            del kwargs['group']
        if 'image' in kwargs:
            self._image = kwargs['image']
        ImageItem2.__init__(self, canvas, x, y, **kwargs)
        if group:
            self.addtag(group)

    def moveTo(self, x, y):
        c = self.coords()
        self.move(x - int(c[0]), y - int(c[1]))

    def show(self):
        self.config(state='normal')

    def hide(self):
        self.config(state='hidden')


MfxCanvasLine = Line


class MfxCanvasRectangle(Rectangle):
    def __init__(self, canvas, *args, **kwargs):
        group = None
        if 'group' in kwargs:
            group = kwargs['group']
            del kwargs['group']
        Rectangle.__init__(self, canvas, *args, **kwargs)
        if group:
            self.addtag(group)


class MfxCanvasText(CanvasText):
    def __init__(self, canvas, x, y, preview=-1, **kwargs):
        self.init_coord = x, y
        self.x, self.y = x, y
        if preview < 0:
            preview = canvas.preview
        if preview > 1:
            return
        if "fill" not in kwargs:
            kwargs["fill"] = canvas._text_color
        group = None
        if 'group' in kwargs:
            group = kwargs['group']
            del kwargs['group']
        CanvasText.__init__(self, canvas, x, y, **kwargs)
        self.text_format = None
        canvas._text_items.append(self)
        if group:
            self.addtag(group)

    def moveTo(self, x, y):
        dx, dy = x - self.x, y - self.y
        self.x, self.y = x, y
        self.move(dx, dy)


# ************************************************************************
# * canvas
# ************************************************************************

class MfxCanvas(tkinter.Canvas):
    def __init__(self, *args, **kw):
        tkinter.Canvas.__init__(self, *args, **kw)
        self.preview = 0
        self.busy = False
        # this is also used by lib-tk/Canvas.py
        self.items = {}
        # private
        self.__tileimage = None
        self.__tiles = []           # id of canvas items
        self.__topimage = None
        self.__tops = []            # id of canvas items
        # friend MfxCanvasText
        self._text_color = "#000000"
        self._stretch_bg_image = 0
        self._save_aspect_bg_image = 0
        self._text_items = []
        #
        self.xmargin, self.ymargin = 10, 10
        # resize bg image
        self.bind('<Configure>', self.setBackgroundImage)

    def setBackgroundImage(self, event=None):
        # print 'setBackgroundImage', self._bg_img
        if not hasattr(self, '_bg_img'):
            return
        if not self._bg_img:  # solid color
            return
        stretch = self._stretch_bg_image
        save_aspect = self._save_aspect_bg_image
        if Image:
            if stretch:
                w, h = self._geometry()
                if save_aspect:
                    w0, h0 = self._bg_img.size
                    a = min(float(w0)/w, float(h0)/h)
                    w0, h0 = int(w0/a), int(h0/a)
                    im = self._bg_img.resize((w0, h0))
                else:
                    im = self._bg_img.resize((w, h))
                image = ImageTk.PhotoImage(im)
            else:
                image = ImageTk.PhotoImage(self._bg_img)
        else:  # not Image
            stretch = 0
            image = self._bg_img
        for id in self.__tiles:
            self.delete(id)
        self.__tiles = []
        # must keep a reference to the image, otherwise Python will
        # garbage collect it...
        self.__tileimage = image
        if stretch:
            #
            if self.preview:
                dx, dy = 0, 0
            else:
                dx, dy = -self.xmargin, -self.ymargin
            id = self._x_create("image", dx, dy, image=image, anchor="nw")
            self.tag_lower(id)          # also see tag_lower above
            self.__tiles.append(id)
        else:
            iw, ih = image.width(), image.height()
            sw, sh = self._geometry()
            for x in range(-self.xmargin, sw, iw):
                for y in range(-self.ymargin, sh, ih):
                    id = self._x_create(
                        "image", x, y, image=image, anchor="nw")
                    self.tag_lower(id)          # also see tag_lower above
                    self.__tiles.append(id)
        return 1

    def _geometry(self):
        w = max(self.winfo_width(), int(self.cget('width')))
        h = max(self.winfo_height(), int(self.cget('height')))
        scrollregion = self.cget('scrollregion')
        if not scrollregion:
            return w, h
        x, y, sw, sh = [int(i) for i in scrollregion.split()]
        sw -= x
        sh -= y
        w = max(w, sw)
        h = max(h, sh)
        return w, h

    #
    # top-image support
    #

    def _x_create(self, itemType, *args, **kw):
        return tkinter.Canvas._create(self, itemType, args, kw)

    def _create(self, itemType, args, kw):
        # print "_create:", itemType, args, kw
        id = tkinter.Canvas._create(self, itemType, args, kw)
        if self.__tops:
            self.tk.call(self._w, "lower", id, self.__tops[0])
        return id

    def tag_raise(self, id, aboveThis=None):
        # print "tag_raise:", id, aboveThis
        if aboveThis is None and self.__tops:
            self.tk.call(self._w, "lower", id, self.__tops[0])
        else:
            self.tk.call(self._w, "raise", id, aboveThis)

    def tag_lower(self, id, belowThis=None):
        # print "tag_lower:", id, belowThis
        if belowThis is None and self.__tiles:
            self.tk.call(self._w, "raise", id, self.__tiles[-1])
        else:
            self.tk.call(self._w, "lower", id, belowThis)

    def setInitialSize(self, width, height, margins=True, scrollregion=True):
        # print 'Canvas.setInitialSize:', width, height, scrollregion
        if self.preview:
            self.config(width=width, height=height,
                        scrollregion=(0, 0, width, height))
        else:
            # add margins
            dx, dy = self.xmargin, self.ymargin
            if margins:
                w, h = dx+width+dx, dy+height+dy
            else:
                w, h = width, height
            self.config(width=w, height=h)
            if scrollregion:
                self.config(scrollregion=(-dx, -dy, width+dx, height+dy))
            else:
                # no scrolls
                self.config(scrollregion=(-dx, -dy, dx, dy))

    # delete all CanvasItems, but keep the background and top tiles
    def deleteAllItems(self):
        self._text_items = []
        for id in list(self.items.keys()):
            assert id not in self.__tiles   # because the tile is created by id
            unbind_destroy(self.items[id])
            self.items[id].delete()
        assert self.items == {}

    def findCard(self, stack, event):
        if isinstance(stack.cards[0].item, Group):
            current = self.gettags("current")           # get tags
            for i in range(len(stack.cards)):
                if stack.cards[i].item.tag in current:
                    return i
        else:
            #  current = self.find("withtag", "current")   # get item ids
            #  for i in range(len(stack.cards)):
            #      if stack.cards[i].item.id in current:
            #          return i
            if self.preview:
                dx, dy = 0, 0
            else:
                dx, dy = -self.xmargin, -self.ymargin
            x = event.x+dx+self.xview()[0]*int(self.cget('width'))
            y = event.y+dy+self.yview()[0]*int(self.cget('height'))
            # x, y = event.x, event.y
            items = list(self.find_overlapping(x, y, x, y))
            items.reverse()
            for item in items:
                for i in range(len(stack.cards)):
                    if stack.cards[i].item.id == item:
                        return i
        return -1

    def setTextColor(self, color):
        if color is None:
            c = self.cget("bg")
            if not isinstance(c, str) or c[0] != "#" or len(c) != 7:
                return
            v = []
            for i in (1, 3, 5):
                v.append(int(c[i:i+2], 16))
            luminance = (0.212671 * v[0] + 0.715160 * v[1] + 0.072169 * v[2]) \
                / 255
            # print c, ":", v, "luminance", luminance
            color = ("#000000", "#ffffff")[luminance < 0.3]
        if self._text_color != color:
            self._text_color = color
            for item in self._text_items:
                item.config(fill=self._text_color)

    def setTile(self, image, stretch=0, save_aspect=0):
        # print 'setTile:', image, stretch
        if image:
            if Image:
                try:
                    self._bg_img = Image.open(image)
                except Exception:
                    return 0
            else:
                try:
                    self._bg_img = loadImage(file=image, dither=1)
                except Exception:
                    return 0
            self._stretch_bg_image = stretch
            self._save_aspect_bg_image = save_aspect
            self.setBackgroundImage()
        else:
            for id in self.__tiles:
                self.delete(id)
            self.__tiles = []
            self._bg_img = None
        return 1

    def setTopImage(self, image, cw=0, ch=0):
        try:
            if image and isinstance(image, str):
                image = loadImage(file=image)
        except tkinter.TclError:
            return 0
        if len(self.__tops) == 1 and image is self.__tops[0]:
            return 1
        for id in self.__tops:
            self.delete(id)
        self.__tops = []
        # must keep a reference to the image, otherwise Python will
        # garbage collect it...
        self.__topimage = image
        if image is None:
            return 1
        iw, ih = image.width(), image.height()
        if cw <= 0:
            # cw = max(int(self.cget("width")), self.winfo_width())
            cw = self.winfo_width()
        if ch <= 0:
            # ch = max(int(self.cget("height")),  self.winfo_height())
            ch = self.winfo_height()
        # print iw, ih, cw, ch
        x = (cw-iw)//2-self.xmargin+self.xview()[0]*int(self.cget('width'))
        y = (ch-ih)//2-self.ymargin+self.yview()[0]*int(self.cget('height'))
        id = self._x_create("image", x, y, image=image, anchor="nw")
        self.tk.call(self._w, "raise", id)
        self.__tops.append(id)
        return 1

    #
    # Pause support
    #

    def hideAllItems(self):
        for item in list(self.items.values()):
            item.config(state='hidden')

    def showAllItems(self):
        for item in list(self.items.values()):
            item.config(state='normal')

    #
    # restricted but fast _bind and _substitute
    #

    def _bind(self, what, sequence, func, add, needcleanup=1):
        funcid = self._register(func, self._substitute, needcleanup)
        cmd = ('%sif {"[%s %s]" == "break"} break\n' %
               (add and '+' or '', funcid, "%x %y"))
        self.tk.call(what + (sequence, cmd))
        return funcid

    def _substitute(self, *args):
        e = tkinter.Event()
        try:
            # Tk changed behavior in 8.4.2, returning "??" rather more often.
            e.x = int(args[0])
        except ValueError:
            e.x = args[0]
        try:
            e.y = int(args[1])
        except ValueError:
            e.y = args[1]
        return (e,)
# Written by Shlomi Fish, under the MIT Expat License.

import unittest

from pysol_tests.common_mocks1 import MockApp, MockCanvas, MockTalon

import pysollib.stack
from pysollib.hint import FreeCellSolver_Hint, PySolHintLayoutImportError


class MockGame:
    def __init__(self):
        self.app = MockApp()
        self.talon = MockTalon(self)

        self.allstacks = []
        self.stackmap = {}
        self.canvas = MockCanvas()
        self.foundations = [
            pysollib.stack.SS_FoundationStack(0, 0, self, s) for s in range(4)]
        self.rows = [pysollib.stack.AC_RowStack(0, 0, self) for s in range(8)]
        self.reserves = [
            pysollib.stack.AC_RowStack(0, 0, self) for s in range(4)]
        self.preview = 0


class Mock_S_Game:
    def __init__(self):
        self.s = MockGame()

    def flipMove(self, foo):
        pass

    def moveMove(self, cnt, frm, to, frames=0):
        c = frm.cards.pop()
        c.face_up = True
        to.addCard(c)
        pass


class MyTests(unittest.TestCase):
    def _calc_hint(self, fn):
        """docstring for _calc_hint"""
        s_game = Mock_S_Game()
        h = FreeCellSolver_Hint(s_game, None)
        fh = open(fn, 'r+b')
        h.importFileHelper(fh, s_game)
        return h

    def _successful_import(self, fn, want_s, blurb):
        self.assertEqual(self._calc_hint(fn).calcBoardString(), want_s, blurb)

    def test_import(self):
        return self._successful_import('tests/unit/data/with-10-for-rank.txt',
                                       '''FC: - - - -
4C 2C 9C 8C QS 4S 2H
5H QH 3C AC 3H 4H QD
QC 9S 6H 9H 3S KS 3D
5D 2S JC 5C JH 6D AS
2D KD TH TC TD 8D
7H JS KH TS KC 7C
AH 5S 6S AD 8H JD
7S 6C 7D 4D 8S 9D
''', 'import worked with "10"s as ranks')

    def test_import_2(self):
        return self._successful_import('tests/unit/data/624.board',
                                       '''FC: - - - -
KC 6H 4C QS 2D 4S AS
4H TH 2S JH 2H 9S AH
3S 6C 9H AD KH QD 7C
3C JS 5H KS TC 9C 8C
4D 9D 7S JC 5D TS
KD QC 5C QH 6S 3D
5S JD 8D 6D TD 8H
8S 7H 3H 2C AC 7D
''', 'import worked with Ts')

    def test_import_utf8_bom(self):
        return self._successful_import(
            'tests/unit/data/624-with-utf8-bom.board',
            '''FC: - - - -
KC 6H 4C QS 2D 4S AS
4H TH 2S JH 2H 9S AH
3S 6C 9H AD KH QD 7C
3C JS 5H KS TC 9C 8C
4D 9D 7S JC 5D TS
KD QC 5C QH 6S 3D
5S JD 8D 6D TD 8H
8S 7H 3H 2C AC 7D
''', 'import worked with utf-8 bom')

    def test_throw_error_on_duplicate_card(self):
        try:
            self._calc_hint('tests/unit/data/624-with-dup-card.board')
        except PySolHintLayoutImportError as err:
            self.assertEqual(err.msg, "Duplicate cards in input")
            self.assertEqual(err.cards, ["KC"])
            self.assertEqual(err.line_num, 1)
            self.assertEqual(err.format(), "Duplicate cards in input:\n\nKC")
            return
        self.fail("No exception thrown.")

    def test_throw_error_on_invalid_foundations_line(self):
        try:
            self._calc_hint(
                'tests/unit/data/624-invalid-foundations-line.board')
        except PySolHintLayoutImportError as err:
            self.assertEqual(err.msg, "Invalid Foundations line")
            self.assertEqual(err.cards, [])
            self.assertEqual(err.line_num, 1)
            return
        self.fail("No exception thrown.")

    def test_throw_error_on_missing_cards(self):
        try:
            self._calc_hint('tests/unit/data/624-missing-cards.board')
        except PySolHintLayoutImportError as err:
            self.assertEqual(err.msg, "Missing cards in input")
            self.assertEqual(err.cards, ["5H"])
            return
        self.fail("No exception thrown.")
# Written by Shlomi Fish, under the MIT Expat License.

import unittest

from pysollib.acard import AbstractCard
from pysollib.hint import Base_Solver_Hint


class MyTests(unittest.TestCase):
    def test_output(self):
        card = AbstractCard(1001, 0, 3, 7, 3001)
        h = Base_Solver_Hint(None, None, base_rank=0)

        got = h.card2str2(card)
        # TEST
        self.assertEqual(got, 'D-8', 'card2str2 works')
        # diag('got == ' + got)

        got = h.card2str1(card)
        # TEST
        self.assertEqual(got, '8D', 'card2str2 works')
        # diag('got == ' + got)
# Written by Shlomi Fish, under the MIT Expat License.

import unittest

from pysol_tests.common_mocks1 import MockApp, MockCanvas, MockItem, MockTalon

import pysollib.stack
from pysollib.acard import AbstractCard
from pysollib.games.spider import Scorpion_RowStack, Spider_RowStack


class MockGame:
    def __init__(self):
        self.app = MockApp()
        self.talon = MockTalon(self)

        self.allstacks = []
        self.stackmap = {}
        self.canvas = MockCanvas()
        self.foundations = [
            pysollib.stack.SS_FoundationStack(0, 0, self, s) for s in range(4)]
        self.rows = [pysollib.stack.Yukon_SS_RowStack(0, 0, self)
                     for s in range(8)]
        self.reserves = [
            pysollib.stack.Yukon_SS_RowStack(0, 0, self) for s in range(4)]
        self.preview = 0


class Mock_S_Game:
    def __init__(self):
        self.s = MockGame()

    def flipMove(self, foo):
        pass

    def moveMove(self, cnt, frm, to, frames=0):
        c = frm.cards.pop()
        c.face_up = True
        to.addCard(c)
        pass


class MyTests(unittest.TestCase):
    def _calc_Scorpion_stack(self):
        g = MockGame()
        stack = Scorpion_RowStack(0, 0, g)
        for s, r in [(2, 5), (3, 7), (2, 7), (2, 0), (2, 3), (2, 4), (1, 4)]:
            c = AbstractCard(1000+r*100+s*10, 0, s, r, g)
            c.face_up = True
            c.item = MockItem()
            stack.addCard(c)
        return stack

    def test_canMoveCards(self):
        stack = self._calc_Scorpion_stack()
        stack.canMoveCards(stack.cards[6:])
        self.assertTrue(stack)

    def test_canMoveCards_non_top(self):
        stack = self._calc_Scorpion_stack()
        self.assertTrue(stack.canMoveCards(stack.cards[4:]))
        self.assertTrue(stack)

    def _calc_Spider_stack(self):
        g = MockGame()
        stack = Spider_RowStack(0, 0, g)
        for s, r in [(2, 5), (3, 7), (2, 7), (2, 0), (2, 3), (2, 5), (1, 4)]:
            c = AbstractCard(1000+r*100+s*10, 0, s, r, g)
            c.face_up = True
            c.item = MockItem()
            stack.addCard(c)
        return stack

    def test_Spider_canMoveCards_non_top(self):
        stack = self._calc_Spider_stack()
        self.assertFalse(stack.canMoveCards(stack.cards[5:]))
        self.assertTrue(stack)
# Written by Shlomi Fish, under the MIT Expat License.

import unittest

from pysollib.game import GameDrag, GameStacks


class MyTests(unittest.TestCase):
    def test_shadows(self):
        d = GameDrag()
        d.shadows.append("test")
        self.assertTrue(len(d.shadows))

    def test_addattr(self):
        s = GameStacks()
        s.addattr(tableaux=[])
        s.tableaux.append("myval")
        self.assertEqual(s.tableaux, ["myval"])
# Written by Shlomi Fish, under the MIT Expat License.

import unittest

from pysollib.mfxutil import latin1_normalize


class MyTests(unittest.TestCase):
    def test_output(self):
        self.assertEqual(latin1_normalize('HELLO%%good'), 'hellogood')
#! /usr/bin/env python MockItem
# -*- coding: utf-8 -*-
# vim:fenc=utf-8
#
# Copyright © 2018 Shlomi Fish <shlomif@cpan.org>
#
# Distributed under terms of the MIT license.

import pysollib.stack
from pysollib.acard import AbstractCard

"""

"""


class MockItem:
    def __init__(self):
        pass

    def tkraise(self):
        return

    def addtag(self, nouse):
        return


class MockCanvas:
    def __init__(self):
        self.xmargin = self.ymargin = 50


class MockImages:
    def __init__(self):
        self.CARDW = self.CARDH = self.CARD_YOFFSET = 50


class MockOpt:
    def __init__(self):
        self.randomize_place = False


class MockApp:
    def __init__(self):
        self.images = MockImages()
        self.opt = MockOpt()


class MockTalon:
    def __init__(self, g):
        self.cards = [
            AbstractCard(1000+r*100+s*10, 0, s, r, g)
            for s in range(4) for r in range(13)]
        for c in self.cards:
            c.item = MockItem()


def _empty_override(*args):
    return True


pysollib.stack.MfxCanvasGroup = _empty_override
# Written by Shlomi Fish, under the MIT Expat License.

import unittest

from pysollib.acard import AbstractCard


class MyTests(unittest.TestCase):
    def test_cards(self):
        card1 = AbstractCard(1001, 0, 1, 2, 3001)
        # TEST
        self.assertEqual(card1.color, 0, 'card1.color is sane.')

        # TEST
        self.assertEqual(card1.rank, 2, 'card1.rank')

        card2 = AbstractCard(1001, 0, 3, 7, 3001)
        # TEST
        self.assertEqual(card2.color, 1, 'card2.color is sane.')

        # TEST
        self.assertEqual(card2.rank, 7, 'card2.rank')
# make_pysol_freecell_board.py - Program to generate the boards of
# PySol for input into Freecell Solver.
#
# Usage: make_pysol_freecell_board.py [board number] | fc-solve
#
# Or on non-UNIXes:
#
# python make_pysol_freecell_board.py [board number] | fc-solve
#
# This program is platform independent and will generate the same results
# on all architectures and operating systems.
#
# Based on the code by Markus Franz Xaver Johannes Oberhumer.
# Modified by Shlomi Fish, 2000
#
# Since much of the code here is ripped from the actual PySol code, this
# program is distributed under the GNU General Public License.
#
#
#
# vim:ts=4:et:nowrap
#
# ---------------------------------------------------------------------------##
#
# PySol -- a Python Solitaire game
#
# Copyright (C) 2000 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 1999 Markus Franz Xaver Johannes Oberhumer
# Copyright (C) 1998 Markus Franz Xaver Johannes Oberhumer
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; see the file COPYING.
# If not, write to the Free Software Foundation, Inc.,
# 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#
# Markus F.X.J. Oberhumer
# <markus.oberhumer@jk.uni-linz.ac.at>
# http://wildsau.idv.uni-linz.ac.at/mfx/pysol.html
#
# ---------------------------------------------------------------------------##


# imports
import unittest

from pysol_cards.cards import CardRenderer
from pysol_cards.deal_game import Game
from pysol_cards.random_base import RandomBase
from pysol_cards.random import random__int2str, random__str2int

# So the localpaths will be overrided.
from pysollib.pysolrandom import constructRandom

# PySol imports

# /***********************************************************************
# // Abstract PySol Random number generator.
# //
# // We use a seed of type long in the range [0, MAX_SEED].
# ************************************************************************/


ren = CardRenderer(True)


class MyTests(unittest.TestCase):
    def _cmp_board(self, got_s, expected_s, blurb):
        if not self.assertEqual(got_s, expected_s, blurb):
            return False
        return True

    def test_main(self):

        def test_24(blurb):
            game = Game("freecell", 24, RandomBase.DEALS_PYSOLFC)
            got_s = game.calc_layout_string(ren)
            self.assertEqual(got_s, '''4C 2C 9C 8C QS 4S 2H
5H QH 3C AC 3H 4H QD
QC 9S 6H 9H 3S KS 3D
5D 2S JC 5C JH 6D AS
2D KD TH TC TD 8D
7H JS KH TS KC 7C
AH 5S 6S AD 8H JD
7S 6C 7D 4D 8S 9D
''', blurb)

        # TEST
        test_24('Deal 24')

        game = Game("freecell", 123456, RandomBase.DEALS_MS)
        # TEST
        got_s = game.calc_layout_string(ren)
        self.assertEqual(got_s, '''QD TC AS KC AH KH 6H
6D TD 8D TH 7C 2H 9C
AC AD 5C 5H 8C 9H 9D
JS 8S 4D 4C 2S 7D 3C
7H 7S 9S 2C JC 5S
5D 3S 3D 3H KD JH
6C QS 4S 2D KS TS
JD QH 6S 4H QC 8H
''', 'Microsoft Deal 123456')

        game = Game("freecell", 123456, True)
        # TEST
        self._cmp_board(game.calc_layout_string(ren), '''3D 6C AS TS QC 8D 4D
2D TC 4H JD TD 2H 5C
2C 8S AH KD KH 5S 7C
9C 8C QH 3C 5D 9S QD
AC 9D 7H 6D KS JH
6H TH 8H QS 7D JC
4C 2S 3S 6S 5H 3H
KC JS 9H 4S 7S AD
''', 'PySolFC deal No. 123456')

        rand = constructRandom('ms3000000000')
        self.assertEqual(rand.getSeedAsStr(), 'ms3000000000')
        game = Game("freecell", 3000000000, RandomBase.DEALS_MS)
        # TEST
        self._cmp_board(game.calc_layout_string(ren), '''8D TS JS TD JH JD JC
4D QS TH AD 4S TC 3C
9H KH QH 4C 5C KD AS
9D 5D 8S 4H KS 6S 9S
6H 2S 7H 3D KC 2C
9C 7C QC 7S QD 7D
6C 3H 8H AC 6D 3S
8C AH 2H 5H 2D 5S
''', 'Microsoft Deal #3E9 - long seed.')

        rand = constructRandom('ms6000000000')
        game = Game("freecell", 6000000000, RandomBase.DEALS_MS)
        # TEST
        got_s = game.calc_layout_string(ren)
        self.assertEqual(got_s, '''2D 2C QS 8D KD 8C 4C
3D AH 2H 4H TS 6H QD
4D JS AD 6S JH JC JD
KH 3H KS AS TC 5D AC
TD 7C 9C 7H 3C 3S
QH 9H 9D 5S 7S 6C
5C 5H 2S KC 9S 4S
6D QC 8S TH 7D 8H
''', 'Microsoft Deal #6E9 - extra long seed.')

        inp = 'ms12345678'
        got = random__int2str(random__str2int(inp))

        # TEST
        self.assertEqual(got, inp, 'long2str ms roundtrip.')

        inp = '246007891097'
        got = random__int2str(random__str2int(inp))

        # TEST
        self.assertEqual(got, inp, 'long2str PySolFC roundtrip.')

        proto_inp = '246007891097'
        inp = random__str2int(proto_inp)
        got = random__str2int(random__int2str(inp))

        # TEST
        self.assertEqual(got, inp, 'str2long PySolFC roundtrip.')

        rand = constructRandom('ms100000')
        seed = rand.increaseSeed(rand.initial_seed)
        seed = rand.str(seed)
        # TEST
        self.assertEqual(seed, 'ms100001', 'increaseSeed for ms deals')
        rand = constructRandom(seed)
        game = Game("freecell", int(seed[2:]), RandomBase.DEALS_MS)
        # TEST
        self._cmp_board(game.calc_layout_string(ren), '''5S AH 4H TD 4S JD JS
3C 8C 4C AC JC AS QS
7C QH 2D QD 8S 9D AD
KS 7S 5H 3H TS 3S 5D
9S 7H KC TH 8D 6S
5C KD 9H 2H 2S 6D
9C JH 8H 3D 4D QC
KH 6H 6C TC 2C 7D
''', 'ms100001')

        seed = 24000024
        rand = constructRandom(str(seed))
        expected0 = rand.randint(0, 100)
        expected1 = rand.randint(0, 100)
        rand.reset()
        got0 = rand.randint(0, 100)
        got1 = rand.randint(0, 100)
        # TEST
        self.assertEqual(
            [got0, got1, ],
            [expected0, expected1, ],
            "same results after reset()",)
#!/usr/bin/env python3

import builtins
import os
import sys

from pysollib.gamedb import GAME_DB
from pysollib.gamedb import GI
from pysollib.mfxutil import latin1_normalize
from pysollib.mygettext import fix_gettext
# outdir = '../html'
pysollib_dir = '../'


builtins._ = lambda x: x
builtins.n_ = lambda x: x

import pysollib.games  # noqa: F402,I100,I202
import pysollib.games.mahjongg  # noqa: F402
import pysollib.games.special  # noqa: F401,F402
import pysollib.games.ultra  # noqa: F401,F402

try:
    os.mkdir('html')
except Exception:
    pass

try:
    os.mkdir('html/rules')
except Exception:
    pass


def merge_dicts(x, y):
    ret = x.copy()
    ret.update(y)
    return ret


pysollib_path = os.path.join(sys.path[0], pysollib_dir)
sys.path[0] = os.path.normpath(pysollib_path)
# print sys.path

fix_gettext()

files = [
    ('credits.html', 'PySol Credits'),
    ('ganjifa.html', 'PySol - General Ganjifa Card Rules'),
    ('general_rules.html', 'PySol - General Rules'),
    ('glossary.html', 'PySol - Glossary'),
    ('hanafuda.html', 'PySol - Rules for General Flower Card Rules'),
    ('hexadeck.html', 'PySol - General Hex A Deck Card Rules'),
    ('howtoplay.html', 'How to play PySol'),
    ('index.html', 'PySol - a Solitaire Game Collection'),
    ('install.html', 'PySol - Installation'),
    ('intro.html', 'PySol - Introduction'),
    ('license.html', 'PySol Software License'),
    ('news.html', 'PySol - a Solitaire Game Collection'),
    # ('rules_alternate.html', 'PySol - a Solitaire Game Collection'),
    # ('rules.html', 'PySol - a Solitaire Game Collection'),
    ]

rules_files = [
    # ('hanoipuzzle.html', ),
    ('mahjongg.html', 'PySol - Rules for Mahjongg'),
    ('matrix.html', 'PySol - Rules for Matrix'),
    ('pegged.html', 'PySol - Rules for Pegged'),
    ('shisensho.html', 'PySol - Rules for Shisen-Sho'),
    ('spider.html', 'PySol - Rules for Spider'),
    ('freecell.html', 'PySol - Rules for FreeCell'),
    ]
wikipedia_files = [
    ('houseinthewood.html', 'PySol - Rules for House in the Woods'),
    ('fourseasons.html', 'PySol - Rules for Four Seasons'),
    ]


def _fmt(fmt, params):
    return fmt % merge_dicts(params, {'logo_url': "images/pysollogo03.png",
                                      'logo_alt': "PySol FC Logo"})


main_header = '''<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
<head>
<title>%(title)s</title>
<meta name="license" content="GNU General Public License">
<meta http-equiv="content-type" content="text/html; charset=utf-8">
</head>
<body text="#000000" bgcolor="#F7F3FF" link="#0000FF" vlink="#660099"
alink="#FF0000">
<img src="%(logo_url)s" alt="%(logo_alt)s">
<br>
'''
main_footer = '''
<p>
<br>
%(back_to_index_link)s
</body>
</html>'''

rules_header = '''<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
<head>
<title>%(title)s</title>
<meta name="license" content="GNU General Public License">
<meta http-equiv="content-type" content="text/html; charset=utf-8">
</head>
<body text="#000000" bgcolor="#F7F3FF" link="#0000FF" vlink="#660099"
link="#FF0000">
<img src="../%(logo_url)s" alt="%(logo_alt)s">
<br>
'''
rules_footer = '''
<p>
%(footer)s
<br>
<a href="../glossary.html">Glossary</a>
<br>
<a href="../general_rules.html">General rules</a>

<p>
<a href="../index.html">Back to the index</a>
</body>
</html>'''

wikipedia_header = '''<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
<head>
<title>%(title)s</title>
<meta name="license" content="GNU General Public License">
<meta http-equiv="content-type" content="text/html; charset=utf-8">
</head>
<body text="#000000" bgcolor="#F7F3FF" link="#0000FF" vlink="#660099"
alink="#FF0000">
<img src="../%(logo_url)s" alt="%(logo_alt)s">
<br>
'''


def getGameRulesFilename(n):
    if n.startswith('Mahjongg'):
        return 'mahjongg.html'
    return latin1_normalize(n) + '.html'


def gen_main_html():
    for infile, title in files:
        outfile = open(os.path.join('html', infile), 'w')
        print(_fmt(main_header, {'title': title}), file=outfile)
        with open(infile, 'r') as file:
            print(file.read(), file=outfile)
        s = '<a href="index.html">Back to the index</a>'
        if infile == 'index.html':
            s = ''
        print(_fmt(main_footer, {'back_to_index_link': s}), file=outfile)
        outfile.close()


def gen_rules_html():
    # ls = glob(os.path.join('rules', '*.html'))
    rules_ls = os.listdir('rules')
    rules_ls.sort()
    wikipedia_ls = os.listdir('wikipedia')
    wikipedia_ls.sort()

    games = GAME_DB.getGamesIdSortedByName()
    rules_list = []
    files_list = []
    for fn, tt in rules_files:
        rules_list.append(('rules', fn, tt, ''))
        files_list.append(fn)
    for fn, tt in wikipedia_files:
        rules_list.append(('wikipedia', fn, tt, ''))
        files_list.append(fn)
    altnames = []

    # open file of list of all rules
    out_rules = open(os.path.join('html', 'rules.html'), 'w')
    print(_fmt(main_header, {'title': 'PySol - a Solitaire Game Collection'}),
          file=out_rules)
    with open('rules.html', 'r') as file:
        print(file.read(), file=out_rules)

    for id in games:
        # create list of rules

        gi = GAME_DB.get(id)

        rules_fn = gi.rules_filename
        if not rules_fn:
            rules_fn = getGameRulesFilename(gi.name)

        if rules_fn in files_list:
            continue

        if rules_fn in rules_ls:
            rules_dir = 'rules'
        elif rules_fn in wikipedia_ls:
            rules_dir = 'wikipedia'
        else:
            print('missing rules for %s (file: %s)'
                  % (gi.name, rules_fn))
            continue

        # print '>>>', rules_fn

        title = 'PySol - Rules for ' + gi.name
        s = ''
        if gi.si.game_type == GI.GT_HANAFUDA:
            s = '<a href="../hanafuda.html">General Flower Card rules</a>'
        elif gi.si.game_type == GI.GT_DASHAVATARA_GANJIFA:
            s = '<a href="../ganjifa.html">About Ganjifa</a>'
        elif gi.si.game_type == GI.GT_HEXADECK:
            s = '<a href="../hexadeck.html">General Hex A Deck rules</a>'
        elif gi.si.game_type == GI.GT_MUGHAL_GANJIFA:
            s = '<a href="../ganjifa.html">About Ganjifa</a>'
            # print '***', gi.name, '***'

        rules_list.append((rules_dir, rules_fn, title, s))
        files_list.append(rules_fn)
        # rules_list.append((rules_fn, gi.name))
        print('<li><a href="rules/%s">%s</a>'
              % (rules_fn, gi.name), file=out_rules)
        for n in gi.altnames:
            altnames.append((n, rules_fn))

    print('</ul>\n' + _fmt(main_footer,
          {'back_to_index_link':
           '<a href="index.html">Back to the index</a>'}),
          file=out_rules)

    out_rules.close()

    # create file of altnames
    out_rules_alt = open(os.path.join('html', 'rules_alternate.html'), 'w')
    print(_fmt(main_header, {'title': 'PySol - a Solitaire Game Collection'}),
          file=out_rules_alt)
    with open('rules_alternate.html', 'r') as file:
        print(file.read(), file=out_rules_alt)
    altnames.sort()
    for name, fn in altnames:
        print('<li> <a href="rules/%s">%s</a>'
              % (fn, name), file=out_rules_alt)
    print('</ul>\n' + _fmt(main_footer,
          {'back_to_index_link':
           '<a href="index.html">Back to the index</a>'}),
          file=out_rules_alt)
    out_rules_alt.close()

    # create rules
    for dir, filename, title, footer in rules_list:
        outfile = open(
            os.path.join('html', 'rules', filename), 'w', encoding='utf-8')
        if dir == 'rules':
            print(_fmt(rules_header, {'title': title}), file=outfile)
        else:  # d == 'wikipedia'
            print(_fmt(wikipedia_header, {'title': title}), file=outfile)
        with open(os.path.join(dir, filename), 'r', encoding='utf-8') as file:
            print(file.read(), file=outfile)
        print(_fmt(rules_footer, {'footer': footer}), file=outfile)
        outfile.close()


gen_main_html()
gen_rules_html()
#!/usr/bin/env python3
# ---------------------------------------------------------------------------
#
# PySol -- a Python Solitaire game
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; see the file COPYING.
# If not, write to the Free Software Foundation, Inc.,
# 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#
# ---------------------------------------------------------------------------

# Starter for kivy/android using buildozer: Needs an explizitly
# named main.py as startpoint.

import sys
if '--kivy' not in sys.argv:
    sys.argv.append('--kivy')

runmain = True
if runmain:
    from pysollib.init import init
init()

if runmain:
    from pysollib.main import main
sys.exit(main(sys.argv))
#!/usr/bin/env python3
# ---------------------------------------------------------------------------
#
# PySol -- a Python Solitaire game
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; see the file COPYING.
# If not, write to the Free Software Foundation, Inc.,
# 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#
# ---------------------------------------------------------------------------

# import pychecker.checker

# Starter for kivy/android using buildozer: Needs an explizitly
# named main.py as startpoint.

if True:
    import sys
    sys.path.insert(0, '..')
if True:
    from pysollib.settings import VERSION
    print(VERSION)
#!/usr/bin/env python3
# -*- mode: python; coding: koi8-r; -*-
#

import os
import sys
import time

# from pprint import pprint
import pysollib.games
import pysollib.games.mahjongg  # noqa: F401
import pysollib.games.special
import pysollib.games.ultra  # noqa: F401
from pysollib.gamedb import GAME_DB
from pysollib.gamedb import GI
from pysollib.mfxutil import latin1_normalize
from pysollib.mygettext import fix_gettext
from pysollib.resource import CSI

from six.moves import builtins
os.environ['LANG'] = 'C'
builtins.__dict__['_'] = lambda x: x
builtins.__dict__['n_'] = lambda x: x

pysollib_path = os.path.join(sys.path[0], '..')
sys.path[0] = os.path.normpath(pysollib_path)
rules_dir = os.path.normpath(os.path.join(pysollib_path, 'data/html/rules'))
# pprint(sys.path)
# print rules_dir
html_mode = None

fix_gettext()


def getGameRulesFilename(n):
    if n.startswith('Mahjongg'):
        return 'mahjongg.html'
    return latin1_normalize(n) + '.html'


GAME_BY_TYPE = {
    GI.GT_BAKERS_DOZEN: "Baker's Dozen",
    GI.GT_BELEAGUERED_CASTLE: "Beleaguered Castle",
    GI.GT_CANFIELD: "Canfield",
    GI.GT_FAN_TYPE: "Fan",
    GI.GT_FORTY_THIEVES: "Forty Thieves",
    GI.GT_FREECELL: "FreeCell",
    GI.GT_GOLF: "Golf",
    GI.GT_GYPSY: "Gypsy",
    GI.GT_KLONDIKE: "Klondike",
    GI.GT_MONTANA: "Montana",
    GI.GT_NAPOLEON: "Napoleon",
    GI.GT_NUMERICA: "Numerica",
    GI.GT_PAIRING_TYPE: "Pairing",
    GI.GT_RAGLAN: "Raglan",
    GI.GT_SIMPLE_TYPE: "Simple game",
    GI.GT_SPIDER: "Spider",
    GI.GT_TERRACE: "Terrace",
    GI.GT_YUKON: "Yukon",
    GI.GT_1DECK_TYPE: "One-Deck game",
    GI.GT_2DECK_TYPE: "Two-Deck game",
    GI.GT_3DECK_TYPE: "Three-Deck game",
    GI.GT_4DECK_TYPE: "Four-Deck game",

    GI.GT_MATRIX: "Matrix",
    GI.GT_MEMORY: "Memory",
    GI.GT_POKER_TYPE: "Poker",
    GI.GT_PUZZLE_TYPE: "Puzzle",
    GI.GT_TAROCK: "Tarock",
    GI.GT_HEXADECK: "Hex A Deck",
    GI.GT_HANAFUDA: "Hanafuda",
    GI.GT_DASHAVATARA_GANJIFA: "Dashavatara Ganjifa",
    GI.GT_MAHJONGG: "Mahjongg",
    GI.GT_MUGHAL_GANJIFA: "Mughal Ganjifa",
    GI.GT_SHISEN_SHO: "Shisen-Sho",

}


def by_category():
    games = GAME_DB.getGamesIdSortedById()
    games_by_cat = {}
    for id in games:
        gi = GAME_DB.get(id)
        gt = CSI.TYPE_NAME[gi.category]
        if gt in games_by_cat:
            games_by_cat[gt] += 1
        else:
            games_by_cat[gt] = 1
    games_by_cat_list = [(i, j) for i, j in games_by_cat.items()]
    games_by_cat_list.sort(key=lambda x: x[1])
    games_by_cat_list = games_by_cat_list[::-1]
#     print '<table border="2"><tr><th>Name</th><th>Number</th></tr>'
#     for i in games_by_cat_list:
#         print '<tr><td>%s</td><td>%s</td></tr>' % i
#     print '</table>'
    print('<ul>')
    for i in games_by_cat_list:
        print('<li>%s (%s games)</li>' % i)
    print('</ul>')
    return


def by_type():
    games = GAME_DB.getGamesIdSortedById()
    games_by_type = {}
    for id in games:
        gi = GAME_DB.get(id)
        if gi.si.game_type not in GAME_BY_TYPE:
            print(gi.si.game_type)
            continue
        gt = GAME_BY_TYPE[gi.si.game_type]
        if gt in games_by_type:
            games_by_type[gt] += 1
        else:
            games_by_type[gt] = 1
    games_by_type_list = list(games_by_type.items())
    games_by_type_list.sort(key=lambda x: x[0])
    #  print '<table border="2"><tr><th>Name</th><th>Number</th></tr>'
    #  for i in games_by_type_list:
    #      print '<tr><td>%s</td><td>%s</td></tr>' % i
    #  print '</table>'
    print('<ul>')
    for i in games_by_type_list:
        print('<li>%s (%s games)</li>' % i)
    print('</ul>')
    return


def all_games(sort_by='id'):
    # rules_dir = 'rules'
    print('''<table><thead>
<tr><th>ID</th><th>Name</th><th>Alternate names</th><th>Type</th></tr>
</thead>
<tbody>
''')

    if sort_by == 'id':
        get_games_func = GAME_DB.getGamesIdSortedById
    else:
        get_games_func = GAME_DB.getGamesIdSortedByName

    for id in get_games_func():
        gi = GAME_DB.get(id)
        if not gi.rules_filename:
            rules_fn = getGameRulesFilename(gi.name)
        else:
            rules_fn = gi.rules_filename
        gt = CSI.TYPE_NAME[gi.category]
        if gt == 'French':
            gt = 'French (%s)' % GAME_BY_TYPE[gi.si.game_type]
        name = gi.name
        altnames = '<br/>'.join(gi.altnames)
        fn = os.path.join(rules_dir, rules_fn)
        if 1 and os.path.exists(fn):
            print('''<tr>
<td>%s</td>
<td> <a href="%s" title="Rules for this game">%s</a> </td>
<td>%s</td>
<td>%s</td>
</tr>
''' % (id, fn, name, altnames, gt))
        else:
            print('''<tr>
<td>%s</td>
<td>%s</td>
<td>%s</td>
<td>%s</td>
</tr>
''' % (id, name, altnames, gt))
    print('</tbody></table>')


def create_html(sort_by):
    if html_mode != 'bare':
        print('''<!DOCTYPE html><html lang="en-US">
<head>
  <title>PySolFC - List of solitaire games</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
</head>
<body>
''')
    print('<strong>Total games: %d</strong>' %
          len(GAME_DB.getGamesIdSortedById()))
    print('<section>')
    print('<h2>Categories</h2>')
    by_category()
    print('</section>')
    print('<section>')
    print('<h2>Types</h2>')
    by_type()
    print('</section>')
    # print '<h2>All games</h2>'
    print('<section>')
    print('<h2>The games</h2>')
    all_games(sort_by)
    print('</section>')
    if html_mode != 'bare':
        print('</body></html>')


def get_text():
    # get_games_func = GAME_DB.getGamesIdSortedById
    get_games_func = GAME_DB.getGamesIdSortedByName

    games_list = {}  # for unique
    for id in get_games_func():
        gi = GAME_DB.get(id)
        games_list[gi.name] = ''
        if gi.name != gi.short_name:
            games_list[gi.short_name] = ''
        for n in gi.altnames:
            games_list[n] = ''
    games_list = list(games_list.keys())
    games_list.sort()
    print('''\
# SOME DESCRIPTIVE TITLE.
# Copyright (C) YEAR ORGANIZATION
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PySol 0.0.1\\n"
"POT-Creation-Date: %s\\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\\n"
"Language-Team: LANGUAGE <LL@li.org>\\n"
"MIME-Version: 1.0\\n"
"Content-Type: text/plain; charset=CHARSET\\n"
"Content-Transfer-Encoding: ENCODING\\n"
"Generated-By: %s 0.1\\n"

''' % (time.asctime(), sys.argv[0]))
    for g in games_list:
        print('msgid "%s"\nmsgstr ""\n' % g)


def old_plain_text():
    # get_games_func = GAME_DB.getGamesIdSortedById
    get_games_func = GAME_DB.getGamesIdSortedByName
    games_list = {}  # for unique
    for id in get_games_func():
        gi = GAME_DB.get(id)
        games_list[gi.name] = ''
        # if gi.name != gi.short_name:
        #    games_list[gi.short_name] = ''
        for n in gi.altnames:
            games_list[n] = ''
    games_list = games_list.keys()
    games_list.sort()
    for g in games_list:
        print(g)


def plain_text():
    get_games_func = GAME_DB.getGamesIdSortedByName
    for id in get_games_func():
        gi = GAME_DB.get(id)
        if gi.category == GI.GC_FRENCH:
            # print str(gi.gameclass)
            # gc = gi.gameclass
            # h = gc.Hint_Class is None and 'None' or gc.Hint_Class.__name__
            # print gi.name.encode('utf-8'), h
            print(gi.name)
            for n in gi.altnames:
                print(n)
            # name = gi.name.lower()
            # name = re.sub('\W', '', name)
            # print id, name #, gi.si.game_type,
            #       gi.si.game_type == GI.GC_FRENCH


if len(sys.argv) < 2 or sys.argv[1] == 'html':
    sort_by = 'id'
    if len(sys.argv) > 2:
        sort_by = sys.argv[2]
    if len(sys.argv) > 3:
        rules_dir = sys.argv[3]
    if len(sys.argv) > 4:
        html_mode = sys.argv[4]
    create_html(sort_by)
elif sys.argv[1] == 'gettext':
    get_text()
elif sys.argv[1] == 'text':
    plain_text()
else:
    sys.exit('invalid argument')
#!/usr/bin/env python
# Written by Shlomi Fish, under the MIT Expat License.

import os
import os.path
import re
from sys import platform

IS_MAC = (platform == "darwin")
TEST_TAGS = os.getenv('TEST_TAGS', '')


def _has_tag(tag):
    return re.search("\\b{}\\b".format(tag), TEST_TAGS)


PY_VERS = ([] if _has_tag('SKIP_PY2') else [2])+[3]
SKIP_GTK = _has_tag('SKIP_GTK')
module_names = []
for d, _, files in os.walk("pysollib"):
    for f in files:
        if re.search("\\.py$", f):
            module_names.append(
                (d + "/" + re.sub("\\.py$", "", f))
                .replace("/", ".").replace(os.sep, "."))

module_names.sort()
for module_name in module_names:
    if "kivy" in module_name:
        continue
    is_gtk = ("gtk" in module_name)
    for ver in PY_VERS:
        if ((not is_gtk) or (ver == 2 and (not IS_MAC) and (not SKIP_GTK))):
            def fmt(s):
                return s % {'module_name': module_name, 'ver': ver}
            open(os.path.join(".", "tests", "individually-importing", fmt("import_v%(ver)d_%(module_name)s.py")), 'w').write(fmt('''#!/usr/bin/env python%(ver)d
import sys
print('1..1')
sys.path.insert(0, ".")
import %(module_name)s
print('ok 1 - imported')
'''))

for ver in PY_VERS:
    for mod in [
            'pysol_tests.acard_unit',
            'pysol_tests.game_drag',
            'pysol_tests.hint',
            'pysol_tests.import_file1',
            'pysol_tests.latin1_conv_unit',
            'pysol_tests.ms_deals1',
            'pysol_tests.scorpion_canMove',
            ]:
        open(os.path.join(".", "tests", "unit-generated",
                          'test__%s__v%d.py' % (mod, ver)
                          ), 'w').write('''#!/usr/bin/env python%(ver)d
import unittest

from pycotap import TAPTestRunner

from %(mod)s import MyTests

suite = unittest.TestLoader().loadTestsFromTestCase(MyTests)
TAPTestRunner().run(suite)
''' % {'mod': mod, 'ver': ver})
#!/usr/bin/env python
# -*- mode: python; coding: utf-8; -*-

import os
import sys

alpha = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'


def decode_layout(layout):
    # decode tile positions
    assert layout[0] == "0"
    assert (len(layout) - 1) % 3 == 0
    tiles = []
    for i in range(1, len(layout), 3):
        n = alpha.find(layout[i])
        level, height = n / 7, n % 7 + 1
        tx = alpha.find(layout[i+1])
        ty = alpha.find(layout[i+2])
        assert n >= 0 and tx >= 0 and ty >= 0
        for tl in range(level, level + height):
            tiles.append((tl, tx, ty))
    tiles.sort()
    return tiles


def encode_layout(layout):
    # encode positions
    s = '0'
    # layout.sort()
    x_max = max([t[1] for t in layout])
    y_max = max([t[2] for t in layout])
    for x in range(x_max+1):
        for y in range(y_max+1):
            mylist = [t[0] for t in layout if t[1] == x and t[2] == y]
            if not mylist:
                continue
            i_0 = i_n = mylist[0]
            for i in mylist[1:]:
                if i == i_n+1:
                    i_n = i
                    continue
                s += alpha[i_0*7+(i_n-i_0)] + alpha[x] + alpha[y]
                i_0 = i_n = i
            s += alpha[i_0*7+(i_n-i_0)] + alpha[x] + alpha[y]

#     for tl, tx, ty in layout:
#         s += alpha[tl*7]+alpha[tx]+alpha[ty]
    return s


def parse_kyodai(filename):
    # Kyodai (http://www.kyodai.com/)

    fd = open(filename)
    fd.readline()
    fd.readline()

    s = fd.readline()
    i = 0
    y = 0
    z = 0
    layout = []
    while True:
        ss = s[i:i+34]
        if not ss:
            break
        x = 0
        for c in ss:
            if c == '1':
                layout.append((z, x, y))
            x += 1
        y += 1
        if y == 20:
            y = 0
            z += 1
        i += 34
    layout.sort()
    return normalize(layout)


def parse_ace(filename):
    # Ace of Penguins (http://www.delorie.com/store/ace/)
    mylist = open(filename).read().replace('\n', '').split(',')
    mylist.reverse()
    layout = []
    layer = 0
    while True:
        x = int(mylist.pop())
        if x == 127:
            break
        if x <= 0:
            x = -x
            y, z = int(mylist.pop()), int(mylist.pop())
            if layer < z:
                layer = z
        layout.append((z, x, y))
    layout.sort()
    return normalize(layout)


def parse_kmahjongg(filename):
    # KMahjongg
    fd = open(filename)
    fd.readline()
    lines = fd.readlines()
    level = 0
    n = 0
    layout = []
    for s in lines:
        i = 0
        while True:
            i = s.find('1', i)
            if i >= 0:
                layout.append((level, i, n))
                i += 1
            else:
                break
        n += 1
        if n == 16:
            n = 0
            level += 1
    layout.sort()
    return normalize(layout)


def parse_xmahjongg(filename):
    if open(filename).readline().startswith('Kyodai'):
        return parse_kyodai(filename)
    fd = open(filename)
    layout = []
    for s in fd:
        s = s.strip()
        if not s:
            continue
        if s.startswith('#'):
            continue
        row, col, lev = s.split()
        layout.append((int(lev), int(col), int(row)))
    layout.sort()
    return normalize(layout)


def normalize(mylist):
    minx = min([i[1] for i in mylist])
    if minx:
        mylist = [(i[0], i[1]-minx, i[2]) for i in mylist]
    miny = min([i[2] for i in mylist])
    if miny:
        mylist = [(i[0], i[1], i[2]-miny) for i in mylist]
    return mylist


if __name__ == '__main__':
    gameid = 5200

    usage = '''usage:
%s TYPE FILE ...
  where TYPE are:
    k | kyodai    - parse kyodai file
    x | xmahjongg - parse xmahjongg file
    m | kmahjongg - parse kmahjongg file
    a | ace       - parse ace of penguins file
''' % sys.argv[0]

    if len(sys.argv) < 3:
        sys.exit(usage)
    if sys.argv[1] in ['k', 'kyodai']:
        parse_func = parse_kyodai
    elif sys.argv[1] in ['x', 'xmahjongg']:
        parse_func = parse_xmahjongg
    elif sys.argv[1] in ['m', 'kmahjongg']:
        parse_func = parse_kmahjongg
    elif sys.argv[1] in ['a', 'ace']:
        parse_func = parse_ace
    else:
        sys.exit(usage)

    for filename in sys.argv[2:]:

        layout = parse_func(filename)
        layout = normalize(layout)

        # print filename, len(layout)

        s = encode_layout(layout)

        # check
        lt = decode_layout(s)
        if lt != layout:
            print('*** ERROR ***')
        else:
            # print s

            gamename = os.path.split(filename)[1].split('.')[0]
            # classname = gamename.replace(' ', '_')
            # classname = 'Mahjongg_' + re.sub('\W', '', classname)

            ncards = len(layout)

            if ncards != 144:
                print('''r(%d, "%s", ncards=%d, layout="%s")
''' % (gameid, gamename, ncards, s))

            else:
                print('''r(%d, "%s", layout="%s")
''' % (gameid, gamename, s))

            gameid += 1
#!/usr/bin/env python3

import os
import sys

import pysollib.settings

if sys.version_info > (3,):
    def execfile(fn):
        return exec(open(fn).read())

prog_name = 'PySol Fan Club edition'


dirs_list = []
files_list = []
for root, dirs, files in os.walk('dist'):
    if files:
        files_list.append(root)
    dirs_list.append(root)

prog_version = pysollib.settings.VERSION

out = open('setup.iss', 'w')

print('''
[Setup]
AppName=%(prog_name)s
AppVerName=%(prog_name)s v.%(prog_version)s
DefaultDirName={pf}\\%(prog_name)s
DefaultGroupName=%(prog_name)s
UninstallDisplayIcon={app}\\pysol.exe
Compression=lzma
SolidCompression=yes
SourceDir=dist
OutputDir=.
OutputBaseFilename=PySolFC_%(prog_version)s_setup
DisableWelcomePage=no
DisableDirPage=no
DisableProgramGroupPage=no

[Icons]
Name: "{group}\\%(prog_name)s"; Filename: "{app}\\pysol.exe"
Name: "{group}\\Uninstall %(prog_name)s"; Filename: "{uninstallexe}"
Name: "{userdesktop}\\%(prog_name)s"; Filename: "{app}\\pysol.exe"
''' % vars(), file=out)

print('[Dirs]', file=out)
for d in dirs_list[1:]:
    print('Name: "{app}%s"' % d.replace('dist', ''), file=out)

print(file=out)
print('[Files]', file=out)
print('Source: "*"; DestDir: "{app}"', file=out)
for d in files_list[1:]:
    d = d.replace('dist\\', '')
    print('Source: "%s\\*"; DestDir: "{app}\\%s"' % (d, d), file=out)

print('Source: "..\\vcredist_x86.exe"; DestDir: {tmp}; \
Flags: deleteafterinstall', file=out)
print('[Run]\n\
Filename: {tmp}\\vcredist_x86.exe; \
Parameters: "/passive /promptrestart /showfinalerror"; \
StatusMsg: "Installing MS Visual C++ 2010 SP1 Redistributable Package (x86)"; \
Check: not isVCInstalled', file=out)
print('''
[Code]
function isVCInstalled: Boolean;
var
  find: TFindRec;
begin
  if FindFirst(ExpandConstant('{sys}\\msvcr100.dll'), find) then begin
    Result := True;
    FindClose(find);
  end else begin
    Result := False;
  end;
 end;

function InitializeSetup(): Boolean;
var
  Version: TWindowsVersion;
begin
  GetWindowsVersionEx(Version);

  // Windows XP SP3 and higher
  if  ((Version.Major = 5) and ((Version.Minor = 1) and
       (Version.ServicePackMajor >= 3) or (Version.Minor > 1)) or
       (Version.Major > 5)) then
    Result := True
  else begin
    MsgBox(
      'This version of Windows is not supported. PySolFC %(prog_version)s \
requires Windows XP SP3 or higher.',
      mbCriticalError, MB_OK);
    Result := False;
  end;
end;
''' % vars(), file=out)

out.close()
#!/usr/bin/env python
# -*- mode: python; coding: koi8-r; -*-
#

import os
import sys
from glob import glob
from math import cos, pi, sin, sqrt

from six.moves import tkinter

try:
    from PIL import Image, ImageTk
except ImportError:
    Image = None

cardset_type = {
    '1': 'French',
    '2': 'Hanafuda',
    '3': 'Tarock',
    '4': 'Mahjongg',
    '5': 'Hexadeck',
    '6': 'Mughal Ganjifa',
    '7': 'Navagraha Ganjifa',
    '8': 'Dashavatara Ganjifa',
    '9': 'Trump only',
    }

all_imgs = False


class Cardset:
    def __init__(self, dir, name, type, ext, x, y):
        self.dir, self.name, self.type, self.ext, self.x, self.y = \
            dir, name, type, ext, x, y


def create_cs_list(ls):
    cardsets_list = {}
    for f in ls:
        dir = os.path.split(f)[0]
        lines = open(f).readlines()
        l0 = lines[0].split(';')
        try:
            ext = l0[2]
        except IndexError:
            # print f
            ext = '.gif'
        if len(l0) > 3:
            type = cardset_type[l0[3]]
        else:
            # type = 'Unknown'
            type = 'French'
        l1 = lines[1].split(';')
        name = l1[1].strip()
        l2 = lines[2].split()
        x, y = int(l2[0]), int(l2[1])
        cs = Cardset(dir, name, type, ext, x, y)
        cardsets_list[name] = cs
    return cardsets_list


tk_images = []
zoom = 0


def show_cardset(*args):
    global tk_images
    tk_images = []
    if list_box.curselection():
        cs_name = list_box.get(list_box.curselection())
        cs = cardsets_dict[cs_name]
        ls = glob(os.path.join(cs.dir, '[0-9][0-9][a-z]'+cs.ext))
        ls += glob(os.path.join(cs.dir, 'back*'+cs.ext))
        if all_imgs:
            ls += glob(os.path.join(cs.dir, 'bottom*'+cs.ext))
            ls += glob(os.path.join(cs.dir, 'l*'+cs.ext))
        # ls = glob(os.path.join(cs.dir, '*.gif'))
        # if not ls: return
        ls.sort()
        pf = None
        x, y = 10, 10
        width, height = 0, 0
        canvas.delete('all')
        for f in ls:
            if Image:
                filter = {
                    'NEAREST': Image.NEAREST,
                    'BILINEAR': Image.BILINEAR,
                    'BICUBIC': Image.BICUBIC,
                    'ANTIALIAS': Image.ANTIALIAS,
                    }[filter_var.get()]
                # filter = Image.BILINEAR
                # filter = Image.BICUBIC
                # filter = Image.ANTIALIAS
                # print f
                im = Image.open(f)
                if zoom != 0:
                    w, h = im.size
                    im = im.convert('RGBA')        # for save transparency
                    if rotate_var.get():
                        # rotate
                        # if filter == Image.ANTIALIAS:
                        #    filter = Image.BICUBIC
                        z = zoom*5
                        a = abs(pi/2/90*z)
                        neww = int(w*cos(a)+h*sin(a))
                        newh = int(h*cos(a)+w*sin(a))
                        # print w, h, neww, newh
                        d = int(sqrt(w*w+h*h))
                        dx, dy = (d-w)/2, (d-h)/2
                        newim = Image.new('RGBA', (d, d))
                        newim.paste(im, (dx, dy))
                        im = newim
                        im = im.rotate(z, resample=filter)
                        x0, y0 = (d-neww)/2, (d-newh)/2
                        x1, y1 = d-x0, d-y0
                        im = im.crop((x0, y0, x1, y1))
                        t = str(z)
                    else:
                        # zoom
                        z = 1.0 + zoom/10.0
                        z = max(0.2, z)
                        if 1:
                            tmp = Image.new('RGBA', (w+2, h+2))
                            tmp.paste(im, (1, 1), im)
                            im = tmp.resize((int(w*z), int(h*z)),
                                            resample=filter)
                        else:
                            im = im.resize((int(w*z), int(h*z)),
                                           resample=filter)
                        t = '%d %%' % int(z*100)

                    zoom_label.config(text=t)

                else:
                    zoom_label.config(text='')
                image = ImageTk.tkinter.PhotoImage(im)
            else:
                image = tkinter.PhotoImage(file=f)
            tk_images.append(image)
            ff = os.path.split(f)[1]
            if pf is None:
                pf = ff[:2]
                x, y = 10, 10
            elif ff[:2] != pf:
                pf = ff[:2]
                x = 10
                y += image.height()+10
            else:
                x += image.width()+10
            canvas.create_image(x, y, image=image, anchor=tkinter.NW)
            # canvas.create_rectangle(x, y, x+image.width(), y+image.height())
            width = max(width, x)
            height = max(height, y)
        width, height = width+image.width()+10, height+image.height()+10
        canvas.config(scrollregion=(0, 0, width, height))
        # print image.width(), image.height()
        label.config(text='''\
Name: %s
Type: %s
Directory: %s''' % (cs.name, cs.type, cs.dir))


def zoom_in(*args):
    global zoom
    zoom += 1
    show_cardset()


def zoom_out(*args):
    global zoom
    zoom -= 1
    show_cardset()


def zoom_cancel(*args):
    global zoom
    zoom = 0
    show_cardset()


def show_info(*args):
    if list_box.curselection():
        cs_name = list_box.get(list_box.curselection())
        cs = cardsets_dict[cs_name]
        fn = os.path.join(cs.dir, 'COPYRIGHT')
        top = tkinter.Toplevel()
        text = tkinter.Text(top)
        text.insert('insert', open(fn).read())
        text.pack(expand=tkinter.YES, fill=tkinter.BOTH)
        b_frame = tkinter.Frame(top)
        b_frame.pack(fill=tkinter.X)
        button = tkinter.Button(b_frame, text='Close', command=top.destroy)
        button.pack(side=tkinter.RIGHT)


def create_widgets():
    global list_box, canvas, label, zoom_label
    #
    root = tkinter.Tk()
    #
    list_box = tkinter.Listbox(root, exportselection=False)
    list_box.grid(row=0, column=0, rowspan=2, sticky=tkinter.NS)
    cardsets_list = list(cardsets_dict)
    cardsets_list.sort()
    for cs in cardsets_list:
        list_box.insert(tkinter.END, cs)
    list_box.bind('<<ListboxSelect>>', show_cardset)
    #
    sb = tkinter.Scrollbar(root)
    sb.grid(row=0, column=1, rowspan=2, sticky=tkinter.NS)
    list_box.config(yscrollcommand=sb.set)
    sb.config(command=list_box.yview)
    #
    canvas = tkinter.Canvas(root, bg='#5eab6b')
    canvas.grid(row=0, column=2, sticky=tkinter.NSEW)
    canvas.bind('<4>', lambda e: canvas.yview_scroll(-5, 'unit'))
    canvas.bind('<5>', lambda e: canvas.yview_scroll(5, 'unit'))
    #
    sb = tkinter.Scrollbar(root)
    sb.grid(row=0, column=3, sticky=tkinter.NS)
    canvas.config(yscrollcommand=sb.set)
    sb.config(command=canvas.yview)
    #
    if True:
        sb = tkinter.Scrollbar(root, orient=tkinter.HORIZONTAL)
        sb.grid(row=1, column=2, sticky=tkinter.EW)
        canvas.config(xscrollcommand=sb.set)
        sb.config(command=canvas.xview)
    #
    label = tkinter.Label(root)
    label.grid(row=2, column=0, columnspan=4)
    #
    b_frame = tkinter.Frame(root)
    b_frame.grid(row=3, column=0, columnspan=4, sticky=tkinter.EW)
    button = tkinter.Button(b_frame, text='Quit', command=root.quit, width=8)
    button.pack(side=tkinter.RIGHT)
    button = tkinter.Button(b_frame, text='Info', command=show_info, width=8)
    button.pack(side=tkinter.RIGHT)
    if Image:
        global rotate_var, filter_var
        rotate_var = tkinter.IntVar(root)
        filter_var = tkinter.StringVar(root)
        button = tkinter.Button(b_frame, text='  +  ', command=zoom_in)
        button.pack(side=tkinter.LEFT)
        button = tkinter.Button(b_frame, text='  -  ', command=zoom_out)
        button.pack(side=tkinter.LEFT)
        button = tkinter.Button(b_frame, text='  =  ', command=zoom_cancel)
        button.pack(side=tkinter.LEFT)
        button = tkinter.Checkbutton(
            b_frame, text='Rotate', indicatoron=0,
            selectcolor=b_frame['bg'], width=8,
            variable=rotate_var, command=show_cardset)
        button.pack(side=tkinter.LEFT, fill='y')
        om = tkinter.OptionMenu(
            b_frame, filter_var,
            'NEAREST', 'BILINEAR', 'BICUBIC', 'ANTIALIAS',
            command=show_cardset)
        filter_var.set('NEAREST')
        om.pack(side=tkinter.LEFT, fill='y')

        zoom_label = tkinter.Label(b_frame)
        zoom_label.pack(side=tkinter.LEFT)
    #
    root.columnconfigure(2, weight=1)
    root.rowconfigure(0, weight=1)

    root.title('Show Cardsets')

    return root


if __name__ == '__main__':
    if '-a' in sys.argv:
        sys.argv.remove('-a')
        all_imgs = True
    if len(sys.argv) > 1:
        data_dir = sys.argv[1]
    else:
        data_dir = os.path.normpath(
            os.path.join(sys.path[0], os.pardir, 'data'))
    ls = glob(os.path.join(data_dir, '*', 'config.txt'))
    cardsets_dict = create_cs_list(ls)
    root = create_widgets()
    root.mainloop()
#!/usr/bin/env python
# -*- mode: python; coding: koi8-r; -*-

import os

import gtk

imdir = 'images'
imtype = 'png'
background = '#efebe7'

# fill_color = 0xff000000                 # red
fill_color = int('ff000000', 16)

if not os.path.exists(imdir):
    os.mkdir(imdir)

gc = None


def draw_rect():
    global gc
    if gc is None:
        gc = drawing_area.window.new_gc()
        colormap = gtk.gdk.colormap_get_system()
        gc.set_colormap(colormap)
        color = gtk.gdk.color_parse('red')
        colormap.alloc_color(color)
        gc.set_rgb_fg_color(color)
    drawing_area.window.draw_rectangle(gc, True, 0, 0, 800, 800)


def save_image(fn, w, h, x=0, y=0):
    pixbuf = gtk.gdk.Pixbuf(gtk.gdk.COLORSPACE_RGB, True, 8, w, h)
    pixbuf.fill(fill_color)
    pb = pixbuf.get_from_drawable(drawing_area.window,
                                  drawing_area.get_colormap(),
                                  x, y, 0, 0, w, h)
    pb.save(os.path.join(imdir, fn+"."+imtype), imtype)
    drawing_area.window.clear()
    draw_rect()


done = False


def save_callback(*args):
    global done

    if done:
        return
    done = True
    print('create images')

    style = drawing_area.get_style()
    draw_rect()

    # separator
    w = 20
    style.paint_vline(drawing_area.window, gtk.STATE_NORMAL, None,
                      drawing_area, "frame", 0, w, 0)
    save_image('sep-v', 2, w)
    style.paint_hline(drawing_area.window, gtk.STATE_NORMAL, None,
                      drawing_area, "frame", 0, w, 0)
    save_image('sep-h', w, 2)

    # tree
    w, h = 32, 32
    w, h = 24, 24
    for fn, state, shadow in (
        ("tree-n", gtk.STATE_NORMAL,      gtk.SHADOW_OUT),
        ("tree-h", gtk.STATE_PRELIGHT,    gtk.SHADOW_OUT),
        ("tree-p", gtk.STATE_ACTIVE,      gtk.SHADOW_IN),
        ("tree-d", gtk.STATE_INSENSITIVE, gtk.SHADOW_IN),
            ):
        style.paint_box(drawing_area.window, state, shadow,
                        None, drawing_area, "stepper", 0, 0, w, h)
        save_image(fn, w, h)

    # sizegrip
    w, h = 16, 16
    fn = 'sizegrip'
    style.paint_resize_grip(drawing_area.window, gtk.STATE_NORMAL, None,
                            drawing_area, "statusbar",
                            gtk.gdk.WINDOW_EDGE_SOUTH_EAST, 0, 0, w, h)
    save_image(fn, w, h)

    # progress
    w, h = 37+3, 16+3
    progress_style = progress.get_style()
    fn = 'progress-h'
    progress_style.paint_box(drawing_area.window,
                             gtk.STATE_PRELIGHT, gtk.SHADOW_NONE,
                             None, progress, "bar", 0, 0, w, h)
    save_image(fn, w, h)

    # button
    w, h = 32, 32
    w, h = 28, 28
    for fn, state, shadow in (
        ("button-n", gtk.STATE_NORMAL,      gtk.SHADOW_OUT),
        ("button-a", gtk.STATE_PRELIGHT,    gtk.SHADOW_OUT),
        ("button-p", gtk.STATE_ACTIVE,      gtk.SHADOW_IN),
        ("button-d", gtk.STATE_INSENSITIVE, gtk.SHADOW_OUT),
            ):
        style.paint_box(drawing_area.window, state, shadow,
                        None, drawing_area, "buttondefault", 0, 0, w, h)
        save_image(fn, w, h)

    style.paint_box(drawing_area.window, gtk.STATE_PRELIGHT, gtk.SHADOW_IN,
                    None, togglebutton, "buttondefault", 0, 0, w, h)
    save_image("button-pa", w, h)

    # toolbar
    w, h = 16, 16
    w, h = 24, 24

    fn = "blank"
    pixbuf = gtk.gdk.Pixbuf(gtk.gdk.COLORSPACE_RGB, True, 8, w, h)
    pixbuf.fill(fill_color)
    pixbuf.save(os.path.join(imdir, fn+"."+imtype), imtype)

    for fn, state, shadow in (
        ("toolbutton-n", gtk.STATE_NORMAL,      gtk.SHADOW_OUT),
        ("toolbutton-a", gtk.STATE_PRELIGHT,    gtk.SHADOW_OUT),
        ("toolbutton-p", gtk.STATE_ACTIVE,      gtk.SHADOW_IN),
        ("toolbutton-d", gtk.STATE_INSENSITIVE, gtk.SHADOW_IN),
            ):
        style.paint_box(drawing_area.window, state, shadow,
                        None, drawing_area, "buttondefault", 0, 0, w, h)
        save_image(fn, w, h)

    style.paint_box(drawing_area.window, gtk.STATE_PRELIGHT, gtk.SHADOW_IN,
                    None, togglebutton, "buttondefault", 0, 0, w, h)
    save_image("toolbutton-pa", w, h)

    # slider
    msl = hscroll.style_get_property("min_slider_length")
    msl = 20
    sw = hscroll.style_get_property("slider_width")
    print('>>', msl, sw)
    for t, w, h, state, orient in (
        ('hn', msl, sw, gtk.STATE_NORMAL,      gtk.ORIENTATION_HORIZONTAL),
        ('ha', msl, sw, gtk.STATE_PRELIGHT,    gtk.ORIENTATION_HORIZONTAL),
        ('hp', msl, sw, gtk.STATE_NORMAL,      gtk.ORIENTATION_HORIZONTAL),
        ('hd', msl, sw, gtk.STATE_INSENSITIVE, gtk.ORIENTATION_HORIZONTAL),

        ('vn', sw, msl, gtk.STATE_NORMAL,      gtk.ORIENTATION_VERTICAL),
        ('va', sw, msl, gtk.STATE_PRELIGHT,    gtk.ORIENTATION_VERTICAL),
        ('vp', sw, msl, gtk.STATE_NORMAL,      gtk.ORIENTATION_VERTICAL),
        ('vd', sw, msl, gtk.STATE_INSENSITIVE, gtk.ORIENTATION_VERTICAL),
            ):
        fn = 'sbthumb-'+t
        if 0:
            style.paint_slider(drawing_area.window, state, gtk.SHADOW_OUT,
                               None, drawing_area, "slider",
                               0, 0, w, h, orient)
        else:
            if orient == gtk.ORIENTATION_VERTICAL:
                w, h = h, w
            style.paint_box(drawing_area.window, state, shadow,
                            None, drawing_area, "stepper", 0, 0, w, h)
        save_image(fn, w, h)

    msl = hscroll.style_get_property("min_slider_length")
    sw = hscroll.style_get_property("slider_width")
    # scale
    for t, w, h, state, orient in (
        ('hn', msl, sw, gtk.STATE_NORMAL,      gtk.ORIENTATION_HORIZONTAL),
        ('ha', msl, sw, gtk.STATE_PRELIGHT,    gtk.ORIENTATION_HORIZONTAL),
        ('hd', msl, sw, gtk.STATE_INSENSITIVE, gtk.ORIENTATION_HORIZONTAL),
        ('vn', sw, msl, gtk.STATE_NORMAL,      gtk.ORIENTATION_VERTICAL),
        ('va', sw, msl, gtk.STATE_PRELIGHT,    gtk.ORIENTATION_VERTICAL),
        ('vd', sw, msl, gtk.STATE_INSENSITIVE, gtk.ORIENTATION_VERTICAL),
            ):
        fn = 'scale-'+t
        if orient == gtk.ORIENTATION_HORIZONTAL:
            detail = "hscale"
        else:
            detail = "vscale"
        style.paint_slider(drawing_area.window, state, gtk.SHADOW_OUT,
                           None, drawing_area, detail, 0, 0, w+2, h+2, orient)
        save_image(fn, w, h, 1, 1)

    w, h = msl, sw
    fn = 'scaletrough-h'
    style.paint_box(drawing_area.window, gtk.STATE_ACTIVE, gtk.SHADOW_IN,
                    None, scale, "trough", 0, 0, w, h)
    save_image(fn, w, h)

    # arrow
    w = h = hscroll.style_get_property("stepper_size")
    # w = h = 15
    arrow_width = w / 2
    arrow_height = h / 2
    arrow_x = (w - arrow_width) / 2
    arrow_y = (h - arrow_height) / 2

    alloc = hscroll.get_allocation()
    x0 = alloc.x
    x1 = alloc.x+alloc.width-w
    alloc = vscroll.get_allocation()
    y0 = alloc.y
    y1 = alloc.y+alloc.height-h

    sn = gtk.STATE_NORMAL
    sp = gtk.STATE_PRELIGHT
    sa = gtk.STATE_ACTIVE
    si = gtk.STATE_INSENSITIVE

    for fn, x, y, state, shadow, arrow_type, widget in (
        ("arrowleft-n", x0, 0, sn, gtk.SHADOW_OUT, gtk.ARROW_LEFT, hscroll),
        ("arrowleft-a", x0, 0, sp, gtk.SHADOW_OUT, gtk.ARROW_LEFT, hscroll),
        ("arrowleft-p", x0, 0, sa, gtk.SHADOW_IN,  gtk.ARROW_LEFT, hscroll),
        ("arrowleft-d", x0, 0, si, gtk.SHADOW_OUT, gtk.ARROW_LEFT, hscroll),

        ("arrowright-n", x1, 0, sn, gtk.SHADOW_OUT, gtk.ARROW_RIGHT, hscroll),
        ("arrowright-a", x1, 0, sp, gtk.SHADOW_OUT, gtk.ARROW_RIGHT, hscroll),
        ("arrowright-p", x1, 0, sa, gtk.SHADOW_IN,  gtk.ARROW_RIGHT, hscroll),
        ("arrowright-d", x1, 0, si, gtk.SHADOW_OUT, gtk.ARROW_RIGHT, hscroll),

        ("arrowup-n", 0, y0, sn, gtk.SHADOW_OUT, gtk.ARROW_UP, vscroll),
        ("arrowup-a", 0, y0, sp, gtk.SHADOW_OUT, gtk.ARROW_UP, vscroll),
        ("arrowup-p", 0, y0, sa, gtk.SHADOW_IN,  gtk.ARROW_UP, vscroll),
        ("arrowup-d", 0, y0, si, gtk.SHADOW_OUT, gtk.ARROW_UP, vscroll),

        ("arrowdown-n", 0, y1, sn, gtk.SHADOW_OUT, gtk.ARROW_DOWN, vscroll),
        ("arrowdown-a", 0, y1, sp, gtk.SHADOW_OUT, gtk.ARROW_DOWN, vscroll),
        ("arrowdown-p", 0, y1, sa, gtk.SHADOW_IN,  gtk.ARROW_DOWN, vscroll),
        ("arrowdown-d", 0, y1, si, gtk.SHADOW_OUT, gtk.ARROW_DOWN, vscroll),
            ):
        if 0:
            detail = 'hscrollbar'
            if widget is vscroll:
                detail = 'vscrollbar'
        else:
            x, y = 0, 0
            detail = 'stepper'
            widget = drawing_area
        style.paint_box(drawing_area.window, state, shadow,
                        None, widget, detail, x, y, w, h)
        style.paint_arrow(drawing_area.window, state, shadow,
                          None, widget, detail, arrow_type, True,
                          x+arrow_x, y+arrow_y, arrow_width, arrow_height)
        save_image(fn, w, h, x, y)

    # combobox
    w, h = w, 24
    w, h = 16, 24
    alloc = hscroll.get_allocation()
    x1 = alloc.x+alloc.width-w
    arrow_width = w / 2
    arrow_height = h / 2
    arrow_x = (w - arrow_width) / 2
    arrow_y = (h - arrow_height) / 2
    detail = 'hscrollbar'
    widget = hscroll
    for fn, state, shadow, arrow_type in (
        ("comboarrow-n", gtk.STATE_NORMAL,     gtk.SHADOW_OUT, gtk.ARROW_DOWN),
        ("comboarrow-a", gtk.STATE_PRELIGHT,   gtk.SHADOW_OUT, gtk.ARROW_DOWN),
        ("comboarrow-p", gtk.STATE_ACTIVE,      gtk.SHADOW_IN, gtk.ARROW_DOWN),
        ("comboarrow-d", gtk.STATE_INSENSITIVE, gtk.SHADOW_IN, gtk.ARROW_DOWN),
            ):
        style.paint_box(drawing_area.window, state, shadow,
                        None, widget, detail, x1, 0, w, h)
        style.paint_arrow(drawing_area.window, state, shadow,
                          None, drawing_area, "stepper", arrow_type, True,
                          x1+arrow_x, arrow_y, arrow_width, arrow_height)
        save_image(fn, w, h, x1, 0)

    w = 24
    for fn, state, shadow in (
        ("combo-rn", gtk.STATE_NORMAL,      gtk.SHADOW_OUT),
        ("combo-ra", gtk.STATE_PRELIGHT,    gtk.SHADOW_OUT),
        ("combo-rp", gtk.STATE_ACTIVE,      gtk.SHADOW_IN),
        ("combo-rd", gtk.STATE_INSENSITIVE, gtk.SHADOW_OUT),
            ):
        style.paint_box(drawing_area.window, state, shadow,
                        None, drawing_area, "button", 0, 0, w+2, h)
        save_image(fn, w, h)

    style.paint_box(drawing_area.window, gtk.STATE_NORMAL, gtk.SHADOW_OUT,
                    None, drawing_area, "button", 0, 0, w+2, h)
    d = 3
    style.paint_focus(drawing_area.window, gtk.STATE_NORMAL,
                      None, drawing_area, "button", d, d, w-2*d, h-2*d)
    save_image('combo-rf', w, h)

    style.paint_shadow(drawing_area.window, gtk.STATE_NORMAL, gtk.SHADOW_IN,
                       None, drawing_area, "entry", 0, 0, w+2, h)
    save_image('combo-n', w, h)

    # checkbutton
    # define INDICATOR_SIZE     13
    # define INDICATOR_SPACING  2
    x, y = 2, 2
    w, h = 13, 13
    # w = h = checkbutton.style_get_property("indicator_size")
    for fn, state, shadow in (
        ("check-nc", gtk.STATE_NORMAL,      gtk.SHADOW_IN),
        ("check-nu", gtk.STATE_NORMAL,      gtk.SHADOW_OUT),
        ("check-ac", gtk.STATE_PRELIGHT,    gtk.SHADOW_IN),
        ("check-au", gtk.STATE_PRELIGHT,    gtk.SHADOW_OUT),
        ("check-pc", gtk.STATE_ACTIVE,      gtk.SHADOW_IN),
        ("check-pu", gtk.STATE_ACTIVE,      gtk.SHADOW_OUT),
        ("check-dc", gtk.STATE_INSENSITIVE, gtk.SHADOW_IN),
        ("check-du", gtk.STATE_INSENSITIVE, gtk.SHADOW_OUT),
            ):
        #   style.paint_flat_box(drawing_area.window,
        #                   gtk.STATE_PRELIGHT,
        #                   gtk.SHADOW_ETCHED_OUT,
        #                   gtk.gdk.Rectangle(0, 0,w, h), drawing_area,
        #                   "checkbutton", 0, 0, w, h)

        style.paint_check(drawing_area.window, state, shadow,
                          None, drawing_area, "checkbutton", x, y, w, h)
        save_image(fn, w+2*x, h+2*y)

    # radiobutton
    for fn, state, shadow in (
        ("radio-nc", gtk.STATE_NORMAL,      gtk.SHADOW_IN),
        ("radio-nu", gtk.STATE_NORMAL,      gtk.SHADOW_OUT),
        ("radio-ac", gtk.STATE_PRELIGHT,    gtk.SHADOW_IN),
        ("radio-au", gtk.STATE_PRELIGHT,    gtk.SHADOW_OUT),
        ("radio-pc", gtk.STATE_ACTIVE,      gtk.SHADOW_IN),
        ("radio-pu", gtk.STATE_ACTIVE,      gtk.SHADOW_OUT),
        ("radio-dc", gtk.STATE_INSENSITIVE, gtk.SHADOW_IN),
        ("radio-du", gtk.STATE_INSENSITIVE, gtk.SHADOW_OUT),
            ):
        #   style.paint_flat_box(drawing_area.window,
        #                   gtk.STATE_PRELIGHT,
        #                   gtk.SHADOW_ETCHED_OUT,
        #                   gtk.gdk.Rectangle(0, 0,w, h), drawing_area,
        #                   "checkbutton", 0, 0, w, h)
        style.paint_option(drawing_area.window, state, shadow,
                           None, drawing_area, "radiobutton", x, y, w, h)
        save_image(fn, w+2*x, h+2*y)

    # notebook
    w, h = 28, 22
    state = gtk.STATE_NORMAL
    shadow = gtk.SHADOW_OUT

    for fn, gap_h, state in (
        ("tab-n", 0, gtk.STATE_NORMAL),
        ("tab-a", 2, gtk.STATE_ACTIVE),
            ):
        #  style.paint_box_gap(drawing_area.window, state, shadow,
        #                      gtk.gdk.Rectangle(0, 0,w,gap_h), drawing_area,
        #                      "notebook", 0, 0, w,gap_h, gtk.POS_TOP, 0, w)
        y = gap_h
        hh = h - y
        style.paint_extension(drawing_area.window, state, gtk.SHADOW_OUT,
                              None, drawing_area, "tab",
                              0, y, w, hh, gtk.POS_BOTTOM)
        save_image(fn, w, h+2)

    print('done')

    gtk.main_quit()


def pack(w, row, col):
    table.attach(w,
                 col, col+1,              row, row+1,
                 gtk.EXPAND | gtk.FILL,   gtk.EXPAND | gtk.FILL,
                 0,                       0)


win = gtk.Window()
win.connect("destroy", gtk.main_quit)

table = gtk.Table()
win.add(table)

row, col = 0, 0

drawing_area = gtk.DrawingArea()
# drawing_area.set_size_request(100, 100)
pack(drawing_area, row, col)
row += 1

vscroll = gtk.VScrollbar()
pack(vscroll, 0, 1)

hscroll = gtk.HScrollbar()
pack(hscroll, row, col)
row += 1


notebook = gtk.Notebook()
label = gtk.Label("Label")
notebook.append_page(label)
label = gtk.Label("Label")
notebook.append_page(label)
pack(notebook, row, col)
row += 1

button = gtk.Button("Button")
pack(button, row, col)
row += 1

checkbutton = gtk.CheckButton("CheckButton")
pack(checkbutton, row, col)
row += 1

progress = gtk.ProgressBar()
pack(progress, row, col)
row += 1

scale = gtk.HScale()
pack(scale, row, col)
row += 1

entry = gtk.Entry()
pack(entry, row, col)
row += 1

togglebutton = gtk.ToggleButton()
pack(togglebutton, row, col)
togglebutton.set_active(True)
row += 1


drawing_area.connect("expose-event", save_callback)
# gobject.timeout_add(2000, save_callback)

win.show_all()
# drawing_area.modify_bg(gtk.STATE_NORMAL, gtk.gdk.color_parse('red'))

gtk.main()
